{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 7, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/@lexical/selection/LexicalSelection.dev.mjs"],"sourcesContent":["/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nimport { $isTextNode, $getCharacterOffsets, $isElementNode, $isRootNode, $getNodeByKey, $getPreviousSelection, $createTextNode, $isRangeSelection, $isTokenOrSegmented, $getRoot, $isRootOrShadowRoot, $hasAncestor, $isLeafNode, $setSelection, $getAdjacentNode, $isDecoratorNode, $isLineBreakNode } from 'lexical';\nexport { $cloneWithProperties } from 'lexical';\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nconst CSS_TO_STYLES = new Map();\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction getDOMTextNode(element) {\n  let node = element;\n  while (node != null) {\n    if (node.nodeType === Node.TEXT_NODE) {\n      return node;\n    }\n    node = node.firstChild;\n  }\n  return null;\n}\nfunction getDOMIndexWithinParent(node) {\n  const parent = node.parentNode;\n  if (parent == null) {\n    throw new Error('Should never happen');\n  }\n  return [parent, Array.from(parent.childNodes).indexOf(node)];\n}\n\n/**\n * Creates a selection range for the DOM.\n * @param editor - The lexical editor.\n * @param anchorNode - The anchor node of a selection.\n * @param _anchorOffset - The amount of space offset from the anchor to the focus.\n * @param focusNode - The current focus.\n * @param _focusOffset - The amount of space offset from the focus to the anchor.\n * @returns The range of selection for the DOM that was created.\n */\nfunction createDOMRange(editor, anchorNode, _anchorOffset, focusNode, _focusOffset) {\n  const anchorKey = anchorNode.getKey();\n  const focusKey = focusNode.getKey();\n  const range = document.createRange();\n  let anchorDOM = editor.getElementByKey(anchorKey);\n  let focusDOM = editor.getElementByKey(focusKey);\n  let anchorOffset = _anchorOffset;\n  let focusOffset = _focusOffset;\n  if ($isTextNode(anchorNode)) {\n    anchorDOM = getDOMTextNode(anchorDOM);\n  }\n  if ($isTextNode(focusNode)) {\n    focusDOM = getDOMTextNode(focusDOM);\n  }\n  if (anchorNode === undefined || focusNode === undefined || anchorDOM === null || focusDOM === null) {\n    return null;\n  }\n  if (anchorDOM.nodeName === 'BR') {\n    [anchorDOM, anchorOffset] = getDOMIndexWithinParent(anchorDOM);\n  }\n  if (focusDOM.nodeName === 'BR') {\n    [focusDOM, focusOffset] = getDOMIndexWithinParent(focusDOM);\n  }\n  const firstChild = anchorDOM.firstChild;\n  if (anchorDOM === focusDOM && firstChild != null && firstChild.nodeName === 'BR' && anchorOffset === 0 && focusOffset === 0) {\n    focusOffset = 1;\n  }\n  try {\n    range.setStart(anchorDOM, anchorOffset);\n    range.setEnd(focusDOM, focusOffset);\n  } catch (e) {\n    return null;\n  }\n  if (range.collapsed && (anchorOffset !== focusOffset || anchorKey !== focusKey)) {\n    // Range is backwards, we need to reverse it\n    range.setStart(focusDOM, focusOffset);\n    range.setEnd(anchorDOM, anchorOffset);\n  }\n  return range;\n}\n\n/**\n * Creates DOMRects, generally used to help the editor find a specific location on the screen.\n * @param editor - The lexical editor\n * @param range - A fragment of a document that can contain nodes and parts of text nodes.\n * @returns The selectionRects as an array.\n */\nfunction createRectsFromDOMRange(editor, range) {\n  const rootElement = editor.getRootElement();\n  if (rootElement === null) {\n    return [];\n  }\n  const rootRect = rootElement.getBoundingClientRect();\n  const computedStyle = getComputedStyle(rootElement);\n  const rootPadding = parseFloat(computedStyle.paddingLeft) + parseFloat(computedStyle.paddingRight);\n  const selectionRects = Array.from(range.getClientRects());\n  let selectionRectsLength = selectionRects.length;\n  //sort rects from top left to bottom right.\n  selectionRects.sort((a, b) => {\n    const top = a.top - b.top;\n    // Some rects match position closely, but not perfectly,\n    // so we give a 3px tolerance.\n    if (Math.abs(top) <= 3) {\n      return a.left - b.left;\n    }\n    return top;\n  });\n  let prevRect;\n  for (let i = 0; i < selectionRectsLength; i++) {\n    const selectionRect = selectionRects[i];\n    // Exclude rects that overlap preceding Rects in the sorted list.\n    const isOverlappingRect = prevRect && prevRect.top <= selectionRect.top && prevRect.top + prevRect.height > selectionRect.top && prevRect.left + prevRect.width > selectionRect.left;\n    // Exclude selections that span the entire element\n    const selectionSpansElement = selectionRect.width + rootPadding === rootRect.width;\n    if (isOverlappingRect || selectionSpansElement) {\n      selectionRects.splice(i--, 1);\n      selectionRectsLength--;\n      continue;\n    }\n    prevRect = selectionRect;\n  }\n  return selectionRects;\n}\n\n/**\n * Creates an object containing all the styles and their values provided in the CSS string.\n * @param css - The CSS string of styles and their values.\n * @returns The styleObject containing all the styles and their values.\n */\nfunction getStyleObjectFromRawCSS(css) {\n  const styleObject = {};\n  const styles = css.split(';');\n  for (const style of styles) {\n    if (style !== '') {\n      const [key, value] = style.split(/:([^]+)/); // split on first colon\n      if (key && value) {\n        styleObject[key.trim()] = value.trim();\n      }\n    }\n  }\n  return styleObject;\n}\n\n/**\n * Given a CSS string, returns an object from the style cache.\n * @param css - The CSS property as a string.\n * @returns The value of the given CSS property.\n */\nfunction getStyleObjectFromCSS(css) {\n  let value = CSS_TO_STYLES.get(css);\n  if (value === undefined) {\n    value = getStyleObjectFromRawCSS(css);\n    CSS_TO_STYLES.set(css, value);\n  }\n  {\n    // Freeze the value in DEV to prevent accidental mutations\n    Object.freeze(value);\n  }\n  return value;\n}\n\n/**\n * Gets the CSS styles from the style object.\n * @param styles - The style object containing the styles to get.\n * @returns A string containing the CSS styles and their values.\n */\nfunction getCSSFromStyleObject(styles) {\n  let css = '';\n  for (const style in styles) {\n    if (style) {\n      css += `${style}: ${styles[style]};`;\n    }\n  }\n  return css;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n/**\n * Generally used to append text content to HTML and JSON. Grabs the text content and \"slices\"\n * it to be generated into the new TextNode.\n * @param selection - The selection containing the node whose TextNode is to be edited.\n * @param textNode - The TextNode to be edited.\n * @returns The updated TextNode.\n */\nfunction $sliceSelectedTextNodeContent(selection, textNode) {\n  const anchorAndFocus = selection.getStartEndPoints();\n  if (textNode.isSelected(selection) && !textNode.isSegmented() && !textNode.isToken() && anchorAndFocus !== null) {\n    const [anchor, focus] = anchorAndFocus;\n    const isBackward = selection.isBackward();\n    const anchorNode = anchor.getNode();\n    const focusNode = focus.getNode();\n    const isAnchor = textNode.is(anchorNode);\n    const isFocus = textNode.is(focusNode);\n    if (isAnchor || isFocus) {\n      const [anchorOffset, focusOffset] = $getCharacterOffsets(selection);\n      const isSame = anchorNode.is(focusNode);\n      const isFirst = textNode.is(isBackward ? focusNode : anchorNode);\n      const isLast = textNode.is(isBackward ? anchorNode : focusNode);\n      let startOffset = 0;\n      let endOffset = undefined;\n      if (isSame) {\n        startOffset = anchorOffset > focusOffset ? focusOffset : anchorOffset;\n        endOffset = anchorOffset > focusOffset ? anchorOffset : focusOffset;\n      } else if (isFirst) {\n        const offset = isBackward ? focusOffset : anchorOffset;\n        startOffset = offset;\n        endOffset = undefined;\n      } else if (isLast) {\n        const offset = isBackward ? anchorOffset : focusOffset;\n        startOffset = 0;\n        endOffset = offset;\n      }\n      textNode.__text = textNode.__text.slice(startOffset, endOffset);\n      return textNode;\n    }\n  }\n  return textNode;\n}\n\n/**\n * Determines if the current selection is at the end of the node.\n * @param point - The point of the selection to test.\n * @returns true if the provided point offset is in the last possible position, false otherwise.\n */\nfunction $isAtNodeEnd(point) {\n  if (point.type === 'text') {\n    return point.offset === point.getNode().getTextContentSize();\n  }\n  const node = point.getNode();\n  if (!$isElementNode(node)) {\n    throw Error(`isAtNodeEnd: node must be a TextNode or ElementNode`);\n  }\n  return point.offset === node.getChildrenSize();\n}\n\n/**\n * Trims text from a node in order to shorten it, eg. to enforce a text's max length. If it deletes text\n * that is an ancestor of the anchor then it will leave 2 indents, otherwise, if no text content exists, it deletes\n * the TextNode. It will move the focus to either the end of any left over text or beginning of a new TextNode.\n * @param editor - The lexical editor.\n * @param anchor - The anchor of the current selection, where the selection should be pointing.\n * @param delCount - The amount of characters to delete. Useful as a dynamic variable eg. textContentSize - maxLength;\n */\nfunction $trimTextContentFromAnchor(editor, anchor, delCount) {\n  // Work from the current selection anchor point\n  let currentNode = anchor.getNode();\n  let remaining = delCount;\n  if ($isElementNode(currentNode)) {\n    const descendantNode = currentNode.getDescendantByIndex(anchor.offset);\n    if (descendantNode !== null) {\n      currentNode = descendantNode;\n    }\n  }\n  while (remaining > 0 && currentNode !== null) {\n    if ($isElementNode(currentNode)) {\n      const lastDescendant = currentNode.getLastDescendant();\n      if (lastDescendant !== null) {\n        currentNode = lastDescendant;\n      }\n    }\n    let nextNode = currentNode.getPreviousSibling();\n    let additionalElementWhitespace = 0;\n    if (nextNode === null) {\n      let parent = currentNode.getParentOrThrow();\n      let parentSibling = parent.getPreviousSibling();\n      while (parentSibling === null) {\n        parent = parent.getParent();\n        if (parent === null) {\n          nextNode = null;\n          break;\n        }\n        parentSibling = parent.getPreviousSibling();\n      }\n      if (parent !== null) {\n        additionalElementWhitespace = parent.isInline() ? 0 : 2;\n        nextNode = parentSibling;\n      }\n    }\n    let text = currentNode.getTextContent();\n    // If the text is empty, we need to consider adding in two line breaks to match\n    // the content if we were to get it from its parent.\n    if (text === '' && $isElementNode(currentNode) && !currentNode.isInline()) {\n      // TODO: should this be handled in core?\n      text = '\\n\\n';\n    }\n    const currentNodeSize = text.length;\n    if (!$isTextNode(currentNode) || remaining >= currentNodeSize) {\n      const parent = currentNode.getParent();\n      currentNode.remove();\n      if (parent != null && parent.getChildrenSize() === 0 && !$isRootNode(parent)) {\n        parent.remove();\n      }\n      remaining -= currentNodeSize + additionalElementWhitespace;\n      currentNode = nextNode;\n    } else {\n      const key = currentNode.getKey();\n      // See if we can just revert it to what was in the last editor state\n      const prevTextContent = editor.getEditorState().read(() => {\n        const prevNode = $getNodeByKey(key);\n        if ($isTextNode(prevNode) && prevNode.isSimpleText()) {\n          return prevNode.getTextContent();\n        }\n        return null;\n      });\n      const offset = currentNodeSize - remaining;\n      const slicedText = text.slice(0, offset);\n      if (prevTextContent !== null && prevTextContent !== text) {\n        const prevSelection = $getPreviousSelection();\n        let target = currentNode;\n        if (!currentNode.isSimpleText()) {\n          const textNode = $createTextNode(prevTextContent);\n          currentNode.replace(textNode);\n          target = textNode;\n        } else {\n          currentNode.setTextContent(prevTextContent);\n        }\n        if ($isRangeSelection(prevSelection) && prevSelection.isCollapsed()) {\n          const prevOffset = prevSelection.anchor.offset;\n          target.select(prevOffset, prevOffset);\n        }\n      } else if (currentNode.isSimpleText()) {\n        // Split text\n        const isSelected = anchor.key === key;\n        let anchorOffset = anchor.offset;\n        // Move offset to end if it's less than the remaining number, otherwise\n        // we'll have a negative splitStart.\n        if (anchorOffset < remaining) {\n          anchorOffset = currentNodeSize;\n        }\n        const splitStart = isSelected ? anchorOffset - remaining : 0;\n        const splitEnd = isSelected ? anchorOffset : offset;\n        if (isSelected && splitStart === 0) {\n          const [excessNode] = currentNode.splitText(splitStart, splitEnd);\n          excessNode.remove();\n        } else {\n          const [, excessNode] = currentNode.splitText(splitStart, splitEnd);\n          excessNode.remove();\n        }\n      } else {\n        const textNode = $createTextNode(slicedText);\n        currentNode.replace(textNode);\n      }\n      remaining = 0;\n    }\n  }\n}\n\n/**\n * Gets the TextNode's style object and adds the styles to the CSS.\n * @param node - The TextNode to add styles to.\n */\nfunction $addNodeStyle(node) {\n  const CSSText = node.getStyle();\n  const styles = getStyleObjectFromRawCSS(CSSText);\n  CSS_TO_STYLES.set(CSSText, styles);\n}\nfunction $patchStyle(target, patch) {\n  const prevStyles = getStyleObjectFromCSS('getStyle' in target ? target.getStyle() : target.style);\n  const newStyles = Object.entries(patch).reduce((styles, [key, value]) => {\n    if (typeof value === 'function') {\n      styles[key] = value(prevStyles[key], target);\n    } else if (value === null) {\n      delete styles[key];\n    } else {\n      styles[key] = value;\n    }\n    return styles;\n  }, {\n    ...prevStyles\n  } || {});\n  const newCSSText = getCSSFromStyleObject(newStyles);\n  target.setStyle(newCSSText);\n  CSS_TO_STYLES.set(newCSSText, newStyles);\n}\n\n/**\n * Applies the provided styles to the TextNodes in the provided Selection.\n * Will update partially selected TextNodes by splitting the TextNode and applying\n * the styles to the appropriate one.\n * @param selection - The selected node(s) to update.\n * @param patch - The patch to apply, which can include multiple styles. \\\\{CSSProperty: value\\\\} . Can also accept a function that returns the new property value.\n */\nfunction $patchStyleText(selection, patch) {\n  const selectedNodes = selection.getNodes();\n  const selectedNodesLength = selectedNodes.length;\n  const anchorAndFocus = selection.getStartEndPoints();\n  if (anchorAndFocus === null) {\n    return;\n  }\n  const [anchor, focus] = anchorAndFocus;\n  const lastIndex = selectedNodesLength - 1;\n  let firstNode = selectedNodes[0];\n  let lastNode = selectedNodes[lastIndex];\n  if (selection.isCollapsed() && $isRangeSelection(selection)) {\n    $patchStyle(selection, patch);\n    return;\n  }\n  const firstNodeText = firstNode.getTextContent();\n  const firstNodeTextLength = firstNodeText.length;\n  const focusOffset = focus.offset;\n  let anchorOffset = anchor.offset;\n  const isBefore = anchor.isBefore(focus);\n  let startOffset = isBefore ? anchorOffset : focusOffset;\n  let endOffset = isBefore ? focusOffset : anchorOffset;\n  const startType = isBefore ? anchor.type : focus.type;\n  const endType = isBefore ? focus.type : anchor.type;\n  const endKey = isBefore ? focus.key : anchor.key;\n\n  // This is the case where the user only selected the very end of the\n  // first node so we don't want to include it in the formatting change.\n  if ($isTextNode(firstNode) && startOffset === firstNodeTextLength) {\n    const nextSibling = firstNode.getNextSibling();\n    if ($isTextNode(nextSibling)) {\n      // we basically make the second node the firstNode, changing offsets accordingly\n      anchorOffset = 0;\n      startOffset = 0;\n      firstNode = nextSibling;\n    }\n  }\n\n  // This is the case where we only selected a single node\n  if (selectedNodes.length === 1) {\n    if ($isTextNode(firstNode) && firstNode.canHaveFormat()) {\n      startOffset = startType === 'element' ? 0 : anchorOffset > focusOffset ? focusOffset : anchorOffset;\n      endOffset = endType === 'element' ? firstNodeTextLength : anchorOffset > focusOffset ? anchorOffset : focusOffset;\n\n      // No actual text is selected, so do nothing.\n      if (startOffset === endOffset) {\n        return;\n      }\n\n      // The entire node is selected or a token/segment, so just format it\n      if ($isTokenOrSegmented(firstNode) || startOffset === 0 && endOffset === firstNodeTextLength) {\n        $patchStyle(firstNode, patch);\n        firstNode.select(startOffset, endOffset);\n      } else {\n        // The node is partially selected, so split it into two nodes\n        // and style the selected one.\n        const splitNodes = firstNode.splitText(startOffset, endOffset);\n        const replacement = startOffset === 0 ? splitNodes[0] : splitNodes[1];\n        $patchStyle(replacement, patch);\n        replacement.select(0, endOffset - startOffset);\n      }\n    } // multiple nodes selected.\n  } else {\n    if ($isTextNode(firstNode) && startOffset < firstNode.getTextContentSize() && firstNode.canHaveFormat()) {\n      if (startOffset !== 0 && !$isTokenOrSegmented(firstNode)) {\n        // the entire first node isn't selected and it isn't a token or segmented, so split it\n        firstNode = firstNode.splitText(startOffset)[1];\n        startOffset = 0;\n        if (isBefore) {\n          anchor.set(firstNode.getKey(), startOffset, 'text');\n        } else {\n          focus.set(firstNode.getKey(), startOffset, 'text');\n        }\n      }\n      $patchStyle(firstNode, patch);\n    }\n    if ($isTextNode(lastNode) && lastNode.canHaveFormat()) {\n      const lastNodeText = lastNode.getTextContent();\n      const lastNodeTextLength = lastNodeText.length;\n\n      // The last node might not actually be the end node\n      //\n      // If not, assume the last node is fully-selected unless the end offset is\n      // zero.\n      if (lastNode.__key !== endKey && endOffset !== 0) {\n        endOffset = lastNodeTextLength;\n      }\n\n      // if the entire last node isn't selected and it isn't a token or segmented, split it\n      if (endOffset !== lastNodeTextLength && !$isTokenOrSegmented(lastNode)) {\n        [lastNode] = lastNode.splitText(endOffset);\n      }\n      if (endOffset !== 0 || endType === 'element') {\n        $patchStyle(lastNode, patch);\n      }\n    }\n\n    // style all the text nodes in between\n    for (let i = 1; i < lastIndex; i++) {\n      const selectedNode = selectedNodes[i];\n      const selectedNodeKey = selectedNode.getKey();\n      if ($isTextNode(selectedNode) && selectedNode.canHaveFormat() && selectedNodeKey !== firstNode.getKey() && selectedNodeKey !== lastNode.getKey() && !selectedNode.isToken()) {\n        $patchStyle(selectedNode, patch);\n      }\n    }\n  }\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n\n/**\n * Converts all nodes in the selection that are of one block type to another.\n * @param selection - The selected blocks to be converted.\n * @param createElement - The function that creates the node. eg. $createParagraphNode.\n */\nfunction $setBlocksType(selection, createElement) {\n  if (selection === null) {\n    return;\n  }\n  const anchorAndFocus = selection.getStartEndPoints();\n  const anchor = anchorAndFocus ? anchorAndFocus[0] : null;\n  if (anchor !== null && anchor.key === 'root') {\n    const element = createElement();\n    const root = $getRoot();\n    const firstChild = root.getFirstChild();\n    if (firstChild) {\n      firstChild.replace(element, true);\n    } else {\n      root.append(element);\n    }\n    return;\n  }\n  const nodes = selection.getNodes();\n  const firstSelectedBlock = anchor !== null ? $getAncestor(anchor.getNode(), INTERNAL_$isBlock) : false;\n  if (firstSelectedBlock && nodes.indexOf(firstSelectedBlock) === -1) {\n    nodes.push(firstSelectedBlock);\n  }\n  for (let i = 0; i < nodes.length; i++) {\n    const node = nodes[i];\n    if (!INTERNAL_$isBlock(node)) {\n      continue;\n    }\n    if (!$isElementNode(node)) {\n      throw Error(`Expected block node to be an ElementNode`);\n    }\n    const targetElement = createElement();\n    targetElement.setFormat(node.getFormatType());\n    targetElement.setIndent(node.getIndent());\n    node.replace(targetElement, true);\n  }\n}\nfunction isPointAttached(point) {\n  return point.getNode().isAttached();\n}\nfunction $removeParentEmptyElements(startingNode) {\n  let node = startingNode;\n  while (node !== null && !$isRootOrShadowRoot(node)) {\n    const latest = node.getLatest();\n    const parentNode = node.getParent();\n    if (latest.getChildrenSize() === 0) {\n      node.remove(true);\n    }\n    node = parentNode;\n  }\n}\n\n/**\n * @deprecated\n * Wraps all nodes in the selection into another node of the type returned by createElement.\n * @param selection - The selection of nodes to be wrapped.\n * @param createElement - A function that creates the wrapping ElementNode. eg. $createParagraphNode.\n * @param wrappingElement - An element to append the wrapped selection and its children to.\n */\nfunction $wrapNodes(selection, createElement, wrappingElement = null) {\n  const anchorAndFocus = selection.getStartEndPoints();\n  const anchor = anchorAndFocus ? anchorAndFocus[0] : null;\n  const nodes = selection.getNodes();\n  const nodesLength = nodes.length;\n  if (anchor !== null && (nodesLength === 0 || nodesLength === 1 && anchor.type === 'element' && anchor.getNode().getChildrenSize() === 0)) {\n    const target = anchor.type === 'text' ? anchor.getNode().getParentOrThrow() : anchor.getNode();\n    const children = target.getChildren();\n    let element = createElement();\n    element.setFormat(target.getFormatType());\n    element.setIndent(target.getIndent());\n    children.forEach(child => element.append(child));\n    if (wrappingElement) {\n      element = wrappingElement.append(element);\n    }\n    target.replace(element);\n    return;\n  }\n  let topLevelNode = null;\n  let descendants = [];\n  for (let i = 0; i < nodesLength; i++) {\n    const node = nodes[i];\n    // Determine whether wrapping has to be broken down into multiple chunks. This can happen if the\n    // user selected multiple Root-like nodes that have to be treated separately as if they are\n    // their own branch. I.e. you don't want to wrap a whole table, but rather the contents of each\n    // of each of the cell nodes.\n    if ($isRootOrShadowRoot(node)) {\n      $wrapNodesImpl(selection, descendants, descendants.length, createElement, wrappingElement);\n      descendants = [];\n      topLevelNode = node;\n    } else if (topLevelNode === null || topLevelNode !== null && $hasAncestor(node, topLevelNode)) {\n      descendants.push(node);\n    } else {\n      $wrapNodesImpl(selection, descendants, descendants.length, createElement, wrappingElement);\n      descendants = [node];\n    }\n  }\n  $wrapNodesImpl(selection, descendants, descendants.length, createElement, wrappingElement);\n}\n\n/**\n * Wraps each node into a new ElementNode.\n * @param selection - The selection of nodes to wrap.\n * @param nodes - An array of nodes, generally the descendants of the selection.\n * @param nodesLength - The length of nodes.\n * @param createElement - A function that creates the wrapping ElementNode. eg. $createParagraphNode.\n * @param wrappingElement - An element to wrap all the nodes into.\n * @returns\n */\nfunction $wrapNodesImpl(selection, nodes, nodesLength, createElement, wrappingElement = null) {\n  if (nodes.length === 0) {\n    return;\n  }\n  const firstNode = nodes[0];\n  const elementMapping = new Map();\n  const elements = [];\n  // The below logic is to find the right target for us to\n  // either insertAfter/insertBefore/append the corresponding\n  // elements to. This is made more complicated due to nested\n  // structures.\n  let target = $isElementNode(firstNode) ? firstNode : firstNode.getParentOrThrow();\n  if (target.isInline()) {\n    target = target.getParentOrThrow();\n  }\n  let targetIsPrevSibling = false;\n  while (target !== null) {\n    const prevSibling = target.getPreviousSibling();\n    if (prevSibling !== null) {\n      target = prevSibling;\n      targetIsPrevSibling = true;\n      break;\n    }\n    target = target.getParentOrThrow();\n    if ($isRootOrShadowRoot(target)) {\n      break;\n    }\n  }\n  const emptyElements = new Set();\n\n  // Find any top level empty elements\n  for (let i = 0; i < nodesLength; i++) {\n    const node = nodes[i];\n    if ($isElementNode(node) && node.getChildrenSize() === 0) {\n      emptyElements.add(node.getKey());\n    }\n  }\n  const movedNodes = new Set();\n\n  // Move out all leaf nodes into our elements array.\n  // If we find a top level empty element, also move make\n  // an element for that.\n  for (let i = 0; i < nodesLength; i++) {\n    const node = nodes[i];\n    let parent = node.getParent();\n    if (parent !== null && parent.isInline()) {\n      parent = parent.getParent();\n    }\n    if (parent !== null && $isLeafNode(node) && !movedNodes.has(node.getKey())) {\n      const parentKey = parent.getKey();\n      if (elementMapping.get(parentKey) === undefined) {\n        const targetElement = createElement();\n        targetElement.setFormat(parent.getFormatType());\n        targetElement.setIndent(parent.getIndent());\n        elements.push(targetElement);\n        elementMapping.set(parentKey, targetElement);\n        // Move node and its siblings to the new\n        // element.\n        parent.getChildren().forEach(child => {\n          targetElement.append(child);\n          movedNodes.add(child.getKey());\n          if ($isElementNode(child)) {\n            // Skip nested leaf nodes if the parent has already been moved\n            child.getChildrenKeys().forEach(key => movedNodes.add(key));\n          }\n        });\n        $removeParentEmptyElements(parent);\n      }\n    } else if (emptyElements.has(node.getKey())) {\n      if (!$isElementNode(node)) {\n        throw Error(`Expected node in emptyElements to be an ElementNode`);\n      }\n      const targetElement = createElement();\n      targetElement.setFormat(node.getFormatType());\n      targetElement.setIndent(node.getIndent());\n      elements.push(targetElement);\n      node.remove(true);\n    }\n  }\n  if (wrappingElement !== null) {\n    for (let i = 0; i < elements.length; i++) {\n      const element = elements[i];\n      wrappingElement.append(element);\n    }\n  }\n  let lastElement = null;\n\n  // If our target is Root-like, let's see if we can re-adjust\n  // so that the target is the first child instead.\n  if ($isRootOrShadowRoot(target)) {\n    if (targetIsPrevSibling) {\n      if (wrappingElement !== null) {\n        target.insertAfter(wrappingElement);\n      } else {\n        for (let i = elements.length - 1; i >= 0; i--) {\n          const element = elements[i];\n          target.insertAfter(element);\n        }\n      }\n    } else {\n      const firstChild = target.getFirstChild();\n      if ($isElementNode(firstChild)) {\n        target = firstChild;\n      }\n      if (firstChild === null) {\n        if (wrappingElement) {\n          target.append(wrappingElement);\n        } else {\n          for (let i = 0; i < elements.length; i++) {\n            const element = elements[i];\n            target.append(element);\n            lastElement = element;\n          }\n        }\n      } else {\n        if (wrappingElement !== null) {\n          firstChild.insertBefore(wrappingElement);\n        } else {\n          for (let i = 0; i < elements.length; i++) {\n            const element = elements[i];\n            firstChild.insertBefore(element);\n            lastElement = element;\n          }\n        }\n      }\n    }\n  } else {\n    if (wrappingElement) {\n      target.insertAfter(wrappingElement);\n    } else {\n      for (let i = elements.length - 1; i >= 0; i--) {\n        const element = elements[i];\n        target.insertAfter(element);\n        lastElement = element;\n      }\n    }\n  }\n  const prevSelection = $getPreviousSelection();\n  if ($isRangeSelection(prevSelection) && isPointAttached(prevSelection.anchor) && isPointAttached(prevSelection.focus)) {\n    $setSelection(prevSelection.clone());\n  } else if (lastElement !== null) {\n    lastElement.selectEnd();\n  } else {\n    selection.dirty = true;\n  }\n}\n\n/**\n * Determines if the default character selection should be overridden. Used with DecoratorNodes\n * @param selection - The selection whose default character selection may need to be overridden.\n * @param isBackward - Is the selection backwards (the focus comes before the anchor)?\n * @returns true if it should be overridden, false if not.\n */\nfunction $shouldOverrideDefaultCharacterSelection(selection, isBackward) {\n  const possibleNode = $getAdjacentNode(selection.focus, isBackward);\n  return $isDecoratorNode(possibleNode) && !possibleNode.isIsolated() || $isElementNode(possibleNode) && !possibleNode.isInline() && !possibleNode.canBeEmpty();\n}\n\n/**\n * Moves the selection according to the arguments.\n * @param selection - The selected text or nodes.\n * @param isHoldingShift - Is the shift key being held down during the operation.\n * @param isBackward - Is the selection selected backwards (the focus comes before the anchor)?\n * @param granularity - The distance to adjust the current selection.\n */\nfunction $moveCaretSelection(selection, isHoldingShift, isBackward, granularity) {\n  selection.modify(isHoldingShift ? 'extend' : 'move', isBackward, granularity);\n}\n\n/**\n * Tests a parent element for right to left direction.\n * @param selection - The selection whose parent is to be tested.\n * @returns true if the selections' parent element has a direction of 'rtl' (right to left), false otherwise.\n */\nfunction $isParentElementRTL(selection) {\n  const anchorNode = selection.anchor.getNode();\n  const parent = $isRootNode(anchorNode) ? anchorNode : anchorNode.getParentOrThrow();\n  return parent.getDirection() === 'rtl';\n}\n\n/**\n * Moves selection by character according to arguments.\n * @param selection - The selection of the characters to move.\n * @param isHoldingShift - Is the shift key being held down during the operation.\n * @param isBackward - Is the selection backward (the focus comes before the anchor)?\n */\nfunction $moveCharacter(selection, isHoldingShift, isBackward) {\n  const isRTL = $isParentElementRTL(selection);\n  $moveCaretSelection(selection, isHoldingShift, isBackward ? !isRTL : isRTL, 'character');\n}\n\n/**\n * Expands the current Selection to cover all of the content in the editor.\n * @param selection - The current selection.\n */\nfunction $selectAll(selection) {\n  const anchor = selection.anchor;\n  const focus = selection.focus;\n  const anchorNode = anchor.getNode();\n  const topParent = anchorNode.getTopLevelElementOrThrow();\n  const root = topParent.getParentOrThrow();\n  let firstNode = root.getFirstDescendant();\n  let lastNode = root.getLastDescendant();\n  let firstType = 'element';\n  let lastType = 'element';\n  let lastOffset = 0;\n  if ($isTextNode(firstNode)) {\n    firstType = 'text';\n  } else if (!$isElementNode(firstNode) && firstNode !== null) {\n    firstNode = firstNode.getParentOrThrow();\n  }\n  if ($isTextNode(lastNode)) {\n    lastType = 'text';\n    lastOffset = lastNode.getTextContentSize();\n  } else if (!$isElementNode(lastNode) && lastNode !== null) {\n    lastNode = lastNode.getParentOrThrow();\n  }\n  if (firstNode && lastNode) {\n    anchor.set(firstNode.getKey(), 0, firstType);\n    focus.set(lastNode.getKey(), lastOffset, lastType);\n  }\n}\n\n/**\n * Returns the current value of a CSS property for Nodes, if set. If not set, it returns the defaultValue.\n * @param node - The node whose style value to get.\n * @param styleProperty - The CSS style property.\n * @param defaultValue - The default value for the property.\n * @returns The value of the property for node.\n */\nfunction $getNodeStyleValueForProperty(node, styleProperty, defaultValue) {\n  const css = node.getStyle();\n  const styleObject = getStyleObjectFromCSS(css);\n  if (styleObject !== null) {\n    return styleObject[styleProperty] || defaultValue;\n  }\n  return defaultValue;\n}\n\n/**\n * Returns the current value of a CSS property for TextNodes in the Selection, if set. If not set, it returns the defaultValue.\n * If all TextNodes do not have the same value, it returns an empty string.\n * @param selection - The selection of TextNodes whose value to find.\n * @param styleProperty - The CSS style property.\n * @param defaultValue - The default value for the property, defaults to an empty string.\n * @returns The value of the property for the selected TextNodes.\n */\nfunction $getSelectionStyleValueForProperty(selection, styleProperty, defaultValue = '') {\n  let styleValue = null;\n  const nodes = selection.getNodes();\n  const anchor = selection.anchor;\n  const focus = selection.focus;\n  const isBackward = selection.isBackward();\n  const endOffset = isBackward ? focus.offset : anchor.offset;\n  const endNode = isBackward ? focus.getNode() : anchor.getNode();\n  if ($isRangeSelection(selection) && selection.isCollapsed() && selection.style !== '') {\n    const css = selection.style;\n    const styleObject = getStyleObjectFromCSS(css);\n    if (styleObject !== null && styleProperty in styleObject) {\n      return styleObject[styleProperty];\n    }\n  }\n  for (let i = 0; i < nodes.length; i++) {\n    const node = nodes[i];\n\n    // if no actual characters in the end node are selected, we don't\n    // include it in the selection for purposes of determining style\n    // value\n    if (i !== 0 && endOffset === 0 && node.is(endNode)) {\n      continue;\n    }\n    if ($isTextNode(node)) {\n      const nodeStyleValue = $getNodeStyleValueForProperty(node, styleProperty, defaultValue);\n      if (styleValue === null) {\n        styleValue = nodeStyleValue;\n      } else if (styleValue !== nodeStyleValue) {\n        // multiple text nodes are in the selection and they don't all\n        // have the same style.\n        styleValue = '';\n        break;\n      }\n    }\n  }\n  return styleValue === null ? defaultValue : styleValue;\n}\n\n/**\n * This function is for internal use of the library.\n * Please do not use it as it may change in the future.\n */\nfunction INTERNAL_$isBlock(node) {\n  if ($isDecoratorNode(node)) {\n    return false;\n  }\n  if (!$isElementNode(node) || $isRootOrShadowRoot(node)) {\n    return false;\n  }\n  const firstChild = node.getFirstChild();\n  const isLeafElement = firstChild === null || $isLineBreakNode(firstChild) || $isTextNode(firstChild) || firstChild.isInline();\n  return !node.isInline() && node.canBeEmpty() !== false && isLeafElement;\n}\nfunction $getAncestor(node, predicate) {\n  let parent = node;\n  while (parent !== null && parent.getParent() !== null && !predicate(parent)) {\n    parent = parent.getParentOrThrow();\n  }\n  return predicate(parent) ? parent : null;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n/** @deprecated renamed to {@link $trimTextContentFromAnchor} by @lexical/eslint-plugin rules-of-lexical */\nconst trimTextContentFromAnchor = $trimTextContentFromAnchor;\n\nexport { $addNodeStyle, $getSelectionStyleValueForProperty, $isAtNodeEnd, $isParentElementRTL, $moveCaretSelection, $moveCharacter, $patchStyleText, $selectAll, $setBlocksType, $shouldOverrideDefaultCharacterSelection, $sliceSelectedTextNodeContent, $trimTextContentFromAnchor, $wrapNodes, createDOMRange, createRectsFromDOMRange, getCSSFromStyleObject, getStyleObjectFromCSS, trimTextContentFromAnchor };\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 917, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 923, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/@lexical/utils/LexicalUtils.dev.mjs"],"sourcesContent":["/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nimport { $getSelection, $isRangeSelection, TextNode, $getRoot, $isElementNode, $cloneWithProperties, $setSelection, $getPreviousSelection, $isRootOrShadowRoot, $isTextNode, $splitNode, $createParagraphNode } from 'lexical';\nexport { $splitNode, isBlockDomNode, isHTMLAnchorElement, isHTMLElement, isInlineDomNode } from 'lexical';\nimport { createRectsFromDOMRange } from '@lexical/selection';\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst CAN_USE_DOM$1 = typeof window !== 'undefined' && typeof window.document !== 'undefined' && typeof window.document.createElement !== 'undefined';\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst documentMode = CAN_USE_DOM$1 && 'documentMode' in document ? document.documentMode : null;\nconst IS_APPLE$1 = CAN_USE_DOM$1 && /Mac|iPod|iPhone|iPad/.test(navigator.platform);\nconst IS_FIREFOX$1 = CAN_USE_DOM$1 && /^(?!.*Seamonkey)(?=.*Firefox).*/i.test(navigator.userAgent);\nconst CAN_USE_BEFORE_INPUT$1 = CAN_USE_DOM$1 && 'InputEvent' in window && !documentMode ? 'getTargetRanges' in new window.InputEvent('input') : false;\nconst IS_SAFARI$1 = CAN_USE_DOM$1 && /Version\\/[\\d.]+.*Safari/.test(navigator.userAgent);\nconst IS_IOS$1 = CAN_USE_DOM$1 && /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;\nconst IS_ANDROID$1 = CAN_USE_DOM$1 && /Android/.test(navigator.userAgent);\n\n// Keep these in case we need to use them in the future.\n// export const IS_WINDOWS: boolean = CAN_USE_DOM && /Win/.test(navigator.platform);\nconst IS_CHROME$1 = CAN_USE_DOM$1 && /^(?=.*Chrome).*/i.test(navigator.userAgent);\n// export const canUseTextInputEvent: boolean = CAN_USE_DOM && 'TextEvent' in window && !documentMode;\n\nconst IS_ANDROID_CHROME$1 = CAN_USE_DOM$1 && IS_ANDROID$1 && IS_CHROME$1;\nconst IS_APPLE_WEBKIT$1 = CAN_USE_DOM$1 && /AppleWebKit\\/[\\d.]+/.test(navigator.userAgent) && !IS_CHROME$1;\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction normalizeClassNames(...classNames) {\n  const rval = [];\n  for (const className of classNames) {\n    if (className && typeof className === 'string') {\n      for (const [s] of className.matchAll(/\\S+/g)) {\n        rval.push(s);\n      }\n    }\n  }\n  return rval;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n/**\n * Returns a function that will execute all functions passed when called. It is generally used\n * to register multiple lexical listeners and then tear them down with a single function call, such\n * as React's useEffect hook.\n * @example\n * ```ts\n * useEffect(() => {\n *   return mergeRegister(\n *     editor.registerCommand(...registerCommand1 logic),\n *     editor.registerCommand(...registerCommand2 logic),\n *     editor.registerCommand(...registerCommand3 logic)\n *   )\n * }, [editor])\n * ```\n * In this case, useEffect is returning the function returned by mergeRegister as a cleanup\n * function to be executed after either the useEffect runs again (due to one of its dependencies\n * updating) or the component it resides in unmounts.\n * Note the functions don't neccesarily need to be in an array as all arguments\n * are considered to be the func argument and spread from there.\n * The order of cleanup is the reverse of the argument order. Generally it is\n * expected that the first \"acquire\" will be \"released\" last (LIFO order),\n * because a later step may have some dependency on an earlier one.\n * @param func - An array of cleanup functions meant to be executed by the returned function.\n * @returns the function which executes all the passed cleanup functions.\n */\nfunction mergeRegister(...func) {\n  return () => {\n    for (let i = func.length - 1; i >= 0; i--) {\n      func[i]();\n    }\n    // Clean up the references and make future calls a no-op\n    func.length = 0;\n  };\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction px(value) {\n  return `${value}px`;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst mutationObserverConfig = {\n  attributes: true,\n  characterData: true,\n  childList: true,\n  subtree: true\n};\nfunction positionNodeOnRange(editor, range, onReposition) {\n  let rootDOMNode = null;\n  let parentDOMNode = null;\n  let observer = null;\n  let lastNodes = [];\n  const wrapperNode = document.createElement('div');\n  function position() {\n    if (!(rootDOMNode !== null)) {\n      throw Error(`Unexpected null rootDOMNode`);\n    }\n    if (!(parentDOMNode !== null)) {\n      throw Error(`Unexpected null parentDOMNode`);\n    }\n    const {\n      left: rootLeft,\n      top: rootTop\n    } = rootDOMNode.getBoundingClientRect();\n    const parentDOMNode_ = parentDOMNode;\n    const rects = createRectsFromDOMRange(editor, range);\n    if (!wrapperNode.isConnected) {\n      parentDOMNode_.append(wrapperNode);\n    }\n    let hasRepositioned = false;\n    for (let i = 0; i < rects.length; i++) {\n      const rect = rects[i];\n      // Try to reuse the previously created Node when possible, no need to\n      // remove/create on the most common case reposition case\n      const rectNode = lastNodes[i] || document.createElement('div');\n      const rectNodeStyle = rectNode.style;\n      if (rectNodeStyle.position !== 'absolute') {\n        rectNodeStyle.position = 'absolute';\n        hasRepositioned = true;\n      }\n      const left = px(rect.left - rootLeft);\n      if (rectNodeStyle.left !== left) {\n        rectNodeStyle.left = left;\n        hasRepositioned = true;\n      }\n      const top = px(rect.top - rootTop);\n      if (rectNodeStyle.top !== top) {\n        rectNode.style.top = top;\n        hasRepositioned = true;\n      }\n      const width = px(rect.width);\n      if (rectNodeStyle.width !== width) {\n        rectNode.style.width = width;\n        hasRepositioned = true;\n      }\n      const height = px(rect.height);\n      if (rectNodeStyle.height !== height) {\n        rectNode.style.height = height;\n        hasRepositioned = true;\n      }\n      if (rectNode.parentNode !== wrapperNode) {\n        wrapperNode.append(rectNode);\n        hasRepositioned = true;\n      }\n      lastNodes[i] = rectNode;\n    }\n    while (lastNodes.length > rects.length) {\n      lastNodes.pop();\n    }\n    if (hasRepositioned) {\n      onReposition(lastNodes);\n    }\n  }\n  function stop() {\n    parentDOMNode = null;\n    rootDOMNode = null;\n    if (observer !== null) {\n      observer.disconnect();\n    }\n    observer = null;\n    wrapperNode.remove();\n    for (const node of lastNodes) {\n      node.remove();\n    }\n    lastNodes = [];\n  }\n  function restart() {\n    const currentRootDOMNode = editor.getRootElement();\n    if (currentRootDOMNode === null) {\n      return stop();\n    }\n    const currentParentDOMNode = currentRootDOMNode.parentElement;\n    if (!(currentParentDOMNode instanceof HTMLElement)) {\n      return stop();\n    }\n    stop();\n    rootDOMNode = currentRootDOMNode;\n    parentDOMNode = currentParentDOMNode;\n    observer = new MutationObserver(mutations => {\n      const nextRootDOMNode = editor.getRootElement();\n      const nextParentDOMNode = nextRootDOMNode && nextRootDOMNode.parentElement;\n      if (nextRootDOMNode !== rootDOMNode || nextParentDOMNode !== parentDOMNode) {\n        return restart();\n      }\n      for (const mutation of mutations) {\n        if (!wrapperNode.contains(mutation.target)) {\n          // TODO throttle\n          return position();\n        }\n      }\n    });\n    observer.observe(currentParentDOMNode, mutationObserverConfig);\n    position();\n  }\n  const removeRootListener = editor.registerRootListener(restart);\n  return () => {\n    removeRootListener();\n    stop();\n  };\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction markSelection(editor, onReposition) {\n  let previousAnchorNode = null;\n  let previousAnchorOffset = null;\n  let previousFocusNode = null;\n  let previousFocusOffset = null;\n  let removeRangeListener = () => {};\n  function compute(editorState) {\n    editorState.read(() => {\n      const selection = $getSelection();\n      if (!$isRangeSelection(selection)) {\n        // TODO\n        previousAnchorNode = null;\n        previousAnchorOffset = null;\n        previousFocusNode = null;\n        previousFocusOffset = null;\n        removeRangeListener();\n        removeRangeListener = () => {};\n        return;\n      }\n      const {\n        anchor,\n        focus\n      } = selection;\n      const currentAnchorNode = anchor.getNode();\n      const currentAnchorNodeKey = currentAnchorNode.getKey();\n      const currentAnchorOffset = anchor.offset;\n      const currentFocusNode = focus.getNode();\n      const currentFocusNodeKey = currentFocusNode.getKey();\n      const currentFocusOffset = focus.offset;\n      const currentAnchorNodeDOM = editor.getElementByKey(currentAnchorNodeKey);\n      const currentFocusNodeDOM = editor.getElementByKey(currentFocusNodeKey);\n      const differentAnchorDOM = previousAnchorNode === null || currentAnchorNodeDOM === null || currentAnchorOffset !== previousAnchorOffset || currentAnchorNodeKey !== previousAnchorNode.getKey() || currentAnchorNode !== previousAnchorNode && (!(previousAnchorNode instanceof TextNode) || currentAnchorNode.updateDOM(previousAnchorNode, currentAnchorNodeDOM, editor._config));\n      const differentFocusDOM = previousFocusNode === null || currentFocusNodeDOM === null || currentFocusOffset !== previousFocusOffset || currentFocusNodeKey !== previousFocusNode.getKey() || currentFocusNode !== previousFocusNode && (!(previousFocusNode instanceof TextNode) || currentFocusNode.updateDOM(previousFocusNode, currentFocusNodeDOM, editor._config));\n      if (differentAnchorDOM || differentFocusDOM) {\n        const anchorHTMLElement = editor.getElementByKey(anchor.getNode().getKey());\n        const focusHTMLElement = editor.getElementByKey(focus.getNode().getKey());\n        // TODO handle selection beyond the common TextNode\n        if (anchorHTMLElement !== null && focusHTMLElement !== null && anchorHTMLElement.tagName === 'SPAN' && focusHTMLElement.tagName === 'SPAN') {\n          const range = document.createRange();\n          let firstHTMLElement;\n          let firstOffset;\n          let lastHTMLElement;\n          let lastOffset;\n          if (focus.isBefore(anchor)) {\n            firstHTMLElement = focusHTMLElement;\n            firstOffset = focus.offset;\n            lastHTMLElement = anchorHTMLElement;\n            lastOffset = anchor.offset;\n          } else {\n            firstHTMLElement = anchorHTMLElement;\n            firstOffset = anchor.offset;\n            lastHTMLElement = focusHTMLElement;\n            lastOffset = focus.offset;\n          }\n          const firstTextNode = firstHTMLElement.firstChild;\n          if (!(firstTextNode !== null)) {\n            throw Error(`Expected text node to be first child of span`);\n          }\n          const lastTextNode = lastHTMLElement.firstChild;\n          if (!(lastTextNode !== null)) {\n            throw Error(`Expected text node to be first child of span`);\n          }\n          range.setStart(firstTextNode, firstOffset);\n          range.setEnd(lastTextNode, lastOffset);\n          removeRangeListener();\n          removeRangeListener = positionNodeOnRange(editor, range, domNodes => {\n            for (const domNode of domNodes) {\n              const domNodeStyle = domNode.style;\n              if (domNodeStyle.background !== 'Highlight') {\n                domNodeStyle.background = 'Highlight';\n              }\n              if (domNodeStyle.color !== 'HighlightText') {\n                domNodeStyle.color = 'HighlightText';\n              }\n              if (domNodeStyle.zIndex !== '-1') {\n                domNodeStyle.zIndex = '-1';\n              }\n              if (domNodeStyle.pointerEvents !== 'none') {\n                domNodeStyle.pointerEvents = 'none';\n              }\n              if (domNodeStyle.marginTop !== px(-1.5)) {\n                domNodeStyle.marginTop = px(-1.5);\n              }\n              if (domNodeStyle.paddingTop !== px(4)) {\n                domNodeStyle.paddingTop = px(4);\n              }\n              if (domNodeStyle.paddingBottom !== px(0)) {\n                domNodeStyle.paddingBottom = px(0);\n              }\n            }\n            if (onReposition !== undefined) {\n              onReposition(domNodes);\n            }\n          });\n        }\n      }\n      previousAnchorNode = currentAnchorNode;\n      previousAnchorOffset = currentAnchorOffset;\n      previousFocusNode = currentFocusNode;\n      previousFocusOffset = currentFocusOffset;\n    });\n  }\n  compute(editor.getEditorState());\n  return mergeRegister(editor.registerUpdateListener(({\n    editorState\n  }) => compute(editorState)), removeRangeListener, () => {\n    removeRangeListener();\n  });\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n// Hotfix to export these with inlined types #5918\nconst CAN_USE_BEFORE_INPUT = CAN_USE_BEFORE_INPUT$1;\nconst CAN_USE_DOM = CAN_USE_DOM$1;\nconst IS_ANDROID = IS_ANDROID$1;\nconst IS_ANDROID_CHROME = IS_ANDROID_CHROME$1;\nconst IS_APPLE = IS_APPLE$1;\nconst IS_APPLE_WEBKIT = IS_APPLE_WEBKIT$1;\nconst IS_CHROME = IS_CHROME$1;\nconst IS_FIREFOX = IS_FIREFOX$1;\nconst IS_IOS = IS_IOS$1;\nconst IS_SAFARI = IS_SAFARI$1;\n\n/**\n * Takes an HTML element and adds the classNames passed within an array,\n * ignoring any non-string types. A space can be used to add multiple classes\n * eg. addClassNamesToElement(element, ['element-inner active', true, null])\n * will add both 'element-inner' and 'active' as classes to that element.\n * @param element - The element in which the classes are added\n * @param classNames - An array defining the class names to add to the element\n */\nfunction addClassNamesToElement(element, ...classNames) {\n  const classesToAdd = normalizeClassNames(...classNames);\n  if (classesToAdd.length > 0) {\n    element.classList.add(...classesToAdd);\n  }\n}\n\n/**\n * Takes an HTML element and removes the classNames passed within an array,\n * ignoring any non-string types. A space can be used to remove multiple classes\n * eg. removeClassNamesFromElement(element, ['active small', true, null])\n * will remove both the 'active' and 'small' classes from that element.\n * @param element - The element in which the classes are removed\n * @param classNames - An array defining the class names to remove from the element\n */\nfunction removeClassNamesFromElement(element, ...classNames) {\n  const classesToRemove = normalizeClassNames(...classNames);\n  if (classesToRemove.length > 0) {\n    element.classList.remove(...classesToRemove);\n  }\n}\n\n/**\n * Returns true if the file type matches the types passed within the acceptableMimeTypes array, false otherwise.\n * The types passed must be strings and are CASE-SENSITIVE.\n * eg. if file is of type 'text' and acceptableMimeTypes = ['TEXT', 'IMAGE'] the function will return false.\n * @param file - The file you want to type check.\n * @param acceptableMimeTypes - An array of strings of types which the file is checked against.\n * @returns true if the file is an acceptable mime type, false otherwise.\n */\nfunction isMimeType(file, acceptableMimeTypes) {\n  for (const acceptableType of acceptableMimeTypes) {\n    if (file.type.startsWith(acceptableType)) {\n      return true;\n    }\n  }\n  return false;\n}\n\n/**\n * Lexical File Reader with:\n *  1. MIME type support\n *  2. batched results (HistoryPlugin compatibility)\n *  3. Order aware (respects the order when multiple Files are passed)\n *\n * const filesResult = await mediaFileReader(files, ['image/']);\n * filesResult.forEach(file => editor.dispatchCommand('INSERT_IMAGE', \\\\{\n *   src: file.result,\n * \\\\}));\n */\nfunction mediaFileReader(files, acceptableMimeTypes) {\n  const filesIterator = files[Symbol.iterator]();\n  return new Promise((resolve, reject) => {\n    const processed = [];\n    const handleNextFile = () => {\n      const {\n        done,\n        value: file\n      } = filesIterator.next();\n      if (done) {\n        return resolve(processed);\n      }\n      const fileReader = new FileReader();\n      fileReader.addEventListener('error', reject);\n      fileReader.addEventListener('load', () => {\n        const result = fileReader.result;\n        if (typeof result === 'string') {\n          processed.push({\n            file,\n            result\n          });\n        }\n        handleNextFile();\n      });\n      if (isMimeType(file, acceptableMimeTypes)) {\n        fileReader.readAsDataURL(file);\n      } else {\n        handleNextFile();\n      }\n    };\n    handleNextFile();\n  });\n}\n/**\n * \"Depth-First Search\" starts at the root/top node of a tree and goes as far as it can down a branch end\n * before backtracking and finding a new path. Consider solving a maze by hugging either wall, moving down a\n * branch until you hit a dead-end (leaf) and backtracking to find the nearest branching path and repeat.\n * It will then return all the nodes found in the search in an array of objects.\n * @param startNode - The node to start the search, if omitted, it will start at the root node.\n * @param endNode - The node to end the search, if omitted, it will find all descendants of the startingNode.\n * @returns An array of objects of all the nodes found by the search, including their depth into the tree.\n * \\\\{depth: number, node: LexicalNode\\\\} It will always return at least 1 node (the start node).\n */\nfunction $dfs(startNode, endNode) {\n  return Array.from($dfsIterator(startNode, endNode));\n}\nconst iteratorDone = {\n  done: true,\n  value: undefined\n};\nconst iteratorNotDone = value => ({\n  done: false,\n  value\n});\n\n/**\n * $dfs iterator. Tree traversal is done on the fly as new values are requested with O(1) memory.\n * @param startNode - The node to start the search, if omitted, it will start at the root node.\n * @param endNode - The node to end the search, if omitted, it will find all descendants of the startingNode.\n * @returns An iterator, each yielded value is a DFSNode. It will always return at least 1 node (the start node).\n */\nfunction $dfsIterator(startNode, endNode) {\n  const start = (startNode || $getRoot()).getLatest();\n  const startDepth = $getDepth(start);\n  const end = endNode;\n  let node = start;\n  let depth = startDepth;\n  let isFirstNext = true;\n  const iterator = {\n    next() {\n      if (node === null) {\n        return iteratorDone;\n      }\n      if (isFirstNext) {\n        isFirstNext = false;\n        return iteratorNotDone({\n          depth,\n          node\n        });\n      }\n      if (node === end) {\n        return iteratorDone;\n      }\n      if ($isElementNode(node) && node.getChildrenSize() > 0) {\n        node = node.getFirstChild();\n        depth++;\n      } else {\n        let depthDiff;\n        [node, depthDiff] = $getNextSiblingOrParentSibling(node) || [null, 0];\n        depth += depthDiff;\n        if (end == null && depth <= startDepth) {\n          node = null;\n        }\n      }\n      if (node === null) {\n        return iteratorDone;\n      }\n      return iteratorNotDone({\n        depth,\n        node\n      });\n    },\n    [Symbol.iterator]() {\n      return iterator;\n    }\n  };\n  return iterator;\n}\n\n/**\n * Returns the Node sibling when this exists, otherwise the closest parent sibling. For example\n * R -> P -> T1, T2\n *   -> P2\n * returns T2 for node T1, P2 for node T2, and null for node P2.\n * @param node LexicalNode.\n * @returns An array (tuple) containing the found Lexical node and the depth difference, or null, if this node doesn't exist.\n */\nfunction $getNextSiblingOrParentSibling(node) {\n  let node_ = node;\n  // Find immediate sibling or nearest parent sibling\n  let sibling = null;\n  let depthDiff = 0;\n  while (sibling === null && node_ !== null) {\n    sibling = node_.getNextSibling();\n    if (sibling === null) {\n      node_ = node_.getParent();\n      depthDiff--;\n    } else {\n      node_ = sibling;\n    }\n  }\n  if (node_ === null) {\n    return null;\n  }\n  return [node_, depthDiff];\n}\nfunction $getDepth(node) {\n  let innerNode = node;\n  let depth = 0;\n  while ((innerNode = innerNode.getParent()) !== null) {\n    depth++;\n  }\n  return depth;\n}\n\n/**\n * Performs a right-to-left preorder tree traversal.\n * From the starting node it goes to the rightmost child, than backtracks to paret and finds new rightmost path.\n * It will return the next node in traversal sequence after the startingNode.\n * The traversal is similar to $dfs functions above, but the nodes are visited right-to-left, not left-to-right.\n * @param startingNode - The node to start the search.\n * @returns The next node in pre-order right to left traversal sequence or `null`, if the node does not exist\n */\nfunction $getNextRightPreorderNode(startingNode) {\n  let node = startingNode;\n  if ($isElementNode(node) && node.getChildrenSize() > 0) {\n    node = node.getLastChild();\n  } else {\n    let sibling = null;\n    while (sibling === null && node !== null) {\n      sibling = node.getPreviousSibling();\n      if (sibling === null) {\n        node = node.getParent();\n      } else {\n        node = sibling;\n      }\n    }\n  }\n  return node;\n}\n\n/**\n * Takes a node and traverses up its ancestors (toward the root node)\n * in order to find a specific type of node.\n * @param node - the node to begin searching.\n * @param klass - an instance of the type of node to look for.\n * @returns the node of type klass that was passed, or null if none exist.\n */\nfunction $getNearestNodeOfType(node, klass) {\n  let parent = node;\n  while (parent != null) {\n    if (parent instanceof klass) {\n      return parent;\n    }\n    parent = parent.getParent();\n  }\n  return null;\n}\n\n/**\n * Returns the element node of the nearest ancestor, otherwise throws an error.\n * @param startNode - The starting node of the search\n * @returns The ancestor node found\n */\nfunction $getNearestBlockElementAncestorOrThrow(startNode) {\n  const blockNode = $findMatchingParent(startNode, node => $isElementNode(node) && !node.isInline());\n  if (!$isElementNode(blockNode)) {\n    {\n      throw Error(`Expected node ${startNode.__key} to have closest block element node.`);\n    }\n  }\n  return blockNode;\n}\n/**\n * Starts with a node and moves up the tree (toward the root node) to find a matching node based on\n * the search parameters of the findFn. (Consider JavaScripts' .find() function where a testing function must be\n * passed as an argument. eg. if( (node) => node.__type === 'div') ) return true; otherwise return false\n * @param startingNode - The node where the search starts.\n * @param findFn - A testing function that returns true if the current node satisfies the testing parameters.\n * @returns A parent node that matches the findFn parameters, or null if one wasn't found.\n */\nconst $findMatchingParent = (startingNode, findFn) => {\n  let curr = startingNode;\n  while (curr !== $getRoot() && curr != null) {\n    if (findFn(curr)) {\n      return curr;\n    }\n    curr = curr.getParent();\n  }\n  return null;\n};\n\n/**\n * Attempts to resolve nested element nodes of the same type into a single node of that type.\n * It is generally used for marks/commenting\n * @param editor - The lexical editor\n * @param targetNode - The target for the nested element to be extracted from.\n * @param cloneNode - See {@link $createMarkNode}\n * @param handleOverlap - Handles any overlap between the node to extract and the targetNode\n * @returns The lexical editor\n */\nfunction registerNestedElementResolver(editor, targetNode, cloneNode, handleOverlap) {\n  const $isTargetNode = node => {\n    return node instanceof targetNode;\n  };\n  const $findMatch = node => {\n    // First validate we don't have any children that are of the target,\n    // as we need to handle them first.\n    const children = node.getChildren();\n    for (let i = 0; i < children.length; i++) {\n      const child = children[i];\n      if ($isTargetNode(child)) {\n        return null;\n      }\n    }\n    let parentNode = node;\n    let childNode = node;\n    while (parentNode !== null) {\n      childNode = parentNode;\n      parentNode = parentNode.getParent();\n      if ($isTargetNode(parentNode)) {\n        return {\n          child: childNode,\n          parent: parentNode\n        };\n      }\n    }\n    return null;\n  };\n  const $elementNodeTransform = node => {\n    const match = $findMatch(node);\n    if (match !== null) {\n      const {\n        child,\n        parent\n      } = match;\n\n      // Simple path, we can move child out and siblings into a new parent.\n\n      if (child.is(node)) {\n        handleOverlap(parent, node);\n        const nextSiblings = child.getNextSiblings();\n        const nextSiblingsLength = nextSiblings.length;\n        parent.insertAfter(child);\n        if (nextSiblingsLength !== 0) {\n          const newParent = cloneNode(parent);\n          child.insertAfter(newParent);\n          for (let i = 0; i < nextSiblingsLength; i++) {\n            newParent.append(nextSiblings[i]);\n          }\n        }\n        if (!parent.canBeEmpty() && parent.getChildrenSize() === 0) {\n          parent.remove();\n        }\n      }\n    }\n  };\n  return editor.registerNodeTransform(targetNode, $elementNodeTransform);\n}\n\n/**\n * Clones the editor and marks it as dirty to be reconciled. If there was a selection,\n * it would be set back to its previous state, or null otherwise.\n * @param editor - The lexical editor\n * @param editorState - The editor's state\n */\nfunction $restoreEditorState(editor, editorState) {\n  const FULL_RECONCILE = 2;\n  const nodeMap = new Map();\n  const activeEditorState = editor._pendingEditorState;\n  for (const [key, node] of editorState._nodeMap) {\n    nodeMap.set(key, $cloneWithProperties(node));\n  }\n  if (activeEditorState) {\n    activeEditorState._nodeMap = nodeMap;\n  }\n  editor._dirtyType = FULL_RECONCILE;\n  const selection = editorState._selection;\n  $setSelection(selection === null ? null : selection.clone());\n}\n\n/**\n * If the selected insertion area is the root/shadow root node (see {@link lexical!$isRootOrShadowRoot}),\n * the node will be appended there, otherwise, it will be inserted before the insertion area.\n * If there is no selection where the node is to be inserted, it will be appended after any current nodes\n * within the tree, as a child of the root node. A paragraph node will then be added after the inserted node and selected.\n * @param node - The node to be inserted\n * @returns The node after its insertion\n */\nfunction $insertNodeToNearestRoot(node) {\n  const selection = $getSelection() || $getPreviousSelection();\n  if ($isRangeSelection(selection)) {\n    const {\n      focus\n    } = selection;\n    const focusNode = focus.getNode();\n    const focusOffset = focus.offset;\n    if ($isRootOrShadowRoot(focusNode)) {\n      const focusChild = focusNode.getChildAtIndex(focusOffset);\n      if (focusChild == null) {\n        focusNode.append(node);\n      } else {\n        focusChild.insertBefore(node);\n      }\n      node.selectNext();\n    } else {\n      let splitNode;\n      let splitOffset;\n      if ($isTextNode(focusNode)) {\n        splitNode = focusNode.getParentOrThrow();\n        splitOffset = focusNode.getIndexWithinParent();\n        if (focusOffset > 0) {\n          splitOffset += 1;\n          focusNode.splitText(focusOffset);\n        }\n      } else {\n        splitNode = focusNode;\n        splitOffset = focusOffset;\n      }\n      const [, rightTree] = $splitNode(splitNode, splitOffset);\n      rightTree.insertBefore(node);\n      rightTree.selectStart();\n    }\n  } else {\n    if (selection != null) {\n      const nodes = selection.getNodes();\n      nodes[nodes.length - 1].getTopLevelElementOrThrow().insertAfter(node);\n    } else {\n      const root = $getRoot();\n      root.append(node);\n    }\n    const paragraphNode = $createParagraphNode();\n    node.insertAfter(paragraphNode);\n    paragraphNode.select();\n  }\n  return node.getLatest();\n}\n\n/**\n * Wraps the node into another node created from a createElementNode function, eg. $createParagraphNode\n * @param node - Node to be wrapped.\n * @param createElementNode - Creates a new lexical element to wrap the to-be-wrapped node and returns it.\n * @returns A new lexical element with the previous node appended within (as a child, including its children).\n */\nfunction $wrapNodeInElement(node, createElementNode) {\n  const elementNode = createElementNode();\n  node.replace(elementNode);\n  elementNode.append(node);\n  return elementNode;\n}\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\n\n/**\n * @param object = The instance of the type\n * @param objectClass = The class of the type\n * @returns Whether the object is has the same Klass of the objectClass, ignoring the difference across window (e.g. different iframs)\n */\nfunction objectKlassEquals(object, objectClass) {\n  return object !== null ? Object.getPrototypeOf(object).constructor.name === objectClass.name : false;\n}\n\n/**\n * Filter the nodes\n * @param nodes Array of nodes that needs to be filtered\n * @param filterFn A filter function that returns node if the current node satisfies the condition otherwise null\n * @returns Array of filtered nodes\n */\n\nfunction $filter(nodes, filterFn) {\n  const result = [];\n  for (let i = 0; i < nodes.length; i++) {\n    const node = filterFn(nodes[i]);\n    if (node !== null) {\n      result.push(node);\n    }\n  }\n  return result;\n}\n/**\n * Appends the node before the first child of the parent node\n * @param parent A parent node\n * @param node Node that needs to be appended\n */\nfunction $insertFirst(parent, node) {\n  const firstChild = parent.getFirstChild();\n  if (firstChild !== null) {\n    firstChild.insertBefore(node);\n  } else {\n    parent.append(node);\n  }\n}\n\n/**\n * Calculates the zoom level of an element as a result of using\n * css zoom property.\n * @param element\n */\nfunction calculateZoomLevel(element) {\n  if (IS_FIREFOX) {\n    return 1;\n  }\n  let zoom = 1;\n  while (element) {\n    zoom *= Number(window.getComputedStyle(element).getPropertyValue('zoom'));\n    element = element.parentElement;\n  }\n  return zoom;\n}\n\n/**\n * Checks if the editor is a nested editor created by LexicalNestedComposer\n */\nfunction $isEditorIsNestedEditor(editor) {\n  return editor._parentEditor !== null;\n}\n\nexport { $dfs, $dfsIterator, $filter, $findMatchingParent, $getDepth, $getNearestBlockElementAncestorOrThrow, $getNearestNodeOfType, $getNextRightPreorderNode, $getNextSiblingOrParentSibling, $insertFirst, $insertNodeToNearestRoot, $isEditorIsNestedEditor, $restoreEditorState, $wrapNodeInElement, CAN_USE_BEFORE_INPUT, CAN_USE_DOM, IS_ANDROID, IS_ANDROID_CHROME, IS_APPLE, IS_APPLE_WEBKIT, IS_CHROME, IS_FIREFOX, IS_IOS, IS_SAFARI, addClassNamesToElement, calculateZoomLevel, isMimeType, markSelection, mediaFileReader, mergeRegister, objectKlassEquals, positionNodeOnRange, registerNestedElementResolver, removeClassNamesFromElement };\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 1773, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1779, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/@lexical/html/LexicalHtml.dev.mjs"],"sourcesContent":["/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nimport { $sliceSelectedTextNodeContent } from '@lexical/selection';\nimport { isHTMLElement, isBlockDomNode } from '@lexical/utils';\nimport { $getRoot, $isElementNode, $cloneWithProperties, $isTextNode, isDocumentFragment, $isRootOrShadowRoot, $isBlockElementNode, $createLineBreakNode, ArtificialNode__DO_NOT_USE, isInlineDomNode, $createParagraphNode } from 'lexical';\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n\n/**\n * How you parse your html string to get a document is left up to you. In the browser you can use the native\n * DOMParser API to generate a document (see clipboard.ts), but to use in a headless environment you can use JSDom\n * or an equivalent library and pass in the document here.\n */\nfunction $generateNodesFromDOM(editor, dom) {\n  const elements = dom.body ? dom.body.childNodes : [];\n  let lexicalNodes = [];\n  const allArtificialNodes = [];\n  for (let i = 0; i < elements.length; i++) {\n    const element = elements[i];\n    if (!IGNORE_TAGS.has(element.nodeName)) {\n      const lexicalNode = $createNodesFromDOM(element, editor, allArtificialNodes, false);\n      if (lexicalNode !== null) {\n        lexicalNodes = lexicalNodes.concat(lexicalNode);\n      }\n    }\n  }\n  $unwrapArtificalNodes(allArtificialNodes);\n  return lexicalNodes;\n}\nfunction $generateHtmlFromNodes(editor, selection) {\n  if (typeof document === 'undefined' || typeof window === 'undefined' && typeof global.window === 'undefined') {\n    throw new Error('To use $generateHtmlFromNodes in headless mode please initialize a headless browser implementation such as JSDom before calling this function.');\n  }\n  const container = document.createElement('div');\n  const root = $getRoot();\n  const topLevelChildren = root.getChildren();\n  for (let i = 0; i < topLevelChildren.length; i++) {\n    const topLevelNode = topLevelChildren[i];\n    $appendNodesToHTML(editor, topLevelNode, container, selection);\n  }\n  return container.innerHTML;\n}\nfunction $appendNodesToHTML(editor, currentNode, parentElement, selection = null) {\n  let shouldInclude = selection !== null ? currentNode.isSelected(selection) : true;\n  const shouldExclude = $isElementNode(currentNode) && currentNode.excludeFromCopy('html');\n  let target = currentNode;\n  if (selection !== null) {\n    let clone = $cloneWithProperties(currentNode);\n    clone = $isTextNode(clone) && selection !== null ? $sliceSelectedTextNodeContent(selection, clone) : clone;\n    target = clone;\n  }\n  const children = $isElementNode(target) ? target.getChildren() : [];\n  const registeredNode = editor._nodes.get(target.getType());\n  let exportOutput;\n\n  // Use HTMLConfig overrides, if available.\n  if (registeredNode && registeredNode.exportDOM !== undefined) {\n    exportOutput = registeredNode.exportDOM(editor, target);\n  } else {\n    exportOutput = target.exportDOM(editor);\n  }\n  const {\n    element,\n    after\n  } = exportOutput;\n  if (!element) {\n    return false;\n  }\n  const fragment = document.createDocumentFragment();\n  for (let i = 0; i < children.length; i++) {\n    const childNode = children[i];\n    const shouldIncludeChild = $appendNodesToHTML(editor, childNode, fragment, selection);\n    if (!shouldInclude && $isElementNode(currentNode) && shouldIncludeChild && currentNode.extractWithChild(childNode, selection, 'html')) {\n      shouldInclude = true;\n    }\n  }\n  if (shouldInclude && !shouldExclude) {\n    if (isHTMLElement(element) || isDocumentFragment(element)) {\n      element.append(fragment);\n    }\n    parentElement.append(element);\n    if (after) {\n      const newElement = after.call(target, element);\n      if (newElement) {\n        if (isDocumentFragment(element)) {\n          element.replaceChildren(newElement);\n        } else {\n          element.replaceWith(newElement);\n        }\n      }\n    }\n  } else {\n    parentElement.append(fragment);\n  }\n  return shouldInclude;\n}\nfunction getConversionFunction(domNode, editor) {\n  const {\n    nodeName\n  } = domNode;\n  const cachedConversions = editor._htmlConversions.get(nodeName.toLowerCase());\n  let currentConversion = null;\n  if (cachedConversions !== undefined) {\n    for (const cachedConversion of cachedConversions) {\n      const domConversion = cachedConversion(domNode);\n      if (domConversion !== null && (currentConversion === null || (currentConversion.priority || 0) < (domConversion.priority || 0))) {\n        currentConversion = domConversion;\n      }\n    }\n  }\n  return currentConversion !== null ? currentConversion.conversion : null;\n}\nconst IGNORE_TAGS = new Set(['STYLE', 'SCRIPT']);\nfunction $createNodesFromDOM(node, editor, allArtificialNodes, hasBlockAncestorLexicalNode, forChildMap = new Map(), parentLexicalNode) {\n  let lexicalNodes = [];\n  if (IGNORE_TAGS.has(node.nodeName)) {\n    return lexicalNodes;\n  }\n  let currentLexicalNode = null;\n  const transformFunction = getConversionFunction(node, editor);\n  const transformOutput = transformFunction ? transformFunction(node) : null;\n  let postTransform = null;\n  if (transformOutput !== null) {\n    postTransform = transformOutput.after;\n    const transformNodes = transformOutput.node;\n    currentLexicalNode = Array.isArray(transformNodes) ? transformNodes[transformNodes.length - 1] : transformNodes;\n    if (currentLexicalNode !== null) {\n      for (const [, forChildFunction] of forChildMap) {\n        currentLexicalNode = forChildFunction(currentLexicalNode, parentLexicalNode);\n        if (!currentLexicalNode) {\n          break;\n        }\n      }\n      if (currentLexicalNode) {\n        lexicalNodes.push(...(Array.isArray(transformNodes) ? transformNodes : [currentLexicalNode]));\n      }\n    }\n    if (transformOutput.forChild != null) {\n      forChildMap.set(node.nodeName, transformOutput.forChild);\n    }\n  }\n\n  // If the DOM node doesn't have a transformer, we don't know what\n  // to do with it but we still need to process any childNodes.\n  const children = node.childNodes;\n  let childLexicalNodes = [];\n  const hasBlockAncestorLexicalNodeForChildren = currentLexicalNode != null && $isRootOrShadowRoot(currentLexicalNode) ? false : currentLexicalNode != null && $isBlockElementNode(currentLexicalNode) || hasBlockAncestorLexicalNode;\n  for (let i = 0; i < children.length; i++) {\n    childLexicalNodes.push(...$createNodesFromDOM(children[i], editor, allArtificialNodes, hasBlockAncestorLexicalNodeForChildren, new Map(forChildMap), currentLexicalNode));\n  }\n  if (postTransform != null) {\n    childLexicalNodes = postTransform(childLexicalNodes);\n  }\n  if (isBlockDomNode(node)) {\n    if (!hasBlockAncestorLexicalNodeForChildren) {\n      childLexicalNodes = wrapContinuousInlines(node, childLexicalNodes, $createParagraphNode);\n    } else {\n      childLexicalNodes = wrapContinuousInlines(node, childLexicalNodes, () => {\n        const artificialNode = new ArtificialNode__DO_NOT_USE();\n        allArtificialNodes.push(artificialNode);\n        return artificialNode;\n      });\n    }\n  }\n  if (currentLexicalNode == null) {\n    if (childLexicalNodes.length > 0) {\n      // If it hasn't been converted to a LexicalNode, we hoist its children\n      // up to the same level as it.\n      lexicalNodes = lexicalNodes.concat(childLexicalNodes);\n    } else {\n      if (isBlockDomNode(node) && isDomNodeBetweenTwoInlineNodes(node)) {\n        // Empty block dom node that hasnt been converted, we replace it with a linebreak if its between inline nodes\n        lexicalNodes = lexicalNodes.concat($createLineBreakNode());\n      }\n    }\n  } else {\n    if ($isElementNode(currentLexicalNode)) {\n      // If the current node is a ElementNode after conversion,\n      // we can append all the children to it.\n      currentLexicalNode.append(...childLexicalNodes);\n    }\n  }\n  return lexicalNodes;\n}\nfunction wrapContinuousInlines(domNode, nodes, createWrapperFn) {\n  const textAlign = domNode.style.textAlign;\n  const out = [];\n  let continuousInlines = [];\n  // wrap contiguous inline child nodes in para\n  for (let i = 0; i < nodes.length; i++) {\n    const node = nodes[i];\n    if ($isBlockElementNode(node)) {\n      if (textAlign && !node.getFormat()) {\n        node.setFormat(textAlign);\n      }\n      out.push(node);\n    } else {\n      continuousInlines.push(node);\n      if (i === nodes.length - 1 || i < nodes.length - 1 && $isBlockElementNode(nodes[i + 1])) {\n        const wrapper = createWrapperFn();\n        wrapper.setFormat(textAlign);\n        wrapper.append(...continuousInlines);\n        out.push(wrapper);\n        continuousInlines = [];\n      }\n    }\n  }\n  return out;\n}\nfunction $unwrapArtificalNodes(allArtificialNodes) {\n  for (const node of allArtificialNodes) {\n    if (node.getNextSibling() instanceof ArtificialNode__DO_NOT_USE) {\n      node.insertAfter($createLineBreakNode());\n    }\n  }\n  // Replace artificial node with it's children\n  for (const node of allArtificialNodes) {\n    const children = node.getChildren();\n    for (const child of children) {\n      node.insertBefore(child);\n    }\n    node.remove();\n  }\n}\nfunction isDomNodeBetweenTwoInlineNodes(node) {\n  if (node.nextSibling == null || node.previousSibling == null) {\n    return false;\n  }\n  return isInlineDomNode(node.nextSibling) && isInlineDomNode(node.previousSibling);\n}\n\nexport { $generateHtmlFromNodes, $generateNodesFromDOM };\n"],"names":[],"mappings":"AAAA;;;;;;CAMC;;;;AAID;AAFA;;;;AAIA;;;;;;CAMC,GAGD;;;;CAIC,GACD,SAAS,sBAAsB,MAAM,EAAE,GAAG;IACxC,MAAM,WAAW,IAAI,IAAI,GAAG,IAAI,IAAI,CAAC,UAAU,GAAG,EAAE;IACpD,IAAI,eAAe,EAAE;IACrB,MAAM,qBAAqB,EAAE;IAC7B,IAAK,IAAI,IAAI,GAAG,IAAI,SAAS,MAAM,EAAE,IAAK;QACxC,MAAM,UAAU,QAAQ,CAAC,EAAE;QAC3B,IAAI,CAAC,YAAY,GAAG,CAAC,QAAQ,QAAQ,GAAG;YACtC,MAAM,cAAc,oBAAoB,SAAS,QAAQ,oBAAoB;YAC7E,IAAI,gBAAgB,MAAM;gBACxB,eAAe,aAAa,MAAM,CAAC;YACrC;QACF;IACF;IACA,sBAAsB;IACtB,OAAO;AACT;AACA,SAAS,uBAAuB,MAAM,EAAE,SAAS;IAC/C,IAAI,OAAO,aAAa,eAAe,gBAAkB,eAAe,OAAO,OAAO,MAAM,KAAK,aAAa;QAC5G,MAAM,IAAI,MAAM;IAClB;IACA,MAAM,YAAY,SAAS,aAAa,CAAC;IACzC,MAAM,OAAO,CAAA,GAAA,0IAAA,CAAA,WAAQ,AAAD;IACpB,MAAM,mBAAmB,KAAK,WAAW;IACzC,IAAK,IAAI,IAAI,GAAG,IAAI,iBAAiB,MAAM,EAAE,IAAK;QAChD,MAAM,eAAe,gBAAgB,CAAC,EAAE;QACxC,mBAAmB,QAAQ,cAAc,WAAW;IACtD;IACA,OAAO,UAAU,SAAS;AAC5B;AACA,SAAS,mBAAmB,MAAM,EAAE,WAAW,EAAE,aAAa,EAAE,YAAY,IAAI;IAC9E,IAAI,gBAAgB,cAAc,OAAO,YAAY,UAAU,CAAC,aAAa;IAC7E,MAAM,gBAAgB,CAAA,GAAA,0IAAA,CAAA,iBAAc,AAAD,EAAE,gBAAgB,YAAY,eAAe,CAAC;IACjF,IAAI,SAAS;IACb,IAAI,cAAc,MAAM;QACtB,IAAI,QAAQ,CAAA,GAAA,0IAAA,CAAA,uBAAoB,AAAD,EAAE;QACjC,QAAQ,CAAA,GAAA,0IAAA,CAAA,cAAW,AAAD,EAAE,UAAU,cAAc,OAAO,CAAA,GAAA,kLAAA,CAAA,gCAA6B,AAAD,EAAE,WAAW,SAAS;QACrG,SAAS;IACX;IACA,MAAM,WAAW,CAAA,GAAA,0IAAA,CAAA,iBAAc,AAAD,EAAE,UAAU,OAAO,WAAW,KAAK,EAAE;IACnE,MAAM,iBAAiB,OAAO,MAAM,CAAC,GAAG,CAAC,OAAO,OAAO;IACvD,IAAI;IAEJ,0CAA0C;IAC1C,IAAI,kBAAkB,eAAe,SAAS,KAAK,WAAW;QAC5D,eAAe,eAAe,SAAS,CAAC,QAAQ;IAClD,OAAO;QACL,eAAe,OAAO,SAAS,CAAC;IAClC;IACA,MAAM,EACJ,OAAO,EACP,KAAK,EACN,GAAG;IACJ,IAAI,CAAC,SAAS;QACZ,OAAO;IACT;IACA,MAAM,WAAW,SAAS,sBAAsB;IAChD,IAAK,IAAI,IAAI,GAAG,IAAI,SAAS,MAAM,EAAE,IAAK;QACxC,MAAM,YAAY,QAAQ,CAAC,EAAE;QAC7B,MAAM,qBAAqB,mBAAmB,QAAQ,WAAW,UAAU;QAC3E,IAAI,CAAC,iBAAiB,CAAA,GAAA,0IAAA,CAAA,iBAAc,AAAD,EAAE,gBAAgB,sBAAsB,YAAY,gBAAgB,CAAC,WAAW,WAAW,SAAS;YACrI,gBAAgB;QAClB;IACF;IACA,IAAI,iBAAiB,CAAC,eAAe;QACnC,IAAI,CAAA,GAAA,0IAAA,CAAA,gBAAa,AAAD,EAAE,YAAY,CAAA,GAAA,0IAAA,CAAA,qBAAkB,AAAD,EAAE,UAAU;YACzD,QAAQ,MAAM,CAAC;QACjB;QACA,cAAc,MAAM,CAAC;QACrB,IAAI,OAAO;YACT,MAAM,aAAa,MAAM,IAAI,CAAC,QAAQ;YACtC,IAAI,YAAY;gBACd,IAAI,CAAA,GAAA,0IAAA,CAAA,qBAAkB,AAAD,EAAE,UAAU;oBAC/B,QAAQ,eAAe,CAAC;gBAC1B,OAAO;oBACL,QAAQ,WAAW,CAAC;gBACtB;YACF;QACF;IACF,OAAO;QACL,cAAc,MAAM,CAAC;IACvB;IACA,OAAO;AACT;AACA,SAAS,sBAAsB,OAAO,EAAE,MAAM;IAC5C,MAAM,EACJ,QAAQ,EACT,GAAG;IACJ,MAAM,oBAAoB,OAAO,gBAAgB,CAAC,GAAG,CAAC,SAAS,WAAW;IAC1E,IAAI,oBAAoB;IACxB,IAAI,sBAAsB,WAAW;QACnC,KAAK,MAAM,oBAAoB,kBAAmB;YAChD,MAAM,gBAAgB,iBAAiB;YACvC,IAAI,kBAAkB,QAAQ,CAAC,sBAAsB,QAAQ,CAAC,kBAAkB,QAAQ,IAAI,CAAC,IAAI,CAAC,cAAc,QAAQ,IAAI,CAAC,CAAC,GAAG;gBAC/H,oBAAoB;YACtB;QACF;IACF;IACA,OAAO,sBAAsB,OAAO,kBAAkB,UAAU,GAAG;AACrE;AACA,MAAM,cAAc,IAAI,IAAI;IAAC;IAAS;CAAS;AAC/C,SAAS,oBAAoB,IAAI,EAAE,MAAM,EAAE,kBAAkB,EAAE,2BAA2B,EAAE,cAAc,IAAI,KAAK,EAAE,iBAAiB;IACpI,IAAI,eAAe,EAAE;IACrB,IAAI,YAAY,GAAG,CAAC,KAAK,QAAQ,GAAG;QAClC,OAAO;IACT;IACA,IAAI,qBAAqB;IACzB,MAAM,oBAAoB,sBAAsB,MAAM;IACtD,MAAM,kBAAkB,oBAAoB,kBAAkB,QAAQ;IACtE,IAAI,gBAAgB;IACpB,IAAI,oBAAoB,MAAM;QAC5B,gBAAgB,gBAAgB,KAAK;QACrC,MAAM,iBAAiB,gBAAgB,IAAI;QAC3C,qBAAqB,MAAM,OAAO,CAAC,kBAAkB,cAAc,CAAC,eAAe,MAAM,GAAG,EAAE,GAAG;QACjG,IAAI,uBAAuB,MAAM;YAC/B,KAAK,MAAM,GAAG,iBAAiB,IAAI,YAAa;gBAC9C,qBAAqB,iBAAiB,oBAAoB;gBAC1D,IAAI,CAAC,oBAAoB;oBACvB;gBACF;YACF;YACA,IAAI,oBAAoB;gBACtB,aAAa,IAAI,IAAK,MAAM,OAAO,CAAC,kBAAkB,iBAAiB;oBAAC;iBAAmB;YAC7F;QACF;QACA,IAAI,gBAAgB,QAAQ,IAAI,MAAM;YACpC,YAAY,GAAG,CAAC,KAAK,QAAQ,EAAE,gBAAgB,QAAQ;QACzD;IACF;IAEA,iEAAiE;IACjE,6DAA6D;IAC7D,MAAM,WAAW,KAAK,UAAU;IAChC,IAAI,oBAAoB,EAAE;IAC1B,MAAM,yCAAyC,sBAAsB,QAAQ,CAAA,GAAA,0IAAA,CAAA,sBAAmB,AAAD,EAAE,sBAAsB,QAAQ,sBAAsB,QAAQ,CAAA,GAAA,0IAAA,CAAA,sBAAmB,AAAD,EAAE,uBAAuB;IACxM,IAAK,IAAI,IAAI,GAAG,IAAI,SAAS,MAAM,EAAE,IAAK;QACxC,kBAAkB,IAAI,IAAI,oBAAoB,QAAQ,CAAC,EAAE,EAAE,QAAQ,oBAAoB,wCAAwC,IAAI,IAAI,cAAc;IACvJ;IACA,IAAI,iBAAiB,MAAM;QACzB,oBAAoB,cAAc;IACpC;IACA,IAAI,CAAA,GAAA,0IAAA,CAAA,iBAAc,AAAD,EAAE,OAAO;QACxB,IAAI,CAAC,wCAAwC;YAC3C,oBAAoB,sBAAsB,MAAM,mBAAmB,0IAAA,CAAA,uBAAoB;QACzF,OAAO;YACL,oBAAoB,sBAAsB,MAAM,mBAAmB;gBACjE,MAAM,iBAAiB,IAAI,0IAAA,CAAA,6BAA0B;gBACrD,mBAAmB,IAAI,CAAC;gBACxB,OAAO;YACT;QACF;IACF;IACA,IAAI,sBAAsB,MAAM;QAC9B,IAAI,kBAAkB,MAAM,GAAG,GAAG;YAChC,sEAAsE;YACtE,8BAA8B;YAC9B,eAAe,aAAa,MAAM,CAAC;QACrC,OAAO;YACL,IAAI,CAAA,GAAA,0IAAA,CAAA,iBAAc,AAAD,EAAE,SAAS,+BAA+B,OAAO;gBAChE,6GAA6G;gBAC7G,eAAe,aAAa,MAAM,CAAC,CAAA,GAAA,0IAAA,CAAA,uBAAoB,AAAD;YACxD;QACF;IACF,OAAO;QACL,IAAI,CAAA,GAAA,0IAAA,CAAA,iBAAc,AAAD,EAAE,qBAAqB;YACtC,yDAAyD;YACzD,wCAAwC;YACxC,mBAAmB,MAAM,IAAI;QAC/B;IACF;IACA,OAAO;AACT;AACA,SAAS,sBAAsB,OAAO,EAAE,KAAK,EAAE,eAAe;IAC5D,MAAM,YAAY,QAAQ,KAAK,CAAC,SAAS;IACzC,MAAM,MAAM,EAAE;IACd,IAAI,oBAAoB,EAAE;IAC1B,6CAA6C;IAC7C,IAAK,IAAI,IAAI,GAAG,IAAI,MAAM,MAAM,EAAE,IAAK;QACrC,MAAM,OAAO,KAAK,CAAC,EAAE;QACrB,IAAI,CAAA,GAAA,0IAAA,CAAA,sBAAmB,AAAD,EAAE,OAAO;YAC7B,IAAI,aAAa,CAAC,KAAK,SAAS,IAAI;gBAClC,KAAK,SAAS,CAAC;YACjB;YACA,IAAI,IAAI,CAAC;QACX,OAAO;YACL,kBAAkB,IAAI,CAAC;YACvB,IAAI,MAAM,MAAM,MAAM,GAAG,KAAK,IAAI,MAAM,MAAM,GAAG,KAAK,CAAA,GAAA,0IAAA,CAAA,sBAAmB,AAAD,EAAE,KAAK,CAAC,IAAI,EAAE,GAAG;gBACvF,MAAM,UAAU;gBAChB,QAAQ,SAAS,CAAC;gBAClB,QAAQ,MAAM,IAAI;gBAClB,IAAI,IAAI,CAAC;gBACT,oBAAoB,EAAE;YACxB;QACF;IACF;IACA,OAAO;AACT;AACA,SAAS,sBAAsB,kBAAkB;IAC/C,KAAK,MAAM,QAAQ,mBAAoB;QACrC,IAAI,KAAK,cAAc,cAAc,0IAAA,CAAA,6BAA0B,EAAE;YAC/D,KAAK,WAAW,CAAC,CAAA,GAAA,0IAAA,CAAA,uBAAoB,AAAD;QACtC;IACF;IACA,6CAA6C;IAC7C,KAAK,MAAM,QAAQ,mBAAoB;QACrC,MAAM,WAAW,KAAK,WAAW;QACjC,KAAK,MAAM,SAAS,SAAU;YAC5B,KAAK,YAAY,CAAC;QACpB;QACA,KAAK,MAAM;IACb;AACF;AACA,SAAS,+BAA+B,IAAI;IAC1C,IAAI,KAAK,WAAW,IAAI,QAAQ,KAAK,eAAe,IAAI,MAAM;QAC5D,OAAO;IACT;IACA,OAAO,CAAA,GAAA,0IAAA,CAAA,kBAAe,AAAD,EAAE,KAAK,WAAW,KAAK,CAAA,GAAA,0IAAA,CAAA,kBAAe,AAAD,EAAE,KAAK,eAAe;AAClF"}},
    {"offset": {"line": 2020, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2026, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/@lexical/clipboard/LexicalClipboard.dev.mjs"],"sourcesContent":["/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nimport { $generateHtmlFromNodes, $generateNodesFromDOM } from '@lexical/html';\nimport { $addNodeStyle, $sliceSelectedTextNodeContent } from '@lexical/selection';\nimport { objectKlassEquals } from '@lexical/utils';\nimport { $isRangeSelection, $getSelection, $createTabNode, SELECTION_INSERT_CLIPBOARD_NODES_COMMAND, $getRoot, $parseSerializedNode, $isTextNode, COPY_COMMAND, COMMAND_PRIORITY_CRITICAL, isSelectionWithinEditor, $getEditor, $isElementNode, $cloneWithProperties } from 'lexical';\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst CAN_USE_DOM = typeof window !== 'undefined' && typeof window.document !== 'undefined' && typeof window.document.createElement !== 'undefined';\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst getDOMSelection = targetWindow => CAN_USE_DOM ? (targetWindow || window).getSelection() : null;\n/**\n * Returns the *currently selected* Lexical content as an HTML string, relying on the\n * logic defined in the exportDOM methods on the LexicalNode classes. Note that\n * this will not return the HTML content of the entire editor (unless all the content is included\n * in the current selection).\n *\n * @param editor - LexicalEditor instance to get HTML content from\n * @param selection - The selection to use (default is $getSelection())\n * @returns a string of HTML content\n */\nfunction $getHtmlContent(editor, selection = $getSelection()) {\n  if (selection == null) {\n    {\n      throw Error(`Expected valid LexicalSelection`);\n    }\n  }\n\n  // If we haven't selected anything\n  if ($isRangeSelection(selection) && selection.isCollapsed() || selection.getNodes().length === 0) {\n    return '';\n  }\n  return $generateHtmlFromNodes(editor, selection);\n}\n\n/**\n * Returns the *currently selected* Lexical content as a JSON string, relying on the\n * logic defined in the exportJSON methods on the LexicalNode classes. Note that\n * this will not return the JSON content of the entire editor (unless all the content is included\n * in the current selection).\n *\n * @param editor  - LexicalEditor instance to get the JSON content from\n * @param selection - The selection to use (default is $getSelection())\n * @returns\n */\nfunction $getLexicalContent(editor, selection = $getSelection()) {\n  if (selection == null) {\n    {\n      throw Error(`Expected valid LexicalSelection`);\n    }\n  }\n\n  // If we haven't selected anything\n  if ($isRangeSelection(selection) && selection.isCollapsed() || selection.getNodes().length === 0) {\n    return null;\n  }\n  return JSON.stringify($generateJSONFromSelectedNodes(editor, selection));\n}\n\n/**\n * Attempts to insert content of the mime-types text/plain or text/uri-list from\n * the provided DataTransfer object into the editor at the provided selection.\n * text/uri-list is only used if text/plain is not also provided.\n *\n * @param dataTransfer an object conforming to the [DataTransfer interface] (https://html.spec.whatwg.org/multipage/dnd.html#the-datatransfer-interface)\n * @param selection the selection to use as the insertion point for the content in the DataTransfer object\n */\nfunction $insertDataTransferForPlainText(dataTransfer, selection) {\n  const text = dataTransfer.getData('text/plain') || dataTransfer.getData('text/uri-list');\n  if (text != null) {\n    selection.insertRawText(text);\n  }\n}\n\n/**\n * Attempts to insert content of the mime-types application/x-lexical-editor, text/html,\n * text/plain, or text/uri-list (in descending order of priority) from the provided DataTransfer\n * object into the editor at the provided selection.\n *\n * @param dataTransfer an object conforming to the [DataTransfer interface] (https://html.spec.whatwg.org/multipage/dnd.html#the-datatransfer-interface)\n * @param selection the selection to use as the insertion point for the content in the DataTransfer object\n * @param editor the LexicalEditor the content is being inserted into.\n */\nfunction $insertDataTransferForRichText(dataTransfer, selection, editor) {\n  const lexicalString = dataTransfer.getData('application/x-lexical-editor');\n  if (lexicalString) {\n    try {\n      const payload = JSON.parse(lexicalString);\n      if (payload.namespace === editor._config.namespace && Array.isArray(payload.nodes)) {\n        const nodes = $generateNodesFromSerializedNodes(payload.nodes);\n        return $insertGeneratedNodes(editor, nodes, selection);\n      }\n    } catch (_unused) {\n      // Fail silently.\n    }\n  }\n  const htmlString = dataTransfer.getData('text/html');\n  if (htmlString) {\n    try {\n      const parser = new DOMParser();\n      const dom = parser.parseFromString(htmlString, 'text/html');\n      const nodes = $generateNodesFromDOM(editor, dom);\n      return $insertGeneratedNodes(editor, nodes, selection);\n    } catch (_unused2) {\n      // Fail silently.\n    }\n  }\n\n  // Multi-line plain text in rich text mode pasted as separate paragraphs\n  // instead of single paragraph with linebreaks.\n  // Webkit-specific: Supports read 'text/uri-list' in clipboard.\n  const text = dataTransfer.getData('text/plain') || dataTransfer.getData('text/uri-list');\n  if (text != null) {\n    if ($isRangeSelection(selection)) {\n      const parts = text.split(/(\\r?\\n|\\t)/);\n      if (parts[parts.length - 1] === '') {\n        parts.pop();\n      }\n      for (let i = 0; i < parts.length; i++) {\n        const currentSelection = $getSelection();\n        if ($isRangeSelection(currentSelection)) {\n          const part = parts[i];\n          if (part === '\\n' || part === '\\r\\n') {\n            currentSelection.insertParagraph();\n          } else if (part === '\\t') {\n            currentSelection.insertNodes([$createTabNode()]);\n          } else {\n            currentSelection.insertText(part);\n          }\n        }\n      }\n    } else {\n      selection.insertRawText(text);\n    }\n  }\n}\n\n/**\n * Inserts Lexical nodes into the editor using different strategies depending on\n * some simple selection-based heuristics. If you're looking for a generic way to\n * to insert nodes into the editor at a specific selection point, you probably want\n * {@link lexical.$insertNodes}\n *\n * @param editor LexicalEditor instance to insert the nodes into.\n * @param nodes The nodes to insert.\n * @param selection The selection to insert the nodes into.\n */\nfunction $insertGeneratedNodes(editor, nodes, selection) {\n  if (!editor.dispatchCommand(SELECTION_INSERT_CLIPBOARD_NODES_COMMAND, {\n    nodes,\n    selection\n  })) {\n    selection.insertNodes(nodes);\n  }\n  return;\n}\nfunction exportNodeToJSON(node) {\n  const serializedNode = node.exportJSON();\n  const nodeClass = node.constructor;\n  if (serializedNode.type !== nodeClass.getType()) {\n    {\n      throw Error(`LexicalNode: Node ${nodeClass.name} does not implement .exportJSON().`);\n    }\n  }\n  if ($isElementNode(node)) {\n    const serializedChildren = serializedNode.children;\n    if (!Array.isArray(serializedChildren)) {\n      {\n        throw Error(`LexicalNode: Node ${nodeClass.name} is an element but .exportJSON() does not have a children array.`);\n      }\n    }\n  }\n  return serializedNode;\n}\nfunction $appendNodesToJSON(editor, selection, currentNode, targetArray = []) {\n  let shouldInclude = selection !== null ? currentNode.isSelected(selection) : true;\n  const shouldExclude = $isElementNode(currentNode) && currentNode.excludeFromCopy('html');\n  let target = currentNode;\n  if (selection !== null) {\n    let clone = $cloneWithProperties(currentNode);\n    clone = $isTextNode(clone) && selection !== null ? $sliceSelectedTextNodeContent(selection, clone) : clone;\n    target = clone;\n  }\n  const children = $isElementNode(target) ? target.getChildren() : [];\n  const serializedNode = exportNodeToJSON(target);\n\n  // TODO: TextNode calls getTextContent() (NOT node.__text) within its exportJSON method\n  // which uses getLatest() to get the text from the original node with the same key.\n  // This is a deeper issue with the word \"clone\" here, it's still a reference to the\n  // same node as far as the LexicalEditor is concerned since it shares a key.\n  // We need a way to create a clone of a Node in memory with its own key, but\n  // until then this hack will work for the selected text extract use case.\n  if ($isTextNode(target)) {\n    const text = target.__text;\n    // If an uncollapsed selection ends or starts at the end of a line of specialized,\n    // TextNodes, such as code tokens, we will get a 'blank' TextNode here, i.e., one\n    // with text of length 0. We don't want this, it makes a confusing mess. Reset!\n    if (text.length > 0) {\n      serializedNode.text = text;\n    } else {\n      shouldInclude = false;\n    }\n  }\n  for (let i = 0; i < children.length; i++) {\n    const childNode = children[i];\n    const shouldIncludeChild = $appendNodesToJSON(editor, selection, childNode, serializedNode.children);\n    if (!shouldInclude && $isElementNode(currentNode) && shouldIncludeChild && currentNode.extractWithChild(childNode, selection, 'clone')) {\n      shouldInclude = true;\n    }\n  }\n  if (shouldInclude && !shouldExclude) {\n    targetArray.push(serializedNode);\n  } else if (Array.isArray(serializedNode.children)) {\n    for (let i = 0; i < serializedNode.children.length; i++) {\n      const serializedChildNode = serializedNode.children[i];\n      targetArray.push(serializedChildNode);\n    }\n  }\n  return shouldInclude;\n}\n\n// TODO why $ function with Editor instance?\n/**\n * Gets the Lexical JSON of the nodes inside the provided Selection.\n *\n * @param editor LexicalEditor to get the JSON content from.\n * @param selection Selection to get the JSON content from.\n * @returns an object with the editor namespace and a list of serializable nodes as JavaScript objects.\n */\nfunction $generateJSONFromSelectedNodes(editor, selection) {\n  const nodes = [];\n  const root = $getRoot();\n  const topLevelChildren = root.getChildren();\n  for (let i = 0; i < topLevelChildren.length; i++) {\n    const topLevelNode = topLevelChildren[i];\n    $appendNodesToJSON(editor, selection, topLevelNode, nodes);\n  }\n  return {\n    namespace: editor._config.namespace,\n    nodes\n  };\n}\n\n/**\n * This method takes an array of objects conforming to the BaseSeralizedNode interface and returns\n * an Array containing instances of the corresponding LexicalNode classes registered on the editor.\n * Normally, you'd get an Array of BaseSerialized nodes from {@link $generateJSONFromSelectedNodes}\n *\n * @param serializedNodes an Array of objects conforming to the BaseSerializedNode interface.\n * @returns an Array of Lexical Node objects.\n */\nfunction $generateNodesFromSerializedNodes(serializedNodes) {\n  const nodes = [];\n  for (let i = 0; i < serializedNodes.length; i++) {\n    const serializedNode = serializedNodes[i];\n    const node = $parseSerializedNode(serializedNode);\n    if ($isTextNode(node)) {\n      $addNodeStyle(node);\n    }\n    nodes.push(node);\n  }\n  return nodes;\n}\nconst EVENT_LATENCY = 50;\nlet clipboardEventTimeout = null;\n\n// TODO custom selection\n// TODO potentially have a node customizable version for plain text\n/**\n * Copies the content of the current selection to the clipboard in\n * text/plain, text/html, and application/x-lexical-editor (Lexical JSON)\n * formats.\n *\n * @param editor the LexicalEditor instance to copy content from\n * @param event the native browser ClipboardEvent to add the content to.\n * @returns\n */\nasync function copyToClipboard(editor, event, data) {\n  if (clipboardEventTimeout !== null) {\n    // Prevent weird race conditions that can happen when this function is run multiple times\n    // synchronously. In the future, we can do better, we can cancel/override the previously running job.\n    return false;\n  }\n  if (event !== null) {\n    return new Promise((resolve, reject) => {\n      editor.update(() => {\n        resolve($copyToClipboardEvent(editor, event, data));\n      });\n    });\n  }\n  const rootElement = editor.getRootElement();\n  const windowDocument = editor._window == null ? window.document : editor._window.document;\n  const domSelection = getDOMSelection(editor._window);\n  if (rootElement === null || domSelection === null) {\n    return false;\n  }\n  const element = windowDocument.createElement('span');\n  element.style.cssText = 'position: fixed; top: -1000px;';\n  element.append(windowDocument.createTextNode('#'));\n  rootElement.append(element);\n  const range = new Range();\n  range.setStart(element, 0);\n  range.setEnd(element, 1);\n  domSelection.removeAllRanges();\n  domSelection.addRange(range);\n  return new Promise((resolve, reject) => {\n    const removeListener = editor.registerCommand(COPY_COMMAND, secondEvent => {\n      if (objectKlassEquals(secondEvent, ClipboardEvent)) {\n        removeListener();\n        if (clipboardEventTimeout !== null) {\n          window.clearTimeout(clipboardEventTimeout);\n          clipboardEventTimeout = null;\n        }\n        resolve($copyToClipboardEvent(editor, secondEvent, data));\n      }\n      // Block the entire copy flow while we wait for the next ClipboardEvent\n      return true;\n    }, COMMAND_PRIORITY_CRITICAL);\n    // If the above hack execCommand hack works, this timeout code should never fire. Otherwise,\n    // the listener will be quickly freed so that the user can reuse it again\n    clipboardEventTimeout = window.setTimeout(() => {\n      removeListener();\n      clipboardEventTimeout = null;\n      resolve(false);\n    }, EVENT_LATENCY);\n    windowDocument.execCommand('copy');\n    element.remove();\n  });\n}\n\n// TODO shouldn't pass editor (pass namespace directly)\nfunction $copyToClipboardEvent(editor, event, data) {\n  if (data === undefined) {\n    const domSelection = getDOMSelection(editor._window);\n    if (!domSelection) {\n      return false;\n    }\n    const anchorDOM = domSelection.anchorNode;\n    const focusDOM = domSelection.focusNode;\n    if (anchorDOM !== null && focusDOM !== null && !isSelectionWithinEditor(editor, anchorDOM, focusDOM)) {\n      return false;\n    }\n    const selection = $getSelection();\n    if (selection === null) {\n      return false;\n    }\n    data = $getClipboardDataFromSelection(selection);\n  }\n  event.preventDefault();\n  const clipboardData = event.clipboardData;\n  if (clipboardData === null) {\n    return false;\n  }\n  setLexicalClipboardDataTransfer(clipboardData, data);\n  return true;\n}\nconst clipboardDataFunctions = [['text/html', $getHtmlContent], ['application/x-lexical-editor', $getLexicalContent]];\n\n/**\n * Serialize the content of the current selection to strings in\n * text/plain, text/html, and application/x-lexical-editor (Lexical JSON)\n * formats (as available).\n *\n * @param selection the selection to serialize (defaults to $getSelection())\n * @returns LexicalClipboardData\n */\nfunction $getClipboardDataFromSelection(selection = $getSelection()) {\n  const clipboardData = {\n    'text/plain': selection ? selection.getTextContent() : ''\n  };\n  if (selection) {\n    const editor = $getEditor();\n    for (const [mimeType, $editorFn] of clipboardDataFunctions) {\n      const v = $editorFn(editor, selection);\n      if (v !== null) {\n        clipboardData[mimeType] = v;\n      }\n    }\n  }\n  return clipboardData;\n}\n\n/**\n * Call setData on the given clipboardData for each MIME type present\n * in the given data (from {@link $getClipboardDataFromSelection})\n *\n * @param clipboardData the event.clipboardData to populate from data\n * @param data The lexical data\n */\nfunction setLexicalClipboardDataTransfer(clipboardData, data) {\n  for (const k in data) {\n    const v = data[k];\n    if (v !== undefined) {\n      clipboardData.setData(k, v);\n    }\n  }\n}\n\nexport { $generateJSONFromSelectedNodes, $generateNodesFromSerializedNodes, $getClipboardDataFromSelection, $getHtmlContent, $getLexicalContent, $insertDataTransferForPlainText, $insertDataTransferForRichText, $insertGeneratedNodes, copyToClipboard, setLexicalClipboardDataTransfer };\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 2404, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2410, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/@lexical/rich-text/LexicalRichText.dev.mjs"],"sourcesContent":["/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nimport { $insertDataTransferForRichText, copyToClipboard } from '@lexical/clipboard';\nimport { $shouldOverrideDefaultCharacterSelection, $moveCharacter } from '@lexical/selection';\nimport { addClassNamesToElement, isHTMLElement, objectKlassEquals, mergeRegister, $findMatchingParent, $getNearestBlockElementAncestorOrThrow } from '@lexical/utils';\nimport { createCommand, ElementNode, $createParagraphNode, $applyNodeReplacement, CLICK_COMMAND, $getSelection, $isNodeSelection, DELETE_CHARACTER_COMMAND, $isRangeSelection, COMMAND_PRIORITY_EDITOR, DELETE_WORD_COMMAND, DELETE_LINE_COMMAND, CONTROLLED_TEXT_INSERTION_COMMAND, REMOVE_TEXT_COMMAND, FORMAT_TEXT_COMMAND, FORMAT_ELEMENT_COMMAND, $isElementNode, INSERT_LINE_BREAK_COMMAND, INSERT_PARAGRAPH_COMMAND, INSERT_TAB_COMMAND, $insertNodes, $createTabNode, INDENT_CONTENT_COMMAND, OUTDENT_CONTENT_COMMAND, KEY_ARROW_UP_COMMAND, $getAdjacentNode, $isDecoratorNode, KEY_ARROW_DOWN_COMMAND, KEY_ARROW_LEFT_COMMAND, KEY_ARROW_RIGHT_COMMAND, KEY_BACKSPACE_COMMAND, $isRootNode, KEY_DELETE_COMMAND, KEY_ENTER_COMMAND, KEY_ESCAPE_COMMAND, DROP_COMMAND, $getNearestNodeFromDOMNode, $createRangeSelection, $isTextNode, $normalizeSelection__EXPERIMENTAL, $setSelection, DRAGSTART_COMMAND, DRAGOVER_COMMAND, SELECT_ALL_COMMAND, $selectAll, COPY_COMMAND, CUT_COMMAND, PASTE_COMMAND, isSelectionCapturedInDecoratorInput, $getRoot } from 'lexical';\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction caretFromPoint(x, y) {\n  if (typeof document.caretRangeFromPoint !== 'undefined') {\n    const range = document.caretRangeFromPoint(x, y);\n    if (range === null) {\n      return null;\n    }\n    return {\n      node: range.startContainer,\n      offset: range.startOffset\n    };\n    // @ts-ignore\n  } else if (document.caretPositionFromPoint !== 'undefined') {\n    // @ts-ignore FF - no types\n    const range = document.caretPositionFromPoint(x, y);\n    if (range === null) {\n      return null;\n    }\n    return {\n      node: range.offsetNode,\n      offset: range.offset\n    };\n  } else {\n    // Gracefully handle IE\n    return null;\n  }\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst CAN_USE_DOM = typeof window !== 'undefined' && typeof window.document !== 'undefined' && typeof window.document.createElement !== 'undefined';\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst documentMode = CAN_USE_DOM && 'documentMode' in document ? document.documentMode : null;\nconst CAN_USE_BEFORE_INPUT = CAN_USE_DOM && 'InputEvent' in window && !documentMode ? 'getTargetRanges' in new window.InputEvent('input') : false;\nconst IS_SAFARI = CAN_USE_DOM && /Version\\/[\\d.]+.*Safari/.test(navigator.userAgent);\nconst IS_IOS = CAN_USE_DOM && /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;\n\n// Keep these in case we need to use them in the future.\n// export const IS_WINDOWS: boolean = CAN_USE_DOM && /Win/.test(navigator.platform);\nconst IS_CHROME = CAN_USE_DOM && /^(?=.*Chrome).*/i.test(navigator.userAgent);\nconst IS_APPLE_WEBKIT = CAN_USE_DOM && /AppleWebKit\\/[\\d.]+/.test(navigator.userAgent) && !IS_CHROME;\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst DRAG_DROP_PASTE = createCommand('DRAG_DROP_PASTE_FILE');\n/** @noInheritDoc */\nclass QuoteNode extends ElementNode {\n  static getType() {\n    return 'quote';\n  }\n  static clone(node) {\n    return new QuoteNode(node.__key);\n  }\n  constructor(key) {\n    super(key);\n  }\n\n  // View\n\n  createDOM(config) {\n    const element = document.createElement('blockquote');\n    addClassNamesToElement(element, config.theme.quote);\n    return element;\n  }\n  updateDOM(prevNode, dom) {\n    return false;\n  }\n  static importDOM() {\n    return {\n      blockquote: node => ({\n        conversion: $convertBlockquoteElement,\n        priority: 0\n      })\n    };\n  }\n  exportDOM(editor) {\n    const {\n      element\n    } = super.exportDOM(editor);\n    if (element && isHTMLElement(element)) {\n      if (this.isEmpty()) {\n        element.append(document.createElement('br'));\n      }\n      const formatType = this.getFormatType();\n      element.style.textAlign = formatType;\n      const direction = this.getDirection();\n      if (direction) {\n        element.dir = direction;\n      }\n    }\n    return {\n      element\n    };\n  }\n  static importJSON(serializedNode) {\n    const node = $createQuoteNode();\n    node.setFormat(serializedNode.format);\n    node.setIndent(serializedNode.indent);\n    node.setDirection(serializedNode.direction);\n    return node;\n  }\n  exportJSON() {\n    return {\n      ...super.exportJSON(),\n      type: 'quote'\n    };\n  }\n\n  // Mutation\n\n  insertNewAfter(_, restoreSelection) {\n    const newBlock = $createParagraphNode();\n    const direction = this.getDirection();\n    newBlock.setDirection(direction);\n    this.insertAfter(newBlock, restoreSelection);\n    return newBlock;\n  }\n  collapseAtStart() {\n    const paragraph = $createParagraphNode();\n    const children = this.getChildren();\n    children.forEach(child => paragraph.append(child));\n    this.replace(paragraph);\n    return true;\n  }\n  canMergeWhenEmpty() {\n    return true;\n  }\n}\nfunction $createQuoteNode() {\n  return $applyNodeReplacement(new QuoteNode());\n}\nfunction $isQuoteNode(node) {\n  return node instanceof QuoteNode;\n}\n/** @noInheritDoc */\nclass HeadingNode extends ElementNode {\n  /** @internal */\n\n  static getType() {\n    return 'heading';\n  }\n  static clone(node) {\n    return new HeadingNode(node.__tag, node.__key);\n  }\n  constructor(tag, key) {\n    super(key);\n    this.__tag = tag;\n  }\n  getTag() {\n    return this.__tag;\n  }\n\n  // View\n\n  createDOM(config) {\n    const tag = this.__tag;\n    const element = document.createElement(tag);\n    const theme = config.theme;\n    const classNames = theme.heading;\n    if (classNames !== undefined) {\n      const className = classNames[tag];\n      addClassNamesToElement(element, className);\n    }\n    return element;\n  }\n  updateDOM(prevNode, dom) {\n    return false;\n  }\n  static importDOM() {\n    return {\n      h1: node => ({\n        conversion: $convertHeadingElement,\n        priority: 0\n      }),\n      h2: node => ({\n        conversion: $convertHeadingElement,\n        priority: 0\n      }),\n      h3: node => ({\n        conversion: $convertHeadingElement,\n        priority: 0\n      }),\n      h4: node => ({\n        conversion: $convertHeadingElement,\n        priority: 0\n      }),\n      h5: node => ({\n        conversion: $convertHeadingElement,\n        priority: 0\n      }),\n      h6: node => ({\n        conversion: $convertHeadingElement,\n        priority: 0\n      }),\n      p: node => {\n        // domNode is a <p> since we matched it by nodeName\n        const paragraph = node;\n        const firstChild = paragraph.firstChild;\n        if (firstChild !== null && isGoogleDocsTitle(firstChild)) {\n          return {\n            conversion: () => ({\n              node: null\n            }),\n            priority: 3\n          };\n        }\n        return null;\n      },\n      span: node => {\n        if (isGoogleDocsTitle(node)) {\n          return {\n            conversion: domNode => {\n              return {\n                node: $createHeadingNode('h1')\n              };\n            },\n            priority: 3\n          };\n        }\n        return null;\n      }\n    };\n  }\n  exportDOM(editor) {\n    const {\n      element\n    } = super.exportDOM(editor);\n    if (element && isHTMLElement(element)) {\n      if (this.isEmpty()) {\n        element.append(document.createElement('br'));\n      }\n      const formatType = this.getFormatType();\n      element.style.textAlign = formatType;\n      const direction = this.getDirection();\n      if (direction) {\n        element.dir = direction;\n      }\n    }\n    return {\n      element\n    };\n  }\n  static importJSON(serializedNode) {\n    const node = $createHeadingNode(serializedNode.tag);\n    node.setFormat(serializedNode.format);\n    node.setIndent(serializedNode.indent);\n    node.setDirection(serializedNode.direction);\n    return node;\n  }\n  exportJSON() {\n    return {\n      ...super.exportJSON(),\n      tag: this.getTag(),\n      type: 'heading',\n      version: 1\n    };\n  }\n\n  // Mutation\n  insertNewAfter(selection, restoreSelection = true) {\n    const anchorOffet = selection ? selection.anchor.offset : 0;\n    const lastDesc = this.getLastDescendant();\n    const isAtEnd = !lastDesc || selection && selection.anchor.key === lastDesc.getKey() && anchorOffet === lastDesc.getTextContentSize();\n    const newElement = isAtEnd || !selection ? $createParagraphNode() : $createHeadingNode(this.getTag());\n    const direction = this.getDirection();\n    newElement.setDirection(direction);\n    this.insertAfter(newElement, restoreSelection);\n    if (anchorOffet === 0 && !this.isEmpty() && selection) {\n      const paragraph = $createParagraphNode();\n      paragraph.select();\n      this.replace(paragraph, true);\n    }\n    return newElement;\n  }\n  collapseAtStart() {\n    const newElement = !this.isEmpty() ? $createHeadingNode(this.getTag()) : $createParagraphNode();\n    const children = this.getChildren();\n    children.forEach(child => newElement.append(child));\n    this.replace(newElement);\n    return true;\n  }\n  extractWithChild() {\n    return true;\n  }\n}\nfunction isGoogleDocsTitle(domNode) {\n  if (domNode.nodeName.toLowerCase() === 'span') {\n    return domNode.style.fontSize === '26pt';\n  }\n  return false;\n}\nfunction $convertHeadingElement(element) {\n  const nodeName = element.nodeName.toLowerCase();\n  let node = null;\n  if (nodeName === 'h1' || nodeName === 'h2' || nodeName === 'h3' || nodeName === 'h4' || nodeName === 'h5' || nodeName === 'h6') {\n    node = $createHeadingNode(nodeName);\n    if (element.style !== null) {\n      node.setFormat(element.style.textAlign);\n    }\n  }\n  return {\n    node\n  };\n}\nfunction $convertBlockquoteElement(element) {\n  const node = $createQuoteNode();\n  if (element.style !== null) {\n    node.setFormat(element.style.textAlign);\n  }\n  return {\n    node\n  };\n}\nfunction $createHeadingNode(headingTag) {\n  return $applyNodeReplacement(new HeadingNode(headingTag));\n}\nfunction $isHeadingNode(node) {\n  return node instanceof HeadingNode;\n}\nfunction onPasteForRichText(event, editor) {\n  event.preventDefault();\n  editor.update(() => {\n    const selection = $getSelection();\n    const clipboardData = objectKlassEquals(event, InputEvent) || objectKlassEquals(event, KeyboardEvent) ? null : event.clipboardData;\n    if (clipboardData != null && selection !== null) {\n      $insertDataTransferForRichText(clipboardData, selection, editor);\n    }\n  }, {\n    tag: 'paste'\n  });\n}\nasync function onCutForRichText(event, editor) {\n  await copyToClipboard(editor, objectKlassEquals(event, ClipboardEvent) ? event : null);\n  editor.update(() => {\n    const selection = $getSelection();\n    if ($isRangeSelection(selection)) {\n      selection.removeText();\n    } else if ($isNodeSelection(selection)) {\n      selection.getNodes().forEach(node => node.remove());\n    }\n  });\n}\n\n// Clipboard may contain files that we aren't allowed to read. While the event is arguably useless,\n// in certain occasions, we want to know whether it was a file transfer, as opposed to text. We\n// control this with the first boolean flag.\nfunction eventFiles(event) {\n  let dataTransfer = null;\n  if (objectKlassEquals(event, DragEvent)) {\n    dataTransfer = event.dataTransfer;\n  } else if (objectKlassEquals(event, ClipboardEvent)) {\n    dataTransfer = event.clipboardData;\n  }\n  if (dataTransfer === null) {\n    return [false, [], false];\n  }\n  const types = dataTransfer.types;\n  const hasFiles = types.includes('Files');\n  const hasContent = types.includes('text/html') || types.includes('text/plain');\n  return [hasFiles, Array.from(dataTransfer.files), hasContent];\n}\nfunction $handleIndentAndOutdent(indentOrOutdent) {\n  const selection = $getSelection();\n  if (!$isRangeSelection(selection)) {\n    return false;\n  }\n  const alreadyHandled = new Set();\n  const nodes = selection.getNodes();\n  for (let i = 0; i < nodes.length; i++) {\n    const node = nodes[i];\n    const key = node.getKey();\n    if (alreadyHandled.has(key)) {\n      continue;\n    }\n    const parentBlock = $findMatchingParent(node, parentNode => $isElementNode(parentNode) && !parentNode.isInline());\n    if (parentBlock === null) {\n      continue;\n    }\n    const parentKey = parentBlock.getKey();\n    if (parentBlock.canIndent() && !alreadyHandled.has(parentKey)) {\n      alreadyHandled.add(parentKey);\n      indentOrOutdent(parentBlock);\n    }\n  }\n  return alreadyHandled.size > 0;\n}\nfunction $isTargetWithinDecorator(target) {\n  const node = $getNearestNodeFromDOMNode(target);\n  return $isDecoratorNode(node);\n}\nfunction $isSelectionAtEndOfRoot(selection) {\n  const focus = selection.focus;\n  return focus.key === 'root' && focus.offset === $getRoot().getChildrenSize();\n}\nfunction registerRichText(editor) {\n  const removeListener = mergeRegister(editor.registerCommand(CLICK_COMMAND, payload => {\n    const selection = $getSelection();\n    if ($isNodeSelection(selection)) {\n      selection.clear();\n      return true;\n    }\n    return false;\n  }, 0), editor.registerCommand(DELETE_CHARACTER_COMMAND, isBackward => {\n    const selection = $getSelection();\n    if (!$isRangeSelection(selection)) {\n      return false;\n    }\n    selection.deleteCharacter(isBackward);\n    return true;\n  }, COMMAND_PRIORITY_EDITOR), editor.registerCommand(DELETE_WORD_COMMAND, isBackward => {\n    const selection = $getSelection();\n    if (!$isRangeSelection(selection)) {\n      return false;\n    }\n    selection.deleteWord(isBackward);\n    return true;\n  }, COMMAND_PRIORITY_EDITOR), editor.registerCommand(DELETE_LINE_COMMAND, isBackward => {\n    const selection = $getSelection();\n    if (!$isRangeSelection(selection)) {\n      return false;\n    }\n    selection.deleteLine(isBackward);\n    return true;\n  }, COMMAND_PRIORITY_EDITOR), editor.registerCommand(CONTROLLED_TEXT_INSERTION_COMMAND, eventOrText => {\n    const selection = $getSelection();\n    if (typeof eventOrText === 'string') {\n      if (selection !== null) {\n        selection.insertText(eventOrText);\n      }\n    } else {\n      if (selection === null) {\n        return false;\n      }\n      const dataTransfer = eventOrText.dataTransfer;\n      if (dataTransfer != null) {\n        $insertDataTransferForRichText(dataTransfer, selection, editor);\n      } else if ($isRangeSelection(selection)) {\n        const data = eventOrText.data;\n        if (data) {\n          selection.insertText(data);\n        }\n        return true;\n      }\n    }\n    return true;\n  }, COMMAND_PRIORITY_EDITOR), editor.registerCommand(REMOVE_TEXT_COMMAND, () => {\n    const selection = $getSelection();\n    if (!$isRangeSelection(selection)) {\n      return false;\n    }\n    selection.removeText();\n    return true;\n  }, COMMAND_PRIORITY_EDITOR), editor.registerCommand(FORMAT_TEXT_COMMAND, format => {\n    const selection = $getSelection();\n    if (!$isRangeSelection(selection)) {\n      return false;\n    }\n    selection.formatText(format);\n    return true;\n  }, COMMAND_PRIORITY_EDITOR), editor.registerCommand(FORMAT_ELEMENT_COMMAND, format => {\n    const selection = $getSelection();\n    if (!$isRangeSelection(selection) && !$isNodeSelection(selection)) {\n      return false;\n    }\n    const nodes = selection.getNodes();\n    for (const node of nodes) {\n      const element = $findMatchingParent(node, parentNode => $isElementNode(parentNode) && !parentNode.isInline());\n      if (element !== null) {\n        element.setFormat(format);\n      }\n    }\n    return true;\n  }, COMMAND_PRIORITY_EDITOR), editor.registerCommand(INSERT_LINE_BREAK_COMMAND, selectStart => {\n    const selection = $getSelection();\n    if (!$isRangeSelection(selection)) {\n      return false;\n    }\n    selection.insertLineBreak(selectStart);\n    return true;\n  }, COMMAND_PRIORITY_EDITOR), editor.registerCommand(INSERT_PARAGRAPH_COMMAND, () => {\n    const selection = $getSelection();\n    if (!$isRangeSelection(selection)) {\n      return false;\n    }\n    selection.insertParagraph();\n    return true;\n  }, COMMAND_PRIORITY_EDITOR), editor.registerCommand(INSERT_TAB_COMMAND, () => {\n    $insertNodes([$createTabNode()]);\n    return true;\n  }, COMMAND_PRIORITY_EDITOR), editor.registerCommand(INDENT_CONTENT_COMMAND, () => {\n    return $handleIndentAndOutdent(block => {\n      const indent = block.getIndent();\n      block.setIndent(indent + 1);\n    });\n  }, COMMAND_PRIORITY_EDITOR), editor.registerCommand(OUTDENT_CONTENT_COMMAND, () => {\n    return $handleIndentAndOutdent(block => {\n      const indent = block.getIndent();\n      if (indent > 0) {\n        block.setIndent(indent - 1);\n      }\n    });\n  }, COMMAND_PRIORITY_EDITOR), editor.registerCommand(KEY_ARROW_UP_COMMAND, event => {\n    const selection = $getSelection();\n    if ($isNodeSelection(selection) && !$isTargetWithinDecorator(event.target)) {\n      // If selection is on a node, let's try and move selection\n      // back to being a range selection.\n      const nodes = selection.getNodes();\n      if (nodes.length > 0) {\n        nodes[0].selectPrevious();\n        return true;\n      }\n    } else if ($isRangeSelection(selection)) {\n      const possibleNode = $getAdjacentNode(selection.focus, true);\n      if (!event.shiftKey && $isDecoratorNode(possibleNode) && !possibleNode.isIsolated() && !possibleNode.isInline()) {\n        possibleNode.selectPrevious();\n        event.preventDefault();\n        return true;\n      }\n    }\n    return false;\n  }, COMMAND_PRIORITY_EDITOR), editor.registerCommand(KEY_ARROW_DOWN_COMMAND, event => {\n    const selection = $getSelection();\n    if ($isNodeSelection(selection)) {\n      // If selection is on a node, let's try and move selection\n      // back to being a range selection.\n      const nodes = selection.getNodes();\n      if (nodes.length > 0) {\n        nodes[0].selectNext(0, 0);\n        return true;\n      }\n    } else if ($isRangeSelection(selection)) {\n      if ($isSelectionAtEndOfRoot(selection)) {\n        event.preventDefault();\n        return true;\n      }\n      const possibleNode = $getAdjacentNode(selection.focus, false);\n      if (!event.shiftKey && $isDecoratorNode(possibleNode) && !possibleNode.isIsolated() && !possibleNode.isInline()) {\n        possibleNode.selectNext();\n        event.preventDefault();\n        return true;\n      }\n    }\n    return false;\n  }, COMMAND_PRIORITY_EDITOR), editor.registerCommand(KEY_ARROW_LEFT_COMMAND, event => {\n    const selection = $getSelection();\n    if ($isNodeSelection(selection)) {\n      // If selection is on a node, let's try and move selection\n      // back to being a range selection.\n      const nodes = selection.getNodes();\n      if (nodes.length > 0) {\n        event.preventDefault();\n        nodes[0].selectPrevious();\n        return true;\n      }\n    }\n    if (!$isRangeSelection(selection)) {\n      return false;\n    }\n    if ($shouldOverrideDefaultCharacterSelection(selection, true)) {\n      const isHoldingShift = event.shiftKey;\n      event.preventDefault();\n      $moveCharacter(selection, isHoldingShift, true);\n      return true;\n    }\n    return false;\n  }, COMMAND_PRIORITY_EDITOR), editor.registerCommand(KEY_ARROW_RIGHT_COMMAND, event => {\n    const selection = $getSelection();\n    if ($isNodeSelection(selection) && !$isTargetWithinDecorator(event.target)) {\n      // If selection is on a node, let's try and move selection\n      // back to being a range selection.\n      const nodes = selection.getNodes();\n      if (nodes.length > 0) {\n        event.preventDefault();\n        nodes[0].selectNext(0, 0);\n        return true;\n      }\n    }\n    if (!$isRangeSelection(selection)) {\n      return false;\n    }\n    const isHoldingShift = event.shiftKey;\n    if ($shouldOverrideDefaultCharacterSelection(selection, false)) {\n      event.preventDefault();\n      $moveCharacter(selection, isHoldingShift, false);\n      return true;\n    }\n    return false;\n  }, COMMAND_PRIORITY_EDITOR), editor.registerCommand(KEY_BACKSPACE_COMMAND, event => {\n    if ($isTargetWithinDecorator(event.target)) {\n      return false;\n    }\n    const selection = $getSelection();\n    if (!$isRangeSelection(selection)) {\n      return false;\n    }\n    event.preventDefault();\n    const {\n      anchor\n    } = selection;\n    const anchorNode = anchor.getNode();\n    if (selection.isCollapsed() && anchor.offset === 0 && !$isRootNode(anchorNode)) {\n      const element = $getNearestBlockElementAncestorOrThrow(anchorNode);\n      if (element.getIndent() > 0) {\n        return editor.dispatchCommand(OUTDENT_CONTENT_COMMAND, undefined);\n      }\n    }\n    return editor.dispatchCommand(DELETE_CHARACTER_COMMAND, true);\n  }, COMMAND_PRIORITY_EDITOR), editor.registerCommand(KEY_DELETE_COMMAND, event => {\n    if ($isTargetWithinDecorator(event.target)) {\n      return false;\n    }\n    const selection = $getSelection();\n    if (!$isRangeSelection(selection)) {\n      return false;\n    }\n    event.preventDefault();\n    return editor.dispatchCommand(DELETE_CHARACTER_COMMAND, false);\n  }, COMMAND_PRIORITY_EDITOR), editor.registerCommand(KEY_ENTER_COMMAND, event => {\n    const selection = $getSelection();\n    if (!$isRangeSelection(selection)) {\n      return false;\n    }\n    if (event !== null) {\n      // If we have beforeinput, then we can avoid blocking\n      // the default behavior. This ensures that the iOS can\n      // intercept that we're actually inserting a paragraph,\n      // and autocomplete, autocapitalize etc work as intended.\n      // This can also cause a strange performance issue in\n      // Safari, where there is a noticeable pause due to\n      // preventing the key down of enter.\n      if ((IS_IOS || IS_SAFARI || IS_APPLE_WEBKIT) && CAN_USE_BEFORE_INPUT) {\n        return false;\n      }\n      event.preventDefault();\n      if (event.shiftKey) {\n        return editor.dispatchCommand(INSERT_LINE_BREAK_COMMAND, false);\n      }\n    }\n    return editor.dispatchCommand(INSERT_PARAGRAPH_COMMAND, undefined);\n  }, COMMAND_PRIORITY_EDITOR), editor.registerCommand(KEY_ESCAPE_COMMAND, () => {\n    const selection = $getSelection();\n    if (!$isRangeSelection(selection)) {\n      return false;\n    }\n    editor.blur();\n    return true;\n  }, COMMAND_PRIORITY_EDITOR), editor.registerCommand(DROP_COMMAND, event => {\n    const [, files] = eventFiles(event);\n    if (files.length > 0) {\n      const x = event.clientX;\n      const y = event.clientY;\n      const eventRange = caretFromPoint(x, y);\n      if (eventRange !== null) {\n        const {\n          offset: domOffset,\n          node: domNode\n        } = eventRange;\n        const node = $getNearestNodeFromDOMNode(domNode);\n        if (node !== null) {\n          const selection = $createRangeSelection();\n          if ($isTextNode(node)) {\n            selection.anchor.set(node.getKey(), domOffset, 'text');\n            selection.focus.set(node.getKey(), domOffset, 'text');\n          } else {\n            const parentKey = node.getParentOrThrow().getKey();\n            const offset = node.getIndexWithinParent() + 1;\n            selection.anchor.set(parentKey, offset, 'element');\n            selection.focus.set(parentKey, offset, 'element');\n          }\n          const normalizedSelection = $normalizeSelection__EXPERIMENTAL(selection);\n          $setSelection(normalizedSelection);\n        }\n        editor.dispatchCommand(DRAG_DROP_PASTE, files);\n      }\n      event.preventDefault();\n      return true;\n    }\n    const selection = $getSelection();\n    if ($isRangeSelection(selection)) {\n      return true;\n    }\n    return false;\n  }, COMMAND_PRIORITY_EDITOR), editor.registerCommand(DRAGSTART_COMMAND, event => {\n    const [isFileTransfer] = eventFiles(event);\n    const selection = $getSelection();\n    if (isFileTransfer && !$isRangeSelection(selection)) {\n      return false;\n    }\n    return true;\n  }, COMMAND_PRIORITY_EDITOR), editor.registerCommand(DRAGOVER_COMMAND, event => {\n    const [isFileTransfer] = eventFiles(event);\n    const selection = $getSelection();\n    if (isFileTransfer && !$isRangeSelection(selection)) {\n      return false;\n    }\n    const x = event.clientX;\n    const y = event.clientY;\n    const eventRange = caretFromPoint(x, y);\n    if (eventRange !== null) {\n      const node = $getNearestNodeFromDOMNode(eventRange.node);\n      if ($isDecoratorNode(node)) {\n        // Show browser caret as the user is dragging the media across the screen. Won't work\n        // for DecoratorNode nor it's relevant.\n        event.preventDefault();\n      }\n    }\n    return true;\n  }, COMMAND_PRIORITY_EDITOR), editor.registerCommand(SELECT_ALL_COMMAND, () => {\n    $selectAll();\n    return true;\n  }, COMMAND_PRIORITY_EDITOR), editor.registerCommand(COPY_COMMAND, event => {\n    copyToClipboard(editor, objectKlassEquals(event, ClipboardEvent) ? event : null);\n    return true;\n  }, COMMAND_PRIORITY_EDITOR), editor.registerCommand(CUT_COMMAND, event => {\n    onCutForRichText(event, editor);\n    return true;\n  }, COMMAND_PRIORITY_EDITOR), editor.registerCommand(PASTE_COMMAND, event => {\n    const [, files, hasTextContent] = eventFiles(event);\n    if (files.length > 0 && !hasTextContent) {\n      editor.dispatchCommand(DRAG_DROP_PASTE, files);\n      return true;\n    }\n\n    // if inputs then paste within the input ignore creating a new node on paste event\n    if (isSelectionCapturedInDecoratorInput(event.target)) {\n      return false;\n    }\n    const selection = $getSelection();\n    if (selection !== null) {\n      onPasteForRichText(event, editor);\n      return true;\n    }\n    return false;\n  }, COMMAND_PRIORITY_EDITOR));\n  return removeListener;\n}\n\nexport { $createHeadingNode, $createQuoteNode, $isHeadingNode, $isQuoteNode, DRAG_DROP_PASTE, HeadingNode, QuoteNode, eventFiles, registerRichText };\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 3175, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 3181, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/@lexical/list/LexicalList.dev.mjs"],"sourcesContent":["/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nimport { $getNearestNodeOfType, removeClassNamesFromElement, addClassNamesToElement, isHTMLElement, mergeRegister } from '@lexical/utils';\nimport { $getSelection, $isRangeSelection, $isRootOrShadowRoot, $isElementNode, $isLeafNode, $createParagraphNode, $isParagraphNode, ElementNode, $applyNodeReplacement, $createTextNode, createCommand, COMMAND_PRIORITY_LOW, INSERT_PARAGRAPH_COMMAND } from 'lexical';\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n\n/**\n * Checks the depth of listNode from the root node.\n * @param listNode - The ListNode to be checked.\n * @returns The depth of the ListNode.\n */\nfunction $getListDepth(listNode) {\n  let depth = 1;\n  let parent = listNode.getParent();\n  while (parent != null) {\n    if ($isListItemNode(parent)) {\n      const parentList = parent.getParent();\n      if ($isListNode(parentList)) {\n        depth++;\n        parent = parentList.getParent();\n        continue;\n      }\n      {\n        throw Error(`A ListItemNode must have a ListNode for a parent.`);\n      }\n    }\n    return depth;\n  }\n  return depth;\n}\n\n/**\n * Finds the nearest ancestral ListNode and returns it, throws an invariant if listItem is not a ListItemNode.\n * @param listItem - The node to be checked.\n * @returns The ListNode found.\n */\nfunction $getTopListNode(listItem) {\n  let list = listItem.getParent();\n  if (!$isListNode(list)) {\n    {\n      throw Error(`A ListItemNode must have a ListNode for a parent.`);\n    }\n  }\n  let parent = list;\n  while (parent !== null) {\n    parent = parent.getParent();\n    if ($isListNode(parent)) {\n      list = parent;\n    }\n  }\n  return list;\n}\n\n/**\n * A recursive Depth-First Search (Postorder Traversal) that finds all of a node's children\n * that are of type ListItemNode and returns them in an array.\n * @param node - The ListNode to start the search.\n * @returns An array containing all nodes of type ListItemNode found.\n */\n// This should probably be $getAllChildrenOfType\nfunction $getAllListItems(node) {\n  let listItemNodes = [];\n  const listChildren = node.getChildren().filter($isListItemNode);\n  for (let i = 0; i < listChildren.length; i++) {\n    const listItemNode = listChildren[i];\n    const firstChild = listItemNode.getFirstChild();\n    if ($isListNode(firstChild)) {\n      listItemNodes = listItemNodes.concat($getAllListItems(firstChild));\n    } else {\n      listItemNodes.push(listItemNode);\n    }\n  }\n  return listItemNodes;\n}\n\n/**\n * Checks to see if the passed node is a ListItemNode and has a ListNode as a child.\n * @param node - The node to be checked.\n * @returns true if the node is a ListItemNode and has a ListNode child, false otherwise.\n */\nfunction isNestedListNode(node) {\n  return $isListItemNode(node) && $isListNode(node.getFirstChild());\n}\n\n/**\n * Takes a deeply nested ListNode or ListItemNode and traverses up the branch to delete the first\n * ancestral ListNode (which could be the root ListNode) or ListItemNode with siblings, essentially\n * bringing the deeply nested node up the branch once. Would remove sublist if it has siblings.\n * Should not break ListItem -> List -> ListItem chain as empty List/ItemNodes should be removed on .remove().\n * @param sublist - The nested ListNode or ListItemNode to be brought up the branch.\n */\nfunction $removeHighestEmptyListParent(sublist) {\n  // Nodes may be repeatedly indented, to create deeply nested lists that each\n  // contain just one bullet.\n  // Our goal is to remove these (empty) deeply nested lists. The easiest\n  // way to do that is crawl back up the tree until we find a node that has siblings\n  // (e.g. is actually part of the list contents) and delete that, or delete\n  // the root of the list (if no list nodes have siblings.)\n  let emptyListPtr = sublist;\n  while (emptyListPtr.getNextSibling() == null && emptyListPtr.getPreviousSibling() == null) {\n    const parent = emptyListPtr.getParent();\n    if (parent == null || !($isListItemNode(emptyListPtr) || $isListNode(emptyListPtr))) {\n      break;\n    }\n    emptyListPtr = parent;\n  }\n  emptyListPtr.remove();\n}\n\n/**\n * Wraps a node into a ListItemNode.\n * @param node - The node to be wrapped into a ListItemNode\n * @returns The ListItemNode which the passed node is wrapped in.\n */\nfunction $wrapInListItem(node) {\n  const listItemWrapper = $createListItemNode();\n  return listItemWrapper.append(node);\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction $isSelectingEmptyListItem(anchorNode, nodes) {\n  return $isListItemNode(anchorNode) && (nodes.length === 0 || nodes.length === 1 && anchorNode.is(nodes[0]) && anchorNode.getChildrenSize() === 0);\n}\n\n/**\n * Inserts a new ListNode. If the selection's anchor node is an empty ListItemNode and is a child of\n * the root/shadow root, it will replace the ListItemNode with a ListNode and the old ListItemNode.\n * Otherwise it will replace its parent with a new ListNode and re-insert the ListItemNode and any previous children.\n * If the selection's anchor node is not an empty ListItemNode, it will add a new ListNode or merge an existing ListNode,\n * unless the the node is a leaf node, in which case it will attempt to find a ListNode up the branch and replace it with\n * a new ListNode, or create a new ListNode at the nearest root/shadow root.\n * @param editor - The lexical editor.\n * @param listType - The type of list, \"number\" | \"bullet\" | \"check\".\n */\nfunction insertList(editor, listType) {\n  editor.update(() => {\n    const selection = $getSelection();\n    if (selection !== null) {\n      const nodes = selection.getNodes();\n      if ($isRangeSelection(selection)) {\n        const anchorAndFocus = selection.getStartEndPoints();\n        if (!(anchorAndFocus !== null)) {\n          throw Error(`insertList: anchor should be defined`);\n        }\n        const [anchor] = anchorAndFocus;\n        const anchorNode = anchor.getNode();\n        const anchorNodeParent = anchorNode.getParent();\n        if ($isSelectingEmptyListItem(anchorNode, nodes)) {\n          const list = $createListNode(listType);\n          if ($isRootOrShadowRoot(anchorNodeParent)) {\n            anchorNode.replace(list);\n            const listItem = $createListItemNode();\n            if ($isElementNode(anchorNode)) {\n              listItem.setFormat(anchorNode.getFormatType());\n              listItem.setIndent(anchorNode.getIndent());\n            }\n            list.append(listItem);\n          } else if ($isListItemNode(anchorNode)) {\n            const parent = anchorNode.getParentOrThrow();\n            append(list, parent.getChildren());\n            parent.replace(list);\n          }\n          return;\n        }\n      }\n      const handled = new Set();\n      for (let i = 0; i < nodes.length; i++) {\n        const node = nodes[i];\n        if ($isElementNode(node) && node.isEmpty() && !$isListItemNode(node) && !handled.has(node.getKey())) {\n          $createListOrMerge(node, listType);\n          continue;\n        }\n        if ($isLeafNode(node)) {\n          let parent = node.getParent();\n          while (parent != null) {\n            const parentKey = parent.getKey();\n            if ($isListNode(parent)) {\n              if (!handled.has(parentKey)) {\n                const newListNode = $createListNode(listType);\n                append(newListNode, parent.getChildren());\n                parent.replace(newListNode);\n                handled.add(parentKey);\n              }\n              break;\n            } else {\n              const nextParent = parent.getParent();\n              if ($isRootOrShadowRoot(nextParent) && !handled.has(parentKey)) {\n                handled.add(parentKey);\n                $createListOrMerge(parent, listType);\n                break;\n              }\n              parent = nextParent;\n            }\n          }\n        }\n      }\n    }\n  });\n}\nfunction append(node, nodesToAppend) {\n  node.splice(node.getChildrenSize(), 0, nodesToAppend);\n}\nfunction $createListOrMerge(node, listType) {\n  if ($isListNode(node)) {\n    return node;\n  }\n  const previousSibling = node.getPreviousSibling();\n  const nextSibling = node.getNextSibling();\n  const listItem = $createListItemNode();\n  listItem.setFormat(node.getFormatType());\n  listItem.setIndent(node.getIndent());\n  append(listItem, node.getChildren());\n  if ($isListNode(previousSibling) && listType === previousSibling.getListType()) {\n    previousSibling.append(listItem);\n    node.remove();\n    // if the same type of list is on both sides, merge them.\n\n    if ($isListNode(nextSibling) && listType === nextSibling.getListType()) {\n      append(previousSibling, nextSibling.getChildren());\n      nextSibling.remove();\n    }\n    return previousSibling;\n  } else if ($isListNode(nextSibling) && listType === nextSibling.getListType()) {\n    nextSibling.getFirstChildOrThrow().insertBefore(listItem);\n    node.remove();\n    return nextSibling;\n  } else {\n    const list = $createListNode(listType);\n    list.append(listItem);\n    node.replace(list);\n    return list;\n  }\n}\n\n/**\n * A recursive function that goes through each list and their children, including nested lists,\n * appending list2 children after list1 children and updating ListItemNode values.\n * @param list1 - The first list to be merged.\n * @param list2 - The second list to be merged.\n */\nfunction mergeLists(list1, list2) {\n  const listItem1 = list1.getLastChild();\n  const listItem2 = list2.getFirstChild();\n  if (listItem1 && listItem2 && isNestedListNode(listItem1) && isNestedListNode(listItem2)) {\n    mergeLists(listItem1.getFirstChild(), listItem2.getFirstChild());\n    listItem2.remove();\n  }\n  const toMerge = list2.getChildren();\n  if (toMerge.length > 0) {\n    list1.append(...toMerge);\n  }\n  list2.remove();\n}\n\n/**\n * Searches for the nearest ancestral ListNode and removes it. If selection is an empty ListItemNode\n * it will remove the whole list, including the ListItemNode. For each ListItemNode in the ListNode,\n * removeList will also generate new ParagraphNodes in the removed ListNode's place. Any child node\n * inside a ListItemNode will be appended to the new ParagraphNodes.\n * @param editor - The lexical editor.\n */\nfunction removeList(editor) {\n  editor.update(() => {\n    const selection = $getSelection();\n    if ($isRangeSelection(selection)) {\n      const listNodes = new Set();\n      const nodes = selection.getNodes();\n      const anchorNode = selection.anchor.getNode();\n      if ($isSelectingEmptyListItem(anchorNode, nodes)) {\n        listNodes.add($getTopListNode(anchorNode));\n      } else {\n        for (let i = 0; i < nodes.length; i++) {\n          const node = nodes[i];\n          if ($isLeafNode(node)) {\n            const listItemNode = $getNearestNodeOfType(node, ListItemNode);\n            if (listItemNode != null) {\n              listNodes.add($getTopListNode(listItemNode));\n            }\n          }\n        }\n      }\n      for (const listNode of listNodes) {\n        let insertionPoint = listNode;\n        const listItems = $getAllListItems(listNode);\n        for (const listItemNode of listItems) {\n          const paragraph = $createParagraphNode();\n          append(paragraph, listItemNode.getChildren());\n          insertionPoint.insertAfter(paragraph);\n          insertionPoint = paragraph;\n\n          // When the anchor and focus fall on the textNode\n          // we don't have to change the selection because the textNode will be appended to\n          // the newly generated paragraph.\n          // When selection is in empty nested list item, selection is actually on the listItemNode.\n          // When the corresponding listItemNode is deleted and replaced by the newly generated paragraph\n          // we should manually set the selection's focus and anchor to the newly generated paragraph.\n          if (listItemNode.__key === selection.anchor.key) {\n            selection.anchor.set(paragraph.getKey(), 0, 'element');\n          }\n          if (listItemNode.__key === selection.focus.key) {\n            selection.focus.set(paragraph.getKey(), 0, 'element');\n          }\n          listItemNode.remove();\n        }\n        listNode.remove();\n      }\n    }\n  });\n}\n\n/**\n * Takes the value of a child ListItemNode and makes it the value the ListItemNode\n * should be if it isn't already. Also ensures that checked is undefined if the\n * parent does not have a list type of 'check'.\n * @param list - The list whose children are updated.\n */\nfunction updateChildrenListItemValue(list) {\n  const isNotChecklist = list.getListType() !== 'check';\n  let value = list.getStart();\n  for (const child of list.getChildren()) {\n    if ($isListItemNode(child)) {\n      if (child.getValue() !== value) {\n        child.setValue(value);\n      }\n      if (isNotChecklist && child.getLatest().__checked != null) {\n        child.setChecked(undefined);\n      }\n      if (!$isListNode(child.getFirstChild())) {\n        value++;\n      }\n    }\n  }\n}\n\n/**\n * Merge the next sibling list if same type.\n * <ul> will merge with <ul>, but NOT <ul> with <ol>.\n * @param list - The list whose next sibling should be potentially merged\n */\nfunction mergeNextSiblingListIfSameType(list) {\n  const nextSibling = list.getNextSibling();\n  if ($isListNode(nextSibling) && list.getListType() === nextSibling.getListType()) {\n    mergeLists(list, nextSibling);\n  }\n}\n\n/**\n * Adds an empty ListNode/ListItemNode chain at listItemNode, so as to\n * create an indent effect. Won't indent ListItemNodes that have a ListNode as\n * a child, but does merge sibling ListItemNodes if one has a nested ListNode.\n * @param listItemNode - The ListItemNode to be indented.\n */\nfunction $handleIndent(listItemNode) {\n  // go through each node and decide where to move it.\n  const removed = new Set();\n  if (isNestedListNode(listItemNode) || removed.has(listItemNode.getKey())) {\n    return;\n  }\n  const parent = listItemNode.getParent();\n\n  // We can cast both of the below `isNestedListNode` only returns a boolean type instead of a user-defined type guards\n  const nextSibling = listItemNode.getNextSibling();\n  const previousSibling = listItemNode.getPreviousSibling();\n  // if there are nested lists on either side, merge them all together.\n\n  if (isNestedListNode(nextSibling) && isNestedListNode(previousSibling)) {\n    const innerList = previousSibling.getFirstChild();\n    if ($isListNode(innerList)) {\n      innerList.append(listItemNode);\n      const nextInnerList = nextSibling.getFirstChild();\n      if ($isListNode(nextInnerList)) {\n        const children = nextInnerList.getChildren();\n        append(innerList, children);\n        nextSibling.remove();\n        removed.add(nextSibling.getKey());\n      }\n    }\n  } else if (isNestedListNode(nextSibling)) {\n    // if the ListItemNode is next to a nested ListNode, merge them\n    const innerList = nextSibling.getFirstChild();\n    if ($isListNode(innerList)) {\n      const firstChild = innerList.getFirstChild();\n      if (firstChild !== null) {\n        firstChild.insertBefore(listItemNode);\n      }\n    }\n  } else if (isNestedListNode(previousSibling)) {\n    const innerList = previousSibling.getFirstChild();\n    if ($isListNode(innerList)) {\n      innerList.append(listItemNode);\n    }\n  } else {\n    // otherwise, we need to create a new nested ListNode\n\n    if ($isListNode(parent)) {\n      const newListItem = $createListItemNode();\n      const newList = $createListNode(parent.getListType());\n      newListItem.append(newList);\n      newList.append(listItemNode);\n      if (previousSibling) {\n        previousSibling.insertAfter(newListItem);\n      } else if (nextSibling) {\n        nextSibling.insertBefore(newListItem);\n      } else {\n        parent.append(newListItem);\n      }\n    }\n  }\n}\n\n/**\n * Removes an indent by removing an empty ListNode/ListItemNode chain. An indented ListItemNode\n * has a great grandparent node of type ListNode, which is where the ListItemNode will reside\n * within as a child.\n * @param listItemNode - The ListItemNode to remove the indent (outdent).\n */\nfunction $handleOutdent(listItemNode) {\n  // go through each node and decide where to move it.\n\n  if (isNestedListNode(listItemNode)) {\n    return;\n  }\n  const parentList = listItemNode.getParent();\n  const grandparentListItem = parentList ? parentList.getParent() : undefined;\n  const greatGrandparentList = grandparentListItem ? grandparentListItem.getParent() : undefined;\n  // If it doesn't have these ancestors, it's not indented.\n\n  if ($isListNode(greatGrandparentList) && $isListItemNode(grandparentListItem) && $isListNode(parentList)) {\n    // if it's the first child in it's parent list, insert it into the\n    // great grandparent list before the grandparent\n    const firstChild = parentList ? parentList.getFirstChild() : undefined;\n    const lastChild = parentList ? parentList.getLastChild() : undefined;\n    if (listItemNode.is(firstChild)) {\n      grandparentListItem.insertBefore(listItemNode);\n      if (parentList.isEmpty()) {\n        grandparentListItem.remove();\n      }\n      // if it's the last child in it's parent list, insert it into the\n      // great grandparent list after the grandparent.\n    } else if (listItemNode.is(lastChild)) {\n      grandparentListItem.insertAfter(listItemNode);\n      if (parentList.isEmpty()) {\n        grandparentListItem.remove();\n      }\n    } else {\n      // otherwise, we need to split the siblings into two new nested lists\n      const listType = parentList.getListType();\n      const previousSiblingsListItem = $createListItemNode();\n      const previousSiblingsList = $createListNode(listType);\n      previousSiblingsListItem.append(previousSiblingsList);\n      listItemNode.getPreviousSiblings().forEach(sibling => previousSiblingsList.append(sibling));\n      const nextSiblingsListItem = $createListItemNode();\n      const nextSiblingsList = $createListNode(listType);\n      nextSiblingsListItem.append(nextSiblingsList);\n      append(nextSiblingsList, listItemNode.getNextSiblings());\n      // put the sibling nested lists on either side of the grandparent list item in the great grandparent.\n      grandparentListItem.insertBefore(previousSiblingsListItem);\n      grandparentListItem.insertAfter(nextSiblingsListItem);\n      // replace the grandparent list item (now between the siblings) with the outdented list item.\n      grandparentListItem.replace(listItemNode);\n    }\n  }\n}\n\n/**\n * Attempts to insert a ParagraphNode at selection and selects the new node. The selection must contain a ListItemNode\n * or a node that does not already contain text. If its grandparent is the root/shadow root, it will get the ListNode\n * (which should be the parent node) and insert the ParagraphNode as a sibling to the ListNode. If the ListNode is\n * nested in a ListItemNode instead, it will add the ParagraphNode after the grandparent ListItemNode.\n * Throws an invariant if the selection is not a child of a ListNode.\n * @returns true if a ParagraphNode was inserted succesfully, false if there is no selection\n * or the selection does not contain a ListItemNode or the node already holds text.\n */\nfunction $handleListInsertParagraph() {\n  const selection = $getSelection();\n  if (!$isRangeSelection(selection) || !selection.isCollapsed()) {\n    return false;\n  }\n  // Only run this code on empty list items\n  const anchor = selection.anchor.getNode();\n  if (!$isListItemNode(anchor) || anchor.getChildrenSize() !== 0) {\n    return false;\n  }\n  const topListNode = $getTopListNode(anchor);\n  const parent = anchor.getParent();\n  if (!$isListNode(parent)) {\n    throw Error(`A ListItemNode must have a ListNode for a parent.`);\n  }\n  const grandparent = parent.getParent();\n  let replacementNode;\n  if ($isRootOrShadowRoot(grandparent)) {\n    replacementNode = $createParagraphNode();\n    topListNode.insertAfter(replacementNode);\n  } else if ($isListItemNode(grandparent)) {\n    replacementNode = $createListItemNode();\n    grandparent.insertAfter(replacementNode);\n  } else {\n    return false;\n  }\n  replacementNode.select();\n  const nextSiblings = anchor.getNextSiblings();\n  if (nextSiblings.length > 0) {\n    const newList = $createListNode(parent.getListType());\n    if ($isParagraphNode(replacementNode)) {\n      replacementNode.insertAfter(newList);\n    } else {\n      const newListItem = $createListItemNode();\n      newListItem.append(newList);\n      replacementNode.insertAfter(newListItem);\n    }\n    nextSiblings.forEach(sibling => {\n      sibling.remove();\n      newList.append(sibling);\n    });\n  }\n\n  // Don't leave hanging nested empty lists\n  $removeHighestEmptyListParent(anchor);\n  return true;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction normalizeClassNames(...classNames) {\n  const rval = [];\n  for (const className of classNames) {\n    if (className && typeof className === 'string') {\n      for (const [s] of className.matchAll(/\\S+/g)) {\n        rval.push(s);\n      }\n    }\n  }\n  return rval;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n/** @noInheritDoc */\nclass ListItemNode extends ElementNode {\n  /** @internal */\n\n  /** @internal */\n\n  static getType() {\n    return 'listitem';\n  }\n  static clone(node) {\n    return new ListItemNode(node.__value, node.__checked, node.__key);\n  }\n  constructor(value, checked, key) {\n    super(key);\n    this.__value = value === undefined ? 1 : value;\n    this.__checked = checked;\n  }\n  createDOM(config) {\n    const element = document.createElement('li');\n    const parent = this.getParent();\n    if ($isListNode(parent) && parent.getListType() === 'check') {\n      updateListItemChecked(element, this, null);\n    }\n    element.value = this.__value;\n    $setListItemThemeClassNames(element, config.theme, this);\n    return element;\n  }\n  updateDOM(prevNode, dom, config) {\n    const parent = this.getParent();\n    if ($isListNode(parent) && parent.getListType() === 'check') {\n      updateListItemChecked(dom, this, prevNode);\n    }\n    // @ts-expect-error - this is always HTMLListItemElement\n    dom.value = this.__value;\n    $setListItemThemeClassNames(dom, config.theme, this);\n    return false;\n  }\n  static transform() {\n    return node => {\n      if (!$isListItemNode(node)) {\n        throw Error(`node is not a ListItemNode`);\n      }\n      if (node.__checked == null) {\n        return;\n      }\n      const parent = node.getParent();\n      if ($isListNode(parent)) {\n        if (parent.getListType() !== 'check' && node.getChecked() != null) {\n          node.setChecked(undefined);\n        }\n      }\n    };\n  }\n  static importDOM() {\n    return {\n      li: () => ({\n        conversion: $convertListItemElement,\n        priority: 0\n      })\n    };\n  }\n  static importJSON(serializedNode) {\n    const node = $createListItemNode();\n    node.setChecked(serializedNode.checked);\n    node.setValue(serializedNode.value);\n    node.setFormat(serializedNode.format);\n    node.setDirection(serializedNode.direction);\n    return node;\n  }\n  exportDOM(editor) {\n    const element = this.createDOM(editor._config);\n    element.style.textAlign = this.getFormatType();\n    return {\n      element\n    };\n  }\n  exportJSON() {\n    return {\n      ...super.exportJSON(),\n      checked: this.getChecked(),\n      type: 'listitem',\n      value: this.getValue(),\n      version: 1\n    };\n  }\n  append(...nodes) {\n    for (let i = 0; i < nodes.length; i++) {\n      const node = nodes[i];\n      if ($isElementNode(node) && this.canMergeWith(node)) {\n        const children = node.getChildren();\n        this.append(...children);\n        node.remove();\n      } else {\n        super.append(node);\n      }\n    }\n    return this;\n  }\n  replace(replaceWithNode, includeChildren) {\n    if ($isListItemNode(replaceWithNode)) {\n      return super.replace(replaceWithNode);\n    }\n    this.setIndent(0);\n    const list = this.getParentOrThrow();\n    if (!$isListNode(list)) {\n      return replaceWithNode;\n    }\n    if (list.__first === this.getKey()) {\n      list.insertBefore(replaceWithNode);\n    } else if (list.__last === this.getKey()) {\n      list.insertAfter(replaceWithNode);\n    } else {\n      // Split the list\n      const newList = $createListNode(list.getListType());\n      let nextSibling = this.getNextSibling();\n      while (nextSibling) {\n        const nodeToAppend = nextSibling;\n        nextSibling = nextSibling.getNextSibling();\n        newList.append(nodeToAppend);\n      }\n      list.insertAfter(replaceWithNode);\n      replaceWithNode.insertAfter(newList);\n    }\n    if (includeChildren) {\n      if (!$isElementNode(replaceWithNode)) {\n        throw Error(`includeChildren should only be true for ElementNodes`);\n      }\n      this.getChildren().forEach(child => {\n        replaceWithNode.append(child);\n      });\n    }\n    this.remove();\n    if (list.getChildrenSize() === 0) {\n      list.remove();\n    }\n    return replaceWithNode;\n  }\n  insertAfter(node, restoreSelection = true) {\n    const listNode = this.getParentOrThrow();\n    if (!$isListNode(listNode)) {\n      {\n        throw Error(`insertAfter: list node is not parent of list item node`);\n      }\n    }\n    if ($isListItemNode(node)) {\n      return super.insertAfter(node, restoreSelection);\n    }\n    const siblings = this.getNextSiblings();\n\n    // Split the lists and insert the node in between them\n    listNode.insertAfter(node, restoreSelection);\n    if (siblings.length !== 0) {\n      const newListNode = $createListNode(listNode.getListType());\n      siblings.forEach(sibling => newListNode.append(sibling));\n      node.insertAfter(newListNode, restoreSelection);\n    }\n    return node;\n  }\n  remove(preserveEmptyParent) {\n    const prevSibling = this.getPreviousSibling();\n    const nextSibling = this.getNextSibling();\n    super.remove(preserveEmptyParent);\n    if (prevSibling && nextSibling && isNestedListNode(prevSibling) && isNestedListNode(nextSibling)) {\n      mergeLists(prevSibling.getFirstChild(), nextSibling.getFirstChild());\n      nextSibling.remove();\n    }\n  }\n  insertNewAfter(_, restoreSelection = true) {\n    const newElement = $createListItemNode(this.__checked == null ? undefined : false);\n    this.insertAfter(newElement, restoreSelection);\n    return newElement;\n  }\n  collapseAtStart(selection) {\n    const paragraph = $createParagraphNode();\n    const children = this.getChildren();\n    children.forEach(child => paragraph.append(child));\n    const listNode = this.getParentOrThrow();\n    const listNodeParent = listNode.getParentOrThrow();\n    const isIndented = $isListItemNode(listNodeParent);\n    if (listNode.getChildrenSize() === 1) {\n      if (isIndented) {\n        // if the list node is nested, we just want to remove it,\n        // effectively unindenting it.\n        listNode.remove();\n        listNodeParent.select();\n      } else {\n        listNode.insertBefore(paragraph);\n        listNode.remove();\n        // If we have selection on the list item, we'll need to move it\n        // to the paragraph\n        const anchor = selection.anchor;\n        const focus = selection.focus;\n        const key = paragraph.getKey();\n        if (anchor.type === 'element' && anchor.getNode().is(this)) {\n          anchor.set(key, anchor.offset, 'element');\n        }\n        if (focus.type === 'element' && focus.getNode().is(this)) {\n          focus.set(key, focus.offset, 'element');\n        }\n      }\n    } else {\n      listNode.insertBefore(paragraph);\n      this.remove();\n    }\n    return true;\n  }\n  getValue() {\n    const self = this.getLatest();\n    return self.__value;\n  }\n  setValue(value) {\n    const self = this.getWritable();\n    self.__value = value;\n  }\n  getChecked() {\n    const self = this.getLatest();\n    let listType;\n    const parent = this.getParent();\n    if ($isListNode(parent)) {\n      listType = parent.getListType();\n    }\n    return listType === 'check' ? Boolean(self.__checked) : undefined;\n  }\n  setChecked(checked) {\n    const self = this.getWritable();\n    self.__checked = checked;\n  }\n  toggleChecked() {\n    this.setChecked(!this.__checked);\n  }\n  getIndent() {\n    // If we don't have a parent, we are likely serializing\n    const parent = this.getParent();\n    if (parent === null) {\n      return this.getLatest().__indent;\n    }\n    // ListItemNode should always have a ListNode for a parent.\n    let listNodeParent = parent.getParentOrThrow();\n    let indentLevel = 0;\n    while ($isListItemNode(listNodeParent)) {\n      listNodeParent = listNodeParent.getParentOrThrow().getParentOrThrow();\n      indentLevel++;\n    }\n    return indentLevel;\n  }\n  setIndent(indent) {\n    if (!(typeof indent === 'number')) {\n      throw Error(`Invalid indent value.`);\n    }\n    indent = Math.floor(indent);\n    if (!(indent >= 0)) {\n      throw Error(`Indent value must be non-negative.`);\n    }\n    let currentIndent = this.getIndent();\n    while (currentIndent !== indent) {\n      if (currentIndent < indent) {\n        $handleIndent(this);\n        currentIndent++;\n      } else {\n        $handleOutdent(this);\n        currentIndent--;\n      }\n    }\n    return this;\n  }\n\n  /** @deprecated @internal */\n  canInsertAfter(node) {\n    return $isListItemNode(node);\n  }\n\n  /** @deprecated @internal */\n  canReplaceWith(replacement) {\n    return $isListItemNode(replacement);\n  }\n  canMergeWith(node) {\n    return $isParagraphNode(node) || $isListItemNode(node);\n  }\n  extractWithChild(child, selection) {\n    if (!$isRangeSelection(selection)) {\n      return false;\n    }\n    const anchorNode = selection.anchor.getNode();\n    const focusNode = selection.focus.getNode();\n    return this.isParentOf(anchorNode) && this.isParentOf(focusNode) && this.getTextContent().length === selection.getTextContent().length;\n  }\n  isParentRequired() {\n    return true;\n  }\n  createParentElementNode() {\n    return $createListNode('bullet');\n  }\n  canMergeWhenEmpty() {\n    return true;\n  }\n}\nfunction $setListItemThemeClassNames(dom, editorThemeClasses, node) {\n  const classesToAdd = [];\n  const classesToRemove = [];\n  const listTheme = editorThemeClasses.list;\n  const listItemClassName = listTheme ? listTheme.listitem : undefined;\n  let nestedListItemClassName;\n  if (listTheme && listTheme.nested) {\n    nestedListItemClassName = listTheme.nested.listitem;\n  }\n  if (listItemClassName !== undefined) {\n    classesToAdd.push(...normalizeClassNames(listItemClassName));\n  }\n  if (listTheme) {\n    const parentNode = node.getParent();\n    const isCheckList = $isListNode(parentNode) && parentNode.getListType() === 'check';\n    const checked = node.getChecked();\n    if (!isCheckList || checked) {\n      classesToRemove.push(listTheme.listitemUnchecked);\n    }\n    if (!isCheckList || !checked) {\n      classesToRemove.push(listTheme.listitemChecked);\n    }\n    if (isCheckList) {\n      classesToAdd.push(checked ? listTheme.listitemChecked : listTheme.listitemUnchecked);\n    }\n  }\n  if (nestedListItemClassName !== undefined) {\n    const nestedListItemClasses = normalizeClassNames(nestedListItemClassName);\n    if (node.getChildren().some(child => $isListNode(child))) {\n      classesToAdd.push(...nestedListItemClasses);\n    } else {\n      classesToRemove.push(...nestedListItemClasses);\n    }\n  }\n  if (classesToRemove.length > 0) {\n    removeClassNamesFromElement(dom, ...classesToRemove);\n  }\n  if (classesToAdd.length > 0) {\n    addClassNamesToElement(dom, ...classesToAdd);\n  }\n}\nfunction updateListItemChecked(dom, listItemNode, prevListItemNode, listNode) {\n  // Only add attributes for leaf list items\n  if ($isListNode(listItemNode.getFirstChild())) {\n    dom.removeAttribute('role');\n    dom.removeAttribute('tabIndex');\n    dom.removeAttribute('aria-checked');\n  } else {\n    dom.setAttribute('role', 'checkbox');\n    dom.setAttribute('tabIndex', '-1');\n    if (!prevListItemNode || listItemNode.__checked !== prevListItemNode.__checked) {\n      dom.setAttribute('aria-checked', listItemNode.getChecked() ? 'true' : 'false');\n    }\n  }\n}\nfunction $convertListItemElement(domNode) {\n  const isGitHubCheckList = domNode.classList.contains('task-list-item');\n  if (isGitHubCheckList) {\n    for (const child of domNode.children) {\n      if (child.tagName === 'INPUT') {\n        return $convertCheckboxInput(child);\n      }\n    }\n  }\n  const ariaCheckedAttr = domNode.getAttribute('aria-checked');\n  const checked = ariaCheckedAttr === 'true' ? true : ariaCheckedAttr === 'false' ? false : undefined;\n  return {\n    node: $createListItemNode(checked)\n  };\n}\nfunction $convertCheckboxInput(domNode) {\n  const isCheckboxInput = domNode.getAttribute('type') === 'checkbox';\n  if (!isCheckboxInput) {\n    return {\n      node: null\n    };\n  }\n  const checked = domNode.hasAttribute('checked');\n  return {\n    node: $createListItemNode(checked)\n  };\n}\n\n/**\n * Creates a new List Item node, passing true/false will convert it to a checkbox input.\n * @param checked - Is the List Item a checkbox and, if so, is it checked? undefined/null: not a checkbox, true/false is a checkbox and checked/unchecked, respectively.\n * @returns The new List Item.\n */\nfunction $createListItemNode(checked) {\n  return $applyNodeReplacement(new ListItemNode(undefined, checked));\n}\n\n/**\n * Checks to see if the node is a ListItemNode.\n * @param node - The node to be checked.\n * @returns true if the node is a ListItemNode, false otherwise.\n */\nfunction $isListItemNode(node) {\n  return node instanceof ListItemNode;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n/** @noInheritDoc */\nclass ListNode extends ElementNode {\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  static getType() {\n    return 'list';\n  }\n  static clone(node) {\n    const listType = node.__listType || TAG_TO_LIST_TYPE[node.__tag];\n    return new ListNode(listType, node.__start, node.__key);\n  }\n  constructor(listType, start, key) {\n    super(key);\n    const _listType = TAG_TO_LIST_TYPE[listType] || listType;\n    this.__listType = _listType;\n    this.__tag = _listType === 'number' ? 'ol' : 'ul';\n    this.__start = start;\n  }\n  getTag() {\n    return this.__tag;\n  }\n  setListType(type) {\n    const writable = this.getWritable();\n    writable.__listType = type;\n    writable.__tag = type === 'number' ? 'ol' : 'ul';\n  }\n  getListType() {\n    return this.__listType;\n  }\n  getStart() {\n    return this.__start;\n  }\n\n  // View\n\n  createDOM(config, _editor) {\n    const tag = this.__tag;\n    const dom = document.createElement(tag);\n    if (this.__start !== 1) {\n      dom.setAttribute('start', String(this.__start));\n    }\n    // @ts-expect-error Internal field.\n    dom.__lexicalListType = this.__listType;\n    $setListThemeClassNames(dom, config.theme, this);\n    return dom;\n  }\n  updateDOM(prevNode, dom, config) {\n    if (prevNode.__tag !== this.__tag) {\n      return true;\n    }\n    $setListThemeClassNames(dom, config.theme, this);\n    return false;\n  }\n  static transform() {\n    return node => {\n      if (!$isListNode(node)) {\n        throw Error(`node is not a ListNode`);\n      }\n      mergeNextSiblingListIfSameType(node);\n      updateChildrenListItemValue(node);\n    };\n  }\n  static importDOM() {\n    return {\n      ol: () => ({\n        conversion: $convertListNode,\n        priority: 0\n      }),\n      ul: () => ({\n        conversion: $convertListNode,\n        priority: 0\n      })\n    };\n  }\n  static importJSON(serializedNode) {\n    const node = $createListNode(serializedNode.listType, serializedNode.start);\n    node.setFormat(serializedNode.format);\n    node.setIndent(serializedNode.indent);\n    node.setDirection(serializedNode.direction);\n    return node;\n  }\n  exportDOM(editor) {\n    const {\n      element\n    } = super.exportDOM(editor);\n    if (element && isHTMLElement(element)) {\n      if (this.__start !== 1) {\n        element.setAttribute('start', String(this.__start));\n      }\n      if (this.__listType === 'check') {\n        element.setAttribute('__lexicalListType', 'check');\n      }\n    }\n    return {\n      element\n    };\n  }\n  exportJSON() {\n    return {\n      ...super.exportJSON(),\n      listType: this.getListType(),\n      start: this.getStart(),\n      tag: this.getTag(),\n      type: 'list',\n      version: 1\n    };\n  }\n  canBeEmpty() {\n    return false;\n  }\n  canIndent() {\n    return false;\n  }\n  append(...nodesToAppend) {\n    for (let i = 0; i < nodesToAppend.length; i++) {\n      const currentNode = nodesToAppend[i];\n      if ($isListItemNode(currentNode)) {\n        super.append(currentNode);\n      } else {\n        const listItemNode = $createListItemNode();\n        if ($isListNode(currentNode)) {\n          listItemNode.append(currentNode);\n        } else if ($isElementNode(currentNode)) {\n          const textNode = $createTextNode(currentNode.getTextContent());\n          listItemNode.append(textNode);\n        } else {\n          listItemNode.append(currentNode);\n        }\n        super.append(listItemNode);\n      }\n    }\n    return this;\n  }\n  extractWithChild(child) {\n    return $isListItemNode(child);\n  }\n}\nfunction $setListThemeClassNames(dom, editorThemeClasses, node) {\n  const classesToAdd = [];\n  const classesToRemove = [];\n  const listTheme = editorThemeClasses.list;\n  if (listTheme !== undefined) {\n    const listLevelsClassNames = listTheme[`${node.__tag}Depth`] || [];\n    const listDepth = $getListDepth(node) - 1;\n    const normalizedListDepth = listDepth % listLevelsClassNames.length;\n    const listLevelClassName = listLevelsClassNames[normalizedListDepth];\n    const listClassName = listTheme[node.__tag];\n    let nestedListClassName;\n    const nestedListTheme = listTheme.nested;\n    const checklistClassName = listTheme.checklist;\n    if (nestedListTheme !== undefined && nestedListTheme.list) {\n      nestedListClassName = nestedListTheme.list;\n    }\n    if (listClassName !== undefined) {\n      classesToAdd.push(listClassName);\n    }\n    if (checklistClassName !== undefined && node.__listType === 'check') {\n      classesToAdd.push(checklistClassName);\n    }\n    if (listLevelClassName !== undefined) {\n      classesToAdd.push(...normalizeClassNames(listLevelClassName));\n      for (let i = 0; i < listLevelsClassNames.length; i++) {\n        if (i !== normalizedListDepth) {\n          classesToRemove.push(node.__tag + i);\n        }\n      }\n    }\n    if (nestedListClassName !== undefined) {\n      const nestedListItemClasses = normalizeClassNames(nestedListClassName);\n      if (listDepth > 1) {\n        classesToAdd.push(...nestedListItemClasses);\n      } else {\n        classesToRemove.push(...nestedListItemClasses);\n      }\n    }\n  }\n  if (classesToRemove.length > 0) {\n    removeClassNamesFromElement(dom, ...classesToRemove);\n  }\n  if (classesToAdd.length > 0) {\n    addClassNamesToElement(dom, ...classesToAdd);\n  }\n}\n\n/*\n * This function normalizes the children of a ListNode after the conversion from HTML,\n * ensuring that they are all ListItemNodes and contain either a single nested ListNode\n * or some other inline content.\n */\nfunction $normalizeChildren(nodes) {\n  const normalizedListItems = [];\n  for (let i = 0; i < nodes.length; i++) {\n    const node = nodes[i];\n    if ($isListItemNode(node)) {\n      normalizedListItems.push(node);\n      const children = node.getChildren();\n      if (children.length > 1) {\n        children.forEach(child => {\n          if ($isListNode(child)) {\n            normalizedListItems.push($wrapInListItem(child));\n          }\n        });\n      }\n    } else {\n      normalizedListItems.push($wrapInListItem(node));\n    }\n  }\n  return normalizedListItems;\n}\nfunction isDomChecklist(domNode) {\n  if (domNode.getAttribute('__lexicallisttype') === 'check' ||\n  // is github checklist\n  domNode.classList.contains('contains-task-list')) {\n    return true;\n  }\n  // if children are checklist items, the node is a checklist ul. Applicable for googledoc checklist pasting.\n  for (const child of domNode.childNodes) {\n    if (isHTMLElement(child) && child.hasAttribute('aria-checked')) {\n      return true;\n    }\n  }\n  return false;\n}\nfunction $convertListNode(domNode) {\n  const nodeName = domNode.nodeName.toLowerCase();\n  let node = null;\n  if (nodeName === 'ol') {\n    // @ts-ignore\n    const start = domNode.start;\n    node = $createListNode('number', start);\n  } else if (nodeName === 'ul') {\n    if (isDomChecklist(domNode)) {\n      node = $createListNode('check');\n    } else {\n      node = $createListNode('bullet');\n    }\n  }\n  return {\n    after: $normalizeChildren,\n    node\n  };\n}\nconst TAG_TO_LIST_TYPE = {\n  ol: 'number',\n  ul: 'bullet'\n};\n\n/**\n * Creates a ListNode of listType.\n * @param listType - The type of list to be created. Can be 'number', 'bullet', or 'check'.\n * @param start - Where an ordered list starts its count, start = 1 if left undefined.\n * @returns The new ListNode\n */\nfunction $createListNode(listType, start = 1) {\n  return $applyNodeReplacement(new ListNode(listType, start));\n}\n\n/**\n * Checks to see if the node is a ListNode.\n * @param node - The node to be checked.\n * @returns true if the node is a ListNode, false otherwise.\n */\nfunction $isListNode(node) {\n  return node instanceof ListNode;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst INSERT_UNORDERED_LIST_COMMAND = createCommand('INSERT_UNORDERED_LIST_COMMAND');\nconst INSERT_ORDERED_LIST_COMMAND = createCommand('INSERT_ORDERED_LIST_COMMAND');\nconst INSERT_CHECK_LIST_COMMAND = createCommand('INSERT_CHECK_LIST_COMMAND');\nconst REMOVE_LIST_COMMAND = createCommand('REMOVE_LIST_COMMAND');\nfunction registerList(editor) {\n  const removeListener = mergeRegister(editor.registerCommand(INSERT_ORDERED_LIST_COMMAND, () => {\n    insertList(editor, 'number');\n    return true;\n  }, COMMAND_PRIORITY_LOW), editor.registerCommand(INSERT_UNORDERED_LIST_COMMAND, () => {\n    insertList(editor, 'bullet');\n    return true;\n  }, COMMAND_PRIORITY_LOW), editor.registerCommand(REMOVE_LIST_COMMAND, () => {\n    removeList(editor);\n    return true;\n  }, COMMAND_PRIORITY_LOW), editor.registerCommand(INSERT_PARAGRAPH_COMMAND, () => {\n    const hasHandledInsertParagraph = $handleListInsertParagraph();\n    if (hasHandledInsertParagraph) {\n      return true;\n    }\n    return false;\n  }, COMMAND_PRIORITY_LOW));\n  return removeListener;\n}\n\nexport { $createListItemNode, $createListNode, $getListDepth, $handleListInsertParagraph, $isListItemNode, $isListNode, INSERT_CHECK_LIST_COMMAND, INSERT_ORDERED_LIST_COMMAND, INSERT_UNORDERED_LIST_COMMAND, ListItemNode, ListNode, REMOVE_LIST_COMMAND, insertList, registerList, removeList };\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 4389, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}}]
}