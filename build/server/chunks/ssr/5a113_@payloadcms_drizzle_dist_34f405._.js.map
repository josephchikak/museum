{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 7, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/@payloadcms/db-postgres/node_modules/@payloadcms/drizzle/src/utilities/isPolymorphicRelationship.ts"],"sourcesContent":["import type { CollectionSlug } from 'payload'\n\nexport const isPolymorphicRelationship = (\n  value: unknown,\n): value is {\n  relationTo: CollectionSlug\n  value: number | string\n} => {\n  return (\n    value &&\n    typeof value === 'object' &&\n    'relationTo' in value &&\n    typeof value.relationTo === 'string' &&\n    'value' in value\n  )\n}\n"],"names":["isPolymorphicRelationship","value","relationTo"],"mappings":";;;AAEO,MAAMA,4BAA4B,CACvCC;IAKA,OACEA,SACA,OAAOA,UAAU,YACjB,gBAAgBA,SAChB,OAAOA,MAAMC,UAAU,KAAK,YAC5B,WAAWD;AAEf,EAAC"}},
    {"offset": {"line": 13, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 19, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/@payloadcms/db-postgres/node_modules/@payloadcms/drizzle/src/utilities/getNameFromDrizzleTable.ts"],"sourcesContent":["import type { Table } from 'drizzle-orm'\n\nexport const getNameFromDrizzleTable = (table: Table): string => {\n  const symbol = Object.getOwnPropertySymbols(table).find((symb) =>\n    symb.description.includes('Name'),\n  )\n\n  return table[symbol]\n}\n"],"names":["getNameFromDrizzleTable","table","symbol","Object","getOwnPropertySymbols","find","symb","description","includes"],"mappings":";;;AAEO,MAAMA,0BAA0B,CAACC;IACtC,MAAMC,SAASC,OAAOC,qBAAqB,CAACH,OAAOI,IAAI,CAAC,CAACC,OACvDA,KAAKC,WAAW,CAACC,QAAQ,CAAC;IAG5B,OAAOP,KAAK,CAACC,OAAO;AACtB,EAAC"}},
    {"offset": {"line": 26, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 32, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/@payloadcms/db-postgres/node_modules/@payloadcms/drizzle/src/queries/addJoinTable.ts"],"sourcesContent":["import type { SQL } from 'drizzle-orm'\nimport type { PgTableWithColumns } from 'drizzle-orm/pg-core'\n\nimport type { GenericTable } from '../types.js'\nimport type { BuildQueryJoinAliases } from './buildQuery.js'\n\nimport { getNameFromDrizzleTable } from '../utilities/getNameFromDrizzleTable.js'\n\nexport const addJoinTable = ({\n  type,\n  condition,\n  joins,\n  table,\n}: {\n  condition: SQL\n  joins: BuildQueryJoinAliases\n  table: GenericTable | PgTableWithColumns<any>\n  type?: 'innerJoin' | 'leftJoin' | 'rightJoin'\n}) => {\n  const name = getNameFromDrizzleTable(table)\n\n  if (!joins.some((eachJoin) => getNameFromDrizzleTable(eachJoin.table) === name)) {\n    joins.push({ type, condition, table })\n  }\n}\n"],"names":["getNameFromDrizzleTable","addJoinTable","type","condition","joins","table","name","some","eachJoin","push"],"mappings":";;;AAMA,SAASA,uBAAuB,QAAQ,0CAAyC;;AAE1E,MAAMC,eAAe,CAAC,EAC3BC,IAAI,EACJC,SAAS,EACTC,KAAK,EACLC,KAAK,EAMN;IACC,MAAMC,qPAAON,0BAAAA,EAAwBK;IAErC,IAAI,CAACD,MAAMG,IAAI,CAAC,CAACC,yPAAaR,0BAAAA,EAAwBQ,SAASH,KAAK,MAAMC,OAAO;QAC/EF,MAAMK,IAAI,CAAC;YAAEP;YAAMC;YAAWE;QAAM;IACtC;AACF,EAAC"}},
    {"offset": {"line": 47, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 53, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/@payloadcms/db-postgres/node_modules/@payloadcms/drizzle/src/queries/getTableAlias.ts"],"sourcesContent":["import type { PgTableWithColumns } from 'drizzle-orm/pg-core'\nimport type { SQLiteTableWithColumns } from 'drizzle-orm/sqlite-core'\n\nimport { alias } from 'drizzle-orm/pg-core'\nimport { alias as aliasSQLite } from 'drizzle-orm/sqlite-core/alias'\nimport toSnakeCase from 'to-snake-case'\nimport { v4 as uuid } from 'uuid'\n\nimport type { DrizzleAdapter } from '../types.js'\n\ntype Table = PgTableWithColumns<any> | SQLiteTableWithColumns<any>\nexport const getTableAlias = ({\n  adapter,\n  tableName,\n}: {\n  adapter: DrizzleAdapter\n  tableName: string\n}): {\n  newAliasTable: Table\n  newAliasTableName: string\n} => {\n  const newAliasTableName = toSnakeCase(uuid())\n  let newAliasTable\n\n  if (adapter.name === 'postgres') {\n    newAliasTable = alias(adapter.tables[tableName], newAliasTableName)\n  }\n  if (adapter.name === 'sqlite') {\n    newAliasTable = aliasSQLite(adapter.tables[tableName], newAliasTableName)\n  }\n\n  return { newAliasTable, newAliasTableName }\n}\n"],"names":["alias","aliasSQLite","toSnakeCase","v4","uuid","getTableAlias","adapter","tableName","newAliasTableName","newAliasTable","name","tables"],"mappings":";;;AAKA,OAAOE,iBAAiB,gBAAe;AACvC,SAASC,MAAMC,IAAI,QAAQ,OAAM;AAHjC,SAASJ,KAAK,QAAQ,sBAAqB;AAC3C,SAASA,SAASC,WAAW,QAAQ,gCAA+B;;;;;AAO7D,MAAMI,gBAAgB,CAAC,EAC5BC,OAAO,EACPC,SAAS,EAIV;IAIC,MAAMC,qKAAoBN,UAAAA,sRAAYE,KAAAA;IACtC,IAAIK;IAEJ,IAAIH,QAAQI,IAAI,KAAK,YAAY;QAC/BD,4NAAgBT,QAAAA,EAAMM,QAAQK,MAAM,CAACJ,UAAU,EAAEC;IACnD;IACA,IAAIF,QAAQI,IAAI,KAAK,UAAU;QAC7BD,gOAAgBR,QAAAA,EAAYK,QAAQK,MAAM,CAACJ,UAAU,EAAEC;IACzD;IAEA,OAAO;QAAEC;QAAeD;IAAkB;AAC5C,EAAC"}},
    {"offset": {"line": 78, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 84, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/@payloadcms/db-postgres/node_modules/@payloadcms/drizzle/src/queries/getTableColumnFromPath.ts"],"sourcesContent":["import type { SQL } from 'drizzle-orm'\nimport type { SQLiteTableWithColumns } from 'drizzle-orm/sqlite-core'\nimport type { Field, FieldAffectingData, NumberField, TabAsField, TextField } from 'payload'\n\nimport { and, eq, like, sql } from 'drizzle-orm'\nimport { type PgTableWithColumns } from 'drizzle-orm/pg-core'\nimport { APIError, flattenTopLevelFields } from 'payload'\nimport { fieldAffectsData, tabHasName } from 'payload/shared'\nimport toSnakeCase from 'to-snake-case'\nimport { validate as uuidValidate } from 'uuid'\n\nimport type { DrizzleAdapter, GenericColumn } from '../types.js'\nimport type { BuildQueryJoinAliases } from './buildQuery.js'\n\nimport { isPolymorphicRelationship } from '../utilities/isPolymorphicRelationship.js'\nimport { addJoinTable } from './addJoinTable.js'\nimport { getTableAlias } from './getTableAlias.js'\n\ntype Constraint = {\n  columnName: string\n  table: PgTableWithColumns<any> | SQLiteTableWithColumns<any>\n  value: unknown\n}\n\ntype TableColumn = {\n  columnName?: string\n  columns?: {\n    idType: 'number' | 'text' | 'uuid'\n    rawColumn: SQL<unknown>\n  }[]\n  constraints: Constraint[]\n  field: FieldAffectingData\n  getNotNullColumnByValue?: (val: unknown) => string\n  pathSegments?: string[]\n  rawColumn?: SQL\n  table: PgTableWithColumns<any> | SQLiteTableWithColumns<any>\n}\n\ntype Args = {\n  adapter: DrizzleAdapter\n  aliasTable?: PgTableWithColumns<any> | SQLiteTableWithColumns<any>\n  collectionPath: string\n  columnPrefix?: string\n  constraintPath?: string\n  constraints?: Constraint[]\n  fields: (Field | TabAsField)[]\n  joins: BuildQueryJoinAliases\n  locale?: string\n  pathSegments: string[]\n  rootTableName?: string\n  selectFields: Record<string, GenericColumn>\n  tableName: string\n  /**\n   * If creating a new table name for arrays and blocks, this suffix should be appended to the table name\n   */\n  tableNameSuffix?: string\n  /**\n   * The raw value of the query before sanitization\n   */\n  value: unknown\n}\n/**\n * Transforms path to table and column name or to a list of OR columns\n * Adds tables to `join`\n * @returns TableColumn\n */\nexport const getTableColumnFromPath = ({\n  adapter,\n  aliasTable,\n  collectionPath,\n  columnPrefix = '',\n  constraintPath: incomingConstraintPath,\n  constraints = [],\n  fields,\n  joins,\n  locale: incomingLocale,\n  pathSegments: incomingSegments,\n  rootTableName: incomingRootTableName,\n  selectFields,\n  tableName,\n  tableNameSuffix = '',\n  value,\n}: Args): TableColumn => {\n  const fieldPath = incomingSegments[0]\n  let locale = incomingLocale\n  const rootTableName = incomingRootTableName || tableName\n  let constraintPath = incomingConstraintPath || ''\n\n  const field = flattenTopLevelFields(fields as Field[]).find(\n    (fieldToFind) => fieldAffectsData(fieldToFind) && fieldToFind.name === fieldPath,\n  ) as Field | TabAsField\n  let newTableName = tableName\n\n  if (!field && fieldPath === 'id') {\n    selectFields.id = adapter.tables[newTableName].id\n    return {\n      columnName: 'id',\n      constraints,\n      field: {\n        name: 'id',\n        type: adapter.idType === 'uuid' ? 'text' : 'number',\n      } as NumberField | TextField,\n      table: adapter.tables[newTableName],\n    }\n  }\n\n  if (field) {\n    const pathSegments = [...incomingSegments]\n\n    // If next segment is a locale,\n    // we need to take it out and use it as the locale from this point on\n    if ('localized' in field && field.localized && adapter.payload.config.localization) {\n      const matchedLocale = adapter.payload.config.localization.localeCodes.find(\n        (locale) => locale === pathSegments[1],\n      )\n\n      if (matchedLocale) {\n        locale = matchedLocale\n        pathSegments.splice(1, 1)\n      }\n    }\n\n    switch (field.type) {\n      case 'tabs': {\n        return getTableColumnFromPath({\n          adapter,\n          aliasTable,\n          collectionPath,\n          columnPrefix,\n          constraintPath,\n          constraints,\n          fields: field.tabs.map((tab) => ({\n            ...tab,\n            type: 'tab',\n          })),\n          joins,\n          locale,\n          pathSegments: pathSegments.slice(1),\n          rootTableName,\n          selectFields,\n          tableName: newTableName,\n          tableNameSuffix,\n          value,\n        })\n      }\n      case 'tab': {\n        if (tabHasName(field)) {\n          return getTableColumnFromPath({\n            adapter,\n            aliasTable,\n            collectionPath,\n            columnPrefix: `${columnPrefix}${field.name}_`,\n            constraintPath: `${constraintPath}${field.name}.`,\n            constraints,\n            fields: field.fields,\n            joins,\n            locale,\n            pathSegments: pathSegments.slice(1),\n            rootTableName,\n            selectFields,\n            tableName: newTableName,\n            tableNameSuffix: `${tableNameSuffix}${toSnakeCase(field.name)}_`,\n            value,\n          })\n        }\n        return getTableColumnFromPath({\n          adapter,\n          aliasTable,\n          collectionPath,\n          columnPrefix,\n          constraintPath,\n          constraints,\n          fields: field.fields,\n          joins,\n          locale,\n          pathSegments: pathSegments.slice(1),\n          rootTableName,\n          selectFields,\n          tableName: newTableName,\n          tableNameSuffix,\n          value,\n        })\n      }\n\n      case 'group': {\n        if (locale && field.localized && adapter.payload.config.localization) {\n          newTableName = `${tableName}${adapter.localesSuffix}`\n\n          let condition = eq(adapter.tables[tableName].id, adapter.tables[newTableName]._parentID)\n\n          if (locale !== 'all') {\n            condition = and(condition, eq(adapter.tables[newTableName]._locale, locale))\n          }\n\n          addJoinTable({\n            condition,\n            joins,\n            table: adapter.tables[newTableName],\n          })\n        }\n        return getTableColumnFromPath({\n          adapter,\n          aliasTable,\n          collectionPath,\n          columnPrefix: `${columnPrefix}${field.name}_`,\n          constraintPath: `${constraintPath}${field.name}.`,\n          constraints,\n          fields: field.fields,\n          joins,\n          locale,\n          pathSegments: pathSegments.slice(1),\n          rootTableName,\n          selectFields,\n          tableName: newTableName,\n          tableNameSuffix: `${tableNameSuffix}${toSnakeCase(field.name)}_`,\n          value,\n        })\n      }\n\n      case 'select': {\n        if (field.hasMany) {\n          const newTableName = adapter.tableNameMap.get(\n            `${tableName}_${tableNameSuffix}${toSnakeCase(field.name)}`,\n          )\n\n          if (locale && field.localized && adapter.payload.config.localization) {\n            const conditions = [\n              eq(adapter.tables[tableName].id, adapter.tables[newTableName].parent),\n              eq(adapter.tables[newTableName]._locale, locale),\n            ]\n\n            if (locale !== 'all') {\n              conditions.push(eq(adapter.tables[newTableName]._locale, locale))\n            }\n\n            addJoinTable({\n              condition: and(...conditions),\n              joins,\n              table: adapter.tables[newTableName],\n            })\n          } else {\n            addJoinTable({\n              condition: eq(adapter.tables[tableName].id, adapter.tables[newTableName].parent),\n              joins,\n              table: adapter.tables[newTableName],\n            })\n          }\n\n          return {\n            columnName: 'value',\n            constraints,\n            field,\n            table: adapter.tables[newTableName],\n          }\n        }\n        break\n      }\n\n      case 'text':\n      case 'number': {\n        if (field.hasMany) {\n          let tableType = 'texts'\n          let columnName = 'text'\n          if (field.type === 'number') {\n            tableType = 'numbers'\n            columnName = 'number'\n          }\n          newTableName = `${rootTableName}_${tableType}`\n          const joinConstraints = [\n            eq(adapter.tables[rootTableName].id, adapter.tables[newTableName].parent),\n            like(adapter.tables[newTableName].path, `${constraintPath}${field.name}`),\n          ]\n\n          if (locale && field.localized && adapter.payload.config.localization) {\n            const conditions = [...joinConstraints]\n\n            if (locale !== 'all') {\n              conditions.push(eq(adapter.tables[newTableName]._locale, locale))\n            }\n            addJoinTable({\n              condition: and(...conditions),\n              joins,\n              table: adapter.tables[newTableName],\n            })\n          } else {\n            addJoinTable({\n              condition: and(...joinConstraints),\n              joins,\n              table: adapter.tables[newTableName],\n            })\n          }\n\n          return {\n            columnName,\n            constraints,\n            field,\n            table: adapter.tables[newTableName],\n          }\n        }\n        break\n      }\n\n      case 'array': {\n        newTableName = adapter.tableNameMap.get(\n          `${tableName}_${tableNameSuffix}${toSnakeCase(field.name)}`,\n        )\n\n        const arrayParentTable = aliasTable || adapter.tables[tableName]\n\n        constraintPath = `${constraintPath}${field.name}.%.`\n        if (locale && field.localized && adapter.payload.config.localization) {\n          const conditions = [eq(arrayParentTable.id, adapter.tables[newTableName]._parentID)]\n\n          if (locale !== 'all') {\n            conditions.push(eq(adapter.tables[newTableName]._locale, locale))\n          }\n          addJoinTable({\n            condition: and(...conditions),\n            joins,\n            table: adapter.tables[newTableName],\n          })\n        } else {\n          addJoinTable({\n            condition: eq(arrayParentTable.id, adapter.tables[newTableName]._parentID),\n            joins,\n            table: adapter.tables[newTableName],\n          })\n        }\n        return getTableColumnFromPath({\n          adapter,\n          collectionPath,\n          constraintPath,\n          constraints,\n          fields: field.fields,\n          joins,\n          locale,\n          pathSegments: pathSegments.slice(1),\n          rootTableName,\n          selectFields,\n          tableName: newTableName,\n          value,\n        })\n      }\n\n      case 'blocks': {\n        let blockTableColumn: TableColumn\n        let newTableName: string\n\n        // handle blockType queries\n        if (pathSegments[1] === 'blockType') {\n          // find the block config using the value\n          const blockTypes = Array.isArray(value) ? value : [value]\n          blockTypes.forEach((blockType) => {\n            const block = field.blocks.find((block) => block.slug === blockType)\n            newTableName = adapter.tableNameMap.get(\n              `${tableName}_blocks_${toSnakeCase(block.slug)}`,\n            )\n\n            const { newAliasTable } = getTableAlias({ adapter, tableName: newTableName })\n\n            joins.push({\n              condition: eq(adapter.tables[tableName].id, newAliasTable._parentID),\n              table: newAliasTable,\n            })\n            constraints.push({\n              columnName: '_path',\n              table: newAliasTable,\n              value: pathSegments[0],\n            })\n          })\n          return {\n            constraints,\n            field,\n            getNotNullColumnByValue: () => 'id',\n            table: adapter.tables[tableName],\n          }\n        }\n\n        const hasBlockField = field.blocks.some((block) => {\n          newTableName = adapter.tableNameMap.get(`${tableName}_blocks_${toSnakeCase(block.slug)}`)\n          constraintPath = `${constraintPath}${field.name}.%.`\n\n          let result\n          const blockConstraints = []\n          const blockSelectFields = {}\n          try {\n            result = getTableColumnFromPath({\n              adapter,\n              collectionPath,\n              constraintPath,\n              constraints: blockConstraints,\n              fields: block.fields,\n              joins,\n              locale,\n              pathSegments: pathSegments.slice(1),\n              rootTableName,\n              selectFields: blockSelectFields,\n              tableName: newTableName,\n              value,\n            })\n          } catch (error) {\n            // this is fine, not every block will have the field\n          }\n          if (!result) {\n            return\n          }\n          blockTableColumn = result\n          constraints = constraints.concat(blockConstraints)\n          selectFields = { ...selectFields, ...blockSelectFields }\n          if (field.localized && adapter.payload.config.localization) {\n            const conditions = [\n              eq(\n                (aliasTable || adapter.tables[tableName]).id,\n                adapter.tables[newTableName]._parentID,\n              ),\n            ]\n\n            if (locale !== 'all') {\n              conditions.push(eq(adapter.tables[newTableName]._locale, locale))\n            }\n\n            joins.push({\n              condition: and(...conditions),\n              table: adapter.tables[newTableName],\n            })\n          } else {\n            joins.push({\n              condition: eq(\n                (aliasTable || adapter.tables[tableName]).id,\n                adapter.tables[newTableName]._parentID,\n              ),\n              table: adapter.tables[newTableName],\n            })\n          }\n          return true\n        })\n        if (hasBlockField) {\n          return {\n            columnName: blockTableColumn.columnName,\n            constraints,\n            field: blockTableColumn.field,\n            pathSegments: pathSegments.slice(1),\n            rawColumn: blockTableColumn.rawColumn,\n            table: blockTableColumn.table,\n          }\n        }\n        break\n      }\n\n      case 'relationship':\n      case 'upload': {\n        const newCollectionPath = pathSegments.slice(1).join('.')\n        if (Array.isArray(field.relationTo) || field.hasMany) {\n          let relationshipFields\n          const relationTableName = `${rootTableName}${adapter.relationshipsSuffix}`\n          const {\n            newAliasTable: aliasRelationshipTable,\n            newAliasTableName: aliasRelationshipTableName,\n          } = getTableAlias({ adapter, tableName: relationTableName })\n\n          // Join in the relationships table\n          if (locale && field.localized && adapter.payload.config.localization) {\n            const conditions = [\n              eq((aliasTable || adapter.tables[rootTableName]).id, aliasRelationshipTable.parent),\n              like(aliasRelationshipTable.path, `${constraintPath}${field.name}`),\n            ]\n\n            if (locale !== 'all') {\n              conditions.push(eq(aliasRelationshipTable.locale, locale))\n            }\n            joins.push({\n              condition: and(...conditions),\n              table: aliasRelationshipTable,\n            })\n          } else {\n            // Join in the relationships table\n            joins.push({\n              condition: and(\n                eq((aliasTable || adapter.tables[rootTableName]).id, aliasRelationshipTable.parent),\n                like(aliasRelationshipTable.path, `${constraintPath}${field.name}`),\n              ),\n              table: aliasRelationshipTable,\n            })\n          }\n\n          selectFields[`${relationTableName}.path`] = aliasRelationshipTable.path\n\n          let newAliasTable\n\n          if (typeof field.relationTo === 'string') {\n            const relationshipConfig = adapter.payload.collections[field.relationTo].config\n\n            newTableName = adapter.tableNameMap.get(toSnakeCase(relationshipConfig.slug))\n\n            // parent to relationship join table\n            relationshipFields = relationshipConfig.fields\n            ;({ newAliasTable } = getTableAlias({ adapter, tableName: newTableName }))\n\n            joins.push({\n              condition: eq(newAliasTable.id, aliasRelationshipTable[`${field.relationTo}ID`]),\n              table: newAliasTable,\n            })\n\n            if (newCollectionPath === '' || newCollectionPath === 'id') {\n              return {\n                columnName: `${field.relationTo}ID`,\n                constraints,\n                field,\n                table: aliasRelationshipTable,\n              }\n            }\n          } else if (newCollectionPath === 'value') {\n            const hasCustomCollectionWithCustomID = field.relationTo.some(\n              (relationTo) => !!adapter.payload.collections[relationTo].customIDType,\n            )\n\n            const columns: TableColumn['columns'] = field.relationTo\n              .map((relationTo) => {\n                let idType: 'number' | 'text' | 'uuid' =\n                  adapter.idType === 'uuid' ? 'uuid' : 'number'\n\n                const { customIDType } = adapter.payload.collections[relationTo]\n\n                if (customIDType) {\n                  idType = customIDType\n                }\n\n                const idTypeTextOrUuid = idType === 'text' || idType === 'uuid'\n\n                // Do not add the column to OR if we know that it can't match by the type\n                // We can't do the same with idType: 'number' because `value` can be from the REST search query params\n                if (typeof value === 'number' && idTypeTextOrUuid) {\n                  return null\n                }\n\n                if (\n                  Array.isArray(value) &&\n                  value.every((val) => typeof val === 'number') &&\n                  idTypeTextOrUuid\n                ) {\n                  return null\n                }\n\n                // Do not add the UUID type column if incoming query value doesn't match UUID. If there aren't any collections with\n                // a custom ID type, we skip this check\n                // We need this because Postgres throws an error if querying by UUID column with a value that isn't a valid UUID.\n                if (\n                  value &&\n                  !Array.isArray(value) &&\n                  idType === 'uuid' &&\n                  hasCustomCollectionWithCustomID\n                ) {\n                  if (!uuidValidate(value)) {\n                    return null\n                  }\n                }\n\n                if (\n                  Array.isArray(value) &&\n                  idType === 'uuid' &&\n                  hasCustomCollectionWithCustomID &&\n                  !value.some((val) => uuidValidate(val))\n                ) {\n                  return null\n                }\n\n                const relationTableName = adapter.tableNameMap.get(\n                  toSnakeCase(adapter.payload.collections[relationTo].config.slug),\n                )\n\n                return {\n                  idType,\n                  rawColumn: sql.raw(`\"${aliasRelationshipTableName}\".\"${relationTableName}_id\"`),\n                }\n              })\n              .filter(Boolean)\n\n            return {\n              columns,\n              constraints,\n              field,\n              table: aliasRelationshipTable,\n            }\n          } else if (newCollectionPath === 'relationTo') {\n            const relationTo = Array.isArray(field.relationTo)\n              ? field.relationTo\n              : [field.relationTo]\n\n            return {\n              constraints,\n              field,\n              getNotNullColumnByValue: (val) => {\n                const matchedRelation = relationTo.find((relation) => relation === val)\n                if (matchedRelation) {\n                  return `${matchedRelation}ID`\n                }\n                return undefined\n              },\n              table: aliasRelationshipTable,\n            }\n          } else if (isPolymorphicRelationship(value)) {\n            const { relationTo } = value\n\n            const relationTableName = adapter.tableNameMap.get(\n              toSnakeCase(adapter.payload.collections[relationTo].config.slug),\n            )\n\n            return {\n              constraints,\n              field,\n              rawColumn: sql.raw(`\"${aliasRelationshipTableName}\".\"${relationTableName}_id\"`),\n              table: aliasRelationshipTable,\n            }\n          } else {\n            throw new APIError('Not supported')\n          }\n\n          return getTableColumnFromPath({\n            adapter,\n            aliasTable: newAliasTable,\n            collectionPath: newCollectionPath,\n            constraints,\n            fields: relationshipFields,\n            joins,\n            locale,\n            pathSegments: pathSegments.slice(1),\n            rootTableName: newTableName,\n            selectFields,\n            tableName: newTableName,\n            value,\n          })\n        } else if (\n          pathSegments.length > 1 &&\n          !(pathSegments.length === 2 && pathSegments[1] === 'id')\n        ) {\n          // simple relationships\n          const columnName = `${columnPrefix}${field.name}`\n          const newTableName = adapter.tableNameMap.get(\n            toSnakeCase(adapter.payload.collections[field.relationTo].config.slug),\n          )\n          const { newAliasTable } = getTableAlias({ adapter, tableName: newTableName })\n\n          if (field.localized && adapter.payload.config.localization) {\n            const { newAliasTable: aliasLocaleTable } = getTableAlias({\n              adapter,\n              tableName: `${rootTableName}${adapter.localesSuffix}`,\n            })\n\n            const condtions = [eq(aliasLocaleTable._parentID, adapter.tables[rootTableName].id)]\n\n            if (locale !== 'all') {\n              condtions.push(eq(aliasLocaleTable._locale, locale))\n            }\n\n            const localesTable = adapter.tables[`${rootTableName}${adapter.localesSuffix}`]\n\n            addJoinTable({\n              condition: and(...condtions),\n              joins,\n              table: localesTable,\n            })\n\n            joins.push({\n              condition: eq(localesTable[columnName], newAliasTable.id),\n              table: newAliasTable,\n            })\n          } else {\n            joins.push({\n              condition: eq(\n                newAliasTable.id,\n                aliasTable ? aliasTable[columnName] : adapter.tables[tableName][columnName],\n              ),\n              table: newAliasTable,\n            })\n          }\n\n          return getTableColumnFromPath({\n            adapter,\n            aliasTable: newAliasTable,\n            collectionPath: newCollectionPath,\n            constraintPath: '',\n            constraints,\n            fields: adapter.payload.collections[field.relationTo].config.fields,\n            joins,\n            locale,\n            pathSegments: pathSegments.slice(1),\n            selectFields,\n            tableName: newTableName,\n            value,\n          })\n        }\n        break\n      }\n\n      default: {\n        // fall through\n        break\n      }\n    }\n\n    if (fieldAffectsData(field)) {\n      let newTable = adapter.tables[newTableName]\n\n      if (field.localized && adapter.payload.config.localization) {\n        // If localized, we go to localized table and set aliasTable to undefined\n        // so it is not picked up below to be used as targetTable\n        const parentTable = aliasTable || adapter.tables[tableName]\n        newTableName = `${tableName}${adapter.localesSuffix}`\n\n        newTable = adapter.tables[newTableName]\n\n        let condition = eq(parentTable.id, newTable._parentID)\n\n        if (locale !== 'all') {\n          condition = and(condition, eq(newTable._locale, locale))\n        }\n\n        addJoinTable({\n          condition,\n          joins,\n          table: newTable,\n        })\n\n        aliasTable = undefined\n      }\n\n      const targetTable = aliasTable || newTable\n\n      selectFields[`${newTableName}.${columnPrefix}${field.name}`] =\n        targetTable[`${columnPrefix}${field.name}`]\n\n      return {\n        columnName: `${columnPrefix}${field.name}`,\n        constraints,\n        field,\n        pathSegments,\n        table: targetTable,\n      }\n    }\n  }\n\n  throw new APIError(`Cannot find field for path at ${fieldPath}`)\n}\n"],"names":["and","eq","like","sql","APIError","flattenTopLevelFields","fieldAffectsData","tabHasName","toSnakeCase","validate","uuidValidate","isPolymorphicRelationship","addJoinTable","getTableAlias","getTableColumnFromPath","adapter","aliasTable","collectionPath","columnPrefix","constraintPath","incomingConstraintPath","constraints","fields","joins","locale","incomingLocale","pathSegments","incomingSegments","rootTableName","incomingRootTableName","selectFields","tableName","tableNameSuffix","value","fieldPath","field","find","fieldToFind","name","newTableName","id","tables","columnName","type","idType","table","localized","payload","config","localization","matchedLocale","localeCodes","splice","tabs","map","tab","slice","localesSuffix","condition","_parentID","_locale","hasMany","tableNameMap","get","conditions","parent","push","tableType","joinConstraints","path","arrayParentTable","blockTableColumn","blockTypes","Array","isArray","forEach","blockType","block","blocks","slug","newAliasTable","getNotNullColumnByValue","hasBlockField","some","result","blockConstraints","blockSelectFields","error","concat","rawColumn","newCollectionPath","join","relationTo","relationshipFields","relationTableName","relationshipsSuffix","aliasRelationshipTable","newAliasTableName","aliasRelationshipTableName","relationshipConfig","collections","hasCustomCollectionWithCustomID","customIDType","columns","idTypeTextOrUuid","every","val","raw","filter","Boolean","matchedRelation","relation","undefined","length","aliasLocaleTable","condtions","localesTable","newTable","parentTable","targetTable"],"mappings":"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"}},
    {"offset": {"line": 670, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 676, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/@payloadcms/db-postgres/node_modules/@payloadcms/drizzle/src/queries/buildOrderBy.ts"],"sourcesContent":["import type { Field, Sort } from 'payload'\n\nimport { asc, desc } from 'drizzle-orm'\n\nimport type { DrizzleAdapter, GenericColumn } from '../types.js'\nimport type { BuildQueryJoinAliases, BuildQueryResult } from './buildQuery.js'\n\nimport { getTableColumnFromPath } from './getTableColumnFromPath.js'\n\ntype Args = {\n  adapter: DrizzleAdapter\n  fields: Field[]\n  joins: BuildQueryJoinAliases\n  locale?: string\n  selectFields: Record<string, GenericColumn>\n  sort?: Sort\n  tableName: string\n}\n\n/**\n * Gets the order by column and direction constructed from the sort argument adds the column to the select fields and joins if necessary\n */\nexport const buildOrderBy = ({\n  adapter,\n  fields,\n  joins,\n  locale,\n  selectFields,\n  sort,\n  tableName,\n}: Args): BuildQueryResult['orderBy'] => {\n  const orderBy: BuildQueryResult['orderBy'] = []\n\n  if (!sort) {\n    const createdAt = adapter.tables[tableName]?.createdAt\n    if (createdAt) {\n      sort = '-createdAt'\n    } else {\n      sort = '-id'\n    }\n  }\n\n  if (typeof sort === 'string') {\n    sort = [sort]\n  }\n\n  for (const sortItem of sort) {\n    let sortProperty: string\n    let sortDirection: 'asc' | 'desc'\n    if (sortItem[0] === '-') {\n      sortProperty = sortItem.substring(1)\n      sortDirection = 'desc'\n    } else {\n      sortProperty = sortItem\n      sortDirection = 'asc'\n    }\n    try {\n      const { columnName: sortTableColumnName, table: sortTable } = getTableColumnFromPath({\n        adapter,\n        collectionPath: sortProperty,\n        fields,\n        joins,\n        locale,\n        pathSegments: sortProperty.replace(/__/g, '.').split('.'),\n        selectFields,\n        tableName,\n        value: sortProperty,\n      })\n      if (sortTable?.[sortTableColumnName]) {\n        orderBy.push({\n          column: sortTable[sortTableColumnName],\n          order: sortDirection === 'asc' ? asc : desc,\n        })\n\n        selectFields[sortTableColumnName] = sortTable[sortTableColumnName]\n      }\n    } catch (err) {\n      // continue\n    }\n  }\n\n  return orderBy\n}\n"],"names":["asc","desc","getTableColumnFromPath","buildOrderBy","adapter","fields","joins","locale","selectFields","sort","tableName","orderBy","createdAt","tables","sortItem","sortProperty","sortDirection","substring","columnName","sortTableColumnName","table","sortTable","collectionPath","pathSegments","replace","split","value","push","column","order","err"],"mappings":";;;AAOA,SAASE,sBAAsB,QAAQ,8BAA6B;AALpE,SAASF,GAAG,EAAEC,IAAI,QAAQ,cAAa;;;AAoBhC,MAAME,eAAe,CAAC,EAC3BC,OAAO,EACPC,MAAM,EACNC,KAAK,EACLC,MAAM,EACNC,YAAY,EACZC,IAAI,EACJC,SAAS,EACJ;IACL,MAAMC,UAAuC,EAAE;IAE/C,IAAI,CAACF,MAAM;QACT,MAAMG,YAAYR,QAAQS,MAAM,CAACH,UAAU,EAAEE;QAC7C,IAAIA,WAAW;YACbH,OAAO;QACT,OAAO;YACLA,OAAO;QACT;IACF;IAEA,IAAI,OAAOA,SAAS,UAAU;QAC5BA,OAAO;YAACA;SAAK;IACf;IAEA,KAAK,MAAMK,YAAYL,KAAM;QAC3B,IAAIM;QACJ,IAAIC;QACJ,IAAIF,QAAQ,CAAC,EAAE,KAAK,KAAK;YACvBC,eAAeD,SAASG,SAAS,CAAC;YAClCD,gBAAgB;QAClB,OAAO;YACLD,eAAeD;YACfE,gBAAgB;QAClB;QACA,IAAI;YACF,MAAM,EAAEE,YAAYC,mBAAmB,EAAEC,OAAOC,SAAS,EAAE,8OAAGnB,yBAAAA,EAAuB;gBACnFE;gBACAkB,gBAAgBP;gBAChBV;gBACAC;gBACAC;gBACAgB,cAAcR,aAAaS,OAAO,CAAC,OAAO,KAAKC,KAAK,CAAC;gBACrDjB;gBACAE;gBACAgB,OAAOX;YACT;YACA,IAAIM,WAAW,CAACF,oBAAoB,EAAE;gBACpCR,QAAQgB,IAAI,CAAC;oBACXC,QAAQP,SAAS,CAACF,oBAAoB;oBACtCU,OAAOb,kBAAkB,yNAAQhB,MAAAA,oNAAMC,OAAAA;gBACzC;gBAEAO,YAAY,CAACW,oBAAoB,GAAGE,SAAS,CAACF,oBAAoB;YACpE;QACF,EAAE,OAAOW,KAAK;QACZ,WAAW;QACb;IACF;IAEA,OAAOnB;AACT,EAAC"}},
    {"offset": {"line": 733, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 739, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/@payloadcms/db-postgres/node_modules/@payloadcms/drizzle/src/queries/buildAndOrConditions.ts"],"sourcesContent":["import type { SQL } from 'drizzle-orm'\nimport type { Field, Where } from 'payload'\n\nimport type { DrizzleAdapter, GenericColumn } from '../types.js'\nimport type { BuildQueryJoinAliases } from './buildQuery.js'\n\nimport { parseParams } from './parseParams.js'\n\nexport function buildAndOrConditions({\n  adapter,\n  fields,\n  joins,\n  locale,\n  selectFields,\n  tableName,\n  where,\n}: {\n  adapter: DrizzleAdapter\n  collectionSlug?: string\n  fields: Field[]\n  globalSlug?: string\n  joins: BuildQueryJoinAliases\n  locale?: string\n  selectFields: Record<string, GenericColumn>\n  tableName: string\n  where: Where[]\n}): SQL[] {\n  const completedConditions = []\n  // Loop over all AND / OR operations and add them to the AND / OR query param\n  // Operations should come through as an array\n\n  for (const condition of where) {\n    // If the operation is properly formatted as an object\n    if (typeof condition === 'object') {\n      const result = parseParams({\n        adapter,\n        fields,\n        joins,\n        locale,\n        selectFields,\n        tableName,\n        where: condition,\n      })\n      if (result && Object.keys(result).length > 0) {\n        completedConditions.push(result)\n      }\n    }\n  }\n  return completedConditions\n}\n"],"names":["parseParams","buildAndOrConditions","adapter","fields","joins","locale","selectFields","tableName","where","completedConditions","condition","result","Object","keys","length","push"],"mappings":";;;AAMA,SAASA,WAAW,QAAQ,mBAAkB;;AAEvC,SAASC,qBAAqB,EACnCC,OAAO,EACPC,MAAM,EACNC,KAAK,EACLC,MAAM,EACNC,YAAY,EACZC,SAAS,EACTC,KAAK,EAWN;IACC,MAAMC,sBAAsB,EAAE;IAC9B,6EAA6E;IAC7E,6CAA6C;IAE7C,KAAK,MAAMC,aAAaF,MAAO;QAC7B,sDAAsD;QACtD,IAAI,OAAOE,cAAc,UAAU;YACjC,MAAMC,UAASX,6OAAAA,EAAY;gBACzBE;gBACAC;gBACAC;gBACAC;gBACAC;gBACAC;gBACAC,OAAOE;YACT;YACA,IAAIC,UAAUC,OAAOC,IAAI,CAACF,QAAQG,MAAM,GAAG,GAAG;gBAC5CL,oBAAoBM,IAAI,CAACJ;YAC3B;QACF;IACF;IACA,OAAOF;AACT"}},
    {"offset": {"line": 767, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 773, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/@payloadcms/db-postgres/node_modules/@payloadcms/drizzle/src/utilities/getCollectionIdType.ts"],"sourcesContent":["import type { Collection } from 'payload'\n\nimport type { DrizzleAdapter } from '../types.js'\n\nconst typeMap: Record<string, 'number' | 'text'> = {\n  number: 'number',\n  serial: 'number',\n  text: 'text',\n  uuid: 'text',\n}\n\nexport const getCollectionIdType = ({\n  adapter,\n  collection,\n}: {\n  adapter: DrizzleAdapter\n  collection: Collection\n}) => {\n  return collection.customIDType ?? typeMap[adapter.idType]\n}\n"],"names":["typeMap","number","serial","text","uuid","getCollectionIdType","adapter","collection","customIDType","idType"],"mappings":";;;AAIA,MAAMA,UAA6C;IACjDC,QAAQ;IACRC,QAAQ;IACRC,MAAM;IACNC,MAAM;AACR;AAEO,MAAMC,sBAAsB,CAAC,EAClCC,OAAO,EACPC,UAAU,EAIX;IACC,OAAOA,WAAWC,YAAY,IAAIR,OAAO,CAACM,QAAQG,MAAM,CAAC;AAC3D,EAAC"}},
    {"offset": {"line": 785, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 791, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/@payloadcms/db-postgres/node_modules/@payloadcms/drizzle/src/queries/sanitizeQueryValue.ts"],"sourcesContent":["import type { SQL } from 'drizzle-orm'\n\nimport { APIError, createArrayFromCommaDelineated, type Field, type TabAsField } from 'payload'\nimport { fieldAffectsData } from 'payload/shared'\nimport { validate as uuidValidate } from 'uuid'\n\nimport type { DrizzleAdapter } from '../types.js'\n\nimport { getCollectionIdType } from '../utilities/getCollectionIdType.js'\nimport { isPolymorphicRelationship } from '../utilities/isPolymorphicRelationship.js'\n\ntype SanitizeQueryValueArgs = {\n  adapter: DrizzleAdapter\n  columns?: {\n    idType: 'number' | 'text' | 'uuid'\n    rawColumn: SQL<unknown>\n  }[]\n  field: Field | TabAsField\n  isUUID: boolean\n  operator: string\n  relationOrPath: string\n  val: any\n}\n\ntype SanitizedColumn = {\n  rawColumn: SQL<unknown>\n  value: unknown\n}\n\nexport const sanitizeQueryValue = ({\n  adapter,\n  columns,\n  field,\n  isUUID,\n  operator: operatorArg,\n  relationOrPath,\n  val,\n}: SanitizeQueryValueArgs): {\n  columns?: SanitizedColumn[]\n  operator: string\n  value: unknown\n} => {\n  let operator = operatorArg\n  let formattedValue = val\n  let formattedColumns: SanitizedColumn[]\n\n  if (!fieldAffectsData(field)) {\n    return { operator, value: formattedValue }\n  }\n\n  if (\n    (field.type === 'relationship' || field.type === 'upload') &&\n    !relationOrPath.endsWith('relationTo') &&\n    Array.isArray(formattedValue)\n  ) {\n    const allPossibleIDTypes: (number | string)[] = []\n    formattedValue.forEach((val) => {\n      if (adapter.idType !== 'uuid' && typeof val === 'string') {\n        allPossibleIDTypes.push(val, parseInt(val))\n      } else if (typeof val === 'string') {\n        allPossibleIDTypes.push(val)\n      } else {\n        allPossibleIDTypes.push(val, String(val))\n      }\n    })\n    formattedValue = allPossibleIDTypes\n  }\n\n  // Cast incoming values as proper searchable types\n  if (field.type === 'checkbox' && typeof val === 'string') {\n    if (val.toLowerCase() === 'true') {\n      formattedValue = true\n    }\n    if (val.toLowerCase() === 'false') {\n      formattedValue = false\n    }\n  }\n\n  if (['all', 'in', 'not_in'].includes(operator)) {\n    if (typeof formattedValue === 'string') {\n      formattedValue = createArrayFromCommaDelineated(formattedValue)\n\n      if (field.type === 'number') {\n        formattedValue = formattedValue.map((arrayVal) => parseFloat(arrayVal))\n      }\n    }\n\n    if (!Array.isArray(formattedValue) || formattedValue.length === 0) {\n      return null\n    }\n  }\n\n  if (field.type === 'number' && typeof formattedValue === 'string') {\n    formattedValue = Number(val)\n\n    if (Number.isNaN(formattedValue)) {\n      formattedValue = null\n    }\n  }\n\n  if (isUUID && typeof formattedValue === 'string') {\n    if (!uuidValidate(val)) {\n      formattedValue = null\n    }\n  }\n\n  if (field.type === 'date' && operator !== 'exists') {\n    if (typeof val === 'string') {\n      formattedValue = new Date(val).toISOString()\n      if (Number.isNaN(Date.parse(formattedValue))) {\n        return { operator, value: undefined }\n      }\n    } else if (typeof val === 'number') {\n      formattedValue = new Date(val).toISOString()\n    }\n  }\n\n  if (field.type === 'relationship' || field.type === 'upload') {\n    if (val === 'null') {\n      formattedValue = null\n    } else if (!(formattedValue === null || typeof formattedValue === 'boolean')) {\n      // convert the value to the idType of the relationship\n      let idType: 'number' | 'text'\n      if (typeof field.relationTo === 'string') {\n        idType = getCollectionIdType({\n          adapter,\n          collection: adapter.payload.collections[field.relationTo],\n        })\n      } else {\n        if (isPolymorphicRelationship(val)) {\n          if (operator !== 'equals') {\n            throw new APIError(\n              `Only 'equals' operator is supported for polymorphic relationship object notation. Given - ${operator}`,\n            )\n          }\n          idType = getCollectionIdType({\n            adapter,\n            collection: adapter.payload.collections[val.relationTo],\n          })\n\n          return {\n            operator,\n            value: idType === 'number' ? Number(val.value) : String(val.value),\n          }\n        }\n\n        formattedColumns = columns\n          .map(({ idType, rawColumn }) => {\n            let formattedValue: number | number[] | string | string[]\n\n            if (Array.isArray(val)) {\n              formattedValue = val\n                .map((eachVal) => {\n                  let formattedValue: number | string\n\n                  if (idType === 'number') {\n                    formattedValue = Number(eachVal)\n\n                    if (Number.isNaN(formattedValue)) {\n                      return null\n                    }\n                  } else {\n                    if (idType === 'uuid' && !uuidValidate(eachVal)) {\n                      return null\n                    }\n\n                    formattedValue = String(eachVal)\n                  }\n\n                  return formattedValue\n                })\n                .filter(Boolean) as number[] | string[]\n            } else if (idType === 'number') {\n              formattedValue = Number(val)\n\n              if (Number.isNaN(formattedValue)) {\n                return null\n              }\n            } else {\n              formattedValue = String(val)\n            }\n\n            return {\n              rawColumn,\n              value: formattedValue,\n            }\n          })\n          .filter(Boolean)\n      }\n      if (Array.isArray(formattedValue)) {\n        formattedValue = formattedValue.map((value) => {\n          if (idType === 'number') {\n            return Number(value)\n          }\n          if (idType === 'text') {\n            return String(value)\n          }\n          return value\n        })\n      } else {\n        if (idType === 'number') {\n          formattedValue = Number(val)\n        }\n        if (idType === 'text') {\n          formattedValue = String(val)\n        }\n      }\n    }\n  }\n\n  if ('hasMany' in field && field.hasMany && operator === 'contains') {\n    operator = 'equals'\n  }\n\n  if (operator === 'near' || operator === 'within' || operator === 'intersects') {\n    throw new APIError(\n      `Querying with '${operator}' is not supported with the postgres database adapter.`,\n    )\n  }\n\n  if (operator === 'contains') {\n    formattedValue = `%${formattedValue}%`\n  }\n\n  if (operator === 'exists') {\n    formattedValue = val === 'true' || val === true\n\n    if (formattedValue) {\n      operator = 'exists'\n    } else {\n      operator = 'isNull'\n    }\n  }\n\n  return {\n    columns: formattedColumns,\n    operator,\n    value: formattedValue,\n  }\n}\n"],"names":["APIError","createArrayFromCommaDelineated","fieldAffectsData","validate","uuidValidate","getCollectionIdType","isPolymorphicRelationship","sanitizeQueryValue","adapter","columns","field","isUUID","operator","operatorArg","relationOrPath","val","formattedValue","formattedColumns","value","type","endsWith","Array","isArray","allPossibleIDTypes","forEach","idType","push","parseInt","String","toLowerCase","includes","map","arrayVal","parseFloat","length","Number","isNaN","Date","toISOString","parse","undefined","relationTo","collection","payload","collections","rawColumn","eachVal","filter","Boolean","hasMany"],"mappings":"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"}},
    {"offset": {"line": 976, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 982, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/@payloadcms/db-postgres/node_modules/@payloadcms/drizzle/src/queries/parseParams.ts"],"sourcesContent":["import type { SQL } from 'drizzle-orm'\nimport type { Field, Operator, Where } from 'payload'\n\nimport { and, isNotNull, isNull, ne, notInArray, or, sql } from 'drizzle-orm'\nimport { PgUUID } from 'drizzle-orm/pg-core'\nimport { QueryError } from 'payload'\nimport { validOperators } from 'payload/shared'\n\nimport type { DrizzleAdapter, GenericColumn } from '../types.js'\nimport type { BuildQueryJoinAliases } from './buildQuery.js'\n\nimport { buildAndOrConditions } from './buildAndOrConditions.js'\nimport { getTableColumnFromPath } from './getTableColumnFromPath.js'\nimport { sanitizeQueryValue } from './sanitizeQueryValue.js'\n\ntype Args = {\n  adapter: DrizzleAdapter\n  fields: Field[]\n  joins: BuildQueryJoinAliases\n  locale: string\n  selectFields: Record<string, GenericColumn>\n  tableName: string\n  where: Where\n}\n\nexport function parseParams({\n  adapter,\n  fields,\n  joins,\n  locale,\n  selectFields,\n  tableName,\n  where,\n}: Args): SQL {\n  let result: SQL\n  const constraints: SQL[] = []\n\n  if (typeof where === 'object' && Object.keys(where).length > 0) {\n    // We need to determine if the whereKey is an AND, OR, or a schema path\n    for (const relationOrPath of Object.keys(where)) {\n      if (relationOrPath) {\n        const condition = where[relationOrPath]\n        let conditionOperator: typeof and | typeof or\n        if (relationOrPath.toLowerCase() === 'and') {\n          conditionOperator = and\n        } else if (relationOrPath.toLowerCase() === 'or') {\n          conditionOperator = or\n        }\n        if (Array.isArray(condition)) {\n          const builtConditions = buildAndOrConditions({\n            adapter,\n            fields,\n            joins,\n            locale,\n            selectFields,\n            tableName,\n            where: condition,\n          })\n          if (builtConditions.length > 0) {\n            result = conditionOperator(...builtConditions)\n          }\n        } else {\n          // It's a path - and there can be multiple comparisons on a single path.\n          // For example - title like 'test' and title not equal to 'tester'\n          // So we need to loop on keys again here to handle each operator independently\n          const pathOperators = where[relationOrPath]\n          if (typeof pathOperators === 'object') {\n            for (let operator of Object.keys(pathOperators)) {\n              if (validOperators.includes(operator as Operator)) {\n                const val = where[relationOrPath][operator]\n\n                const {\n                  columnName,\n                  columns,\n                  constraints: queryConstraints,\n                  field,\n                  getNotNullColumnByValue,\n                  pathSegments,\n                  rawColumn,\n                  table,\n                } = getTableColumnFromPath({\n                  adapter,\n                  collectionPath: relationOrPath,\n                  fields,\n                  joins,\n                  locale,\n                  pathSegments: relationOrPath.replace(/__/g, '.').split('.'),\n                  selectFields,\n                  tableName,\n                  value: val,\n                })\n\n                queryConstraints.forEach(({ columnName: col, table: constraintTable, value }) => {\n                  if (typeof value === 'string' && value.indexOf('%') > -1) {\n                    constraints.push(adapter.operators.like(constraintTable[col], value))\n                  } else {\n                    constraints.push(adapter.operators.equals(constraintTable[col], value))\n                  }\n                })\n\n                if (\n                  ['json', 'richText'].includes(field.type) &&\n                  Array.isArray(pathSegments) &&\n                  pathSegments.length > 1\n                ) {\n                  const segments = pathSegments.slice(1)\n                  segments.unshift(table[columnName].name)\n\n                  if (field.type === 'richText') {\n                    // use the table name from the nearest join to handle blocks, arrays, etc. or use the tableName arg\n                    const jsonTable =\n                      joins.length === 0\n                        ? tableName\n                        : joins[joins.length - 1].table[\n                            Object.getOwnPropertySymbols(joins[joins.length - 1].table)[0]\n                          ]\n                    const jsonQuery = adapter.createJSONQuery({\n                      operator,\n                      pathSegments: segments,\n                      table: jsonTable,\n                      treatAsArray: ['children'],\n                      treatRootAsArray: true,\n                      value: val,\n                    })\n\n                    constraints.push(sql.raw(jsonQuery))\n                    break\n                  }\n\n                  const jsonQuery = adapter.convertPathToJSONTraversal(pathSegments)\n                  const operatorKeys: Record<string, { operator: string; wildcard: string }> = {\n                    contains: { operator: 'like', wildcard: '%' },\n                    equals: { operator: '=', wildcard: '' },\n                    exists: { operator: val === true ? 'is not null' : 'is null', wildcard: '' },\n                    in: { operator: 'in', wildcard: '' },\n                    like: { operator: 'like', wildcard: '%' },\n                    not_equals: { operator: '<>', wildcard: '' },\n                    not_in: { operator: 'not in', wildcard: '' },\n                  }\n\n                  let formattedValue = val\n                  if (adapter.name === 'sqlite' && operator === 'equals' && !isNaN(val)) {\n                    formattedValue = val\n                  } else if (['in', 'not_in'].includes(operator) && Array.isArray(val)) {\n                    if (adapter.name === 'sqlite') {\n                      formattedValue = `(${val.map((v) => `${v}`).join(',')})`\n                    } else {\n                      formattedValue = `(${val.map((v) => `'${v}'`).join(', ')})`\n                    }\n                  } else {\n                    formattedValue = `'${operatorKeys[operator].wildcard}${val}${operatorKeys[operator].wildcard}'`\n                  }\n                  if (operator === 'exists') {\n                    formattedValue = ''\n                  }\n\n                  constraints.push(\n                    sql.raw(\n                      `${table[columnName].name}${jsonQuery} ${operatorKeys[operator].operator} ${formattedValue}`,\n                    ),\n                  )\n\n                  break\n                }\n\n                if (getNotNullColumnByValue) {\n                  const columnName = getNotNullColumnByValue(val)\n                  if (columnName) {\n                    constraints.push(isNotNull(table[columnName]))\n                  } else {\n                    throw new QueryError([{ path: relationOrPath }])\n                  }\n                  break\n                }\n\n                if (\n                  operator === 'like' &&\n                  (field.type === 'number' || table[columnName].columnType === 'PgUUID')\n                ) {\n                  operator = 'equals'\n                }\n\n                if (operator === 'like') {\n                  constraints.push(\n                    and(\n                      ...val\n                        .split(' ')\n                        .map((word) => adapter.operators.like(table[columnName], `%${word}%`)),\n                    ),\n                  )\n                  break\n                }\n\n                const sanitizedQueryValue = sanitizeQueryValue({\n                  adapter,\n                  columns,\n                  field,\n                  isUUID: table?.[columnName] instanceof PgUUID,\n                  operator,\n                  relationOrPath,\n                  val,\n                })\n\n                if (sanitizedQueryValue === null) {\n                  break\n                }\n\n                const {\n                  columns: queryColumns,\n                  operator: queryOperator,\n                  value: queryValue,\n                } = sanitizedQueryValue\n\n                // Handle polymorphic relationships by value\n                if (queryColumns) {\n                  if (!queryColumns.length) {\n                    break\n                  }\n\n                  let wrapOperator = or\n\n                  if (queryValue === null && ['equals', 'not_equals'].includes(operator)) {\n                    if (operator === 'equals') {\n                      wrapOperator = and\n                    }\n\n                    constraints.push(\n                      wrapOperator(\n                        ...queryColumns.map(({ rawColumn }) =>\n                          operator === 'equals' ? isNull(rawColumn) : isNotNull(rawColumn),\n                        ),\n                      ),\n                    )\n                    break\n                  }\n\n                  if (['not_equals', 'not_in'].includes(operator)) {\n                    wrapOperator = and\n                  }\n\n                  constraints.push(\n                    wrapOperator(\n                      ...queryColumns.map(({ rawColumn, value }) =>\n                        adapter.operators[queryOperator](rawColumn, value),\n                      ),\n                    ),\n                  )\n\n                  break\n                }\n\n                if (queryOperator === 'not_equals' && queryValue !== null) {\n                  constraints.push(\n                    or(\n                      isNull(rawColumn || table[columnName]),\n                      /* eslint-disable @typescript-eslint/no-explicit-any */\n                      ne<any>(rawColumn || table[columnName], queryValue),\n                    ),\n                  )\n                  break\n                }\n\n                if (\n                  (field.type === 'relationship' || field.type === 'upload') &&\n                  Array.isArray(queryValue) &&\n                  operator === 'not_in'\n                ) {\n                  constraints.push(\n                    sql`(${notInArray(table[columnName], queryValue)} OR\n                    ${table[columnName]}\n                    IS\n                    NULL)`,\n                  )\n\n                  break\n                }\n\n                if (operator === 'equals' && queryValue === null) {\n                  constraints.push(isNull(rawColumn || table[columnName]))\n                  break\n                }\n\n                if (operator === 'not_equals' && queryValue === null) {\n                  constraints.push(isNotNull(rawColumn || table[columnName]))\n                  break\n                }\n\n                constraints.push(\n                  adapter.operators[queryOperator](rawColumn || table[columnName], queryValue),\n                )\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n  if (constraints.length > 0) {\n    if (result) {\n      result = and(result, ...constraints)\n    } else {\n      result = and(...constraints)\n    }\n  }\n  if (constraints.length === 1 && !result) {\n    ;[result] = constraints\n  }\n\n  return result\n}\n"],"names":["and","isNotNull","isNull","ne","notInArray","or","sql","PgUUID","QueryError","validOperators","buildAndOrConditions","getTableColumnFromPath","sanitizeQueryValue","parseParams","adapter","fields","joins","locale","selectFields","tableName","where","result","constraints","Object","keys","length","relationOrPath","condition","conditionOperator","toLowerCase","Array","isArray","builtConditions","pathOperators","operator","includes","val","columnName","columns","queryConstraints","field","getNotNullColumnByValue","pathSegments","rawColumn","table","collectionPath","replace","split","value","forEach","col","constraintTable","indexOf","push","operators","like","equals","type","segments","slice","unshift","name","jsonTable","getOwnPropertySymbols","jsonQuery","createJSONQuery","treatAsArray","treatRootAsArray","raw","convertPathToJSONTraversal","operatorKeys","contains","wildcard","exists","in","not_equals","not_in","formattedValue","isNaN","map","v","join","path","columnType","word","sanitizedQueryValue","isUUID","queryColumns","queryOperator","queryValue","wrapOperator"],"mappings":"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"}},
    {"offset": {"line": 1225, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1231, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/@payloadcms/db-postgres/node_modules/@payloadcms/drizzle/src/queries/buildQuery.ts"],"sourcesContent":["import type { asc, desc, SQL } from 'drizzle-orm'\nimport type { PgTableWithColumns } from 'drizzle-orm/pg-core'\nimport type { Field, Sort, Where } from 'payload'\n\nimport type { DrizzleAdapter, GenericColumn, GenericTable } from '../types.js'\n\nimport { buildOrderBy } from './buildOrderBy.js'\nimport { parseParams } from './parseParams.js'\n\nexport type BuildQueryJoinAliases = {\n  condition: SQL\n  table: GenericTable | PgTableWithColumns<any>\n  type?: 'innerJoin' | 'leftJoin' | 'rightJoin'\n}[]\n\ntype BuildQueryArgs = {\n  adapter: DrizzleAdapter\n  fields: Field[]\n  joins?: BuildQueryJoinAliases\n  locale?: string\n  sort?: Sort\n  tableName: string\n  where: Where\n}\n\nexport type BuildQueryResult = {\n  joins: BuildQueryJoinAliases\n  orderBy: {\n    column: GenericColumn\n    order: typeof asc | typeof desc\n  }[]\n  selectFields: Record<string, GenericColumn>\n  where: SQL\n}\nconst buildQuery = function buildQuery({\n  adapter,\n  fields,\n  joins = [],\n  locale,\n  sort,\n  tableName,\n  where: incomingWhere,\n}: BuildQueryArgs): BuildQueryResult {\n  const selectFields: Record<string, GenericColumn> = {\n    id: adapter.tables[tableName].id,\n  }\n\n  const orderBy = buildOrderBy({\n    adapter,\n    fields,\n    joins,\n    locale,\n    selectFields,\n    sort,\n    tableName,\n  })\n\n  let where: SQL\n\n  if (incomingWhere && Object.keys(incomingWhere).length > 0) {\n    where = parseParams({\n      adapter,\n      fields,\n      joins,\n      locale,\n      selectFields,\n      tableName,\n      where: incomingWhere,\n    })\n  }\n\n  return {\n    joins,\n    orderBy,\n    selectFields,\n    where,\n  }\n}\n\nexport default buildQuery\n"],"names":["buildOrderBy","parseParams","buildQuery","adapter","fields","joins","locale","sort","tableName","where","incomingWhere","selectFields","id","tables","orderBy","Object","keys","length"],"mappings":";;;AAMA,SAASA,YAAY,QAAQ,oBAAmB;AAChD,SAASC,WAAW,QAAQ,mBAAkB;;;AA2B9C,MAAMC,aAAa,SAASA,WAAW,EACrCC,OAAO,EACPC,MAAM,EACNC,QAAQ,EAAE,EACVC,MAAM,EACNC,IAAI,EACJC,SAAS,EACTC,OAAOC,aAAa,EACL;IACf,MAAMC,eAA8C;QAClDC,IAAIT,QAAQU,MAAM,CAACL,UAAU,CAACI,EAAE;IAClC;IAEA,MAAME,2OAAUd,eAAAA,EAAa;QAC3BG;QACAC;QACAC;QACAC;QACAK;QACAJ;QACAC;IACF;IAEA,IAAIC;IAEJ,IAAIC,iBAAiBK,OAAOC,IAAI,CAACN,eAAeO,MAAM,GAAG,GAAG;QAC1DR,wOAAQR,cAAAA,EAAY;YAClBE;YACAC;YACAC;YACAC;YACAK;YACAH;YACAC,OAAOC;QACT;IACF;IAEA,OAAO;QACLL;QACAS;QACAH;QACAF;IACF;AACF;uCAEeP,WAAU"}},
    {"offset": {"line": 1272, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1278, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/@payloadcms/db-postgres/node_modules/@payloadcms/drizzle/src/count.ts"],"sourcesContent":["import type { Count, SanitizedCollectionConfig } from 'payload'\n\nimport toSnakeCase from 'to-snake-case'\n\nimport type { DrizzleAdapter } from './types.js'\n\nimport buildQuery from './queries/buildQuery.js'\n\nexport const count: Count = async function count(\n  this: DrizzleAdapter,\n  { collection, locale, req, where: whereArg },\n) {\n  const collectionConfig: SanitizedCollectionConfig = this.payload.collections[collection].config\n\n  const tableName = this.tableNameMap.get(toSnakeCase(collectionConfig.slug))\n\n  const db = this.sessions[await req?.transactionID]?.db || this.drizzle\n\n  const { joins, where } = buildQuery({\n    adapter: this,\n    fields: collectionConfig.fields,\n    locale,\n    tableName,\n    where: whereArg,\n  })\n\n  const countResult = await this.countDistinct({\n    db,\n    joins,\n    tableName,\n    where,\n  })\n\n  return { totalDocs: countResult }\n}\n"],"names":["toSnakeCase","buildQuery","count","collection","locale","req","where","whereArg","collectionConfig","payload","collections","config","tableName","tableNameMap","get","slug","db","sessions","transactionID","drizzle","joins","adapter","fields","countResult","countDistinct","totalDocs"],"mappings":";;;AAEA,OAAOA,iBAAiB,gBAAe;AAIvC,OAAOC,gBAAgB,0BAAyB;;;AAEzC,MAAMC,QAAe,eAAeA,MAEzC,EAAEC,UAAU,EAAEC,MAAM,EAAEC,GAAG,EAAEC,OAAOC,QAAQ,EAAE;IAE5C,MAAMC,mBAA8C,IAAI,CAACC,OAAO,CAACC,WAAW,CAACP,WAAW,CAACQ,MAAM;IAE/F,MAAMC,YAAY,IAAI,CAACC,YAAY,CAACC,GAAG,kJAACd,UAAAA,EAAYQ,iBAAiBO,IAAI;IAEzE,MAAMC,KAAK,IAAI,CAACC,QAAQ,CAAC,MAAMZ,KAAKa,cAAc,EAAEF,MAAM,IAAI,CAACG,OAAO;IAEtE,MAAM,EAAEC,KAAK,EAAEd,KAAK,EAAE,kOAAGL,UAAAA,EAAW;QAClCoB,SAAS,IAAI;QACbC,QAAQd,iBAAiBc,MAAM;QAC/BlB;QACAQ;QACAN,OAAOC;IACT;IAEA,MAAMgB,cAAc,MAAM,IAAI,CAACC,aAAa,CAAC;QAC3CR;QACAI;QACAR;QACAN;IACF;IAEA,OAAO;QAAEmB,WAAWF;IAAY;AAClC,EAAC"}},
    {"offset": {"line": 1306, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1312, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/@payloadcms/db-postgres/node_modules/@payloadcms/drizzle/src/find/chainMethods.ts"],"sourcesContent":["import type { QueryPromise } from 'drizzle-orm'\n\nexport type ChainedMethods = {\n  args: unknown[]\n  method: string\n}[]\n\n/**\n * Call and returning methods that would normally be chained together but cannot be because of control logic\n * @param methods\n * @param query\n */\nconst chainMethods = <T>({ methods, query }): QueryPromise<T> => {\n  return methods.reduce((query, { args, method }) => {\n    return query[method](...args)\n  }, query)\n}\n\nexport { chainMethods }\n"],"names":["chainMethods","methods","query","reduce","args","method"],"mappings":"AAOA;;;;CAIC;;;AACD,MAAMA,eAAe,CAAI,EAAEC,OAAO,EAAEC,KAAK,EAAE;IACzC,OAAOD,QAAQE,MAAM,CAAC,CAACD,OAAO,EAAEE,IAAI,EAAEC,MAAM,EAAE;QAC5C,OAAOH,KAAK,CAACG,OAAO,IAAID;IAC1B,GAAGF;AACL"}},
    {"offset": {"line": 1326, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1332, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/@payloadcms/db-postgres/node_modules/@payloadcms/drizzle/src/find/traverseFields.ts"],"sourcesContent":["import type { LibSQLDatabase } from 'drizzle-orm/libsql'\nimport type { Field, JoinQuery } from 'payload'\n\nimport { and, eq, sql } from 'drizzle-orm'\nimport { fieldAffectsData, fieldIsVirtual, tabHasName } from 'payload/shared'\nimport toSnakeCase from 'to-snake-case'\n\nimport type { BuildQueryJoinAliases, ChainedMethods, DrizzleAdapter } from '../types.js'\nimport type { Result } from './buildFindManyArgs.js'\n\nimport buildQuery from '../queries/buildQuery.js'\nimport { chainMethods } from './chainMethods.js'\n\ntype TraverseFieldArgs = {\n  _locales: Result\n  adapter: DrizzleAdapter\n  currentArgs: Result\n  currentTableName: string\n  depth?: number\n  fields: Field[]\n  joinQuery: JoinQuery\n  joins?: BuildQueryJoinAliases\n  locale?: string\n  path: string\n  tablePath: string\n  topLevelArgs: Record<string, unknown>\n  topLevelTableName: string\n  versions?: boolean\n}\n\nexport const traverseFields = ({\n  _locales,\n  adapter,\n  currentArgs,\n  currentTableName,\n  depth,\n  fields,\n  joinQuery = {},\n  joins,\n  locale,\n  path,\n  tablePath,\n  topLevelArgs,\n  topLevelTableName,\n  versions,\n}: TraverseFieldArgs) => {\n  fields.forEach((field) => {\n    if (fieldIsVirtual(field)) {\n      return\n    }\n\n    // handle simple relationship\n    if (\n      depth > 0 &&\n      (field.type === 'upload' || field.type === 'relationship') &&\n      !field.hasMany &&\n      typeof field.relationTo === 'string'\n    ) {\n      if (field.localized) {\n        _locales.with[`${path}${field.name}`] = true\n      } else {\n        currentArgs.with[`${path}${field.name}`] = true\n      }\n    }\n\n    if (field.type === 'collapsible' || field.type === 'row') {\n      traverseFields({\n        _locales,\n        adapter,\n        currentArgs,\n        currentTableName,\n        depth,\n        fields: field.fields,\n        joinQuery,\n        joins,\n        path,\n        tablePath,\n        topLevelArgs,\n        topLevelTableName,\n      })\n\n      return\n    }\n\n    if (field.type === 'tabs') {\n      field.tabs.forEach((tab) => {\n        const tabPath = tabHasName(tab) ? `${path}${tab.name}_` : path\n        const tabTablePath = tabHasName(tab) ? `${tablePath}${toSnakeCase(tab.name)}_` : tablePath\n\n        traverseFields({\n          _locales,\n          adapter,\n          currentArgs,\n          currentTableName,\n          depth,\n          fields: tab.fields,\n          joinQuery,\n          joins,\n          path: tabPath,\n          tablePath: tabTablePath,\n          topLevelArgs,\n          topLevelTableName,\n          versions,\n        })\n      })\n\n      return\n    }\n\n    if (fieldAffectsData(field)) {\n      switch (field.type) {\n        case 'array': {\n          const withArray: Result = {\n            columns: {\n              _parentID: false,\n            },\n            orderBy: ({ _order }, { asc }) => [asc(_order)],\n            with: {},\n          }\n\n          const arrayTableName = adapter.tableNameMap.get(\n            `${currentTableName}_${tablePath}${toSnakeCase(field.name)}`,\n          )\n\n          const arrayTableNameWithLocales = `${arrayTableName}${adapter.localesSuffix}`\n\n          if (adapter.tables[arrayTableNameWithLocales]) {\n            withArray.with._locales = {\n              columns: {\n                id: false,\n                _parentID: false,\n              },\n              with: {},\n            }\n          }\n          currentArgs.with[`${path}${field.name}`] = withArray\n\n          traverseFields({\n            _locales: withArray.with._locales,\n            adapter,\n            currentArgs: withArray,\n            currentTableName: arrayTableName,\n            depth,\n            fields: field.fields,\n            joinQuery,\n            path: '',\n            tablePath: '',\n            topLevelArgs,\n            topLevelTableName,\n          })\n\n          break\n        }\n\n        case 'select': {\n          if (field.hasMany) {\n            const withSelect: Result = {\n              columns: {\n                id: false,\n                order: false,\n                parent: false,\n              },\n              orderBy: ({ order }, { asc }) => [asc(order)],\n            }\n\n            currentArgs.with[`${path}${field.name}`] = withSelect\n          }\n\n          break\n        }\n\n        case 'blocks':\n          field.blocks.forEach((block) => {\n            const blockKey = `_blocks_${block.slug}`\n\n            if (!topLevelArgs[blockKey]) {\n              const withBlock: Result = {\n                columns: {\n                  _parentID: false,\n                },\n                orderBy: ({ _order }, { asc }) => [asc(_order)],\n                with: {},\n              }\n\n              const tableName = adapter.tableNameMap.get(\n                `${topLevelTableName}_blocks_${toSnakeCase(block.slug)}`,\n              )\n\n              if (adapter.tables[`${tableName}${adapter.localesSuffix}`]) {\n                withBlock.with._locales = {\n                  with: {},\n                }\n              }\n              topLevelArgs.with[blockKey] = withBlock\n\n              traverseFields({\n                _locales: withBlock.with._locales,\n                adapter,\n                currentArgs: withBlock,\n                currentTableName: tableName,\n                depth,\n                fields: block.fields,\n                joinQuery,\n                path: '',\n                tablePath: '',\n                topLevelArgs,\n                topLevelTableName,\n              })\n            }\n          })\n\n          break\n\n        case 'group': {\n          traverseFields({\n            _locales,\n            adapter,\n            currentArgs,\n            currentTableName,\n            depth,\n            fields: field.fields,\n            joinQuery,\n            joins,\n            path: `${path}${field.name}_`,\n            tablePath: `${tablePath}${toSnakeCase(field.name)}_`,\n            topLevelArgs,\n            topLevelTableName,\n            versions,\n          })\n\n          break\n        }\n\n        case 'join': {\n          // when `joinsQuery` is false, do not join\n          if (joinQuery === false) {\n            break\n          }\n\n          const {\n            limit: limitArg = 10,\n            sort,\n            where,\n          } = joinQuery[`${path.replaceAll('_', '.')}${field.name}`] || {}\n          let limit = limitArg\n\n          if (limit !== 0) {\n            // get an additional document and slice it later to determine if there is a next page\n            limit += 1\n          }\n\n          const fields = adapter.payload.collections[field.collection].config.fields\n\n          const joinCollectionTableName = adapter.tableNameMap.get(toSnakeCase(field.collection))\n\n          const joins: BuildQueryJoinAliases = []\n\n          const buildQueryResult = buildQuery({\n            adapter,\n            fields,\n            joins,\n            locale,\n            sort,\n            tableName: joinCollectionTableName,\n            where,\n          })\n\n          let subQueryWhere = buildQueryResult.where\n          const orderBy = buildQueryResult.orderBy\n\n          let joinLocalesCollectionTableName: string | undefined\n\n          const currentIDColumn = versions\n            ? adapter.tables[currentTableName].parent\n            : adapter.tables[currentTableName].id\n\n          // Handle hasMany _rels table\n          if (field.hasMany) {\n            const joinRelsCollectionTableName = `${joinCollectionTableName}${adapter.relationshipsSuffix}`\n\n            if (field.localized) {\n              joinLocalesCollectionTableName = joinRelsCollectionTableName\n            }\n\n            let columnReferenceToCurrentID: string\n\n            if (versions) {\n              columnReferenceToCurrentID = `${topLevelTableName.replace('_', '').replace(new RegExp(`${adapter.versionsSuffix}$`), '')}_id`\n            } else {\n              columnReferenceToCurrentID = `${topLevelTableName}_id`\n            }\n\n            joins.push({\n              type: 'innerJoin',\n              condition: and(\n                eq(\n                  adapter.tables[joinRelsCollectionTableName].parent,\n                  adapter.tables[joinCollectionTableName].id,\n                ),\n                eq(\n                  sql.raw(`\"${joinRelsCollectionTableName}\".\"${columnReferenceToCurrentID}\"`),\n                  currentIDColumn,\n                ),\n                eq(adapter.tables[joinRelsCollectionTableName].path, field.on),\n              ),\n              table: adapter.tables[joinRelsCollectionTableName],\n            })\n          } else {\n            // Handle localized without hasMany\n\n            const foreignColumn = field.on.replaceAll('.', '_')\n\n            if (field.localized) {\n              joinLocalesCollectionTableName = `${joinCollectionTableName}${adapter.localesSuffix}`\n\n              joins.push({\n                type: 'innerJoin',\n                condition: and(\n                  eq(\n                    adapter.tables[joinLocalesCollectionTableName]._parentID,\n                    adapter.tables[joinCollectionTableName].id,\n                  ),\n                  eq(\n                    adapter.tables[joinLocalesCollectionTableName][foreignColumn],\n                    currentIDColumn,\n                  ),\n                ),\n                table: adapter.tables[joinLocalesCollectionTableName],\n              })\n              // Handle without localized and without hasMany, just a condition append to where. With localized the inner join handles eq.\n            } else {\n              const constraint = eq(\n                adapter.tables[joinCollectionTableName][foreignColumn],\n                currentIDColumn,\n              )\n\n              if (subQueryWhere) {\n                subQueryWhere = and(subQueryWhere, constraint)\n              } else {\n                subQueryWhere = constraint\n              }\n            }\n          }\n\n          const chainedMethods: ChainedMethods = []\n\n          joins.forEach(({ type, condition, table }) => {\n            chainedMethods.push({\n              args: [table, condition],\n              method: type ?? 'leftJoin',\n            })\n          })\n\n          if (limit !== 0) {\n            chainedMethods.push({\n              args: [limit],\n              method: 'limit',\n            })\n          }\n\n          const db = adapter.drizzle as LibSQLDatabase\n\n          const subQuery = chainMethods({\n            methods: chainedMethods,\n            query: db\n              .select({\n                id: adapter.tables[joinCollectionTableName].id,\n                ...(joinLocalesCollectionTableName && {\n                  locale:\n                    adapter.tables[joinLocalesCollectionTableName].locale ||\n                    adapter.tables[joinLocalesCollectionTableName]._locale,\n                }),\n              })\n              .from(adapter.tables[joinCollectionTableName])\n              .where(subQueryWhere)\n              .orderBy(() => orderBy.map(({ column, order }) => order(column))),\n          })\n\n          const columnName = `${path.replaceAll('.', '_')}${field.name}`\n\n          const jsonObjectSelect = field.localized\n            ? sql.raw(\n                `'_parentID', \"id\", '_locale', \"${adapter.tables[joinLocalesCollectionTableName].locale ? 'locale' : '_locale'}\"`,\n              )\n            : sql.raw(`'id', \"id\"`)\n\n          if (adapter.name === 'sqlite') {\n            currentArgs.extras[columnName] = sql`\n              COALESCE((\n                SELECT json_group_array(json_object(${jsonObjectSelect}))\n                FROM (\n                  ${subQuery}\n                ) AS ${sql.raw(`${columnName}_sub`)}\n              ), '[]')\n            `.as(columnName)\n          } else {\n            currentArgs.extras[columnName] = sql`\n              COALESCE((\n                SELECT json_agg(json_build_object(${jsonObjectSelect}))\n                FROM (\n                  ${subQuery}\n                ) AS ${sql.raw(`${columnName}_sub`)}\n              ), '[]'::json)\n            `.as(columnName)\n          }\n\n          break\n        }\n\n        default: {\n          break\n        }\n      }\n    }\n  })\n\n  return topLevelArgs\n}\n"],"names":["and","eq","sql","fieldAffectsData","fieldIsVirtual","tabHasName","toSnakeCase","buildQuery","chainMethods","traverseFields","_locales","adapter","currentArgs","currentTableName","depth","fields","joinQuery","joins","locale","path","tablePath","topLevelArgs","topLevelTableName","versions","forEach","field","type","hasMany","relationTo","localized","with","name","tabs","tab","tabPath","tabTablePath","withArray","columns","_parentID","orderBy","_order","asc","arrayTableName","tableNameMap","get","arrayTableNameWithLocales","localesSuffix","tables","id","withSelect","order","parent","blocks","block","blockKey","slug","withBlock","tableName","limit","limitArg","sort","where","replaceAll","payload","collections","collection","config","joinCollectionTableName","buildQueryResult","subQueryWhere","joinLocalesCollectionTableName","currentIDColumn","joinRelsCollectionTableName","relationshipsSuffix","columnReferenceToCurrentID","replace","RegExp","versionsSuffix","push","condition","raw","on","table","foreignColumn","constraint","chainedMethods","args","method","db","drizzle","subQuery","methods","query","select","_locale","from","map","column","columnName","jsonObjectSelect","extras","as"],"mappings":"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"}},
    {"offset": {"line": 1635, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1641, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/@payloadcms/db-postgres/node_modules/@payloadcms/drizzle/src/find/buildFindManyArgs.ts"],"sourcesContent":["import type { DBQueryConfig } from 'drizzle-orm'\nimport type { Field, JoinQuery } from 'payload'\n\nimport type { BuildQueryJoinAliases, DrizzleAdapter } from '../types.js'\n\nimport { traverseFields } from './traverseFields.js'\n\ntype BuildFindQueryArgs = {\n  adapter: DrizzleAdapter\n  depth: number\n  fields: Field[]\n  joinQuery?: JoinQuery\n  /**\n   * The joins array will be mutated by pushing any joins needed for the where queries of join field joins\n   */\n  joins?: BuildQueryJoinAliases\n  locale?: string\n  tableName: string\n  versions?: boolean\n}\n\nexport type Result = {\n  with?: {\n    _locales?: DBQueryConfig<'many', true, any, any>\n  } & DBQueryConfig<'many', true, any, any>\n} & DBQueryConfig<'many', true, any, any>\n\n// Generate the Drizzle query for findMany based on\n// a collection field structure\nexport const buildFindManyArgs = ({\n  adapter,\n  depth,\n  fields,\n  joinQuery,\n  joins = [],\n  locale,\n  tableName,\n  versions,\n}: BuildFindQueryArgs): Record<string, unknown> => {\n  const result: Result = {\n    extras: {},\n    with: {},\n  }\n\n  const _locales: Result = {\n    columns: {\n      id: false,\n      _parentID: false,\n    },\n    extras: {},\n    with: {},\n  }\n\n  if (adapter.tables[`${tableName}_texts`]) {\n    result.with._texts = {\n      columns: {\n        id: false,\n        parent: false,\n      },\n      orderBy: ({ order }, { asc: ASC }) => [ASC(order)],\n    }\n  }\n\n  if (adapter.tables[`${tableName}_numbers`]) {\n    result.with._numbers = {\n      columns: {\n        id: false,\n        parent: false,\n      },\n      orderBy: ({ order }, { asc: ASC }) => [ASC(order)],\n    }\n  }\n\n  if (adapter.tables[`${tableName}${adapter.relationshipsSuffix}`]) {\n    result.with._rels = {\n      columns: {\n        id: false,\n        parent: false,\n      },\n      orderBy: ({ order }, { asc: ASC }) => [ASC(order)],\n    }\n  }\n\n  if (adapter.tables[`${tableName}${adapter.localesSuffix}`]) {\n    result.with._locales = _locales\n  }\n\n  traverseFields({\n    _locales,\n    adapter,\n    currentArgs: result,\n    currentTableName: tableName,\n    depth,\n    fields,\n    joinQuery,\n    joins,\n    locale,\n    path: '',\n    tablePath: '',\n    topLevelArgs: result,\n    topLevelTableName: tableName,\n    versions,\n  })\n\n  return result\n}\n"],"names":["traverseFields","buildFindManyArgs","adapter","depth","fields","joinQuery","joins","locale","tableName","versions","result","extras","with","_locales","columns","id","_parentID","tables","_texts","parent","orderBy","order","asc","ASC","_numbers","relationshipsSuffix","_rels","localesSuffix","currentArgs","currentTableName","path","tablePath","topLevelArgs","topLevelTableName"],"mappings":";;;AAKA,SAASA,cAAc,QAAQ,sBAAqB;;AAwB7C,MAAMC,oBAAoB,CAAC,EAChCC,OAAO,EACPC,KAAK,EACLC,MAAM,EACNC,SAAS,EACTC,QAAQ,EAAE,EACVC,MAAM,EACNC,SAAS,EACTC,QAAQ,EACW;IACnB,MAAMC,SAAiB;QACrBC,QAAQ,CAAC;QACTC,MAAM,CAAC;IACT;IAEA,MAAMC,WAAmB;QACvBC,SAAS;YACPC,IAAI;YACJC,WAAW;QACb;QACAL,QAAQ,CAAC;QACTC,MAAM,CAAC;IACT;IAEA,IAAIV,QAAQe,MAAM,CAAC,CAAC,EAAET,UAAU,MAAM,CAAC,CAAC,EAAE;QACxCE,OAAOE,IAAI,CAACM,MAAM,GAAG;YACnBJ,SAAS;gBACPC,IAAI;gBACJI,QAAQ;YACV;YACAC,SAAS,CAAC,EAAEC,KAAK,EAAE,EAAE,EAAEC,KAAKC,GAAG,EAAE,GAAK;oBAACA,IAAIF;iBAAO;QACpD;IACF;IAEA,IAAInB,QAAQe,MAAM,CAAC,CAAC,EAAET,UAAU,QAAQ,CAAC,CAAC,EAAE;QAC1CE,OAAOE,IAAI,CAACY,QAAQ,GAAG;YACrBV,SAAS;gBACPC,IAAI;gBACJI,QAAQ;YACV;YACAC,SAAS,CAAC,EAAEC,KAAK,EAAE,EAAE,EAAEC,KAAKC,GAAG,EAAE,GAAK;oBAACA,IAAIF;iBAAO;QACpD;IACF;IAEA,IAAInB,QAAQe,MAAM,CAAC,CAAC,EAAET,UAAU,EAAEN,QAAQuB,mBAAmB,CAAC,CAAC,CAAC,EAAE;QAChEf,OAAOE,IAAI,CAACc,KAAK,GAAG;YAClBZ,SAAS;gBACPC,IAAI;gBACJI,QAAQ;YACV;YACAC,SAAS,CAAC,EAAEC,KAAK,EAAE,EAAE,EAAEC,KAAKC,GAAG,EAAE,GAAK;oBAACA,IAAIF;iBAAO;QACpD;IACF;IAEA,IAAInB,QAAQe,MAAM,CAAC,CAAC,EAAET,UAAU,EAAEN,QAAQyB,aAAa,CAAC,CAAC,CAAC,EAAE;QAC1DjB,OAAOE,IAAI,CAACC,QAAQ,GAAGA;IACzB;oOAEAb,iBAAAA,EAAe;QACba;QACAX;QACA0B,aAAalB;QACbmB,kBAAkBrB;QAClBL;QACAC;QACAC;QACAC;QACAC;QACAuB,MAAM;QACNC,WAAW;QACXC,cAActB;QACduB,mBAAmBzB;QACnBC;IACF;IAEA,OAAOC;AACT,EAAC"}},
    {"offset": {"line": 1713, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1719, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/@payloadcms/db-postgres/node_modules/@payloadcms/drizzle/src/utilities/createBlocksMap.ts"],"sourcesContent":["export type BlocksMap = {\n  [path: string]: Record<string, unknown>[]\n}\n\nexport const createBlocksMap = (data: Record<string, unknown>): BlocksMap => {\n  const blocksMap: BlocksMap = {}\n\n  Object.entries(data).forEach(([key, rows]) => {\n    if (key.startsWith('_blocks_') && Array.isArray(rows)) {\n      const blockType = key.replace('_blocks_', '')\n\n      rows.forEach((row) => {\n        if ('_path' in row) {\n          if (!(row._path in blocksMap)) {\n            blocksMap[row._path] = []\n          }\n\n          row.blockType = blockType\n          blocksMap[row._path].push(row)\n\n          delete row._path\n        }\n      })\n\n      delete data[key]\n    }\n  })\n\n  Object.entries(blocksMap).reduce((sortedBlocksMap, [path, blocks]) => {\n    sortedBlocksMap[path] = blocks.sort((a, b) => {\n      if (typeof a._order === 'number' && typeof b._order === 'number') {\n        return a._order - b._order\n      }\n\n      return 0\n    })\n\n    return sortedBlocksMap\n  }, {})\n\n  return blocksMap\n}\n"],"names":["createBlocksMap","data","blocksMap","Object","entries","forEach","key","rows","startsWith","Array","isArray","blockType","replace","row","_path","push","reduce","sortedBlocksMap","path","blocks","sort","a","b","_order"],"mappings":";;;AAIO,MAAMA,kBAAkB,CAACC;IAC9B,MAAMC,YAAuB,CAAC;IAE9BC,OAAOC,OAAO,CAACH,MAAMI,OAAO,CAAC,CAAC,CAACC,KAAKC,KAAK;QACvC,IAAID,IAAIE,UAAU,CAAC,eAAeC,MAAMC,OAAO,CAACH,OAAO;YACrD,MAAMI,YAAYL,IAAIM,OAAO,CAAC,YAAY;YAE1CL,KAAKF,OAAO,CAAC,CAACQ;gBACZ,IAAI,WAAWA,KAAK;oBAClB,IAAI,CAAEA,CAAAA,IAAIC,KAAK,IAAIZ,SAAQ,GAAI;wBAC7BA,SAAS,CAACW,IAAIC,KAAK,CAAC,GAAG,EAAE;oBAC3B;oBAEAD,IAAIF,SAAS,GAAGA;oBAChBT,SAAS,CAACW,IAAIC,KAAK,CAAC,CAACC,IAAI,CAACF;oBAE1B,OAAOA,IAAIC,KAAK;gBAClB;YACF;YAEA,OAAOb,IAAI,CAACK,IAAI;QAClB;IACF;IAEAH,OAAOC,OAAO,CAACF,WAAWc,MAAM,CAAC,CAACC,iBAAiB,CAACC,MAAMC,OAAO;QAC/DF,eAAe,CAACC,KAAK,GAAGC,OAAOC,IAAI,CAAC,CAACC,GAAGC;YACtC,IAAI,OAAOD,EAAEE,MAAM,KAAK,YAAY,OAAOD,EAAEC,MAAM,KAAK,UAAU;gBAChE,OAAOF,EAAEE,MAAM,GAAGD,EAAEC,MAAM;YAC5B;YAEA,OAAO;QACT;QAEA,OAAON;IACT,GAAG,CAAC;IAEJ,OAAOf;AACT,EAAC"}},
    {"offset": {"line": 1751, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1757, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/@payloadcms/db-postgres/node_modules/@payloadcms/drizzle/src/utilities/createRelationshipMap.ts"],"sourcesContent":["// Flatten rows to object with path keys\n// for easier retrieval\nexport const createPathMap = (rows: unknown): Record<string, Record<string, unknown>[]> => {\n  let rowsByPath = {}\n\n  if (Array.isArray(rows)) {\n    rowsByPath = rows.reduce((res, row) => {\n      const formattedRow = {\n        ...row,\n      }\n\n      delete formattedRow.path\n\n      if (!res[row.path]) {\n        res[row.path] = []\n      }\n      res[row.path].push(row)\n\n      return res\n    }, {})\n  }\n\n  return rowsByPath\n}\n"],"names":["createPathMap","rows","rowsByPath","Array","isArray","reduce","res","row","formattedRow","path","push"],"mappings":"AAAA,wCAAwC;AACxC,uBAAuB;;;;AAChB,MAAMA,gBAAgB,CAACC;IAC5B,IAAIC,aAAa,CAAC;IAElB,IAAIC,MAAMC,OAAO,CAACH,OAAO;QACvBC,aAAaD,KAAKI,MAAM,CAAC,CAACC,KAAKC;YAC7B,MAAMC,eAAe;gBACnB,GAAGD,GAAG;YACR;YAEA,OAAOC,aAAaC,IAAI;YAExB,IAAI,CAACH,GAAG,CAACC,IAAIE,IAAI,CAAC,EAAE;gBAClBH,GAAG,CAACC,IAAIE,IAAI,CAAC,GAAG,EAAE;YACpB;YACAH,GAAG,CAACC,IAAIE,IAAI,CAAC,CAACC,IAAI,CAACH;YAEnB,OAAOD;QACT,GAAG,CAAC;IACN;IAEA,OAAOJ;AACT,EAAC"}},
    {"offset": {"line": 1779, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1785, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/@payloadcms/db-postgres/node_modules/@payloadcms/drizzle/src/transform/read/hasManyNumber.ts"],"sourcesContent":["import type { NumberField } from 'payload'\n\ntype Args = {\n  field: NumberField\n  locale?: string\n  numberRows: Record<string, unknown>[]\n  ref: Record<string, unknown>\n  withinArrayOrBlockLocale?: string\n}\n\nexport const transformHasManyNumber = ({\n  field,\n  locale,\n  numberRows,\n  ref,\n  withinArrayOrBlockLocale,\n}: Args) => {\n  let result: unknown[]\n\n  if (withinArrayOrBlockLocale) {\n    result = numberRows.reduce((acc, { locale, number }) => {\n      if (locale === withinArrayOrBlockLocale) {\n        acc.push(number)\n      }\n\n      return acc\n    }, [])\n  } else {\n    result = numberRows.map(({ number }) => number)\n  }\n\n  if (locale) {\n    ref[field.name][locale] = result\n  } else {\n    ref[field.name] = result\n  }\n}\n"],"names":["transformHasManyNumber","field","locale","numberRows","ref","withinArrayOrBlockLocale","result","reduce","acc","number","push","map","name"],"mappings":";;;AAUO,MAAMA,yBAAyB,CAAC,EACrCC,KAAK,EACLC,MAAM,EACNC,UAAU,EACVC,GAAG,EACHC,wBAAwB,EACnB;IACL,IAAIC;IAEJ,IAAID,0BAA0B;QAC5BC,SAASH,WAAWI,MAAM,CAAC,CAACC,KAAK,EAAEN,MAAM,EAAEO,MAAM,EAAE;YACjD,IAAIP,WAAWG,0BAA0B;gBACvCG,IAAIE,IAAI,CAACD;YACX;YAEA,OAAOD;QACT,GAAG,EAAE;IACP,OAAO;QACLF,SAASH,WAAWQ,GAAG,CAAC,CAAC,EAAEF,MAAM,EAAE,GAAKA;IAC1C;IAEA,IAAIP,QAAQ;QACVE,GAAG,CAACH,MAAMW,IAAI,CAAC,CAACV,OAAO,GAAGI;IAC5B,OAAO;QACLF,GAAG,CAACH,MAAMW,IAAI,CAAC,GAAGN;IACpB;AACF,EAAC"}},
    {"offset": {"line": 1806, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1812, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/@payloadcms/db-postgres/node_modules/@payloadcms/drizzle/src/transform/read/hasManyText.ts"],"sourcesContent":["import type { TextField } from 'payload'\n\ntype Args = {\n  field: TextField\n  locale?: string\n  ref: Record<string, unknown>\n  textRows: Record<string, unknown>[]\n  withinArrayOrBlockLocale?: string\n}\n\nexport const transformHasManyText = ({\n  field,\n  locale,\n  ref,\n  textRows,\n  withinArrayOrBlockLocale,\n}: Args) => {\n  let result: unknown[]\n\n  if (withinArrayOrBlockLocale) {\n    result = textRows.reduce((acc, { locale, text }) => {\n      if (locale === withinArrayOrBlockLocale) {\n        acc.push(text)\n      }\n\n      return acc\n    }, [])\n  } else {\n    result = textRows.map(({ text }) => text)\n  }\n\n  if (locale) {\n    ref[field.name][locale] = result\n  } else {\n    ref[field.name] = result\n  }\n}\n"],"names":["transformHasManyText","field","locale","ref","textRows","withinArrayOrBlockLocale","result","reduce","acc","text","push","map","name"],"mappings":";;;AAUO,MAAMA,uBAAuB,CAAC,EACnCC,KAAK,EACLC,MAAM,EACNC,GAAG,EACHC,QAAQ,EACRC,wBAAwB,EACnB;IACL,IAAIC;IAEJ,IAAID,0BAA0B;QAC5BC,SAASF,SAASG,MAAM,CAAC,CAACC,KAAK,EAAEN,MAAM,EAAEO,IAAI,EAAE;YAC7C,IAAIP,WAAWG,0BAA0B;gBACvCG,IAAIE,IAAI,CAACD;YACX;YAEA,OAAOD;QACT,GAAG,EAAE;IACP,OAAO;QACLF,SAASF,SAASO,GAAG,CAAC,CAAC,EAAEF,IAAI,EAAE,GAAKA;IACtC;IAEA,IAAIP,QAAQ;QACVC,GAAG,CAACF,MAAMW,IAAI,CAAC,CAACV,OAAO,GAAGI;IAC5B,OAAO;QACLH,GAAG,CAACF,MAAMW,IAAI,CAAC,GAAGN;IACpB;AACF,EAAC"}},
    {"offset": {"line": 1833, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1839, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/@payloadcms/db-postgres/node_modules/@payloadcms/drizzle/src/transform/read/relationship.ts"],"sourcesContent":["import type { RelationshipField, UploadField } from 'payload'\n\ntype Args = {\n  field: RelationshipField | UploadField\n  locale?: string\n  ref: Record<string, unknown>\n  relations: Record<string, unknown>[]\n  withinArrayOrBlockLocale?: string\n}\n\nexport const transformRelationship = ({\n  field,\n  locale,\n  ref,\n  relations,\n  withinArrayOrBlockLocale,\n}: Args) => {\n  let result: unknown\n\n  if (!('hasMany' in field) || field.hasMany === false) {\n    let relation = relations[0]\n\n    if (withinArrayOrBlockLocale) {\n      relation = relations.find((rel) => rel.locale === withinArrayOrBlockLocale)\n    }\n\n    if (relation) {\n      // Handle hasOne Poly\n      if (Array.isArray(field.relationTo)) {\n        const matchedRelation = Object.entries(relation).find(([key, val]) => {\n          return val !== null && !['id', 'locale', 'order', 'parent', 'path'].includes(key)\n        })\n\n        if (matchedRelation) {\n          const relationTo = matchedRelation[0].replace('ID', '')\n\n          result = {\n            relationTo,\n            value: matchedRelation[1],\n          }\n        }\n      }\n    }\n  } else {\n    const transformedRelations = []\n\n    relations.forEach((relation) => {\n      let matchedLocale = true\n\n      if (withinArrayOrBlockLocale) {\n        matchedLocale = relation.locale === withinArrayOrBlockLocale\n      }\n\n      // Handle hasMany\n      if (!Array.isArray(field.relationTo)) {\n        const relatedData = relation[`${field.relationTo}ID`]\n\n        if (relatedData && matchedLocale) {\n          transformedRelations.push(relatedData)\n        }\n      } else {\n        // Handle hasMany Poly\n        const matchedRelation = Object.entries(relation).find(\n          ([key, val]) =>\n            val !== null &&\n            !['id', 'locale', 'order', 'parent', 'path'].includes(key) &&\n            matchedLocale,\n        )\n\n        if (matchedRelation) {\n          const relationTo = matchedRelation[0].replace('ID', '')\n\n          transformedRelations.push({\n            relationTo,\n            value: matchedRelation[1],\n          })\n        }\n      }\n    })\n\n    result = transformedRelations\n  }\n\n  if (locale) {\n    ref[field.name][locale] = result\n  } else {\n    ref[field.name] = result\n  }\n}\n"],"names":["transformRelationship","field","locale","ref","relations","withinArrayOrBlockLocale","result","hasMany","relation","find","rel","Array","isArray","relationTo","matchedRelation","Object","entries","key","val","includes","replace","value","transformedRelations","forEach","matchedLocale","relatedData","push","name"],"mappings":";;;AAUO,MAAMA,wBAAwB,CAAC,EACpCC,KAAK,EACLC,MAAM,EACNC,GAAG,EACHC,SAAS,EACTC,wBAAwB,EACnB;IACL,IAAIC;IAEJ,IAAI,CAAE,CAAA,aAAaL,KAAI,KAAMA,MAAMM,OAAO,KAAK,OAAO;QACpD,IAAIC,WAAWJ,SAAS,CAAC,EAAE;QAE3B,IAAIC,0BAA0B;YAC5BG,WAAWJ,UAAUK,IAAI,CAAC,CAACC,MAAQA,IAAIR,MAAM,KAAKG;QACpD;QAEA,IAAIG,UAAU;YACZ,qBAAqB;YACrB,IAAIG,MAAMC,OAAO,CAACX,MAAMY,UAAU,GAAG;gBACnC,MAAMC,kBAAkBC,OAAOC,OAAO,CAACR,UAAUC,IAAI,CAAC,CAAC,CAACQ,KAAKC,IAAI;oBAC/D,OAAOA,QAAQ,QAAQ,CAAC;wBAAC;wBAAM;wBAAU;wBAAS;wBAAU;qBAAO,CAACC,QAAQ,CAACF;gBAC/E;gBAEA,IAAIH,iBAAiB;oBACnB,MAAMD,aAAaC,eAAe,CAAC,EAAE,CAACM,OAAO,CAAC,MAAM;oBAEpDd,SAAS;wBACPO;wBACAQ,OAAOP,eAAe,CAAC,EAAE;oBAC3B;gBACF;YACF;QACF;IACF,OAAO;QACL,MAAMQ,uBAAuB,EAAE;QAE/BlB,UAAUmB,OAAO,CAAC,CAACf;YACjB,IAAIgB,gBAAgB;YAEpB,IAAInB,0BAA0B;gBAC5BmB,gBAAgBhB,SAASN,MAAM,KAAKG;YACtC;YAEA,iBAAiB;YACjB,IAAI,CAACM,MAAMC,OAAO,CAACX,MAAMY,UAAU,GAAG;gBACpC,MAAMY,cAAcjB,QAAQ,CAAC,CAAC,EAAEP,MAAMY,UAAU,CAAC,EAAE,CAAC,CAAC;gBAErD,IAAIY,eAAeD,eAAe;oBAChCF,qBAAqBI,IAAI,CAACD;gBAC5B;YACF,OAAO;gBACL,sBAAsB;gBACtB,MAAMX,kBAAkBC,OAAOC,OAAO,CAACR,UAAUC,IAAI,CACnD,CAAC,CAACQ,KAAKC,IAAI,GACTA,QAAQ,QACR,CAAC;wBAAC;wBAAM;wBAAU;wBAAS;wBAAU;qBAAO,CAACC,QAAQ,CAACF,QACtDO;gBAGJ,IAAIV,iBAAiB;oBACnB,MAAMD,aAAaC,eAAe,CAAC,EAAE,CAACM,OAAO,CAAC,MAAM;oBAEpDE,qBAAqBI,IAAI,CAAC;wBACxBb;wBACAQ,OAAOP,eAAe,CAAC,EAAE;oBAC3B;gBACF;YACF;QACF;QAEAR,SAASgB;IACX;IAEA,IAAIpB,QAAQ;QACVC,GAAG,CAACF,MAAM0B,IAAI,CAAC,CAACzB,OAAO,GAAGI;IAC5B,OAAO;QACLH,GAAG,CAACF,MAAM0B,IAAI,CAAC,GAAGrB;IACpB;AACF,EAAC"}},
    {"offset": {"line": 1909, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1915, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/@payloadcms/db-postgres/node_modules/@payloadcms/drizzle/src/transform/read/traverseFields.ts"],"sourcesContent":["import type { Field, JoinQuery, SanitizedConfig, TabAsField } from 'payload'\n\nimport { fieldAffectsData, fieldIsVirtual } from 'payload/shared'\n\nimport type { DrizzleAdapter } from '../../types.js'\nimport type { BlocksMap } from '../../utilities/createBlocksMap.js'\n\nimport { transformHasManyNumber } from './hasManyNumber.js'\nimport { transformHasManyText } from './hasManyText.js'\nimport { transformRelationship } from './relationship.js'\n\ntype TraverseFieldsArgs = {\n  /**\n   * The DB adapter\n   */\n  adapter: DrizzleAdapter\n  /**\n   * Pre-formatted blocks map\n   */\n  blocks: BlocksMap\n  /**\n   * The full Payload config\n   */\n  config: SanitizedConfig\n  /**\n   * The data reference to be mutated within this recursive function\n   */\n  dataRef: Record<string, unknown>\n  /**\n   * Data that needs to be removed from the result after all fields have populated\n   */\n  deletions: (() => void)[]\n  /**\n   * Column prefix can be built up by group and named tab fields\n   */\n  fieldPrefix: string\n  /**\n   * An array of Payload fields to traverse\n   */\n  fields: (Field | TabAsField)[]\n  /**\n   *\n   */\n  joinQuery?: JoinQuery\n  /**\n   * All hasMany number fields, as returned by Drizzle, keyed on an object by field path\n   */\n  numbers: Record<string, Record<string, unknown>[]>\n  /**\n   * The current field path (in dot notation), used to merge in relationships\n   */\n  path: string\n  /**\n   * All related documents, as returned by Drizzle, keyed on an object by field path\n   */\n  relationships: Record<string, Record<string, unknown>[]>\n  /**\n   * Data structure representing the nearest table from db\n   */\n  table: Record<string, unknown>\n  /**\n   * All hasMany text fields, as returned by Drizzle, keyed on an object by field path\n   */\n  texts: Record<string, Record<string, unknown>[]>\n  /**\n   * Set to a locale if this group of fields is within a localized array or block.\n   */\n  withinArrayOrBlockLocale?: string\n}\n\n// Traverse fields recursively, transforming data\n// for each field type into required Payload shape\nexport const traverseFields = <T extends Record<string, unknown>>({\n  adapter,\n  blocks,\n  config,\n  dataRef,\n  deletions,\n  fieldPrefix,\n  fields,\n  joinQuery,\n  numbers,\n  path,\n  relationships,\n  table,\n  texts,\n  withinArrayOrBlockLocale,\n}: TraverseFieldsArgs): T => {\n  const sanitizedPath = path ? `${path}.` : path\n\n  const formatted = fields.reduce((result, field) => {\n    if (field.type === 'tabs') {\n      traverseFields({\n        adapter,\n        blocks,\n        config,\n        dataRef,\n        deletions,\n        fieldPrefix,\n        fields: field.tabs.map((tab) => ({ ...tab, type: 'tab' })),\n        joinQuery,\n        numbers,\n        path,\n        relationships,\n        table,\n        texts,\n        withinArrayOrBlockLocale,\n      })\n    }\n\n    if (\n      field.type === 'collapsible' ||\n      field.type === 'row' ||\n      (field.type === 'tab' && !('name' in field))\n    ) {\n      traverseFields({\n        adapter,\n        blocks,\n        config,\n        dataRef,\n        deletions,\n        fieldPrefix,\n        fields: field.fields,\n        joinQuery,\n        numbers,\n        path,\n        relationships,\n        table,\n        texts,\n        withinArrayOrBlockLocale,\n      })\n    }\n\n    if (fieldAffectsData(field)) {\n      if (fieldIsVirtual(field)) {\n        return result\n      }\n\n      const fieldName = `${fieldPrefix || ''}${field.name}`\n      let fieldData = table[fieldName]\n      const localizedFieldData = {}\n      const valuesToTransform: {\n        ref: Record<string, unknown>\n        table: Record<string, unknown>\n      }[] = []\n\n      if (fieldPrefix) {\n        deletions.push(() => delete table[fieldName])\n      }\n\n      if (field.type === 'array') {\n        if (Array.isArray(fieldData)) {\n          if (field.localized) {\n            result[field.name] = fieldData.reduce((arrayResult, row) => {\n              if (typeof row._locale === 'string') {\n                if (!arrayResult[row._locale]) {\n                  arrayResult[row._locale] = []\n                }\n                const locale = row._locale\n                const data = {}\n                delete row._locale\n                if (row._uuid) {\n                  row.id = row._uuid\n                  delete row._uuid\n                }\n\n                const rowResult = traverseFields<T>({\n                  adapter,\n                  blocks,\n                  config,\n                  dataRef: data,\n                  deletions,\n                  fieldPrefix: '',\n                  fields: field.fields,\n                  numbers,\n                  path: `${sanitizedPath}${field.name}.${row._order - 1}`,\n                  relationships,\n                  table: row,\n                  texts,\n                  withinArrayOrBlockLocale: locale,\n                })\n\n                if ('_order' in rowResult) {\n                  delete rowResult._order\n                }\n\n                arrayResult[locale].push(rowResult)\n              }\n\n              return arrayResult\n            }, {})\n          } else {\n            result[field.name] = fieldData.reduce((acc, row, i) => {\n              if (row._uuid) {\n                row.id = row._uuid\n                delete row._uuid\n              }\n\n              if ('_order' in row) {\n                delete row._order\n              }\n\n              if (\n                !withinArrayOrBlockLocale ||\n                (withinArrayOrBlockLocale && withinArrayOrBlockLocale === row._locale)\n              ) {\n                if (row._locale) {\n                  delete row._locale\n                }\n\n                acc.push(\n                  traverseFields<T>({\n                    adapter,\n                    blocks,\n                    config,\n                    dataRef: row,\n                    deletions,\n                    fieldPrefix: '',\n                    fields: field.fields,\n                    numbers,\n                    path: `${sanitizedPath}${field.name}.${i}`,\n                    relationships,\n                    table: row,\n                    texts,\n                    withinArrayOrBlockLocale,\n                  }),\n                )\n              }\n\n              return acc\n            }, [])\n          }\n        }\n\n        return result\n      }\n\n      if (field.type === 'blocks') {\n        const blockFieldPath = `${sanitizedPath}${field.name}`\n        const blocksByPath = blocks[blockFieldPath]\n\n        if (Array.isArray(blocksByPath)) {\n          if (field.localized) {\n            result[field.name] = {}\n\n            blocksByPath.forEach((row) => {\n              if (row._uuid) {\n                row.id = row._uuid\n                delete row._uuid\n              }\n              if (typeof row._locale === 'string') {\n                if (!result[field.name][row._locale]) {\n                  result[field.name][row._locale] = []\n                }\n                result[field.name][row._locale].push(row)\n                delete row._locale\n              }\n            })\n\n            Object.entries(result[field.name]).forEach(([locale, localizedBlocks]) => {\n              result[field.name][locale] = localizedBlocks.map((row) => {\n                const block = field.blocks.find(({ slug }) => slug === row.blockType)\n\n                if (block) {\n                  const blockResult = traverseFields<T>({\n                    adapter,\n                    blocks,\n                    config,\n                    dataRef: row,\n                    deletions,\n                    fieldPrefix: '',\n                    fields: block.fields,\n                    numbers,\n                    path: `${blockFieldPath}.${row._order - 1}`,\n                    relationships,\n                    table: row,\n                    texts,\n                    withinArrayOrBlockLocale: locale,\n                  })\n\n                  delete blockResult._order\n                  return blockResult\n                }\n\n                return {}\n              })\n            })\n          } else {\n            // Add locale-specific index to have a proper blockFieldPath for current locale\n            // because blocks can be in the same array for different locales!\n            if (withinArrayOrBlockLocale && config.localization) {\n              for (const locale of config.localization.localeCodes) {\n                let localeIndex = 0\n\n                for (let i = 0; i < blocksByPath.length; i++) {\n                  const row = blocksByPath[i]\n                  if (row._locale === locale) {\n                    row._index = localeIndex\n                    localeIndex++\n                  }\n                }\n              }\n            }\n\n            result[field.name] = blocksByPath.reduce((acc, row, i) => {\n              delete row._order\n              if (row._uuid) {\n                row.id = row._uuid\n                delete row._uuid\n              }\n              const block = field.blocks.find(({ slug }) => slug === row.blockType)\n\n              if (block) {\n                if (\n                  !withinArrayOrBlockLocale ||\n                  (withinArrayOrBlockLocale && withinArrayOrBlockLocale === row._locale)\n                ) {\n                  if (row._locale) {\n                    delete row._locale\n                  }\n                  if (typeof row._index === 'number') {\n                    i = row._index\n                    delete row._index\n                  }\n\n                  acc.push(\n                    traverseFields<T>({\n                      adapter,\n                      blocks,\n                      config,\n                      dataRef: row,\n                      deletions,\n                      fieldPrefix: '',\n                      fields: block.fields,\n                      numbers,\n                      path: `${blockFieldPath}.${i}`,\n                      relationships,\n                      table: row,\n                      texts,\n                      withinArrayOrBlockLocale,\n                    }),\n                  )\n\n                  return acc\n                }\n              } else {\n                acc.push({})\n              }\n\n              return acc\n            }, [])\n          }\n        }\n\n        return result\n      }\n\n      if (field.type === 'relationship' || field.type === 'upload') {\n        if (typeof field.relationTo === 'string' && !('hasMany' in field && field.hasMany)) {\n          if (\n            field.localized &&\n            config.localization &&\n            config.localization.locales &&\n            Array.isArray(table?._locales)\n          ) {\n            table._locales.forEach((localeRow) => {\n              result[field.name] = { [localeRow._locale]: localeRow[fieldName] }\n            })\n          } else {\n            valuesToTransform.push({ ref: result, table })\n          }\n        } else {\n          const relationPathMatch = relationships[`${sanitizedPath}${field.name}`]\n\n          if (!relationPathMatch) {\n            if ('hasMany' in field && field.hasMany) {\n              if (field.localized && config.localization && config.localization.locales) {\n                result[field.name] = {\n                  [config.localization.defaultLocale]: [],\n                }\n              } else {\n                result[field.name] = []\n              }\n            }\n\n            return result\n          }\n\n          if (field.localized) {\n            result[field.name] = {}\n            const relationsByLocale: Record<string, Record<string, unknown>[]> = {}\n\n            relationPathMatch.forEach((row) => {\n              if (typeof row.locale === 'string') {\n                if (!relationsByLocale[row.locale]) {\n                  relationsByLocale[row.locale] = []\n                }\n                relationsByLocale[row.locale].push(row)\n              }\n            })\n\n            Object.entries(relationsByLocale).forEach(([locale, relations]) => {\n              transformRelationship({\n                field,\n                locale,\n                ref: result,\n                relations,\n              })\n            })\n          } else {\n            transformRelationship({\n              field,\n              ref: result,\n              relations: relationPathMatch,\n              withinArrayOrBlockLocale,\n            })\n          }\n          return result\n        }\n      }\n\n      if (field.type === 'join') {\n        const { limit = 10 } = joinQuery?.[`${fieldPrefix.replaceAll('_', '.')}${field.name}`] || {}\n\n        // raw hasMany results from SQLite\n        if (typeof fieldData === 'string') {\n          fieldData = JSON.parse(fieldData)\n        }\n\n        let fieldResult:\n          | { docs: unknown[]; hasNextPage: boolean }\n          | Record<string, { docs: unknown[]; hasNextPage: boolean }>\n        if (Array.isArray(fieldData)) {\n          if (field.localized) {\n            fieldResult = fieldData.reduce((joinResult, row) => {\n              if (typeof row._locale === 'string') {\n                if (!joinResult[row._locale]) {\n                  joinResult[row._locale] = {\n                    docs: [],\n                    hasNextPage: false,\n                  }\n                }\n                joinResult[row._locale].docs.push(row._parentID)\n              }\n\n              return joinResult\n            }, {})\n            Object.keys(fieldResult).forEach((locale) => {\n              fieldResult[locale].hasNextPage = fieldResult[locale].docs.length > limit\n              fieldResult[locale].docs = fieldResult[locale].docs.slice(0, limit)\n            })\n          } else {\n            const hasNextPage = limit !== 0 && fieldData.length > limit\n            fieldResult = {\n              docs: (hasNextPage ? fieldData.slice(0, limit) : fieldData).map(({ id }) => ({\n                id,\n              })),\n              hasNextPage,\n            }\n          }\n        }\n\n        result[field.name] = fieldResult\n        return result\n      }\n\n      if (field.type === 'text' && field?.hasMany) {\n        const textPathMatch = texts[`${sanitizedPath}${field.name}`]\n        if (!textPathMatch) {\n          return result\n        }\n\n        if (field.localized) {\n          result[field.name] = {}\n          const textsByLocale: Record<string, Record<string, unknown>[]> = {}\n\n          textPathMatch.forEach((row) => {\n            if (typeof row.locale === 'string') {\n              if (!textsByLocale[row.locale]) {\n                textsByLocale[row.locale] = []\n              }\n              textsByLocale[row.locale].push(row)\n            }\n          })\n\n          Object.entries(textsByLocale).forEach(([locale, texts]) => {\n            transformHasManyText({\n              field,\n              locale,\n              ref: result,\n              textRows: texts,\n            })\n          })\n        } else {\n          transformHasManyText({\n            field,\n            ref: result,\n            textRows: textPathMatch,\n            withinArrayOrBlockLocale,\n          })\n        }\n\n        return result\n      }\n\n      if (field.type === 'number' && field.hasMany) {\n        const numberPathMatch = numbers[`${sanitizedPath}${field.name}`]\n        if (!numberPathMatch) {\n          return result\n        }\n\n        if (field.localized) {\n          result[field.name] = {}\n          const numbersByLocale: Record<string, Record<string, unknown>[]> = {}\n\n          numberPathMatch.forEach((row) => {\n            if (typeof row.locale === 'string') {\n              if (!numbersByLocale[row.locale]) {\n                numbersByLocale[row.locale] = []\n              }\n              numbersByLocale[row.locale].push(row)\n            }\n          })\n\n          Object.entries(numbersByLocale).forEach(([locale, numbers]) => {\n            transformHasManyNumber({\n              field,\n              locale,\n              numberRows: numbers,\n              ref: result,\n            })\n          })\n        } else {\n          transformHasManyNumber({\n            field,\n            numberRows: numberPathMatch,\n            ref: result,\n            withinArrayOrBlockLocale,\n          })\n        }\n\n        return result\n      }\n\n      if (field.type === 'select' && field.hasMany) {\n        if (Array.isArray(fieldData)) {\n          if (field.localized) {\n            result[field.name] = fieldData.reduce((selectResult, row) => {\n              if (typeof row.locale === 'string') {\n                if (!selectResult[row.locale]) {\n                  selectResult[row.locale] = []\n                }\n                selectResult[row.locale].push(row.value)\n              }\n\n              return selectResult\n            }, {})\n          } else {\n            let selectData = fieldData\n            if (withinArrayOrBlockLocale) {\n              selectData = selectData.filter(({ locale }) => locale === withinArrayOrBlockLocale)\n            }\n            result[field.name] = selectData.map(({ value }) => value)\n          }\n        }\n        return result\n      }\n\n      if (field.localized && Array.isArray(table._locales)) {\n        if (!table._locales.length && adapter.payload.config.localization) {\n          adapter.payload.config.localization.localeCodes.forEach((_locale) =>\n            (table._locales as unknown[]).push({ _locale }),\n          )\n        }\n\n        table._locales.forEach((localeRow) => {\n          valuesToTransform.push({\n            ref: localizedFieldData,\n            table: {\n              ...table,\n              ...localeRow,\n            },\n          })\n        })\n      } else {\n        valuesToTransform.push({ ref: result, table })\n      }\n\n      valuesToTransform.forEach(({ ref, table }) => {\n        const fieldData = table[`${fieldPrefix || ''}${field.name}`]\n        const locale = table?._locale\n        let val = fieldData\n\n        switch (field.type) {\n          case 'tab':\n          case 'group': {\n            const groupFieldPrefix = `${fieldPrefix || ''}${field.name}_`\n            const groupData = {}\n            const locale = table._locale as string\n            const refKey = field.localized && locale ? locale : field.name\n\n            if (field.localized && locale) {\n              delete table._locale\n            }\n            ref[refKey] = traverseFields<Record<string, unknown>>({\n              adapter,\n              blocks,\n              config,\n              dataRef: groupData as Record<string, unknown>,\n              deletions,\n              fieldPrefix: groupFieldPrefix,\n              fields: field.fields,\n              numbers,\n              path: `${sanitizedPath}${field.name}`,\n              relationships,\n              table,\n              texts,\n              withinArrayOrBlockLocale: locale || withinArrayOrBlockLocale,\n            })\n\n            if ('_order' in ref) {\n              delete ref._order\n            }\n\n            return\n          }\n\n          case 'text': {\n            if (typeof fieldData === 'string') {\n              val = String(fieldData)\n            }\n\n            break\n          }\n\n          case 'number': {\n            if (typeof fieldData === 'string') {\n              val = Number.parseFloat(fieldData)\n            }\n\n            break\n          }\n\n          case 'date': {\n            if (typeof fieldData === 'string') {\n              val = new Date(fieldData).toISOString()\n            }\n\n            break\n          }\n\n          case 'relationship':\n          case 'upload': {\n            if (\n              val &&\n              typeof field.relationTo === 'string' &&\n              adapter.payload.collections[field.relationTo].customIDType === 'number'\n            ) {\n              val = Number(val)\n            }\n\n            break\n          }\n\n          default: {\n            break\n          }\n        }\n        if (typeof locale === 'string') {\n          ref[locale] = val\n        } else {\n          result[field.name] = val\n        }\n      })\n\n      if (Object.keys(localizedFieldData).length > 0) {\n        result[field.name] = localizedFieldData\n      }\n\n      return result\n    }\n\n    return result\n  }, dataRef)\n\n  if (Array.isArray(table._locales)) {\n    deletions.push(() => delete table._locales)\n  }\n\n  return formatted as T\n}\n"],"names":["fieldAffectsData","fieldIsVirtual","transformHasManyNumber","transformHasManyText","transformRelationship","traverseFields","adapter","blocks","config","dataRef","deletions","fieldPrefix","fields","joinQuery","numbers","path","relationships","table","texts","withinArrayOrBlockLocale","sanitizedPath","formatted","reduce","result","field","type","tabs","map","tab","fieldName","name","fieldData","localizedFieldData","valuesToTransform","push","Array","isArray","localized","arrayResult","row","_locale","locale","data","_uuid","id","rowResult","_order","acc","i","blockFieldPath","blocksByPath","forEach","Object","entries","localizedBlocks","block","find","slug","blockType","blockResult","localization","localeCodes","localeIndex","length","_index","relationTo","hasMany","locales","_locales","localeRow","ref","relationPathMatch","defaultLocale","relationsByLocale","relations","limit","replaceAll","JSON","parse","fieldResult","joinResult","docs","hasNextPage","_parentID","keys","slice","textPathMatch","textsByLocale","textRows","numberPathMatch","numbersByLocale","numberRows","selectResult","value","selectData","filter","payload","val","groupFieldPrefix","groupData","refKey","String","Number","parseFloat","Date","toISOString","collections","customIDType"],"mappings":"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"}},
    {"offset": {"line": 2446, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2452, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/@payloadcms/db-postgres/node_modules/@payloadcms/drizzle/src/transform/read/index.ts"],"sourcesContent":["import type { Field, JoinQuery, SanitizedConfig, TypeWithID } from 'payload'\n\nimport type { DrizzleAdapter } from '../../types.js'\n\nimport { createBlocksMap } from '../../utilities/createBlocksMap.js'\nimport { createPathMap } from '../../utilities/createRelationshipMap.js'\nimport { traverseFields } from './traverseFields.js'\n\ntype TransformArgs = {\n  adapter: DrizzleAdapter\n  config: SanitizedConfig\n  data: Record<string, unknown>\n  fallbackLocale?: false | string\n  fields: Field[]\n  joinQuery?: JoinQuery\n  locale?: string\n}\n\n// This is the entry point to transform Drizzle output data\n// into the shape Payload expects based on field schema\nexport const transform = <T extends Record<string, unknown> | TypeWithID>({\n  adapter,\n  config,\n  data,\n  fields,\n  joinQuery,\n}: TransformArgs): T => {\n  let relationships: Record<string, Record<string, unknown>[]> = {}\n  let texts: Record<string, Record<string, unknown>[]> = {}\n  let numbers: Record<string, Record<string, unknown>[]> = {}\n\n  if ('_rels' in data) {\n    relationships = createPathMap(data._rels)\n    delete data._rels\n  }\n\n  if ('_texts' in data) {\n    texts = createPathMap(data._texts)\n    delete data._texts\n  }\n\n  if ('_numbers' in data) {\n    numbers = createPathMap(data._numbers)\n    delete data._numbers\n  }\n\n  const blocks = createBlocksMap(data)\n  const deletions = []\n\n  const result = traverseFields<T>({\n    adapter,\n    blocks,\n    config,\n    dataRef: {\n      id: data.id,\n    },\n    deletions,\n    fieldPrefix: '',\n    fields,\n    joinQuery,\n    numbers,\n    path: '',\n    relationships,\n    table: data,\n    texts,\n  })\n\n  deletions.forEach((deletion) => deletion())\n\n  return result\n}\n"],"names":["createBlocksMap","createPathMap","traverseFields","transform","adapter","config","data","fields","joinQuery","relationships","texts","numbers","_rels","_texts","_numbers","blocks","deletions","result","dataRef","id","fieldPrefix","path","table","forEach","deletion"],"mappings":";;;AAIA,SAASA,eAAe,QAAQ,qCAAoC;AACpE,SAASC,aAAa,QAAQ,2CAA0C;AACxE,SAASC,cAAc,QAAQ,sBAAqB;;;;AAc7C,MAAMC,YAAY,CAAiD,EACxEC,OAAO,EACPC,MAAM,EACNC,IAAI,EACJC,MAAM,EACNC,SAAS,EACK;IACd,IAAIC,gBAA2D,CAAC;IAChE,IAAIC,QAAmD,CAAC;IACxD,IAAIC,UAAqD,CAAC;IAE1D,IAAI,WAAWL,MAAM;QACnBG,4PAAgBR,gBAAAA,EAAcK,KAAKM,KAAK;QACxC,OAAON,KAAKM,KAAK;IACnB;IAEA,IAAI,YAAYN,MAAM;QACpBI,oPAAQT,gBAAAA,EAAcK,KAAKO,MAAM;QACjC,OAAOP,KAAKO,MAAM;IACpB;IAEA,IAAI,cAAcP,MAAM;QACtBK,sPAAUV,gBAAAA,EAAcK,KAAKQ,QAAQ;QACrC,OAAOR,KAAKQ,QAAQ;IACtB;IAEA,MAAMC,+OAASf,kBAAAA,EAAgBM;IAC/B,MAAMU,YAAY,EAAE;IAEpB,MAAMC,sPAASf,iBAAAA,EAAkB;QAC/BE;QACAW;QACAV;QACAa,SAAS;YACPC,IAAIb,KAAKa,EAAE;QACb;QACAH;QACAI,aAAa;QACbb;QACAC;QACAG;QACAU,MAAM;QACNZ;QACAa,OAAOhB;QACPI;IACF;IAEAM,UAAUO,OAAO,CAAC,CAACC,WAAaA;IAEhC,OAAOP;AACT,EAAC"}},
    {"offset": {"line": 2499, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2505, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/@payloadcms/db-postgres/node_modules/@payloadcms/drizzle/src/utilities/isArrayOfRows.ts"],"sourcesContent":["export function isArrayOfRows(data: unknown): data is Record<string, unknown>[] {\n  return Array.isArray(data)\n}\n"],"names":["isArrayOfRows","data","Array","isArray"],"mappings":";;;AAAO,SAASA,cAAcC,IAAa;IACzC,OAAOC,MAAMC,OAAO,CAACF;AACvB"}},
    {"offset": {"line": 2511, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2517, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/@payloadcms/db-postgres/node_modules/@payloadcms/drizzle/src/transform/write/array.ts"],"sourcesContent":["import type { ArrayField } from 'payload'\n\nimport type { DrizzleAdapter } from '../../types.js'\nimport type { ArrayRowToInsert, BlockRowToInsert, RelationshipToDelete } from './types.js'\n\nimport { isArrayOfRows } from '../../utilities/isArrayOfRows.js'\nimport { traverseFields } from './traverseFields.js'\n\ntype Args = {\n  adapter: DrizzleAdapter\n  arrayTableName: string\n  baseTableName: string\n  blocks: {\n    [blockType: string]: BlockRowToInsert[]\n  }\n  blocksToDelete: Set<string>\n  data: unknown\n  field: ArrayField\n  locale?: string\n  numbers: Record<string, unknown>[]\n  path: string\n  relationships: Record<string, unknown>[]\n  relationshipsToDelete: RelationshipToDelete[]\n  selects: {\n    [tableName: string]: Record<string, unknown>[]\n  }\n  texts: Record<string, unknown>[]\n  /**\n   * Set to a locale code if this set of fields is traversed within a\n   * localized array or block field\n   */\n  withinArrayOrBlockLocale?: string\n}\n\nexport const transformArray = ({\n  adapter,\n  arrayTableName,\n  baseTableName,\n  blocks,\n  blocksToDelete,\n  data,\n  field,\n  locale,\n  numbers,\n  path,\n  relationships,\n  relationshipsToDelete,\n  selects,\n  texts,\n  withinArrayOrBlockLocale,\n}: Args) => {\n  const newRows: ArrayRowToInsert[] = []\n\n  const hasUUID = adapter.tables[arrayTableName]._uuid\n\n  if (isArrayOfRows(data)) {\n    data.forEach((arrayRow, i) => {\n      const newRow: ArrayRowToInsert = {\n        arrays: {},\n        locales: {},\n        row: {\n          _order: i + 1,\n        },\n      }\n\n      // If we have declared a _uuid field on arrays,\n      // that means the ID has to be unique,\n      // and our ids within arrays are not unique.\n      // So move the ID to a uuid field for storage\n      // and allow the database to generate a serial id automatically\n      if (hasUUID) {\n        newRow.row._uuid = arrayRow.id\n        delete arrayRow.id\n      }\n\n      if (locale) {\n        newRow.locales[locale] = {\n          _locale: locale,\n        }\n      }\n\n      if (field.localized) {\n        newRow.row._locale = locale\n      }\n\n      if (withinArrayOrBlockLocale) {\n        newRow.row._locale = withinArrayOrBlockLocale\n      }\n\n      traverseFields({\n        adapter,\n        arrays: newRow.arrays,\n        baseTableName,\n        blocks,\n        blocksToDelete,\n        columnPrefix: '',\n        data: arrayRow,\n        fieldPrefix: '',\n        fields: field.fields,\n        locales: newRow.locales,\n        numbers,\n        parentTableName: arrayTableName,\n        path: `${path || ''}${field.name}.${i}.`,\n        relationships,\n        relationshipsToDelete,\n        row: newRow.row,\n        selects,\n        texts,\n        withinArrayOrBlockLocale,\n      })\n\n      newRows.push(newRow)\n    })\n  }\n\n  return newRows\n}\n"],"names":["isArrayOfRows","traverseFields","transformArray","adapter","arrayTableName","baseTableName","blocks","blocksToDelete","data","field","locale","numbers","path","relationships","relationshipsToDelete","selects","texts","withinArrayOrBlockLocale","newRows","hasUUID","tables","_uuid","forEach","arrayRow","i","newRow","arrays","locales","row","_order","id","_locale","localized","columnPrefix","fieldPrefix","fields","parentTableName","name","push"],"mappings":";;;AAKA,SAASA,aAAa,QAAQ,mCAAkC;AAChE,SAASC,cAAc,QAAQ,sBAAqB;;;AA4B7C,MAAMC,iBAAiB,CAAC,EAC7BC,OAAO,EACPC,cAAc,EACdC,aAAa,EACbC,MAAM,EACNC,cAAc,EACdC,IAAI,EACJC,KAAK,EACLC,MAAM,EACNC,OAAO,EACPC,IAAI,EACJC,aAAa,EACbC,qBAAqB,EACrBC,OAAO,EACPC,KAAK,EACLC,wBAAwB,EACnB;IACL,MAAMC,UAA8B,EAAE;IAEtC,MAAMC,UAAUhB,QAAQiB,MAAM,CAAChB,eAAe,CAACiB,KAAK;IAEpD,wOAAIrB,gBAAAA,EAAcQ,OAAO;QACvBA,KAAKc,OAAO,CAAC,CAACC,UAAUC;YACtB,MAAMC,SAA2B;gBAC/BC,QAAQ,CAAC;gBACTC,SAAS,CAAC;gBACVC,KAAK;oBACHC,QAAQL,IAAI;gBACd;YACF;YAEA,+CAA+C;YAC/C,sCAAsC;YACtC,4CAA4C;YAC5C,6CAA6C;YAC7C,+DAA+D;YAC/D,IAAIL,SAAS;gBACXM,OAAOG,GAAG,CAACP,KAAK,GAAGE,SAASO,EAAE;gBAC9B,OAAOP,SAASO,EAAE;YACpB;YAEA,IAAIpB,QAAQ;gBACVe,OAAOE,OAAO,CAACjB,OAAO,GAAG;oBACvBqB,SAASrB;gBACX;YACF;YAEA,IAAID,MAAMuB,SAAS,EAAE;gBACnBP,OAAOG,GAAG,CAACG,OAAO,GAAGrB;YACvB;YAEA,IAAIO,0BAA0B;gBAC5BQ,OAAOG,GAAG,CAACG,OAAO,GAAGd;YACvB;YAEAhB,+PAAAA,EAAe;gBACbE;gBACAuB,QAAQD,OAAOC,MAAM;gBACrBrB;gBACAC;gBACAC;gBACA0B,cAAc;gBACdzB,MAAMe;gBACNW,aAAa;gBACbC,QAAQ1B,MAAM0B,MAAM;gBACpBR,SAASF,OAAOE,OAAO;gBACvBhB;gBACAyB,iBAAiBhC;gBACjBQ,MAAM,CAAC,EAAEA,QAAQ,GAAG,EAAEH,MAAM4B,IAAI,CAAC,CAAC,EAAEb,EAAE,CAAC,CAAC;gBACxCX;gBACAC;gBACAc,KAAKH,OAAOG,GAAG;gBACfb;gBACAC;gBACAC;YACF;YAEAC,QAAQoB,IAAI,CAACb;QACf;IACF;IAEA,OAAOP;AACT,EAAC"}},
    {"offset": {"line": 2582, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2588, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/@payloadcms/db-postgres/node_modules/@payloadcms/drizzle/src/transform/write/blocks.ts"],"sourcesContent":["import type { BlocksField } from 'payload'\n\nimport toSnakeCase from 'to-snake-case'\n\nimport type { DrizzleAdapter } from '../../types.js'\nimport type { BlockRowToInsert, RelationshipToDelete } from './types.js'\n\nimport { traverseFields } from './traverseFields.js'\n\ntype Args = {\n  adapter: DrizzleAdapter\n  baseTableName: string\n  blocks: {\n    [blockType: string]: BlockRowToInsert[]\n  }\n  blocksToDelete: Set<string>\n  data: Record<string, unknown>[]\n  field: BlocksField\n  locale?: string\n  numbers: Record<string, unknown>[]\n  path: string\n  relationships: Record<string, unknown>[]\n  relationshipsToDelete: RelationshipToDelete[]\n  selects: {\n    [tableName: string]: Record<string, unknown>[]\n  }\n  texts: Record<string, unknown>[]\n  /**\n   * Set to a locale code if this set of fields is traversed within a\n   * localized array or block field\n   */\n  withinArrayOrBlockLocale?: string\n}\nexport const transformBlocks = ({\n  adapter,\n  baseTableName,\n  blocks,\n  blocksToDelete,\n  data,\n  field,\n  locale,\n  numbers,\n  path,\n  relationships,\n  relationshipsToDelete,\n  selects,\n  texts,\n  withinArrayOrBlockLocale,\n}: Args) => {\n  data.forEach((blockRow, i) => {\n    if (typeof blockRow.blockType !== 'string') {\n      return\n    }\n    const matchedBlock = field.blocks.find(({ slug }) => slug === blockRow.blockType)\n    if (!matchedBlock) {\n      return\n    }\n    const blockType = toSnakeCase(blockRow.blockType)\n\n    if (!blocks[blockType]) {\n      blocks[blockType] = []\n    }\n\n    const newRow: BlockRowToInsert = {\n      arrays: {},\n      locales: {},\n      row: {\n        _order: i + 1,\n        _path: `${path}${field.name}`,\n      },\n    }\n\n    if (field.localized && locale) {\n      newRow.row._locale = locale\n    }\n    if (withinArrayOrBlockLocale) {\n      newRow.row._locale = withinArrayOrBlockLocale\n    }\n\n    const blockTableName = adapter.tableNameMap.get(`${baseTableName}_blocks_${blockType}`)\n\n    const hasUUID = adapter.tables[blockTableName]._uuid\n\n    // If we have declared a _uuid field on arrays,\n    // that means the ID has to be unique,\n    // and our ids within arrays are not unique.\n    // So move the ID to a uuid field for storage\n    // and allow the database to generate a serial id automatically\n    if (hasUUID) {\n      newRow.row._uuid = blockRow.id\n      delete blockRow.id\n    }\n\n    traverseFields({\n      adapter,\n      arrays: newRow.arrays,\n      baseTableName,\n      blocks,\n      blocksToDelete,\n      columnPrefix: '',\n      data: blockRow,\n      fieldPrefix: '',\n      fields: matchedBlock.fields,\n      locales: newRow.locales,\n      numbers,\n      parentTableName: blockTableName,\n      path: `${path || ''}${field.name}.${i}.`,\n      relationships,\n      relationshipsToDelete,\n      row: newRow.row,\n      selects,\n      texts,\n      withinArrayOrBlockLocale,\n    })\n\n    blocks[blockType].push(newRow)\n  })\n}\n"],"names":["toSnakeCase","traverseFields","transformBlocks","adapter","baseTableName","blocks","blocksToDelete","data","field","locale","numbers","path","relationships","relationshipsToDelete","selects","texts","withinArrayOrBlockLocale","forEach","blockRow","i","blockType","matchedBlock","find","slug","newRow","arrays","locales","row","_order","_path","name","localized","_locale","blockTableName","tableNameMap","get","hasUUID","tables","_uuid","id","columnPrefix","fieldPrefix","fields","parentTableName","push"],"mappings":";;;AAEA,OAAOA,iBAAiB,gBAAe;AAKvC,SAASC,cAAc,QAAQ,sBAAqB;;;AA0B7C,MAAMC,kBAAkB,CAAC,EAC9BC,OAAO,EACPC,aAAa,EACbC,MAAM,EACNC,cAAc,EACdC,IAAI,EACJC,KAAK,EACLC,MAAM,EACNC,OAAO,EACPC,IAAI,EACJC,aAAa,EACbC,qBAAqB,EACrBC,OAAO,EACPC,KAAK,EACLC,wBAAwB,EACnB;IACLT,KAAKU,OAAO,CAAC,CAACC,UAAUC;QACtB,IAAI,OAAOD,SAASE,SAAS,KAAK,UAAU;YAC1C;QACF;QACA,MAAMC,eAAeb,MAAMH,MAAM,CAACiB,IAAI,CAAC,CAAC,EAAEC,IAAI,EAAE,GAAKA,SAASL,SAASE,SAAS;QAChF,IAAI,CAACC,cAAc;YACjB;QACF;QACA,MAAMD,6JAAYpB,UAAAA,EAAYkB,SAASE,SAAS;QAEhD,IAAI,CAACf,MAAM,CAACe,UAAU,EAAE;YACtBf,MAAM,CAACe,UAAU,GAAG,EAAE;QACxB;QAEA,MAAMI,SAA2B;YAC/BC,QAAQ,CAAC;YACTC,SAAS,CAAC;YACVC,KAAK;gBACHC,QAAQT,IAAI;gBACZU,OAAO,CAAC,EAAElB,KAAK,EAAEH,MAAMsB,IAAI,CAAC,CAAC;YAC/B;QACF;QAEA,IAAItB,MAAMuB,SAAS,IAAItB,QAAQ;YAC7Be,OAAOG,GAAG,CAACK,OAAO,GAAGvB;QACvB;QACA,IAAIO,0BAA0B;YAC5BQ,OAAOG,GAAG,CAACK,OAAO,GAAGhB;QACvB;QAEA,MAAMiB,iBAAiB9B,QAAQ+B,YAAY,CAACC,GAAG,CAAC,CAAC,EAAE/B,cAAc,QAAQ,EAAEgB,UAAU,CAAC;QAEtF,MAAMgB,UAAUjC,QAAQkC,MAAM,CAACJ,eAAe,CAACK,KAAK;QAEpD,+CAA+C;QAC/C,sCAAsC;QACtC,4CAA4C;QAC5C,6CAA6C;QAC7C,+DAA+D;QAC/D,IAAIF,SAAS;YACXZ,OAAOG,GAAG,CAACW,KAAK,GAAGpB,SAASqB,EAAE;YAC9B,OAAOrB,SAASqB,EAAE;QACpB;sPAEAtC,iBAAAA,EAAe;YACbE;YACAsB,QAAQD,OAAOC,MAAM;YACrBrB;YACAC;YACAC;YACAkC,cAAc;YACdjC,MAAMW;YACNuB,aAAa;YACbC,QAAQrB,aAAaqB,MAAM;YAC3BhB,SAASF,OAAOE,OAAO;YACvBhB;YACAiC,iBAAiBV;YACjBtB,MAAM,CAAC,EAAEA,QAAQ,GAAG,EAAEH,MAAMsB,IAAI,CAAC,CAAC,EAAEX,EAAE,CAAC,CAAC;YACxCP;YACAC;YACAc,KAAKH,OAAOG,GAAG;YACfb;YACAC;YACAC;QACF;QAEAX,MAAM,CAACe,UAAU,CAACwB,IAAI,CAACpB;IACzB;AACF,EAAC"}},
    {"offset": {"line": 2657, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2663, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/@payloadcms/db-postgres/node_modules/@payloadcms/drizzle/src/transform/write/numbers.ts"],"sourcesContent":["type Args = {\n  baseRow: Record<string, unknown>\n  data: unknown[]\n  numbers: Record<string, unknown>[]\n}\n\nexport const transformNumbers = ({ baseRow, data, numbers }: Args) => {\n  data.forEach((val, i) => {\n    numbers.push({\n      ...baseRow,\n      number: val,\n      order: i + 1,\n    })\n  })\n}\n"],"names":["transformNumbers","baseRow","data","numbers","forEach","val","i","push","number","order"],"mappings":";;;AAMO,MAAMA,mBAAmB,CAAC,EAAEC,OAAO,EAAEC,IAAI,EAAEC,OAAO,EAAQ;IAC/DD,KAAKE,OAAO,CAAC,CAACC,KAAKC;QACjBH,QAAQI,IAAI,CAAC;YACX,GAAGN,OAAO;YACVO,QAAQH;YACRI,OAAOH,IAAI;QACb;IACF;AACF,EAAC"}},
    {"offset": {"line": 2675, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2681, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/@payloadcms/db-postgres/node_modules/@payloadcms/drizzle/src/transform/write/relationships.ts"],"sourcesContent":["import type { RelationshipField, UploadField } from 'payload'\n\nimport { valueIsValueWithRelation } from 'payload/shared'\n\ntype Args = {\n  baseRow: Record<string, unknown>\n  data: unknown\n  field: RelationshipField | UploadField\n  relationships: Record<string, unknown>[]\n}\n\nexport const transformRelationship = ({ baseRow, data, field, relationships }: Args) => {\n  const relations = Array.isArray(data) ? data : [data]\n\n  relations.forEach((relation, i) => {\n    if (relation) {\n      const relationRow = { ...baseRow }\n      if ('hasMany' in field && field.hasMany) {\n        relationRow.order = i + 1\n      }\n\n      if (Array.isArray(field.relationTo) && valueIsValueWithRelation(relation)) {\n        relationRow[`${relation.relationTo}ID`] = relation.value\n        relationships.push(relationRow)\n      } else {\n        relationRow[`${field.relationTo}ID`] = relation\n        if (relation) {\n          relationships.push(relationRow)\n        }\n      }\n    }\n  })\n}\n"],"names":["valueIsValueWithRelation","transformRelationship","baseRow","data","field","relationships","relations","Array","isArray","forEach","relation","i","relationRow","hasMany","order","relationTo","value","push"],"mappings":";;;AAEA,SAASA,wBAAwB,QAAQ,iBAAgB;;AASlD,MAAMC,wBAAwB,CAAC,EAAEC,OAAO,EAAEC,IAAI,EAAEC,KAAK,EAAEC,aAAa,EAAQ;IACjF,MAAMC,YAAYC,MAAMC,OAAO,CAACL,QAAQA,OAAO;QAACA;KAAK;IAErDG,UAAUG,OAAO,CAAC,CAACC,UAAUC;QAC3B,IAAID,UAAU;YACZ,MAAME,cAAc;gBAAE,GAAGV,OAAO;YAAC;YACjC,IAAI,aAAaE,SAASA,MAAMS,OAAO,EAAE;gBACvCD,YAAYE,KAAK,GAAGH,IAAI;YAC1B;YAEA,IAAIJ,MAAMC,OAAO,CAACJ,MAAMW,UAAU,MAAKf,2LAAAA,EAAyBU,WAAW;gBACzEE,WAAW,CAAC,CAAC,EAAEF,SAASK,UAAU,CAAC,EAAE,CAAC,CAAC,GAAGL,SAASM,KAAK;gBACxDX,cAAcY,IAAI,CAACL;YACrB,OAAO;gBACLA,WAAW,CAAC,CAAC,EAAER,MAAMW,UAAU,CAAC,EAAE,CAAC,CAAC,GAAGL;gBACvC,IAAIA,UAAU;oBACZL,cAAcY,IAAI,CAACL;gBACrB;YACF;QACF;IACF;AACF,EAAC"}},
    {"offset": {"line": 2710, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2716, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/@payloadcms/db-postgres/node_modules/@payloadcms/drizzle/src/transform/write/selects.ts"],"sourcesContent":["import { isArrayOfRows } from '../../utilities/isArrayOfRows.js'\n\ntype Args = {\n  data: unknown\n  id?: unknown\n  locale?: string\n}\n\nexport const transformSelects = ({ id, data, locale }: Args) => {\n  const newRows: Record<string, unknown>[] = []\n\n  if (isArrayOfRows(data)) {\n    data.forEach((value, i) => {\n      const newRow: Record<string, unknown> = {\n        order: i + 1,\n        parent: id,\n        value,\n      }\n\n      if (locale) {\n        newRow.locale = locale\n      }\n\n      newRows.push(newRow)\n    })\n  }\n\n  return newRows\n}\n"],"names":["isArrayOfRows","transformSelects","id","data","locale","newRows","forEach","value","i","newRow","order","parent","push"],"mappings":";;;AAAA,SAASA,aAAa,QAAQ,mCAAkC;;AAQzD,MAAMC,mBAAmB,CAAC,EAAEC,EAAE,EAAEC,IAAI,EAAEC,MAAM,EAAQ;IACzD,MAAMC,UAAqC,EAAE;IAE7C,wOAAIL,gBAAAA,EAAcG,OAAO;QACvBA,KAAKG,OAAO,CAAC,CAACC,OAAOC;YACnB,MAAMC,SAAkC;gBACtCC,OAAOF,IAAI;gBACXG,QAAQT;gBACRK;YACF;YAEA,IAAIH,QAAQ;gBACVK,OAAOL,MAAM,GAAGA;YAClB;YAEAC,QAAQO,IAAI,CAACH;QACf;IACF;IAEA,OAAOJ;AACT,EAAC"}},
    {"offset": {"line": 2738, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2744, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/@payloadcms/db-postgres/node_modules/@payloadcms/drizzle/src/transform/write/texts.ts"],"sourcesContent":["type Args = {\n  baseRow: Record<string, unknown>\n  data: unknown[]\n  texts: Record<string, unknown>[]\n}\n\nexport const transformTexts = ({ baseRow, data, texts }: Args) => {\n  data.forEach((val, i) => {\n    texts.push({\n      ...baseRow,\n      order: i + 1,\n      text: val,\n    })\n  })\n}\n"],"names":["transformTexts","baseRow","data","texts","forEach","val","i","push","order","text"],"mappings":";;;AAMO,MAAMA,iBAAiB,CAAC,EAAEC,OAAO,EAAEC,IAAI,EAAEC,KAAK,EAAQ;IAC3DD,KAAKE,OAAO,CAAC,CAACC,KAAKC;QACjBH,MAAMI,IAAI,CAAC;YACT,GAAGN,OAAO;YACVO,OAAOF,IAAI;YACXG,MAAMJ;QACR;IACF;AACF,EAAC"}},
    {"offset": {"line": 2756, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2762, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/@payloadcms/db-postgres/node_modules/@payloadcms/drizzle/src/transform/write/traverseFields.ts"],"sourcesContent":["import type { Field } from 'payload'\n\nimport { fieldAffectsData, fieldIsVirtual } from 'payload/shared'\nimport toSnakeCase from 'to-snake-case'\n\nimport type { DrizzleAdapter } from '../../types.js'\nimport type { ArrayRowToInsert, BlockRowToInsert, RelationshipToDelete } from './types.js'\n\nimport { isArrayOfRows } from '../../utilities/isArrayOfRows.js'\nimport { transformArray } from './array.js'\nimport { transformBlocks } from './blocks.js'\nimport { transformNumbers } from './numbers.js'\nimport { transformRelationship } from './relationships.js'\nimport { transformSelects } from './selects.js'\nimport { transformTexts } from './texts.js'\n\ntype Args = {\n  adapter: DrizzleAdapter\n  arrays: {\n    [tableName: string]: ArrayRowToInsert[]\n  }\n  /**\n   * This is the name of the base table\n   */\n  baseTableName: string\n  blocks: {\n    [blockType: string]: BlockRowToInsert[]\n  }\n  blocksToDelete: Set<string>\n  /**\n   * A snake-case field prefix, representing prior fields\n   * Ex: my_group_my_named_tab_\n   */\n  columnPrefix: string\n  data: Record<string, unknown>\n  existingLocales?: Record<string, unknown>[]\n  /**\n   * A prefix that will retain camel-case formatting, representing prior fields\n   * Ex: myGroup_myNamedTab_\n   */\n  fieldPrefix: string\n  fields: Field[]\n  forcedLocale?: string\n  locales: {\n    [locale: string]: Record<string, unknown>\n  }\n  numbers: Record<string, unknown>[]\n  /**\n   * This is the name of the parent table\n   */\n  parentTableName: string\n  path: string\n  relationships: Record<string, unknown>[]\n  relationshipsToDelete: RelationshipToDelete[]\n  row: Record<string, unknown>\n  selects: {\n    [tableName: string]: Record<string, unknown>[]\n  }\n  texts: Record<string, unknown>[]\n  /**\n   * Set to a locale code if this set of fields is traversed within a\n   * localized array or block field\n   */\n  withinArrayOrBlockLocale?: string\n}\n\nexport const traverseFields = ({\n  adapter,\n  arrays,\n  baseTableName,\n  blocks,\n  blocksToDelete,\n  columnPrefix,\n  data,\n  existingLocales,\n  fieldPrefix,\n  fields,\n  forcedLocale,\n  locales,\n  numbers,\n  parentTableName,\n  path,\n  relationships,\n  relationshipsToDelete,\n  row,\n  selects,\n  texts,\n  withinArrayOrBlockLocale,\n}: Args) => {\n  fields.forEach((field) => {\n    let columnName = ''\n    let fieldName = ''\n    let fieldData: unknown\n\n    if (fieldAffectsData(field)) {\n      if (fieldIsVirtual(field)) {\n        return\n      }\n\n      columnName = `${columnPrefix || ''}${toSnakeCase(field.name)}`\n      fieldName = `${fieldPrefix || ''}${field.name}`\n      fieldData = data[field.name]\n    }\n\n    if (field.type === 'array') {\n      const arrayTableName = adapter.tableNameMap.get(`${parentTableName}_${columnName}`)\n\n      if (!arrays[arrayTableName]) {\n        arrays[arrayTableName] = []\n      }\n\n      if (field.localized) {\n        if (typeof data[field.name] === 'object' && data[field.name] !== null) {\n          Object.entries(data[field.name]).forEach(([localeKey, localeData]) => {\n            if (Array.isArray(localeData)) {\n              const newRows = transformArray({\n                adapter,\n                arrayTableName,\n                baseTableName,\n                blocks,\n                blocksToDelete,\n                data: localeData,\n                field,\n                locale: localeKey,\n                numbers,\n                path,\n                relationships,\n                relationshipsToDelete,\n                selects,\n                texts,\n                withinArrayOrBlockLocale: localeKey,\n              })\n\n              arrays[arrayTableName] = arrays[arrayTableName].concat(newRows)\n            }\n          })\n        }\n      } else {\n        const newRows = transformArray({\n          adapter,\n          arrayTableName,\n          baseTableName,\n          blocks,\n          blocksToDelete,\n          data: data[field.name],\n          field,\n          numbers,\n          path,\n          relationships,\n          relationshipsToDelete,\n          selects,\n          texts,\n          withinArrayOrBlockLocale,\n        })\n\n        arrays[arrayTableName] = arrays[arrayTableName].concat(newRows)\n      }\n\n      return\n    }\n\n    if (field.type === 'blocks') {\n      field.blocks.forEach(({ slug }) => {\n        blocksToDelete.add(toSnakeCase(slug))\n      })\n\n      if (field.localized) {\n        if (typeof data[field.name] === 'object' && data[field.name] !== null) {\n          Object.entries(data[field.name]).forEach(([localeKey, localeData]) => {\n            if (Array.isArray(localeData)) {\n              transformBlocks({\n                adapter,\n                baseTableName,\n                blocks,\n                blocksToDelete,\n                data: localeData,\n                field,\n                locale: localeKey,\n                numbers,\n                path,\n                relationships,\n                relationshipsToDelete,\n                selects,\n                texts,\n                withinArrayOrBlockLocale: localeKey,\n              })\n            }\n          })\n        }\n      } else if (isArrayOfRows(fieldData)) {\n        transformBlocks({\n          adapter,\n          baseTableName,\n          blocks,\n          blocksToDelete,\n          data: fieldData,\n          field,\n          numbers,\n          path,\n          relationships,\n          relationshipsToDelete,\n          selects,\n          texts,\n          withinArrayOrBlockLocale,\n        })\n      }\n\n      return\n    }\n\n    if (field.type === 'group') {\n      if (typeof data[field.name] === 'object' && data[field.name] !== null) {\n        if (field.localized) {\n          Object.entries(data[field.name]).forEach(([localeKey, localeData]) => {\n            // preserve array ID if there is\n            localeData._uuid = data.id || data._uuid\n\n            traverseFields({\n              adapter,\n              arrays,\n              baseTableName,\n              blocks,\n              blocksToDelete,\n              columnPrefix: `${columnName}_`,\n              data: localeData as Record<string, unknown>,\n              existingLocales,\n              fieldPrefix: `${fieldName}_`,\n              fields: field.fields,\n              forcedLocale: localeKey,\n              locales,\n              numbers,\n              parentTableName,\n              path: `${path || ''}${field.name}.`,\n              relationships,\n              relationshipsToDelete,\n              row,\n              selects,\n              texts,\n              withinArrayOrBlockLocale: localeKey,\n            })\n          })\n        } else {\n          // preserve array ID if there is\n          const groupData = data[field.name] as Record<string, unknown>\n          groupData._uuid = data.id || data._uuid\n\n          traverseFields({\n            adapter,\n            arrays,\n            baseTableName,\n            blocks,\n            blocksToDelete,\n            columnPrefix: `${columnName}_`,\n            data: groupData,\n            existingLocales,\n            fieldPrefix: `${fieldName}_`,\n            fields: field.fields,\n            locales,\n            numbers,\n            parentTableName,\n            path: `${path || ''}${field.name}.`,\n            relationships,\n            relationshipsToDelete,\n            row,\n            selects,\n            texts,\n            withinArrayOrBlockLocale,\n          })\n        }\n      }\n\n      return\n    }\n\n    if (field.type === 'tabs') {\n      field.tabs.forEach((tab) => {\n        if ('name' in tab) {\n          if (fieldIsVirtual(tab)) {\n            return\n          }\n\n          if (typeof data[tab.name] === 'object' && data[tab.name] !== null) {\n            if (tab.localized) {\n              Object.entries(data[tab.name]).forEach(([localeKey, localeData]) => {\n                // preserve array ID if there is\n                localeData._uuid = data.id || data._uuid\n\n                traverseFields({\n                  adapter,\n                  arrays,\n                  baseTableName,\n                  blocks,\n                  blocksToDelete,\n                  columnPrefix: `${columnPrefix || ''}${toSnakeCase(tab.name)}_`,\n                  data: localeData as Record<string, unknown>,\n                  existingLocales,\n                  fieldPrefix: `${fieldPrefix || ''}${tab.name}_`,\n                  fields: tab.fields,\n                  forcedLocale: localeKey,\n                  locales,\n                  numbers,\n                  parentTableName,\n                  path: `${path || ''}${tab.name}.`,\n                  relationships,\n                  relationshipsToDelete,\n                  row,\n                  selects,\n                  texts,\n                  withinArrayOrBlockLocale: localeKey,\n                })\n              })\n            } else {\n              const tabData = data[tab.name] as Record<string, unknown>\n              // preserve array ID if there is\n              tabData._uuid = data.id || data._uuid\n\n              traverseFields({\n                adapter,\n                arrays,\n                baseTableName,\n                blocks,\n                blocksToDelete,\n                columnPrefix: `${columnPrefix || ''}${toSnakeCase(tab.name)}_`,\n                data: tabData,\n                existingLocales,\n                fieldPrefix: `${fieldPrefix || ''}${tab.name}_`,\n                fields: tab.fields,\n                locales,\n                numbers,\n                parentTableName,\n                path: `${path || ''}${tab.name}.`,\n                relationships,\n                relationshipsToDelete,\n                row,\n                selects,\n                texts,\n                withinArrayOrBlockLocale,\n              })\n            }\n          }\n        } else {\n          traverseFields({\n            adapter,\n            arrays,\n            baseTableName,\n            blocks,\n            blocksToDelete,\n            columnPrefix,\n            data,\n            existingLocales,\n            fieldPrefix,\n            fields: tab.fields,\n            locales,\n            numbers,\n            parentTableName,\n            path,\n            relationships,\n            relationshipsToDelete,\n            row,\n            selects,\n            texts,\n            withinArrayOrBlockLocale,\n          })\n        }\n      })\n    }\n\n    if (field.type === 'row' || field.type === 'collapsible') {\n      traverseFields({\n        adapter,\n        arrays,\n        baseTableName,\n        blocks,\n        blocksToDelete,\n        columnPrefix,\n        data,\n        existingLocales,\n        fieldPrefix,\n        fields: field.fields,\n        forcedLocale,\n        locales,\n        numbers,\n        parentTableName,\n        path,\n        relationships,\n        relationshipsToDelete,\n        row,\n        selects,\n        texts,\n        withinArrayOrBlockLocale,\n      })\n    }\n\n    if (field.type === 'relationship' || field.type === 'upload') {\n      const relationshipPath = `${path || ''}${field.name}`\n\n      if (\n        field.localized &&\n        (Array.isArray(field.relationTo) || ('hasMany' in field && field.hasMany))\n      ) {\n        if (typeof fieldData === 'object') {\n          Object.entries(fieldData).forEach(([localeKey, localeData]) => {\n            if (localeData === null) {\n              relationshipsToDelete.push({\n                locale: localeKey,\n                path: relationshipPath,\n              })\n              return\n            }\n\n            transformRelationship({\n              baseRow: {\n                locale: localeKey,\n                path: relationshipPath,\n              },\n              data: localeData,\n              field,\n              relationships,\n            })\n          })\n        }\n        return\n      } else if (Array.isArray(field.relationTo) || ('hasMany' in field && field.hasMany)) {\n        if (fieldData === null || (Array.isArray(fieldData) && fieldData.length === 0)) {\n          relationshipsToDelete.push({ path: relationshipPath })\n          return\n        }\n\n        transformRelationship({\n          baseRow: {\n            locale: withinArrayOrBlockLocale,\n            path: relationshipPath,\n          },\n          data: fieldData,\n          field,\n          relationships,\n        })\n        return\n      } else {\n        if (\n          !field.localized &&\n          fieldData &&\n          typeof fieldData === 'object' &&\n          'id' in fieldData &&\n          fieldData?.id\n        ) {\n          fieldData = fieldData.id\n        } else if (field.localized) {\n          if (typeof fieldData === 'object') {\n            Object.entries(fieldData).forEach(([localeKey, localeData]) => {\n              if (typeof localeData === 'object') {\n                if (localeData && 'id' in localeData && localeData?.id) {\n                  fieldData[localeKey] = localeData.id\n                }\n              } else {\n                fieldData[localeKey] = localeData\n              }\n            })\n          }\n        }\n      }\n    }\n\n    if (field.type === 'text' && field.hasMany) {\n      const textPath = `${path || ''}${field.name}`\n\n      if (field.localized) {\n        if (typeof fieldData === 'object') {\n          Object.entries(fieldData).forEach(([localeKey, localeData]) => {\n            if (Array.isArray(localeData)) {\n              transformTexts({\n                baseRow: {\n                  locale: localeKey,\n                  path: textPath,\n                },\n                data: localeData,\n                texts,\n              })\n            }\n          })\n        }\n      } else if (Array.isArray(fieldData)) {\n        transformTexts({\n          baseRow: {\n            locale: withinArrayOrBlockLocale,\n            path: textPath,\n          },\n          data: fieldData,\n          texts,\n        })\n      }\n\n      return\n    }\n\n    if (field.type === 'number' && field.hasMany) {\n      const numberPath = `${path || ''}${field.name}`\n\n      if (field.localized) {\n        if (typeof fieldData === 'object') {\n          Object.entries(fieldData).forEach(([localeKey, localeData]) => {\n            if (Array.isArray(localeData)) {\n              transformNumbers({\n                baseRow: {\n                  locale: localeKey,\n                  path: numberPath,\n                },\n                data: localeData,\n                numbers,\n              })\n            }\n          })\n        }\n      } else if (Array.isArray(fieldData)) {\n        transformNumbers({\n          baseRow: {\n            locale: withinArrayOrBlockLocale,\n            path: numberPath,\n          },\n          data: fieldData,\n          numbers,\n        })\n      }\n\n      return\n    }\n\n    if (field.type === 'select' && field.hasMany) {\n      const selectTableName = adapter.tableNameMap.get(`${parentTableName}_${columnName}`)\n      if (!selects[selectTableName]) {\n        selects[selectTableName] = []\n      }\n\n      if (field.localized) {\n        if (typeof data[field.name] === 'object' && data[field.name] !== null) {\n          Object.entries(data[field.name]).forEach(([localeKey, localeData]) => {\n            if (Array.isArray(localeData)) {\n              const newRows = transformSelects({\n                id: data._uuid || data.id,\n                data: localeData,\n                locale: localeKey,\n              })\n\n              selects[selectTableName] = selects[selectTableName].concat(newRows)\n            }\n          })\n        }\n      } else if (Array.isArray(data[field.name])) {\n        const newRows = transformSelects({\n          id: data._uuid || data.id,\n          data: data[field.name],\n          locale: withinArrayOrBlockLocale,\n        })\n\n        selects[selectTableName] = selects[selectTableName].concat(newRows)\n      }\n\n      return\n    }\n\n    if (fieldAffectsData(field)) {\n      const valuesToTransform: { localeKey?: string; ref: unknown; value: unknown }[] = []\n\n      if (field.localized) {\n        if (typeof fieldData === 'object' && fieldData !== null) {\n          Object.entries(fieldData).forEach(([localeKey, localeData]) => {\n            if (!locales[localeKey]) {\n              locales[localeKey] = {}\n            }\n\n            valuesToTransform.push({\n              localeKey,\n              ref: locales,\n              value: localeData,\n            })\n          })\n        }\n      } else {\n        let ref = row\n\n        if (forcedLocale) {\n          if (!locales[forcedLocale]) {\n            locales[forcedLocale] = {}\n          }\n          ref = locales[forcedLocale]\n        }\n\n        valuesToTransform.push({ ref, value: fieldData })\n      }\n\n      valuesToTransform.forEach(({ localeKey, ref, value }) => {\n        if (typeof value !== 'undefined') {\n          let formattedValue = value\n\n          if (field.type === 'date') {\n            if (typeof value === 'number' && !Number.isNaN(value)) {\n              formattedValue = new Date(value).toISOString()\n            } else if (value instanceof Date) {\n              formattedValue = value.toISOString()\n            } else if (fieldName === 'updatedAt') {\n              // let the db handle this\n              formattedValue = new Date().toISOString()\n            }\n          }\n\n          if (localeKey) {\n            ref[localeKey][fieldName] = formattedValue\n          } else {\n            ref[fieldName] = formattedValue\n          }\n        }\n      })\n    }\n  })\n}\n"],"names":["fieldAffectsData","fieldIsVirtual","toSnakeCase","isArrayOfRows","transformArray","transformBlocks","transformNumbers","transformRelationship","transformSelects","transformTexts","traverseFields","adapter","arrays","baseTableName","blocks","blocksToDelete","columnPrefix","data","existingLocales","fieldPrefix","fields","forcedLocale","locales","numbers","parentTableName","path","relationships","relationshipsToDelete","row","selects","texts","withinArrayOrBlockLocale","forEach","field","columnName","fieldName","fieldData","name","type","arrayTableName","tableNameMap","get","localized","Object","entries","localeKey","localeData","Array","isArray","newRows","locale","concat","slug","add","_uuid","id","groupData","tabs","tab","tabData","relationshipPath","relationTo","hasMany","push","baseRow","length","textPath","numberPath","selectTableName","valuesToTransform","ref","value","formattedValue","Number","isNaN","Date","toISOString"],"mappings":"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"}},
    {"offset": {"line": 3263, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 3269, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/@payloadcms/db-postgres/node_modules/@payloadcms/drizzle/src/transform/write/index.ts"],"sourcesContent":["import type { Field } from 'payload'\n\nimport type { DrizzleAdapter } from '../../types.js'\nimport type { RowToInsert } from './types.js'\n\nimport { traverseFields } from './traverseFields.js'\n\ntype Args = {\n  adapter: DrizzleAdapter\n  data: Record<string, unknown>\n  fields: Field[]\n  path?: string\n  tableName: string\n}\n\nexport const transformForWrite = ({\n  adapter,\n  data,\n  fields,\n  path = '',\n  tableName,\n}: Args): RowToInsert => {\n  // Split out the incoming data into rows to insert / delete\n  const rowToInsert: RowToInsert = {\n    arrays: {},\n    blocks: {},\n    blocksToDelete: new Set(),\n    locales: {},\n    numbers: [],\n    relationships: [],\n    relationshipsToDelete: [],\n    row: {},\n    selects: {},\n    texts: [],\n  }\n\n  // This function is responsible for building up the\n  // above rowToInsert\n  traverseFields({\n    adapter,\n    arrays: rowToInsert.arrays,\n    baseTableName: tableName,\n    blocks: rowToInsert.blocks,\n    blocksToDelete: rowToInsert.blocksToDelete,\n    columnPrefix: '',\n    data,\n    fieldPrefix: '',\n    fields,\n    locales: rowToInsert.locales,\n    numbers: rowToInsert.numbers,\n    parentTableName: tableName,\n    path,\n    relationships: rowToInsert.relationships,\n    relationshipsToDelete: rowToInsert.relationshipsToDelete,\n    row: rowToInsert.row,\n    selects: rowToInsert.selects,\n    texts: rowToInsert.texts,\n  })\n\n  return rowToInsert\n}\n"],"names":["traverseFields","transformForWrite","adapter","data","fields","path","tableName","rowToInsert","arrays","blocks","blocksToDelete","Set","locales","numbers","relationships","relationshipsToDelete","row","selects","texts","baseTableName","columnPrefix","fieldPrefix","parentTableName"],"mappings":";;;AAKA,SAASA,cAAc,QAAQ,sBAAqB;;AAU7C,MAAMC,oBAAoB,CAAC,EAChCC,OAAO,EACPC,IAAI,EACJC,MAAM,EACNC,OAAO,EAAE,EACTC,SAAS,EACJ;IACL,2DAA2D;IAC3D,MAAMC,cAA2B;QAC/BC,QAAQ,CAAC;QACTC,QAAQ,CAAC;QACTC,gBAAgB,IAAIC;QACpBC,SAAS,CAAC;QACVC,SAAS,EAAE;QACXC,eAAe,EAAE;QACjBC,uBAAuB,EAAE;QACzBC,KAAK,CAAC;QACNC,SAAS,CAAC;QACVC,OAAO,EAAE;IACX;IAEA,mDAAmD;IACnD,oBAAoB;kPACpBlB,iBAAAA,EAAe;QACbE;QACAM,QAAQD,YAAYC,MAAM;QAC1BW,eAAeb;QACfG,QAAQF,YAAYE,MAAM;QAC1BC,gBAAgBH,YAAYG,cAAc;QAC1CU,cAAc;QACdjB;QACAkB,aAAa;QACbjB;QACAQ,SAASL,YAAYK,OAAO;QAC5BC,SAASN,YAAYM,OAAO;QAC5BS,iBAAiBhB;QACjBD;QACAS,eAAeP,YAAYO,aAAa;QACxCC,uBAAuBR,YAAYQ,qBAAqB;QACxDC,KAAKT,YAAYS,GAAG;QACpBC,SAASV,YAAYU,OAAO;QAC5BC,OAAOX,YAAYW,KAAK;IAC1B;IAEA,OAAOX;AACT,EAAC"}},
    {"offset": {"line": 3312, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 3318, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/@payloadcms/db-postgres/node_modules/@payloadcms/drizzle/src/upsertRow/deleteExistingArrayRows.ts"],"sourcesContent":["import { and, eq } from 'drizzle-orm'\n\nimport type { DrizzleAdapter, DrizzleTransaction } from '../types.js'\n\ntype Args = {\n  adapter: DrizzleAdapter\n  db: DrizzleAdapter['drizzle'] | DrizzleTransaction\n  parentID: unknown\n  tableName: string\n}\n\nexport const deleteExistingArrayRows = async ({\n  adapter,\n  db,\n  parentID,\n  tableName,\n}: Args): Promise<void> => {\n  const table = adapter.tables[tableName]\n\n  const whereConstraints = [eq(table._parentID, parentID)]\n\n  await adapter.deleteWhere({\n    db,\n    tableName,\n    where: and(...whereConstraints),\n  })\n}\n"],"names":["and","eq","deleteExistingArrayRows","adapter","db","parentID","tableName","table","tables","whereConstraints","_parentID","deleteWhere","where"],"mappings":";;;AAAA,SAASA,GAAG,EAAEC,EAAE,QAAQ,cAAa;;AAW9B,MAAMC,0BAA0B,OAAO,EAC5CC,OAAO,EACPC,EAAE,EACFC,QAAQ,EACRC,SAAS,EACJ;IACL,MAAMC,QAAQJ,QAAQK,MAAM,CAACF,UAAU;IAEvC,MAAMG,mBAAmB;QAACR,8NAAAA,EAAGM,MAAMG,SAAS,EAAEL;KAAU;IAExD,MAAMF,QAAQQ,WAAW,CAAC;QACxBP;QACAE;QACAM,gOAAOZ,MAAAA,KAAOS;IAChB;AACF,EAAC"}},
    {"offset": {"line": 3334, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 3340, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/@payloadcms/db-postgres/node_modules/@payloadcms/drizzle/src/upsertRow/deleteExistingRowsByPath.ts"],"sourcesContent":["import { and, eq, inArray } from 'drizzle-orm'\n\nimport type { DrizzleAdapter, DrizzleTransaction } from '../types.js'\n\ntype Args = {\n  adapter: DrizzleAdapter\n  db: DrizzleAdapter['drizzle'] | DrizzleTransaction\n  localeColumnName?: string\n  parentColumnName?: string\n  parentID: unknown\n  pathColumnName?: string\n  rows: Record<string, unknown>[]\n  tableName: string\n}\n\nexport const deleteExistingRowsByPath = async ({\n  adapter,\n  db,\n  localeColumnName = '_locale',\n  parentColumnName = '_parentID',\n  parentID,\n  pathColumnName = '_path',\n  rows,\n  tableName,\n}: Args): Promise<void> => {\n  const localizedPathsToDelete = new Set<string>()\n  const pathsToDelete = new Set<string>()\n  const table = adapter.tables[tableName]\n\n  rows.forEach((row) => {\n    const path = row[pathColumnName]\n    const localeData = row[localeColumnName]\n    if (typeof path === 'string') {\n      if (typeof localeData === 'string') {\n        localizedPathsToDelete.add(path)\n      } else {\n        pathsToDelete.add(path)\n      }\n    }\n  })\n\n  if (localizedPathsToDelete.size > 0) {\n    const whereConstraints = [eq(table[parentColumnName], parentID)]\n\n    if (pathColumnName) {\n      whereConstraints.push(inArray(table[pathColumnName], Array.from(localizedPathsToDelete)))\n    }\n\n    await adapter.deleteWhere({\n      db,\n      tableName,\n      where: and(...whereConstraints),\n    })\n  }\n\n  if (pathsToDelete.size > 0) {\n    const whereConstraints = [eq(table[parentColumnName], parentID)]\n\n    if (pathColumnName) {\n      whereConstraints.push(inArray(table[pathColumnName], Array.from(pathsToDelete)))\n    }\n\n    await adapter.deleteWhere({\n      db,\n      tableName,\n      where: and(...whereConstraints),\n    })\n  }\n}\n"],"names":["and","eq","inArray","deleteExistingRowsByPath","adapter","db","localeColumnName","parentColumnName","parentID","pathColumnName","rows","tableName","localizedPathsToDelete","Set","pathsToDelete","table","tables","forEach","row","path","localeData","add","size","whereConstraints","push","Array","from","deleteWhere","where"],"mappings":";;;AAAA,SAASA,GAAG,EAAEC,EAAE,EAAEC,OAAO,QAAQ,cAAa;;AAevC,MAAMC,2BAA2B,OAAO,EAC7CC,OAAO,EACPC,EAAE,EACFC,mBAAmB,SAAS,EAC5BC,mBAAmB,WAAW,EAC9BC,QAAQ,EACRC,iBAAiB,OAAO,EACxBC,IAAI,EACJC,SAAS,EACJ;IACL,MAAMC,yBAAyB,IAAIC;IACnC,MAAMC,gBAAgB,IAAID;IAC1B,MAAME,QAAQX,QAAQY,MAAM,CAACL,UAAU;IAEvCD,KAAKO,OAAO,CAAC,CAACC;QACZ,MAAMC,OAAOD,GAAG,CAACT,eAAe;QAChC,MAAMW,aAAaF,GAAG,CAACZ,iBAAiB;QACxC,IAAI,OAAOa,SAAS,UAAU;YAC5B,IAAI,OAAOC,eAAe,UAAU;gBAClCR,uBAAuBS,GAAG,CAACF;YAC7B,OAAO;gBACLL,cAAcO,GAAG,CAACF;YACpB;QACF;IACF;IAEA,IAAIP,uBAAuBU,IAAI,GAAG,GAAG;QACnC,MAAMC,mBAAmB;qOAACtB,KAAAA,EAAGc,KAAK,CAACR,iBAAiB,EAAEC;SAAU;QAEhE,IAAIC,gBAAgB;YAClBc,iBAAiBC,IAAI,EAACtB,kOAAAA,EAAQa,KAAK,CAACN,eAAe,EAAEgB,MAAMC,IAAI,CAACd;QAClE;QAEA,MAAMR,QAAQuB,WAAW,CAAC;YACxBtB;YACAM;YACAiB,QAAO5B,8NAAAA,KAAOuB;QAChB;IACF;IAEA,IAAIT,cAAcQ,IAAI,GAAG,GAAG;QAC1B,MAAMC,mBAAmB;qOAACtB,KAAAA,EAAGc,KAAK,CAACR,iBAAiB,EAAEC;SAAU;QAEhE,IAAIC,gBAAgB;YAClBc,iBAAiBC,IAAI,0NAACtB,UAAAA,EAAQa,KAAK,CAACN,eAAe,EAAEgB,MAAMC,IAAI,CAACZ;QAClE;QAEA,MAAMV,QAAQuB,WAAW,CAAC;YACxBtB;YACAM;YACAiB,gOAAO5B,MAAAA,KAAOuB;QAChB;IACF;AACF,EAAC"}},
    {"offset": {"line": 3387, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 3393, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/@payloadcms/db-postgres/node_modules/@payloadcms/drizzle/src/upsertRow/insertArrays.ts"],"sourcesContent":["import type { ArrayRowToInsert } from '../transform/write/types.js'\nimport type { DrizzleAdapter, DrizzleTransaction } from '../types.js'\n\ntype Args = {\n  adapter: DrizzleAdapter\n  arrays: {\n    [tableName: string]: ArrayRowToInsert[]\n  }[]\n  db: DrizzleAdapter['drizzle'] | DrizzleTransaction\n  parentRows: Record<string, unknown>[]\n}\n\ntype RowsByTable = {\n  [tableName: string]: {\n    arrays: {\n      [tableName: string]: ArrayRowToInsert[]\n    }[]\n    locales: Record<string, unknown>[]\n    rows: Record<string, unknown>[]\n  }\n}\n\nexport const insertArrays = async ({ adapter, arrays, db, parentRows }: Args): Promise<void> => {\n  // Maintain a map of flattened rows by table\n  const rowsByTable: RowsByTable = {}\n\n  arrays.forEach((arraysByTable, parentRowIndex) => {\n    Object.entries(arraysByTable).forEach(([tableName, arrayRows]) => {\n      // If the table doesn't exist in map, initialize it\n      if (!rowsByTable[tableName]) {\n        rowsByTable[tableName] = {\n          arrays: [],\n          locales: [],\n          rows: [],\n        }\n      }\n\n      const parentID = parentRows[parentRowIndex].id\n\n      // Add any sub arrays that need to be created\n      // We will call this recursively below\n      arrayRows.forEach((arrayRow, i) => {\n        if (Object.keys(arrayRow.arrays).length > 0) {\n          rowsByTable[tableName].arrays.push(arrayRow.arrays)\n        }\n\n        // Set up parent IDs for both row and locale row\n        arrayRow.row._parentID = parentID\n        rowsByTable[tableName].rows.push(arrayRow.row)\n\n        Object.entries(arrayRow.locales).forEach(([arrayRowLocale, arrayRowLocaleData]) => {\n          arrayRowLocaleData._parentID = arrayRow.row.id\n          arrayRowLocaleData._locale = arrayRowLocale\n          rowsByTable[tableName].locales.push(arrayRowLocaleData)\n          if (!arrayRow.row.id) {\n            arrayRowLocaleData._getParentID = (rows: { _uuid: string; id: number }[]) => {\n              const { id } = rows.find((each) => each._uuid === arrayRow.row._uuid)\n              return id\n            }\n          }\n        })\n      })\n    })\n  })\n\n  // Insert all corresponding arrays\n  // (one insert per array table)\n  for (const [tableName, row] of Object.entries(rowsByTable)) {\n    // the nested arrays need the ID for the parentID foreign key\n    let insertedRows: Args['parentRows']\n    if (row.rows.length > 0) {\n      insertedRows = await adapter.insert({\n        db,\n        tableName,\n        values: row.rows,\n      })\n    }\n\n    // Insert locale rows\n    if (adapter.tables[`${tableName}${adapter.localesSuffix}`] && row.locales.length > 0) {\n      if (!row.locales[0]._parentID) {\n        row.locales = row.locales.map((localeRow) => {\n          if (typeof localeRow._getParentID === 'function') {\n            localeRow._parentID = localeRow._getParentID(insertedRows)\n            delete localeRow._getParentID\n          }\n          return localeRow\n        })\n      }\n      await adapter.insert({\n        db,\n        tableName: `${tableName}${adapter.localesSuffix}`,\n        values: row.locales,\n      })\n    }\n\n    // If there are sub arrays, call this function recursively\n    if (row.arrays.length > 0) {\n      await insertArrays({\n        adapter,\n        arrays: row.arrays,\n        db,\n        parentRows: insertedRows,\n      })\n    }\n  }\n}\n"],"names":["insertArrays","adapter","arrays","db","parentRows","rowsByTable","forEach","arraysByTable","parentRowIndex","Object","entries","tableName","arrayRows","locales","rows","parentID","id","arrayRow","i","keys","length","push","row","_parentID","arrayRowLocale","arrayRowLocaleData","_locale","_getParentID","find","each","_uuid","insertedRows","insert","values","tables","localesSuffix","map","localeRow"],"mappings":"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"}},
    {"offset": {"line": 3473, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 3479, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/@payloadcms/db-postgres/node_modules/@payloadcms/drizzle/src/upsertRow/index.ts"],"sourcesContent":["import type { TypeWithID } from 'payload'\n\nimport { eq } from 'drizzle-orm'\nimport { ValidationError } from 'payload'\n\nimport type { BlockRowToInsert } from '../transform/write/types.js'\nimport type { Args } from './types.js'\n\nimport { buildFindManyArgs } from '../find/buildFindManyArgs.js'\nimport { transform } from '../transform/read/index.js'\nimport { transformForWrite } from '../transform/write/index.js'\nimport { deleteExistingArrayRows } from './deleteExistingArrayRows.js'\nimport { deleteExistingRowsByPath } from './deleteExistingRowsByPath.js'\nimport { insertArrays } from './insertArrays.js'\n\nexport const upsertRow = async <T extends Record<string, unknown> | TypeWithID>({\n  id,\n  adapter,\n  data,\n  db,\n  fields,\n  ignoreResult,\n  joinQuery,\n  operation,\n  path = '',\n  req,\n  tableName,\n  upsertTarget,\n  where,\n}: Args): Promise<T> => {\n  // Split out the incoming data into the corresponding:\n  // base row, locales, relationships, blocks, and arrays\n  const rowToInsert = transformForWrite({\n    adapter,\n    data,\n    fields,\n    path,\n    tableName,\n  })\n\n  // First, we insert the main row\n  let insertedRow: Record<string, unknown>\n\n  try {\n    if (operation === 'update') {\n      const target = upsertTarget || adapter.tables[tableName].id\n\n      if (id) {\n        rowToInsert.row.id = id\n        ;[insertedRow] = await adapter.insert({\n          db,\n          onConflictDoUpdate: { set: rowToInsert.row, target },\n          tableName,\n          values: rowToInsert.row,\n        })\n      } else {\n        ;[insertedRow] = await adapter.insert({\n          db,\n          onConflictDoUpdate: { set: rowToInsert.row, target, where },\n          tableName,\n          values: rowToInsert.row,\n        })\n      }\n    } else {\n      ;[insertedRow] = await adapter.insert({\n        db,\n        tableName,\n        values: rowToInsert.row,\n      })\n    }\n\n    const localesToInsert: Record<string, unknown>[] = []\n    const relationsToInsert: Record<string, unknown>[] = []\n    const textsToInsert: Record<string, unknown>[] = []\n    const numbersToInsert: Record<string, unknown>[] = []\n    const blocksToInsert: { [blockType: string]: BlockRowToInsert[] } = {}\n    const selectsToInsert: { [selectTableName: string]: Record<string, unknown>[] } = {}\n\n    // If there are locale rows with data, add the parent and locale to each\n    if (Object.keys(rowToInsert.locales).length > 0) {\n      Object.entries(rowToInsert.locales).forEach(([locale, localeRow]) => {\n        localeRow._parentID = insertedRow.id\n        localeRow._locale = locale\n        localesToInsert.push(localeRow)\n      })\n    }\n\n    // If there are relationships, add parent to each\n    if (rowToInsert.relationships.length > 0) {\n      rowToInsert.relationships.forEach((relation) => {\n        relation.parent = insertedRow.id\n        relationsToInsert.push(relation)\n      })\n    }\n\n    // If there are texts, add parent to each\n    if (rowToInsert.texts.length > 0) {\n      rowToInsert.texts.forEach((textRow) => {\n        textRow.parent = insertedRow.id\n        textsToInsert.push(textRow)\n      })\n    }\n\n    // If there are numbers, add parent to each\n    if (rowToInsert.numbers.length > 0) {\n      rowToInsert.numbers.forEach((numberRow) => {\n        numberRow.parent = insertedRow.id\n        numbersToInsert.push(numberRow)\n      })\n    }\n\n    // If there are selects, add parent to each, and then\n    // store by table name and rows\n    if (Object.keys(rowToInsert.selects).length > 0) {\n      Object.entries(rowToInsert.selects).forEach(([selectTableName, selectRows]) => {\n        selectRows.forEach((row) => {\n          if (typeof row.parent === 'undefined') {\n            row.parent = insertedRow.id\n          }\n          if (!selectsToInsert[selectTableName]) {\n            selectsToInsert[selectTableName] = []\n          }\n          selectsToInsert[selectTableName].push(row)\n        })\n      })\n    }\n\n    // If there are blocks, add parent to each, and then\n    // store by table name and rows\n    Object.keys(rowToInsert.blocks).forEach((blockName) => {\n      rowToInsert.blocks[blockName].forEach((blockRow) => {\n        blockRow.row._parentID = insertedRow.id\n        if (!blocksToInsert[blockName]) {\n          blocksToInsert[blockName] = []\n        }\n        if (blockRow.row.uuid) {\n          delete blockRow.row.uuid\n        }\n        blocksToInsert[blockName].push(blockRow)\n      })\n    })\n\n    // //////////////////////////////////\n    // INSERT LOCALES\n    // //////////////////////////////////\n\n    if (localesToInsert.length > 0) {\n      const localeTableName = `${tableName}${adapter.localesSuffix}`\n      const localeTable = adapter.tables[`${tableName}${adapter.localesSuffix}`]\n\n      if (operation === 'update') {\n        await adapter.deleteWhere({\n          db,\n          tableName: localeTableName,\n          where: eq(localeTable._parentID, insertedRow.id),\n        })\n      }\n\n      await adapter.insert({\n        db,\n        tableName: localeTableName,\n        values: localesToInsert,\n      })\n    }\n\n    // //////////////////////////////////\n    // INSERT RELATIONSHIPS\n    // //////////////////////////////////\n\n    const relationshipsTableName = `${tableName}${adapter.relationshipsSuffix}`\n\n    if (operation === 'update') {\n      await deleteExistingRowsByPath({\n        adapter,\n        db,\n        localeColumnName: 'locale',\n        parentColumnName: 'parent',\n        parentID: insertedRow.id,\n        pathColumnName: 'path',\n        rows: [...relationsToInsert, ...rowToInsert.relationshipsToDelete],\n        tableName: relationshipsTableName,\n      })\n    }\n\n    if (relationsToInsert.length > 0) {\n      await adapter.insert({\n        db,\n        tableName: relationshipsTableName,\n        values: relationsToInsert,\n      })\n    }\n\n    // //////////////////////////////////\n    // INSERT hasMany TEXTS\n    // //////////////////////////////////\n\n    const textsTableName = `${tableName}_texts`\n\n    if (operation === 'update') {\n      await deleteExistingRowsByPath({\n        adapter,\n        db,\n        localeColumnName: 'locale',\n        parentColumnName: 'parent',\n        parentID: insertedRow.id,\n        pathColumnName: 'path',\n        rows: textsToInsert,\n        tableName: textsTableName,\n      })\n    }\n\n    if (textsToInsert.length > 0) {\n      await adapter.insert({\n        db,\n        tableName: textsTableName,\n        values: textsToInsert,\n      })\n    }\n\n    // //////////////////////////////////\n    // INSERT hasMany NUMBERS\n    // //////////////////////////////////\n\n    const numbersTableName = `${tableName}_numbers`\n\n    if (operation === 'update') {\n      await deleteExistingRowsByPath({\n        adapter,\n        db,\n        localeColumnName: 'locale',\n        parentColumnName: 'parent',\n        parentID: insertedRow.id,\n        pathColumnName: 'path',\n        rows: numbersToInsert,\n        tableName: numbersTableName,\n      })\n    }\n\n    if (numbersToInsert.length > 0) {\n      await adapter.insert({\n        db,\n        tableName: numbersTableName,\n        values: numbersToInsert,\n      })\n    }\n\n    // //////////////////////////////////\n    // INSERT BLOCKS\n    // //////////////////////////////////\n\n    const insertedBlockRows: Record<string, Record<string, unknown>[]> = {}\n\n    if (operation === 'update') {\n      for (const blockName of rowToInsert.blocksToDelete) {\n        const blockTableName = adapter.tableNameMap.get(`${tableName}_blocks_${blockName}`)\n        const blockTable = adapter.tables[blockTableName]\n        await adapter.deleteWhere({\n          db,\n          tableName: blockTableName,\n          where: eq(blockTable._parentID, insertedRow.id),\n        })\n      }\n    }\n\n    for (const [blockName, blockRows] of Object.entries(blocksToInsert)) {\n      const blockTableName = adapter.tableNameMap.get(`${tableName}_blocks_${blockName}`)\n      insertedBlockRows[blockName] = await adapter.insert({\n        db,\n        tableName: blockTableName,\n        values: blockRows.map(({ row }) => row),\n      })\n\n      insertedBlockRows[blockName].forEach((row, i) => {\n        blockRows[i].row = row\n      })\n\n      const blockLocaleIndexMap: number[] = []\n\n      const blockLocaleRowsToInsert = blockRows.reduce((acc, blockRow, i) => {\n        if (Object.entries(blockRow.locales).length > 0) {\n          Object.entries(blockRow.locales).forEach(([blockLocale, blockLocaleData]) => {\n            if (Object.keys(blockLocaleData).length > 0) {\n              blockLocaleData._parentID = blockRow.row.id\n              blockLocaleData._locale = blockLocale\n              acc.push(blockLocaleData)\n              blockLocaleIndexMap.push(i)\n            }\n          })\n        }\n\n        return acc\n      }, [])\n\n      if (blockLocaleRowsToInsert.length > 0) {\n        await adapter.insert({\n          db,\n          tableName: `${blockTableName}${adapter.localesSuffix}`,\n          values: blockLocaleRowsToInsert,\n        })\n      }\n\n      await insertArrays({\n        adapter,\n        arrays: blockRows.map(({ arrays }) => arrays),\n        db,\n        parentRows: insertedBlockRows[blockName],\n      })\n    }\n\n    // //////////////////////////////////\n    // INSERT ARRAYS RECURSIVELY\n    // //////////////////////////////////\n\n    if (operation === 'update') {\n      for (const arrayTableName of Object.keys(rowToInsert.arrays)) {\n        await deleteExistingArrayRows({\n          adapter,\n          db,\n          parentID: insertedRow.id,\n          tableName: arrayTableName,\n        })\n      }\n    }\n\n    await insertArrays({\n      adapter,\n      arrays: [rowToInsert.arrays],\n      db,\n      parentRows: [insertedRow],\n    })\n\n    // //////////////////////////////////\n    // INSERT hasMany SELECTS\n    // //////////////////////////////////\n\n    for (const [selectTableName, tableRows] of Object.entries(selectsToInsert)) {\n      const selectTable = adapter.tables[selectTableName]\n      if (operation === 'update') {\n        await adapter.deleteWhere({\n          db,\n          tableName: selectTableName,\n          where: eq(selectTable.parent, insertedRow.id),\n        })\n      }\n      await adapter.insert({\n        db,\n        tableName: selectTableName,\n        values: tableRows,\n      })\n    }\n\n    // //////////////////////////////////\n    // Error Handling\n    // //////////////////////////////////\n  } catch (error) {\n    if (error.code === '23505') {\n      let fieldName: null | string = null\n      // We need to try and find the right constraint for the field but if we can't we fallback to a generic message\n      if (adapter.fieldConstraints?.[tableName]) {\n        if (adapter.fieldConstraints[tableName]?.[error.constraint]) {\n          fieldName = adapter.fieldConstraints[tableName]?.[error.constraint]\n        } else {\n          const replacement = `${tableName}_`\n\n          if (error.constraint.includes(replacement)) {\n            const replacedConstraint = error.constraint.replace(replacement, '')\n\n            if (replacedConstraint && adapter.fieldConstraints[tableName]?.[replacedConstraint]) {\n              fieldName = adapter.fieldConstraints[tableName][replacedConstraint]\n            }\n          }\n        }\n      }\n\n      if (!fieldName) {\n        // Last case scenario we extract the key and value from the detail on the error\n        const detail = error.detail\n        const regex = /Key \\(([^)]+)\\)=\\(([^)]+)\\)/\n        const match = detail.match(regex)\n\n        if (match) {\n          const key = match[1]\n\n          fieldName = key\n        }\n      }\n\n      throw new ValidationError(\n        {\n          id,\n          errors: [\n            {\n              field: fieldName,\n              message: req.t('error:valueMustBeUnique'),\n            },\n          ],\n        },\n        req.t,\n      )\n    } else {\n      throw error\n    }\n  }\n\n  if (ignoreResult) {\n    return data as T\n  }\n\n  // //////////////////////////////////\n  // RETRIEVE NEWLY UPDATED ROW\n  // //////////////////////////////////\n\n  const findManyArgs = buildFindManyArgs({\n    adapter,\n    depth: 0,\n    fields,\n    joinQuery,\n    tableName,\n  })\n\n  findManyArgs.where = eq(adapter.tables[tableName].id, insertedRow.id)\n\n  const doc = await db.query[tableName].findFirst(findManyArgs)\n\n  // //////////////////////////////////\n  // TRANSFORM DATA\n  // //////////////////////////////////\n\n  const result = transform<T>({\n    adapter,\n    config: adapter.payload.config,\n    data: doc,\n    fields,\n    joinQuery,\n  })\n\n  return result\n}\n"],"names":["eq","ValidationError","buildFindManyArgs","transform","transformForWrite","deleteExistingArrayRows","deleteExistingRowsByPath","insertArrays","upsertRow","id","adapter","data","db","fields","ignoreResult","joinQuery","operation","path","req","tableName","upsertTarget","where","rowToInsert","insertedRow","target","tables","row","insert","onConflictDoUpdate","set","values","localesToInsert","relationsToInsert","textsToInsert","numbersToInsert","blocksToInsert","selectsToInsert","Object","keys","locales","length","entries","forEach","locale","localeRow","_parentID","_locale","push","relationships","relation","parent","texts","textRow","numbers","numberRow","selects","selectTableName","selectRows","blocks","blockName","blockRow","uuid","localeTableName","localesSuffix","localeTable","deleteWhere","relationshipsTableName","relationshipsSuffix","localeColumnName","parentColumnName","parentID","pathColumnName","rows","relationshipsToDelete","textsTableName","numbersTableName","insertedBlockRows","blocksToDelete","blockTableName","tableNameMap","get","blockTable","blockRows","map","i","blockLocaleIndexMap","blockLocaleRowsToInsert","reduce","acc","blockLocale","blockLocaleData","arrays","parentRows","arrayTableName","tableRows","selectTable","error","code","fieldName","fieldConstraints","constraint","replacement","includes","replacedConstraint","replace","detail","regex","match","key","errors","field","message","t","findManyArgs","depth","doc","query","findFirst","result","config","payload"],"mappings":"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"}},
    {"offset": {"line": 3862, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 3868, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/@payloadcms/db-postgres/node_modules/@payloadcms/drizzle/src/create.ts"],"sourcesContent":["import type { Create } from 'payload'\n\nimport toSnakeCase from 'to-snake-case'\n\nimport type { DrizzleAdapter } from './types.js'\n\nimport { upsertRow } from './upsertRow/index.js'\n\nexport const create: Create = async function create(\n  this: DrizzleAdapter,\n  { collection: collectionSlug, data, req },\n) {\n  const db = this.sessions[await req?.transactionID]?.db || this.drizzle\n  const collection = this.payload.collections[collectionSlug].config\n\n  const tableName = this.tableNameMap.get(toSnakeCase(collection.slug))\n\n  const result = await upsertRow({\n    adapter: this,\n    data,\n    db,\n    fields: collection.fields,\n    operation: 'create',\n    req,\n    tableName,\n  })\n\n  return result\n}\n"],"names":["toSnakeCase","upsertRow","create","collection","collectionSlug","data","req","db","sessions","transactionID","drizzle","payload","collections","config","tableName","tableNameMap","get","slug","result","adapter","fields","operation"],"mappings":";;;AAEA,OAAOA,iBAAiB,gBAAe;AAIvC,SAASC,SAAS,QAAQ,uBAAsB;;;AAEzC,MAAMC,SAAiB,eAAeA,OAE3C,EAAEC,YAAYC,cAAc,EAAEC,IAAI,EAAEC,GAAG,EAAE;IAEzC,MAAMC,KAAK,IAAI,CAACC,QAAQ,CAAC,MAAMF,KAAKG,cAAc,EAAEF,MAAM,IAAI,CAACG,OAAO;IACtE,MAAMP,aAAa,IAAI,CAACQ,OAAO,CAACC,WAAW,CAACR,eAAe,CAACS,MAAM;IAElE,MAAMC,YAAY,IAAI,CAACC,YAAY,CAACC,GAAG,kJAAChB,UAAAA,EAAYG,WAAWc,IAAI;IAEnE,MAAMC,SAAS,kOAAMjB,YAAAA,EAAU;QAC7BkB,SAAS,IAAI;QACbd;QACAE;QACAa,QAAQjB,WAAWiB,MAAM;QACzBC,WAAW;QACXf;QACAQ;IACF;IAEA,OAAOI;AACT,EAAC"}},
    {"offset": {"line": 3890, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 3896, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/@payloadcms/db-postgres/node_modules/@payloadcms/drizzle/src/createGlobal.ts"],"sourcesContent":["import type { CreateGlobalArgs, PayloadRequest } from 'payload'\n\nimport toSnakeCase from 'to-snake-case'\n\nimport type { DrizzleAdapter } from './types.js'\n\nimport { upsertRow } from './upsertRow/index.js'\n\nexport async function createGlobal<T extends Record<string, unknown>>(\n  this: DrizzleAdapter,\n  { slug, data, req = {} as PayloadRequest }: CreateGlobalArgs,\n): Promise<T> {\n  const db = this.sessions[await req?.transactionID]?.db || this.drizzle\n  const globalConfig = this.payload.globals.config.find((config) => config.slug === slug)\n\n  const tableName = this.tableNameMap.get(toSnakeCase(globalConfig.slug))\n\n  const result = await upsertRow<T>({\n    adapter: this,\n    data,\n    db,\n    fields: globalConfig.fields,\n    operation: 'create',\n    req,\n    tableName,\n  })\n\n  return result\n}\n"],"names":["toSnakeCase","upsertRow","createGlobal","slug","data","req","db","sessions","transactionID","drizzle","globalConfig","payload","globals","config","find","tableName","tableNameMap","get","result","adapter","fields","operation"],"mappings":";;;AAEA,OAAOA,iBAAiB,gBAAe;AAIvC,SAASC,SAAS,QAAQ,uBAAsB;;;AAEzC,eAAeC,aAEpB,EAAEC,IAAI,EAAEC,IAAI,EAAEC,MAAM,CAAC,CAAmB,EAAoB;IAE5D,MAAMC,KAAK,IAAI,CAACC,QAAQ,CAAC,MAAMF,KAAKG,cAAc,EAAEF,MAAM,IAAI,CAACG,OAAO;IACtE,MAAMC,eAAe,IAAI,CAACC,OAAO,CAACC,OAAO,CAACC,MAAM,CAACC,IAAI,CAAC,CAACD,SAAWA,OAAOV,IAAI,KAAKA;IAElF,MAAMY,YAAY,IAAI,CAACC,YAAY,CAACC,GAAG,kJAACjB,UAAAA,EAAYU,aAAaP,IAAI;IAErE,MAAMe,SAAS,kOAAMjB,YAAAA,EAAa;QAChCkB,SAAS,IAAI;QACbf;QACAE;QACAc,QAAQV,aAAaU,MAAM;QAC3BC,WAAW;QACXhB;QACAU;IACF;IAEA,OAAOG;AACT"}},
    {"offset": {"line": 3918, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 3924, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/@payloadcms/db-postgres/node_modules/@payloadcms/drizzle/src/createGlobalVersion.ts"],"sourcesContent":["import type { CreateGlobalVersionArgs, PayloadRequest, TypeWithID, TypeWithVersion } from 'payload'\n\nimport { sql } from 'drizzle-orm'\nimport { buildVersionGlobalFields } from 'payload'\nimport toSnakeCase from 'to-snake-case'\n\nimport type { DrizzleAdapter } from './types.js'\n\nimport { upsertRow } from './upsertRow/index.js'\n\nexport async function createGlobalVersion<T extends TypeWithID>(\n  this: DrizzleAdapter,\n  {\n    autosave,\n    createdAt,\n    globalSlug,\n    publishedLocale,\n    req = {} as PayloadRequest,\n    snapshot,\n    updatedAt,\n    versionData,\n  }: CreateGlobalVersionArgs,\n) {\n  const db = this.sessions[await req?.transactionID]?.db || this.drizzle\n  const global = this.payload.globals.config.find(({ slug }) => slug === globalSlug)\n\n  const tableName = this.tableNameMap.get(`_${toSnakeCase(global.slug)}${this.versionsSuffix}`)\n\n  const result = await upsertRow<TypeWithVersion<T>>({\n    adapter: this,\n    data: {\n      autosave,\n      createdAt,\n      latest: true,\n      publishedLocale,\n      snapshot,\n      updatedAt,\n      version: versionData,\n    },\n    db,\n    fields: buildVersionGlobalFields(this.payload.config, global),\n    operation: 'create',\n    req,\n    tableName,\n  })\n\n  const table = this.tables[tableName]\n  if (global.versions.drafts) {\n    await this.execute({\n      db,\n      sql: sql`\n          UPDATE ${table}\n          SET latest = false\n          WHERE ${table.id} != ${result.id};\n        `,\n    })\n  }\n\n  return result\n}\n"],"names":["sql","buildVersionGlobalFields","toSnakeCase","upsertRow","createGlobalVersion","autosave","createdAt","globalSlug","publishedLocale","req","snapshot","updatedAt","versionData","db","sessions","transactionID","drizzle","global","payload","globals","config","find","slug","tableName","tableNameMap","get","versionsSuffix","result","adapter","data","latest","version","fields","operation","table","tables","versions","drafts","execute","id"],"mappings":";;;AAIA,OAAOE,iBAAiB,gBAAe;AAIvC,SAASC,SAAS,QAAQ,uBAAsB;AALhD,SAASF,wBAAwB,QAAQ,UAAS;AADlD,SAASD,GAAG,QAAQ,cAAa;;;;;AAQ1B,eAAeI,oBAEpB,EACEC,QAAQ,EACRC,SAAS,EACTC,UAAU,EACVC,eAAe,EACfC,MAAM,CAAC,CAAmB,EAC1BC,QAAQ,EACRC,SAAS,EACTC,WAAW,EACa;IAE1B,MAAMC,KAAK,IAAI,CAACC,QAAQ,CAAC,MAAML,KAAKM,cAAc,EAAEF,MAAM,IAAI,CAACG,OAAO;IACtE,MAAMC,SAAS,IAAI,CAACC,OAAO,CAACC,OAAO,CAACC,MAAM,CAACC,IAAI,CAAC,CAAC,EAAEC,IAAI,EAAE,GAAKA,SAASf;IAEvE,MAAMgB,YAAY,IAAI,CAACC,YAAY,CAACC,GAAG,CAAC,CAAC,CAAC,GAAEvB,0JAAAA,EAAYe,OAAOK,IAAI,EAAE,EAAE,IAAI,CAACI,cAAc,CAAC,CAAC;IAE5F,MAAMC,SAAS,kOAAMxB,YAAAA,EAA8B;QACjDyB,SAAS,IAAI;QACbC,MAAM;YACJxB;YACAC;YACAwB,QAAQ;YACRtB;YACAE;YACAC;YACAoB,SAASnB;QACX;QACAC;QACAmB,SAAQ/B,+LAAAA,EAAyB,IAAI,CAACiB,OAAO,CAACE,MAAM,EAAEH;QACtDgB,WAAW;QACXxB;QACAc;IACF;IAEA,MAAMW,QAAQ,IAAI,CAACC,MAAM,CAACZ,UAAU;IACpC,IAAIN,OAAOmB,QAAQ,CAACC,MAAM,EAAE;QAC1B,MAAM,IAAI,CAACC,OAAO,CAAC;YACjBzB;YACAb,oMAAKA,MAAG,CAAC;iBACE,EAAEkC,MAAM;;gBAET,EAAEA,MAAMK,EAAE,CAAC,IAAI,EAAEZ,OAAOY,EAAE,CAAC;QACnC,CAAC;QACL;IACF;IAEA,OAAOZ;AACT"}},
    {"offset": {"line": 3969, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 3975, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/@payloadcms/db-postgres/node_modules/@payloadcms/drizzle/src/createTableName.ts"],"sourcesContent":["import type { DBIdentifierName } from 'payload'\n\nimport { APIError } from 'payload'\nimport toSnakeCase from 'to-snake-case'\n\nimport type { DrizzleAdapter } from './types.js'\n\ntype Args = {\n  adapter: Pick<DrizzleAdapter, 'tableNameMap' | 'versionsSuffix'>\n  /** The collection, global or field config **/\n  config: {\n    dbName?: DBIdentifierName\n    enumName?: DBIdentifierName\n    name?: string\n    slug?: string\n  }\n  /** For nested tables passed for the user custom dbName functions to handle their own iterations */\n  parentTableName?: string\n  /** For sub tables (array for example) this needs to include the parentTableName */\n  prefix?: string\n  /** For tables based on fields that could have both enumName and dbName (ie: select with hasMany), default: 'dbName' */\n  target?: 'dbName' | 'enumName'\n  /** Throws error if true for postgres when table and enum names exceed 63 characters */\n  throwValidationError?: boolean\n  /** Adds the versions suffix to the default table name - should only be used on the base collection to avoid duplicate suffixing */\n  versions?: boolean\n  /** Adds the versions suffix to custom dbName only - this is used while creating blocks / selects / arrays / etc */\n  versionsCustomName?: boolean\n}\n\n/**\n * Used to name database enums and tables\n * Returns the table or enum name for a given entity\n */\nexport const createTableName = ({\n  adapter,\n  config: { name, slug },\n  config,\n  parentTableName,\n  prefix = '',\n  target = 'dbName',\n  throwValidationError = false,\n  versions = false,\n  versionsCustomName = false,\n}: Args): string => {\n  let customNameDefinition = config[target]\n\n  let defaultTableName = `${prefix}${toSnakeCase(name ?? slug)}`\n\n  if (versions) {\n    defaultTableName = `_${defaultTableName}${adapter.versionsSuffix}`\n  }\n\n  let customTableNameResult: string\n\n  if (!customNameDefinition && target === 'enumName') {\n    customNameDefinition = config['dbName']\n  }\n\n  if (customNameDefinition) {\n    customTableNameResult =\n      typeof customNameDefinition === 'function'\n        ? customNameDefinition({ tableName: parentTableName })\n        : customNameDefinition\n\n    if (versionsCustomName) {\n      customTableNameResult = `_${customTableNameResult}${adapter.versionsSuffix}`\n    }\n  }\n\n  const result = customTableNameResult || defaultTableName\n\n  adapter.tableNameMap.set(defaultTableName, result)\n\n  if (!throwValidationError) {\n    return result\n  }\n\n  if (result.length > 63) {\n    throw new APIError(\n      `Exceeded max identifier length for table or enum name of 63 characters. Invalid name: ${result}`,\n    )\n  }\n\n  return result\n}\n"],"names":["APIError","toSnakeCase","createTableName","adapter","config","name","slug","parentTableName","prefix","target","throwValidationError","versions","versionsCustomName","customNameDefinition","defaultTableName","versionsSuffix","customTableNameResult","tableName","result","tableNameMap","set","length"],"mappings":";;;AAGA,OAAOC,iBAAiB,gBAAe;AADvC,SAASD,QAAQ,QAAQ,UAAS;;;AAgC3B,MAAME,kBAAkB,CAAC,EAC9BC,OAAO,EACPC,QAAQ,EAAEC,IAAI,EAAEC,IAAI,EAAE,EACtBF,MAAM,EACNG,eAAe,EACfC,SAAS,EAAE,EACXC,SAAS,QAAQ,EACjBC,uBAAuB,KAAK,EAC5BC,WAAW,KAAK,EAChBC,qBAAqB,KAAK,EACrB;IACL,IAAIC,uBAAuBT,MAAM,CAACK,OAAO;IAEzC,IAAIK,mBAAmB,CAAC,EAAEN,OAAO,GAAEP,0JAAAA,EAAYI,QAAQC,MAAM,CAAC;IAE9D,IAAIK,UAAU;QACZG,mBAAmB,CAAC,CAAC,EAAEA,iBAAiB,EAAEX,QAAQY,cAAc,CAAC,CAAC;IACpE;IAEA,IAAIC;IAEJ,IAAI,CAACH,wBAAwBJ,WAAW,YAAY;QAClDI,uBAAuBT,MAAM,CAAC,SAAS;IACzC;IAEA,IAAIS,sBAAsB;QACxBG,wBACE,OAAOH,yBAAyB,aAC5BA,qBAAqB;YAAEI,WAAWV;QAAgB,KAClDM;QAEN,IAAID,oBAAoB;YACtBI,wBAAwB,CAAC,CAAC,EAAEA,sBAAsB,EAAEb,QAAQY,cAAc,CAAC,CAAC;QAC9E;IACF;IAEA,MAAMG,SAASF,yBAAyBF;IAExCX,QAAQgB,YAAY,CAACC,GAAG,CAACN,kBAAkBI;IAE3C,IAAI,CAACR,sBAAsB;QACzB,OAAOQ;IACT;IAEA,IAAIA,OAAOG,MAAM,GAAG,IAAI;QACtB,MAAM,0JAAIrB,WAAAA,CACR,CAAC,sFAAsF,EAAEkB,OAAO,CAAC;IAErG;IAEA,OAAOA;AACT,EAAC"}},
    {"offset": {"line": 4010, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 4016, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/@payloadcms/db-postgres/node_modules/@payloadcms/drizzle/src/createVersion.ts"],"sourcesContent":["import type { CreateVersionArgs, PayloadRequest, TypeWithID, TypeWithVersion } from 'payload'\n\nimport { sql } from 'drizzle-orm'\nimport { buildVersionCollectionFields } from 'payload'\nimport toSnakeCase from 'to-snake-case'\n\nimport type { DrizzleAdapter } from './types.js'\n\nimport { upsertRow } from './upsertRow/index.js'\n\nexport async function createVersion<T extends TypeWithID>(\n  this: DrizzleAdapter,\n  {\n    autosave,\n    collectionSlug,\n    createdAt,\n    parent,\n    publishedLocale,\n    req = {} as PayloadRequest,\n    snapshot,\n    updatedAt,\n    versionData,\n  }: CreateVersionArgs<T>,\n) {\n  const db = this.sessions[await req?.transactionID]?.db || this.drizzle\n  const collection = this.payload.collections[collectionSlug].config\n  const defaultTableName = toSnakeCase(collection.slug)\n\n  const tableName = this.tableNameMap.get(`_${defaultTableName}${this.versionsSuffix}`)\n\n  const version = { ...versionData }\n  if (version.id) {\n    delete version.id\n  }\n\n  const data: Record<string, unknown> = {\n    autosave,\n    createdAt,\n    latest: true,\n    parent,\n    publishedLocale,\n    snapshot,\n    updatedAt,\n    version,\n  }\n\n  const result = await upsertRow<TypeWithVersion<T>>({\n    adapter: this,\n    data,\n    db,\n    fields: buildVersionCollectionFields(this.payload.config, collection),\n    operation: 'create',\n    req,\n    tableName,\n  })\n\n  const table = this.tables[tableName]\n\n  if (collection.versions.drafts) {\n    await this.execute({\n      db,\n      sql: sql`\n        UPDATE ${table}\n        SET latest = false\n        WHERE ${table.id} != ${result.id}\n          AND ${table.parent} = ${parent}\n      `,\n    })\n  }\n\n  return result\n}\n"],"names":["sql","buildVersionCollectionFields","toSnakeCase","upsertRow","createVersion","autosave","collectionSlug","createdAt","parent","publishedLocale","req","snapshot","updatedAt","versionData","db","sessions","transactionID","drizzle","collection","payload","collections","config","defaultTableName","slug","tableName","tableNameMap","get","versionsSuffix","version","id","data","latest","result","adapter","fields","operation","table","tables","versions","drafts","execute"],"mappings":";;;AAIA,OAAOE,iBAAiB,gBAAe;AAIvC,SAASC,SAAS,QAAQ,uBAAsB;AALhD,SAASF,4BAA4B,QAAQ,UAAS;AADtD,SAASD,GAAG,QAAQ,cAAa;;;;;AAQ1B,eAAeI,cAEpB,EACEC,QAAQ,EACRC,cAAc,EACdC,SAAS,EACTC,MAAM,EACNC,eAAe,EACfC,MAAM,CAAC,CAAmB,EAC1BC,QAAQ,EACRC,SAAS,EACTC,WAAW,EACU;IAEvB,MAAMC,KAAK,IAAI,CAACC,QAAQ,CAAC,MAAML,KAAKM,cAAc,EAAEF,MAAM,IAAI,CAACG,OAAO;IACtE,MAAMC,aAAa,IAAI,CAACC,OAAO,CAACC,WAAW,CAACd,eAAe,CAACe,MAAM;IAClE,MAAMC,oBAAmBpB,0JAAAA,EAAYgB,WAAWK,IAAI;IAEpD,MAAMC,YAAY,IAAI,CAACC,YAAY,CAACC,GAAG,CAAC,CAAC,CAAC,EAAEJ,iBAAiB,EAAE,IAAI,CAACK,cAAc,CAAC,CAAC;IAEpF,MAAMC,UAAU;QAAE,GAAGf,WAAW;IAAC;IACjC,IAAIe,QAAQC,EAAE,EAAE;QACd,OAAOD,QAAQC,EAAE;IACnB;IAEA,MAAMC,OAAgC;QACpCzB;QACAE;QACAwB,QAAQ;QACRvB;QACAC;QACAE;QACAC;QACAgB;IACF;IAEA,MAAMI,SAAS,MAAM7B,wOAAAA,EAA8B;QACjD8B,SAAS,IAAI;QACbH;QACAhB;QACAoB,iLAAQjC,+BAAAA,EAA6B,IAAI,CAACkB,OAAO,CAACE,MAAM,EAAEH;QAC1DiB,WAAW;QACXzB;QACAc;IACF;IAEA,MAAMY,QAAQ,IAAI,CAACC,MAAM,CAACb,UAAU;IAEpC,IAAIN,WAAWoB,QAAQ,CAACC,MAAM,EAAE;QAC9B,MAAM,IAAI,CAACC,OAAO,CAAC;YACjB1B;YACAd,oMAAKA,MAAG,CAAC;eACA,EAAEoC,MAAM;;cAET,EAAEA,MAAMP,EAAE,CAAC,IAAI,EAAEG,OAAOH,EAAE,CAAC;cAC3B,EAAEO,MAAM5B,MAAM,CAAC,GAAG,EAAEA,OAAO;MACnC,CAAC;QACH;IACF;IAEA,OAAOwB;AACT"}},
    {"offset": {"line": 4071, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 4077, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/@payloadcms/db-postgres/node_modules/@payloadcms/drizzle/src/queries/selectDistinct.ts"],"sourcesContent":["import type { QueryPromise, SQL } from 'drizzle-orm'\nimport type { SQLiteColumn } from 'drizzle-orm/sqlite-core'\n\nimport type { ChainedMethods } from '../find/chainMethods.js'\nimport type {\n  DrizzleAdapter,\n  DrizzleTransaction,\n  GenericColumn,\n  GenericPgColumn,\n  TransactionPg,\n  TransactionSQLite,\n} from '../types.js'\nimport type { BuildQueryJoinAliases } from './buildQuery.js'\n\nimport { chainMethods } from '../find/chainMethods.js'\n\ntype Args = {\n  adapter: DrizzleAdapter\n  chainedMethods?: ChainedMethods\n  db: DrizzleAdapter['drizzle'] | DrizzleTransaction\n  joins: BuildQueryJoinAliases\n  selectFields: Record<string, GenericColumn>\n  tableName: string\n  where: SQL\n}\n\n/**\n * Selects distinct records from a table only if there are joins that need to be used, otherwise return null\n */\nexport const selectDistinct = ({\n  adapter,\n  chainedMethods = [],\n  db,\n  joins,\n  selectFields,\n  tableName,\n  where,\n}: Args): QueryPromise<{ id: number | string }[] & Record<string, GenericColumn>> => {\n  if (Object.keys(joins).length > 0) {\n    if (where) {\n      chainedMethods.push({ args: [where], method: 'where' })\n    }\n\n    joins.forEach(({ condition, table }) => {\n      chainedMethods.push({\n        args: [table, condition],\n        method: 'leftJoin',\n      })\n    })\n\n    let query\n    const table = adapter.tables[tableName]\n\n    if (adapter.name === 'postgres') {\n      query = (db as TransactionPg)\n        .selectDistinct(selectFields as Record<string, GenericPgColumn>)\n        .from(table)\n    }\n    if (adapter.name === 'sqlite') {\n      query = (db as TransactionSQLite)\n        .selectDistinct(selectFields as Record<string, SQLiteColumn>)\n        .from(table)\n    }\n\n    return chainMethods({\n      methods: chainedMethods,\n      query,\n    })\n  }\n}\n"],"names":["chainMethods","selectDistinct","adapter","chainedMethods","db","joins","selectFields","tableName","where","Object","keys","length","push","args","method","forEach","condition","table","query","tables","name","from","methods"],"mappings":";;;AAcA,SAASA,YAAY,QAAQ,0BAAyB;;AAe/C,MAAMC,iBAAiB,CAAC,EAC7BC,OAAO,EACPC,iBAAiB,EAAE,EACnBC,EAAE,EACFC,KAAK,EACLC,YAAY,EACZC,SAAS,EACTC,KAAK,EACA;IACL,IAAIC,OAAOC,IAAI,CAACL,OAAOM,MAAM,GAAG,GAAG;QACjC,IAAIH,OAAO;YACTL,eAAeS,IAAI,CAAC;gBAAEC,MAAM;oBAACL;iBAAM;gBAAEM,QAAQ;YAAQ;QACvD;QAEAT,MAAMU,OAAO,CAAC,CAAC,EAAEC,SAAS,EAAEC,KAAK,EAAE;YACjCd,eAAeS,IAAI,CAAC;gBAClBC,MAAM;oBAACI;oBAAOD;iBAAU;gBACxBF,QAAQ;YACV;QACF;QAEA,IAAII;QACJ,MAAMD,QAAQf,QAAQiB,MAAM,CAACZ,UAAU;QAEvC,IAAIL,QAAQkB,IAAI,KAAK,YAAY;YAC/BF,QAASd,GACNH,cAAc,CAACK,cACfe,IAAI,CAACJ;QACV;QACA,IAAIf,QAAQkB,IAAI,KAAK,UAAU;YAC7BF,QAASd,GACNH,cAAc,CAACK,cACfe,IAAI,CAACJ;QACV;QAEA,qOAAOjB,eAAAA,EAAa;YAClBsB,SAASnB;YACTe;QACF;IACF;AACF,EAAC"}},
    {"offset": {"line": 4115, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 4121, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/@payloadcms/db-postgres/node_modules/@payloadcms/drizzle/src/find/findMany.ts"],"sourcesContent":["import type { Field, FindArgs, PayloadRequest, TypeWithID } from 'payload'\n\nimport { inArray } from 'drizzle-orm'\n\nimport type { DrizzleAdapter } from '../types.js'\nimport type { ChainedMethods } from './chainMethods.js'\n\nimport buildQuery from '../queries/buildQuery.js'\nimport { selectDistinct } from '../queries/selectDistinct.js'\nimport { transform } from '../transform/read/index.js'\nimport { buildFindManyArgs } from './buildFindManyArgs.js'\n\ntype Args = {\n  adapter: DrizzleAdapter\n  fields: Field[]\n  tableName: string\n  versions?: boolean\n} & Omit<FindArgs, 'collection'>\n\nexport const findMany = async function find({\n  adapter,\n  fields,\n  joins: joinQuery,\n  limit: limitArg,\n  locale,\n  page = 1,\n  pagination,\n  req = {} as PayloadRequest,\n  skip,\n  sort,\n  tableName,\n  versions,\n  where: whereArg,\n}: Args) {\n  const db = adapter.sessions[await req.transactionID]?.db || adapter.drizzle\n  let limit = limitArg\n  let totalDocs: number\n  let totalPages: number\n  let hasPrevPage: boolean\n  let hasNextPage: boolean\n  let pagingCounter: number\n  const offset = skip || (page - 1) * limit\n\n  if (limit === 0) {\n    limit = undefined\n  }\n\n  const { joins, orderBy, selectFields, where } = buildQuery({\n    adapter,\n    fields,\n    locale,\n    sort,\n    tableName,\n    where: whereArg,\n  })\n\n  const orderedIDMap: Record<number | string, number> = {}\n  let orderedIDs: (number | string)[]\n\n  const selectDistinctMethods: ChainedMethods = []\n\n  if (orderBy) {\n    selectDistinctMethods.push({\n      args: [() => orderBy.map(({ column, order }) => order(column))],\n      method: 'orderBy',\n    })\n  }\n\n  const findManyArgs = buildFindManyArgs({\n    adapter,\n    depth: 0,\n    fields,\n    joinQuery,\n    joins,\n    tableName,\n    versions,\n  })\n\n  selectDistinctMethods.push({ args: [offset], method: 'offset' })\n  selectDistinctMethods.push({ args: [limit], method: 'limit' })\n\n  const selectDistinctResult = await selectDistinct({\n    adapter,\n    chainedMethods: selectDistinctMethods,\n    db,\n    joins,\n    selectFields,\n    tableName,\n    where,\n  })\n\n  if (selectDistinctResult) {\n    if (selectDistinctResult.length === 0) {\n      return {\n        docs: [],\n        hasNextPage: false,\n        hasPrevPage: false,\n        limit,\n        nextPage: null,\n        page: 1,\n        pagingCounter: 0,\n        prevPage: null,\n        totalDocs: 0,\n        totalPages: 0,\n      }\n    } else {\n      // set the id in an object for sorting later\n      selectDistinctResult.forEach(({ id }, i) => {\n        orderedIDMap[id] = i\n      })\n      orderedIDs = Object.keys(orderedIDMap)\n      findManyArgs.where = inArray(adapter.tables[tableName].id, orderedIDs)\n    }\n  } else {\n    findManyArgs.limit = limit\n    findManyArgs.offset = offset\n    findManyArgs.orderBy = () => orderBy.map(({ column, order }) => order(column))\n\n    if (where) {\n      findManyArgs.where = where\n    }\n  }\n\n  const findPromise = db.query[tableName].findMany(findManyArgs)\n\n  if (pagination !== false && (orderedIDs ? orderedIDs?.length <= limit : true)) {\n    totalDocs = await adapter.countDistinct({\n      db,\n      joins,\n      tableName,\n      where,\n    })\n\n    totalPages = typeof limit === 'number' && limit !== 0 ? Math.ceil(totalDocs / limit) : 1\n    hasPrevPage = page > 1\n    hasNextPage = totalPages > page\n    pagingCounter = (page - 1) * limit + 1\n  }\n\n  const rawDocs = await findPromise\n  // sort rawDocs from selectQuery\n  if (Object.keys(orderedIDMap).length > 0) {\n    rawDocs.sort((a, b) => orderedIDMap[a.id] - orderedIDMap[b.id])\n  }\n\n  if (pagination === false || !totalDocs) {\n    totalDocs = rawDocs.length\n    totalPages = 1\n    pagingCounter = 1\n    hasPrevPage = false\n    hasNextPage = false\n  }\n\n  const docs = rawDocs.map((data: TypeWithID) => {\n    return transform({\n      adapter,\n      config: adapter.payload.config,\n      data,\n      fields,\n      joinQuery,\n    })\n  })\n\n  return {\n    docs,\n    hasNextPage,\n    hasPrevPage,\n    limit: limitArg,\n    nextPage: hasNextPage ? page + 1 : null,\n    page,\n    pagingCounter,\n    prevPage: hasPrevPage ? page - 1 : null,\n    totalDocs,\n    totalPages,\n  }\n}\n"],"names":["inArray","buildQuery","selectDistinct","transform","buildFindManyArgs","findMany","find","adapter","fields","joins","joinQuery","limit","limitArg","locale","page","pagination","req","skip","sort","tableName","versions","where","whereArg","db","sessions","transactionID","drizzle","totalDocs","totalPages","hasPrevPage","hasNextPage","pagingCounter","offset","undefined","orderBy","selectFields","orderedIDMap","orderedIDs","selectDistinctMethods","push","args","map","column","order","method","findManyArgs","depth","selectDistinctResult","chainedMethods","length","docs","nextPage","prevPage","forEach","id","i","Object","keys","tables","findPromise","query","countDistinct","Math","ceil","rawDocs","a","b","data","config","payload"],"mappings":"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"}},
    {"offset": {"line": 4272, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 4278, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/@payloadcms/db-postgres/node_modules/@payloadcms/drizzle/src/deleteMany.ts"],"sourcesContent":["import type { DeleteMany, PayloadRequest } from 'payload'\n\nimport { inArray } from 'drizzle-orm'\nimport toSnakeCase from 'to-snake-case'\n\nimport type { DrizzleAdapter } from './types.js'\n\nimport { findMany } from './find/findMany.js'\n\nexport const deleteMany: DeleteMany = async function deleteMany(\n  this: DrizzleAdapter,\n  { collection, req = {} as PayloadRequest, where },\n) {\n  const db = this.sessions[await req?.transactionID]?.db || this.drizzle\n  const collectionConfig = this.payload.collections[collection].config\n\n  const tableName = this.tableNameMap.get(toSnakeCase(collectionConfig.slug))\n\n  const result = await findMany({\n    adapter: this,\n    fields: collectionConfig.fields,\n    limit: 0,\n    locale: req.locale,\n    page: 1,\n    pagination: false,\n    req,\n    tableName,\n    where,\n  })\n\n  const ids = []\n\n  result.docs.forEach((data) => {\n    ids.push(data.id)\n  })\n\n  if (ids.length > 0) {\n    await this.deleteWhere({\n      db,\n      tableName,\n      where: inArray(this.tables[tableName].id, ids),\n    })\n  }\n}\n"],"names":["inArray","toSnakeCase","findMany","deleteMany","collection","req","where","db","sessions","transactionID","drizzle","collectionConfig","payload","collections","config","tableName","tableNameMap","get","slug","result","adapter","fields","limit","locale","page","pagination","ids","docs","forEach","data","push","id","length","deleteWhere","tables"],"mappings":";;;AAGA,OAAOC,iBAAiB,gBAAe;AAIvC,SAASC,QAAQ,QAAQ,qBAAoB;AAL7C,SAASF,OAAO,QAAQ,cAAa;;;;AAO9B,MAAMG,aAAyB,eAAeA,WAEnD,EAAEC,UAAU,EAAEC,MAAM,CAAC,CAAmB,EAAEC,KAAK,EAAE;IAEjD,MAAMC,KAAK,IAAI,CAACC,QAAQ,CAAC,MAAMH,KAAKI,cAAc,EAAEF,MAAM,IAAI,CAACG,OAAO;IACtE,MAAMC,mBAAmB,IAAI,CAACC,OAAO,CAACC,WAAW,CAACT,WAAW,CAACU,MAAM;IAEpE,MAAMC,YAAY,IAAI,CAACC,YAAY,CAACC,GAAG,kJAAChB,UAAAA,EAAYU,iBAAiBO,IAAI;IAEzE,MAAMC,SAAS,gOAAMjB,WAAAA,EAAS;QAC5BkB,SAAS,IAAI;QACbC,QAAQV,iBAAiBU,MAAM;QAC/BC,OAAO;QACPC,QAAQlB,IAAIkB,MAAM;QAClBC,MAAM;QACNC,YAAY;QACZpB;QACAU;QACAT;IACF;IAEA,MAAMoB,MAAM,EAAE;IAEdP,OAAOQ,IAAI,CAACC,OAAO,CAAC,CAACC;QACnBH,IAAII,IAAI,CAACD,KAAKE,EAAE;IAClB;IAEA,IAAIL,IAAIM,MAAM,GAAG,GAAG;QAClB,MAAM,IAAI,CAACC,WAAW,CAAC;YACrB1B;YACAQ;YACAT,gOAAON,UAAAA,EAAQ,IAAI,CAACkC,MAAM,CAACnB,UAAU,CAACgB,EAAE,EAAEL;QAC5C;IACF;AACF,EAAC"}},
    {"offset": {"line": 4314, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 4320, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/@payloadcms/db-postgres/node_modules/@payloadcms/drizzle/src/deleteOne.ts"],"sourcesContent":["import type { DeleteOne, PayloadRequest } from 'payload'\n\nimport { eq } from 'drizzle-orm'\nimport toSnakeCase from 'to-snake-case'\n\nimport type { DrizzleAdapter } from './types.js'\n\nimport { buildFindManyArgs } from './find/buildFindManyArgs.js'\nimport buildQuery from './queries/buildQuery.js'\nimport { selectDistinct } from './queries/selectDistinct.js'\nimport { transform } from './transform/read/index.js'\n\nexport const deleteOne: DeleteOne = async function deleteOne(\n  this: DrizzleAdapter,\n  { collection: collectionSlug, joins: joinQuery, req = {} as PayloadRequest, where: whereArg },\n) {\n  const db = this.sessions[await req?.transactionID]?.db || this.drizzle\n  const collection = this.payload.collections[collectionSlug].config\n\n  const tableName = this.tableNameMap.get(toSnakeCase(collection.slug))\n\n  let docToDelete: Record<string, unknown>\n\n  const { joins, selectFields, where } = buildQuery({\n    adapter: this,\n    fields: collection.fields,\n    locale: req.locale,\n    tableName,\n    where: whereArg,\n  })\n\n  const selectDistinctResult = await selectDistinct({\n    adapter: this,\n    chainedMethods: [{ args: [1], method: 'limit' }],\n    db,\n    joins,\n    selectFields,\n    tableName,\n    where,\n  })\n\n  if (selectDistinctResult?.[0]?.id) {\n    docToDelete = await db.query[tableName].findFirst({\n      where: eq(this.tables[tableName].id, selectDistinctResult[0].id),\n    })\n  } else {\n    const findManyArgs = buildFindManyArgs({\n      adapter: this,\n      depth: 0,\n      fields: collection.fields,\n      joinQuery,\n      tableName,\n    })\n\n    findManyArgs.where = where\n\n    docToDelete = await db.query[tableName].findFirst(findManyArgs)\n  }\n\n  const result = transform({\n    adapter: this,\n    config: this.payload.config,\n    data: docToDelete,\n    fields: collection.fields,\n    joinQuery,\n  })\n\n  await this.deleteWhere({\n    db,\n    tableName,\n    where: eq(this.tables[tableName].id, docToDelete.id),\n  })\n\n  return result\n}\n"],"names":["eq","toSnakeCase","buildFindManyArgs","buildQuery","selectDistinct","transform","deleteOne","collection","collectionSlug","joins","joinQuery","req","where","whereArg","db","sessions","transactionID","drizzle","payload","collections","config","tableName","tableNameMap","get","slug","docToDelete","selectFields","adapter","fields","locale","selectDistinctResult","chainedMethods","args","method","id","query","findFirst","tables","findManyArgs","depth","result","data","deleteWhere"],"mappings":";;;AAGA,OAAOC,iBAAiB,gBAAe;AAIvC,SAASC,iBAAiB,QAAQ,8BAA6B;AAC/D,OAAOC,gBAAgB,0BAAyB;AAChD,SAASC,cAAc,QAAQ,8BAA6B;AAC5D,SAASC,SAAS,QAAQ,4BAA2B;AARrD,SAASL,EAAE,QAAQ,cAAa;;;;;;;AAUzB,MAAMM,YAAuB,eAAeA,UAEjD,EAAEC,YAAYC,cAAc,EAAEC,OAAOC,SAAS,EAAEC,MAAM,CAAC,CAAmB,EAAEC,OAAOC,QAAQ,EAAE;IAE7F,MAAMC,KAAK,IAAI,CAACC,QAAQ,CAAC,MAAMJ,KAAKK,cAAc,EAAEF,MAAM,IAAI,CAACG,OAAO;IACtE,MAAMV,aAAa,IAAI,CAACW,OAAO,CAACC,WAAW,CAACX,eAAe,CAACY,MAAM;IAElE,MAAMC,YAAY,IAAI,CAACC,YAAY,CAACC,GAAG,kJAACtB,UAAAA,EAAYM,WAAWiB,IAAI;IAEnE,IAAIC;IAEJ,MAAM,EAAEhB,KAAK,EAAEiB,YAAY,EAAEd,KAAK,EAAE,IAAGT,wOAAAA,EAAW;QAChDwB,SAAS,IAAI;QACbC,QAAQrB,WAAWqB,MAAM;QACzBC,QAAQlB,IAAIkB,MAAM;QAClBR;QACAT,OAAOC;IACT;IAEA,MAAMiB,uBAAuB,yOAAM1B,iBAAAA,EAAe;QAChDuB,SAAS,IAAI;QACbI,gBAAgB;YAAC;gBAAEC,MAAM;oBAAC;iBAAE;gBAAEC,QAAQ;YAAQ;SAAE;QAChDnB;QACAL;QACAiB;QACAL;QACAT;IACF;IAEA,IAAIkB,sBAAsB,CAAC,EAAE,EAAEI,IAAI;QACjCT,cAAc,MAAMX,GAAGqB,KAAK,CAACd,UAAU,CAACe,SAAS,CAAC;YAChDxB,OAAOZ,8NAAAA,EAAG,IAAI,CAACqC,MAAM,CAAChB,UAAU,CAACa,EAAE,EAAEJ,oBAAoB,CAAC,EAAE,CAACI,EAAE;QACjE;IACF,OAAO;QACL,MAAMI,gBAAepC,sPAAAA,EAAkB;YACrCyB,SAAS,IAAI;YACbY,OAAO;YACPX,QAAQrB,WAAWqB,MAAM;YACzBlB;YACAW;QACF;QAEAiB,aAAa1B,KAAK,GAAGA;QAErBa,cAAc,MAAMX,GAAGqB,KAAK,CAACd,UAAU,CAACe,SAAS,CAACE;IACpD;IAEA,MAAME,UAASnC,+OAAAA,EAAU;QACvBsB,SAAS,IAAI;QACbP,QAAQ,IAAI,CAACF,OAAO,CAACE,MAAM;QAC3BqB,MAAMhB;QACNG,QAAQrB,WAAWqB,MAAM;QACzBlB;IACF;IAEA,MAAM,IAAI,CAACgC,WAAW,CAAC;QACrB5B;QACAO;QACAT,gOAAOZ,KAAAA,EAAG,IAAI,CAACqC,MAAM,CAAChB,UAAU,CAACa,EAAE,EAAET,YAAYS,EAAE;IACrD;IAEA,OAAOM;AACT,EAAC"}},
    {"offset": {"line": 4392, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 4398, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/@payloadcms/db-postgres/node_modules/@payloadcms/drizzle/src/deleteVersions.ts"],"sourcesContent":["import type { DeleteVersions, PayloadRequest, SanitizedCollectionConfig } from 'payload'\n\nimport { inArray } from 'drizzle-orm'\nimport { buildVersionCollectionFields } from 'payload'\nimport toSnakeCase from 'to-snake-case'\n\nimport type { DrizzleAdapter } from './types.js'\n\nimport { findMany } from './find/findMany.js'\n\nexport const deleteVersions: DeleteVersions = async function deleteVersion(\n  this: DrizzleAdapter,\n  { collection, locale, req = {} as PayloadRequest, where: where },\n) {\n  const db = this.sessions[await req?.transactionID]?.db || this.drizzle\n  const collectionConfig: SanitizedCollectionConfig = this.payload.collections[collection].config\n\n  const tableName = this.tableNameMap.get(\n    `_${toSnakeCase(collectionConfig.slug)}${this.versionsSuffix}`,\n  )\n\n  const fields = buildVersionCollectionFields(this.payload.config, collectionConfig)\n\n  const { docs } = await findMany({\n    adapter: this,\n    fields,\n    limit: 0,\n    locale,\n    page: 1,\n    pagination: false,\n    req,\n    tableName,\n    where,\n  })\n\n  const ids = []\n\n  docs.forEach((doc) => {\n    ids.push(doc.id)\n  })\n\n  if (ids.length > 0) {\n    await this.deleteWhere({\n      db,\n      tableName,\n      where: inArray(this.tables[tableName].id, ids),\n    })\n  }\n\n  return docs\n}\n"],"names":["inArray","buildVersionCollectionFields","toSnakeCase","findMany","deleteVersions","deleteVersion","collection","locale","req","where","db","sessions","transactionID","drizzle","collectionConfig","payload","collections","config","tableName","tableNameMap","get","slug","versionsSuffix","fields","docs","adapter","limit","page","pagination","ids","forEach","doc","push","id","length","deleteWhere","tables"],"mappings":";;;AAIA,OAAOE,iBAAiB,gBAAe;AAIvC,SAASC,QAAQ,QAAQ,qBAAoB;AAL7C,SAASF,4BAA4B,QAAQ,UAAS;AADtD,SAASD,OAAO,QAAQ,cAAa;;;;;AAQ9B,MAAMI,iBAAiC,eAAeC,cAE3D,EAAEC,UAAU,EAAEC,MAAM,EAAEC,MAAM,CAAC,CAAmB,EAAEC,OAAOA,KAAK,EAAE;IAEhE,MAAMC,KAAK,IAAI,CAACC,QAAQ,CAAC,MAAMH,KAAKI,cAAc,EAAEF,MAAM,IAAI,CAACG,OAAO;IACtE,MAAMC,mBAA8C,IAAI,CAACC,OAAO,CAACC,WAAW,CAACV,WAAW,CAACW,MAAM;IAE/F,MAAMC,YAAY,IAAI,CAACC,YAAY,CAACC,GAAG,CACrC,CAAC,CAAC,mJAAElB,UAAAA,EAAYY,iBAAiBO,IAAI,EAAE,EAAE,IAAI,CAACC,cAAc,CAAC,CAAC;IAGhE,MAAMC,kLAAStB,+BAAAA,EAA6B,IAAI,CAACc,OAAO,CAACE,MAAM,EAAEH;IAEjE,MAAM,EAAEU,IAAI,EAAE,GAAG,gOAAMrB,WAAAA,EAAS;QAC9BsB,SAAS,IAAI;QACbF;QACAG,OAAO;QACPnB;QACAoB,MAAM;QACNC,YAAY;QACZpB;QACAU;QACAT;IACF;IAEA,MAAMoB,MAAM,EAAE;IAEdL,KAAKM,OAAO,CAAC,CAACC;QACZF,IAAIG,IAAI,CAACD,IAAIE,EAAE;IACjB;IAEA,IAAIJ,IAAIK,MAAM,GAAG,GAAG;QAClB,MAAM,IAAI,CAACC,WAAW,CAAC;YACrBzB;YACAQ;YACAT,OAAOT,mOAAAA,EAAQ,IAAI,CAACoC,MAAM,CAAClB,UAAU,CAACe,EAAE,EAAEJ;QAC5C;IACF;IAEA,OAAOL;AACT,EAAC"}},
    {"offset": {"line": 4438, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 4444, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/@payloadcms/db-postgres/node_modules/@payloadcms/drizzle/src/destroy.ts"],"sourcesContent":["import type { Destroy } from 'payload'\n\nimport type { DrizzleAdapter } from './types.js'\n\n// eslint-disable-next-line @typescript-eslint/require-await\nexport const destroy: Destroy = async function destroy(this: DrizzleAdapter) {\n  if (this.enums) {\n    this.enums = {}\n  }\n  this.schema = {}\n  this.tables = {}\n  this.relations = {}\n  this.fieldConstraints = {}\n  this.drizzle = undefined\n  this.initializing = new Promise((res, rej) => {\n    this.resolveInitializing = res\n    this.rejectInitializing = rej\n  })\n}\n"],"names":["destroy","enums","schema","tables","relations","fieldConstraints","drizzle","undefined","initializing","Promise","res","rej","resolveInitializing","rejectInitializing"],"mappings":"AAIA,4DAA4D;;;;AACrD,MAAMA,UAAmB,eAAeA;IAC7C,IAAI,IAAI,CAACC,KAAK,EAAE;QACd,IAAI,CAACA,KAAK,GAAG,CAAC;IAChB;IACA,IAAI,CAACC,MAAM,GAAG,CAAC;IACf,IAAI,CAACC,MAAM,GAAG,CAAC;IACf,IAAI,CAACC,SAAS,GAAG,CAAC;IAClB,IAAI,CAACC,gBAAgB,GAAG,CAAC;IACzB,IAAI,CAACC,OAAO,GAAGC;IACf,IAAI,CAACC,YAAY,GAAG,IAAIC,QAAQ,CAACC,KAAKC;QACpC,IAAI,CAACC,mBAAmB,GAAGF;QAC3B,IAAI,CAACG,kBAAkB,GAAGF;IAC5B;AACF,EAAC"}},
    {"offset": {"line": 4462, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 4468, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/@payloadcms/db-postgres/node_modules/@payloadcms/drizzle/src/find.ts"],"sourcesContent":["import type { Find, PayloadRequest, SanitizedCollectionConfig } from 'payload'\n\nimport toSnakeCase from 'to-snake-case'\n\nimport type { DrizzleAdapter } from './types.js'\n\nimport { findMany } from './find/findMany.js'\n\nexport const find: Find = async function find(\n  this: DrizzleAdapter,\n  {\n    collection,\n    joins,\n    limit,\n    locale,\n    page = 1,\n    pagination,\n    req = {} as PayloadRequest,\n    sort: sortArg,\n    where,\n  },\n) {\n  const collectionConfig: SanitizedCollectionConfig = this.payload.collections[collection].config\n  const sort = sortArg !== undefined && sortArg !== null ? sortArg : collectionConfig.defaultSort\n\n  const tableName = this.tableNameMap.get(toSnakeCase(collectionConfig.slug))\n\n  return findMany({\n    adapter: this,\n    fields: collectionConfig.fields,\n    joins,\n    limit,\n    locale,\n    page,\n    pagination,\n    req,\n    sort,\n    tableName,\n    where,\n  })\n}\n"],"names":["toSnakeCase","findMany","find","collection","joins","limit","locale","page","pagination","req","sort","sortArg","where","collectionConfig","payload","collections","config","undefined","defaultSort","tableName","tableNameMap","get","slug","adapter","fields"],"mappings":";;;AAEA,OAAOA,iBAAiB,gBAAe;AAIvC,SAASC,QAAQ,QAAQ,qBAAoB;;;AAEtC,MAAMC,OAAa,eAAeA,KAEvC,EACEC,UAAU,EACVC,KAAK,EACLC,KAAK,EACLC,MAAM,EACNC,OAAO,CAAC,EACRC,UAAU,EACVC,MAAM,CAAC,CAAmB,EAC1BC,MAAMC,OAAO,EACbC,KAAK,EACN;IAED,MAAMC,mBAA8C,IAAI,CAACC,OAAO,CAACC,WAAW,CAACZ,WAAW,CAACa,MAAM;IAC/F,MAAMN,OAAOC,YAAYM,aAAaN,YAAY,OAAOA,UAAUE,iBAAiBK,WAAW;IAE/F,MAAMC,YAAY,IAAI,CAACC,YAAY,CAACC,GAAG,kJAACrB,UAAAA,EAAYa,iBAAiBS,IAAI;IAEzE,iOAAOrB,WAAAA,EAAS;QACdsB,SAAS,IAAI;QACbC,QAAQX,iBAAiBW,MAAM;QAC/BpB;QACAC;QACAC;QACAC;QACAC;QACAC;QACAC;QACAS;QACAP;IACF;AACF,EAAC"}},
    {"offset": {"line": 4493, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 4499, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/@payloadcms/db-postgres/node_modules/@payloadcms/drizzle/src/findGlobal.ts"],"sourcesContent":["import type { FindGlobal } from 'payload'\n\nimport toSnakeCase from 'to-snake-case'\n\nimport type { DrizzleAdapter } from './types.js'\n\nimport { findMany } from './find/findMany.js'\n\nexport const findGlobal: FindGlobal = async function findGlobal(\n  this: DrizzleAdapter,\n  { slug, locale, req, where },\n) {\n  const globalConfig = this.payload.globals.config.find((config) => config.slug === slug)\n\n  const tableName = this.tableNameMap.get(toSnakeCase(globalConfig.slug))\n\n  const {\n    docs: [doc],\n  } = await findMany({\n    adapter: this,\n    fields: globalConfig.fields,\n    limit: 1,\n    locale,\n    pagination: false,\n    req,\n    tableName,\n    where,\n  })\n\n  if (doc) {\n    doc.globalType = slug\n    return doc\n  }\n\n  return {}\n}\n"],"names":["toSnakeCase","findMany","findGlobal","slug","locale","req","where","globalConfig","payload","globals","config","find","tableName","tableNameMap","get","docs","doc","adapter","fields","limit","pagination","globalType"],"mappings":";;;AAEA,OAAOA,iBAAiB,gBAAe;AAIvC,SAASC,QAAQ,QAAQ,qBAAoB;;;AAEtC,MAAMC,aAAyB,eAAeA,WAEnD,EAAEC,IAAI,EAAEC,MAAM,EAAEC,GAAG,EAAEC,KAAK,EAAE;IAE5B,MAAMC,eAAe,IAAI,CAACC,OAAO,CAACC,OAAO,CAACC,MAAM,CAACC,IAAI,CAAC,CAACD,SAAWA,OAAOP,IAAI,KAAKA;IAElF,MAAMS,YAAY,IAAI,CAACC,YAAY,CAACC,GAAG,kJAACd,UAAAA,EAAYO,aAAaJ,IAAI;IAErE,MAAM,EACJY,MAAM,CAACC,IAAI,EACZ,GAAG,gOAAMf,WAAAA,EAAS;QACjBgB,SAAS,IAAI;QACbC,QAAQX,aAAaW,MAAM;QAC3BC,OAAO;QACPf;QACAgB,YAAY;QACZf;QACAO;QACAN;IACF;IAEA,IAAIU,KAAK;QACPA,IAAIK,UAAU,GAAGlB;QACjB,OAAOa;IACT;IAEA,OAAO,CAAC;AACV,EAAC"}},
    {"offset": {"line": 4525, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 4531, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/@payloadcms/db-postgres/node_modules/@payloadcms/drizzle/src/findGlobalVersions.ts"],"sourcesContent":["import type { FindGlobalVersions, PayloadRequest, SanitizedGlobalConfig } from 'payload'\n\nimport { buildVersionGlobalFields } from 'payload'\nimport toSnakeCase from 'to-snake-case'\n\nimport type { DrizzleAdapter } from './types.js'\n\nimport { findMany } from './find/findMany.js'\n\nexport const findGlobalVersions: FindGlobalVersions = async function findGlobalVersions(\n  this: DrizzleAdapter,\n  {\n    global,\n    limit,\n    locale,\n    page,\n    pagination,\n    req = {} as PayloadRequest,\n    skip,\n    sort: sortArg,\n    where,\n  },\n) {\n  const globalConfig: SanitizedGlobalConfig = this.payload.globals.config.find(\n    ({ slug }) => slug === global,\n  )\n  const sort = sortArg !== undefined && sortArg !== null ? sortArg : '-createdAt'\n\n  const tableName = this.tableNameMap.get(\n    `_${toSnakeCase(globalConfig.slug)}${this.versionsSuffix}`,\n  )\n\n  const fields = buildVersionGlobalFields(this.payload.config, globalConfig)\n\n  return findMany({\n    adapter: this,\n    fields,\n    limit,\n    locale,\n    page,\n    pagination,\n    req,\n    skip,\n    sort,\n    tableName,\n    where,\n  })\n}\n"],"names":["buildVersionGlobalFields","toSnakeCase","findMany","findGlobalVersions","global","limit","locale","page","pagination","req","skip","sort","sortArg","where","globalConfig","payload","globals","config","find","slug","undefined","tableName","tableNameMap","get","versionsSuffix","fields","adapter"],"mappings":";;;AAGA,OAAOC,iBAAiB,gBAAe;AAIvC,SAASC,QAAQ,QAAQ,qBAAoB;AAL7C,SAASF,wBAAwB,QAAQ,UAAS;;;;AAO3C,MAAMG,qBAAyC,eAAeA,mBAEnE,EACEC,MAAM,EACNC,KAAK,EACLC,MAAM,EACNC,IAAI,EACJC,UAAU,EACVC,MAAM,CAAC,CAAmB,EAC1BC,IAAI,EACJC,MAAMC,OAAO,EACbC,KAAK,EACN;IAED,MAAMC,eAAsC,IAAI,CAACC,OAAO,CAACC,OAAO,CAACC,MAAM,CAACC,IAAI,CAC1E,CAAC,EAAEC,IAAI,EAAE,GAAKA,SAASf;IAEzB,MAAMO,OAAOC,YAAYQ,aAAaR,YAAY,OAAOA,UAAU;IAEnE,MAAMS,YAAY,IAAI,CAACC,YAAY,CAACC,GAAG,CACrC,CAAC,CAAC,mJAAEtB,UAAAA,EAAYa,aAAaK,IAAI,EAAE,EAAE,IAAI,CAACK,cAAc,CAAC,CAAC;IAG5D,MAAMC,8KAASzB,2BAAAA,EAAyB,IAAI,CAACe,OAAO,CAACE,MAAM,EAAEH;IAE7D,iOAAOZ,WAAAA,EAAS;QACdwB,SAAS,IAAI;QACbD;QACApB;QACAC;QACAC;QACAC;QACAC;QACAC;QACAC;QACAU;QACAR;IACF;AACF,EAAC"}},
    {"offset": {"line": 4559, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 4565, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/@payloadcms/db-postgres/node_modules/@payloadcms/drizzle/src/findMigrationDir.ts"],"sourcesContent":["import fs from 'fs'\nimport path from 'path'\n\n/**\n * Attempt to find migrations directory.\n *\n * Checks for the following directories in order:\n * - `migrationDir` argument from Payload config\n * - `src/migrations`\n * - `dist/migrations`\n * - `migrations`\n *\n * Defaults to `src/migrations`\n *\n * @param migrationDir\n * @returns\n */\nexport function findMigrationDir(migrationDir?: string): string {\n  const cwd = process.cwd()\n  const srcDir = path.resolve(cwd, 'src/migrations')\n  const distDir = path.resolve(cwd, 'dist/migrations')\n  const relativeMigrations = path.resolve(cwd, 'migrations')\n\n  // Use arg if provided\n  if (migrationDir) {\n    return migrationDir\n  }\n\n  // Check other common locations\n  if (fs.existsSync(srcDir)) {\n    return srcDir\n  }\n\n  if (fs.existsSync(distDir)) {\n    return distDir\n  }\n\n  if (fs.existsSync(relativeMigrations)) {\n    return relativeMigrations\n  }\n\n  return srcDir\n}\n"],"names":["fs","path","findMigrationDir","migrationDir","cwd","process","srcDir","resolve","distDir","relativeMigrations","existsSync"],"mappings":";;;AAAA,OAAOA,QAAQ,KAAI;AACnB,OAAOC,UAAU,OAAM;;;AAgBhB,SAASC,iBAAiBC,YAAqB;IACpD,MAAMC,MAAMC,QAAQD,GAAG;IACvB,MAAME,uGAASL,UAAAA,CAAKM,OAAO,CAACH,KAAK;IACjC,MAAMI,wGAAUP,UAAAA,CAAKM,OAAO,CAACH,KAAK;IAClC,MAAMK,mHAAqBR,UAAAA,CAAKM,OAAO,CAACH,KAAK;IAE7C,sBAAsB;IACtB,IAAID,cAAc;QAChB,OAAOA;IACT;IAEA,+BAA+B;IAC/B,gGAAIH,UAAAA,CAAGU,UAAU,CAACJ,SAAS;QACzB,OAAOA;IACT;IAEA,gGAAIN,UAAAA,CAAGU,UAAU,CAACF,UAAU;QAC1B,OAAOA;IACT;IAEA,gGAAIR,UAAAA,CAAGU,UAAU,CAACD,qBAAqB;QACrC,OAAOA;IACT;IAEA,OAAOH;AACT"}},
    {"offset": {"line": 4593, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 4599, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/@payloadcms/db-postgres/node_modules/@payloadcms/drizzle/src/findOne.ts"],"sourcesContent":["import type { FindOneArgs, PayloadRequest, SanitizedCollectionConfig, TypeWithID } from 'payload'\n\nimport toSnakeCase from 'to-snake-case'\n\nimport type { DrizzleAdapter } from './types.js'\n\nimport { findMany } from './find/findMany.js'\n\nexport async function findOne<T extends TypeWithID>(\n  this: DrizzleAdapter,\n  { collection, joins, locale, req = {} as PayloadRequest, where }: FindOneArgs,\n): Promise<T> {\n  const collectionConfig: SanitizedCollectionConfig = this.payload.collections[collection].config\n\n  const tableName = this.tableNameMap.get(toSnakeCase(collectionConfig.slug))\n\n  const { docs } = await findMany({\n    adapter: this,\n    fields: collectionConfig.fields,\n    joins,\n    limit: 1,\n    locale,\n    page: 1,\n    pagination: false,\n    req,\n    sort: undefined,\n    tableName,\n    where,\n  })\n\n  return docs?.[0] || null\n}\n"],"names":["toSnakeCase","findMany","findOne","collection","joins","locale","req","where","collectionConfig","payload","collections","config","tableName","tableNameMap","get","slug","docs","adapter","fields","limit","page","pagination","sort","undefined"],"mappings":";;;AAEA,OAAOA,iBAAiB,gBAAe;AAIvC,SAASC,QAAQ,QAAQ,qBAAoB;;;AAEtC,eAAeC,QAEpB,EAAEC,UAAU,EAAEC,KAAK,EAAEC,MAAM,EAAEC,MAAM,CAAC,CAAmB,EAAEC,KAAK,EAAe;IAE7E,MAAMC,mBAA8C,IAAI,CAACC,OAAO,CAACC,WAAW,CAACP,WAAW,CAACQ,MAAM;IAE/F,MAAMC,YAAY,IAAI,CAACC,YAAY,CAACC,GAAG,kJAACd,UAAAA,EAAYQ,iBAAiBO,IAAI;IAEzE,MAAM,EAAEC,IAAI,EAAE,GAAG,gOAAMf,WAAAA,EAAS;QAC9BgB,SAAS,IAAI;QACbC,QAAQV,iBAAiBU,MAAM;QAC/Bd;QACAe,OAAO;QACPd;QACAe,MAAM;QACNC,YAAY;QACZf;QACAgB,MAAMC;QACNX;QACAL;IACF;IAEA,OAAOS,MAAM,CAAC,EAAE,IAAI;AACtB"}},
    {"offset": {"line": 4624, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 4630, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/@payloadcms/db-postgres/node_modules/@payloadcms/drizzle/src/findVersions.ts"],"sourcesContent":["import type { FindVersions, PayloadRequest, SanitizedCollectionConfig } from 'payload'\n\nimport { buildVersionCollectionFields } from 'payload'\nimport toSnakeCase from 'to-snake-case'\n\nimport type { DrizzleAdapter } from './types.js'\n\nimport { findMany } from './find/findMany.js'\n\nexport const findVersions: FindVersions = async function findVersions(\n  this: DrizzleAdapter,\n  {\n    collection,\n    limit,\n    locale,\n    page,\n    pagination,\n    req = {} as PayloadRequest,\n    skip,\n    sort: sortArg,\n    where,\n  },\n) {\n  const collectionConfig: SanitizedCollectionConfig = this.payload.collections[collection].config\n  const sort = sortArg !== undefined && sortArg !== null ? sortArg : collectionConfig.defaultSort\n\n  const tableName = this.tableNameMap.get(\n    `_${toSnakeCase(collectionConfig.slug)}${this.versionsSuffix}`,\n  )\n\n  const fields = buildVersionCollectionFields(this.payload.config, collectionConfig)\n\n  return findMany({\n    adapter: this,\n    fields,\n    limit,\n    locale,\n    page,\n    pagination,\n    req,\n    skip,\n    sort,\n    tableName,\n    where,\n  })\n}\n"],"names":["buildVersionCollectionFields","toSnakeCase","findMany","findVersions","collection","limit","locale","page","pagination","req","skip","sort","sortArg","where","collectionConfig","payload","collections","config","undefined","defaultSort","tableName","tableNameMap","get","slug","versionsSuffix","fields","adapter"],"mappings":";;;AAGA,OAAOC,iBAAiB,gBAAe;AAIvC,SAASC,QAAQ,QAAQ,qBAAoB;AAL7C,SAASF,4BAA4B,QAAQ,UAAS;;;;AAO/C,MAAMG,eAA6B,eAAeA,aAEvD,EACEC,UAAU,EACVC,KAAK,EACLC,MAAM,EACNC,IAAI,EACJC,UAAU,EACVC,MAAM,CAAC,CAAmB,EAC1BC,IAAI,EACJC,MAAMC,OAAO,EACbC,KAAK,EACN;IAED,MAAMC,mBAA8C,IAAI,CAACC,OAAO,CAACC,WAAW,CAACZ,WAAW,CAACa,MAAM;IAC/F,MAAMN,OAAOC,YAAYM,aAAaN,YAAY,OAAOA,UAAUE,iBAAiBK,WAAW;IAE/F,MAAMC,YAAY,IAAI,CAACC,YAAY,CAACC,GAAG,CACrC,CAAC,CAAC,GAAErB,0JAAAA,EAAYa,iBAAiBS,IAAI,EAAE,EAAE,IAAI,CAACC,cAAc,CAAC,CAAC;IAGhE,MAAMC,kLAASzB,+BAAAA,EAA6B,IAAI,CAACe,OAAO,CAACE,MAAM,EAAEH;IAEjE,iOAAOZ,WAAAA,EAAS;QACdwB,SAAS,IAAI;QACbD;QACApB;QACAC;QACAC;QACAC;QACAC;QACAC;QACAC;QACAS;QACAP;IACF;AACF,EAAC"}},
    {"offset": {"line": 4658, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 4664, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/@payloadcms/db-postgres/node_modules/@payloadcms/drizzle/src/utilities/migrationTableExists.ts"],"sourcesContent":["import type { DrizzleAdapter } from '../types.js'\n\nexport const migrationTableExists = async (adapter: DrizzleAdapter): Promise<boolean> => {\n  let statement\n\n  if (adapter.name === 'postgres') {\n    const prependSchema = adapter.schemaName ? `\"${adapter.schemaName}\".` : ''\n    statement = `SELECT to_regclass('${prependSchema}\"payload_migrations\"') AS exists;`\n  }\n\n  if (adapter.name === 'sqlite') {\n    statement = `\n      SELECT CASE\n               WHEN COUNT(*) > 0 THEN 1\n               ELSE 0\n               END AS 'exists'\n      FROM sqlite_master\n      WHERE type = 'table'\n        AND name = 'payload_migrations';`\n  }\n\n  const result = await adapter.execute({\n    drizzle: adapter.drizzle,\n    raw: statement,\n  })\n\n  const [row] = result.rows\n\n  return row && typeof row === 'object' && 'exists' in row && !!row.exists\n}\n"],"names":["migrationTableExists","adapter","statement","name","prependSchema","schemaName","result","execute","drizzle","raw","row","rows","exists"],"mappings":";;;AAEO,MAAMA,uBAAuB,OAAOC;IACzC,IAAIC;IAEJ,IAAID,QAAQE,IAAI,KAAK,YAAY;QAC/B,MAAMC,gBAAgBH,QAAQI,UAAU,GAAG,CAAC,CAAC,EAAEJ,QAAQI,UAAU,CAAC,EAAE,CAAC,GAAG;QACxEH,YAAY,CAAC,oBAAoB,EAAEE,cAAc,iCAAiC,CAAC;IACrF;IAEA,IAAIH,QAAQE,IAAI,KAAK,UAAU;QAC7BD,YAAY,CAAC;;;;;;;wCAOuB,CAAC;IACvC;IAEA,MAAMI,SAAS,MAAML,QAAQM,OAAO,CAAC;QACnCC,SAASP,QAAQO,OAAO;QACxBC,KAAKP;IACP;IAEA,MAAM,CAACQ,IAAI,GAAGJ,OAAOK,IAAI;IAEzB,OAAOD,OAAO,OAAOA,QAAQ,YAAY,YAAYA,OAAO,CAAC,CAACA,IAAIE,MAAM;AAC1E,EAAC"}},
    {"offset": {"line": 4690, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 4696, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/@payloadcms/db-postgres/node_modules/@payloadcms/drizzle/src/utilities/parseError.ts"],"sourcesContent":["/**\n * Format error message with hint if available\n */\nexport const parseError = (err: unknown, msg: string): string => {\n  let formattedMsg = `${msg}`\n  if (err instanceof Error) {\n    formattedMsg += ` ${err.message}.`\n    // Check if the error has a hint property\n    if ('hint' in err && typeof err.hint === 'string') {\n      formattedMsg += ` ${err.hint}.`\n    }\n  }\n  return formattedMsg\n}\n"],"names":["parseError","err","msg","formattedMsg","Error","message","hint"],"mappings":"AAAA;;CAEC,GACD;;;AAAO,MAAMA,aAAa,CAACC,KAAcC;IACvC,IAAIC,eAAe,CAAC,EAAED,IAAI,CAAC;IAC3B,IAAID,eAAeG,OAAO;QACxBD,gBAAgB,CAAC,CAAC,EAAEF,IAAII,OAAO,CAAC,CAAC,CAAC;QAClC,yCAAyC;QACzC,IAAI,UAAUJ,OAAO,OAAOA,IAAIK,IAAI,KAAK,UAAU;YACjDH,gBAAgB,CAAC,CAAC,EAAEF,IAAIK,IAAI,CAAC,CAAC,CAAC;QACjC;IACF;IACA,OAAOH;AACT,EAAC"}},
    {"offset": {"line": 4712, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 4718, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/@payloadcms/db-postgres/node_modules/@payloadcms/drizzle/src/migrate.ts"],"sourcesContent":["import type { Payload, PayloadRequest } from 'payload'\n\nimport { commitTransaction, initTransaction, killTransaction, readMigrationFiles } from 'payload'\nimport prompts from 'prompts'\n\nimport type { DrizzleAdapter, Migration } from './types.js'\n\nimport { migrationTableExists } from './utilities/migrationTableExists.js'\nimport { parseError } from './utilities/parseError.js'\n\nexport const migrate: DrizzleAdapter['migrate'] = async function migrate(\n  this: DrizzleAdapter,\n  args,\n): Promise<void> {\n  const { payload } = this\n  const migrationFiles = args?.migrations || (await readMigrationFiles({ payload }))\n\n  if (!migrationFiles.length) {\n    payload.logger.info({ msg: 'No migrations to run.' })\n    return\n  }\n\n  let latestBatch = 0\n  let migrationsInDB = []\n\n  const hasMigrationTable = await migrationTableExists(this)\n\n  if (hasMigrationTable) {\n    ;({ docs: migrationsInDB } = await payload.find({\n      collection: 'payload-migrations',\n      limit: 0,\n      sort: '-name',\n    }))\n    if (Number(migrationsInDB?.[0]?.batch) > 0) {\n      latestBatch = Number(migrationsInDB[0]?.batch)\n    }\n  }\n\n  if (migrationsInDB.find((m) => m.batch === -1)) {\n    const { confirm: runMigrations } = await prompts(\n      {\n        name: 'confirm',\n        type: 'confirm',\n        initial: false,\n        message:\n          \"It looks like you've run Payload in dev mode, meaning you've dynamically pushed changes to your database.\\n\\n\" +\n          \"If you'd like to run migrations, data loss will occur. Would you like to proceed?\",\n      },\n      {\n        onCancel: () => {\n          process.exit(0)\n        },\n      },\n    )\n\n    if (!runMigrations) {\n      process.exit(0)\n    }\n  }\n\n  const newBatch = latestBatch + 1\n\n  // Execute 'up' function for each migration sequentially\n  for (const migration of migrationFiles) {\n    const alreadyRan = migrationsInDB.find((existing) => existing.name === migration.name)\n\n    // If already ran, skip\n    if (alreadyRan) {\n      continue\n    }\n\n    await runMigrationFile(payload, migration, newBatch)\n  }\n}\n\nasync function runMigrationFile(payload: Payload, migration: Migration, batch: number) {\n  const start = Date.now()\n  const req = { payload } as PayloadRequest\n  const adapter = payload.db as DrizzleAdapter\n\n  payload.logger.info({ msg: `Migrating: ${migration.name}` })\n\n  try {\n    await initTransaction(req)\n    const db = adapter?.sessions[await req.transactionID]?.db || adapter.drizzle\n    await migration.up({ db, payload, req })\n    payload.logger.info({ msg: `Migrated:  ${migration.name} (${Date.now() - start}ms)` })\n    await payload.create({\n      collection: 'payload-migrations',\n      data: {\n        name: migration.name,\n        batch,\n      },\n      req,\n    })\n    await commitTransaction(req)\n  } catch (err: unknown) {\n    await killTransaction(req)\n    payload.logger.error({\n      err,\n      msg: parseError(err, `Error running migration ${migration.name}`),\n    })\n    process.exit(1)\n  }\n}\n"],"names":["commitTransaction","initTransaction","killTransaction","readMigrationFiles","prompts","migrationTableExists","parseError","migrate","args","payload","migrationFiles","migrations","length","logger","info","msg","latestBatch","migrationsInDB","hasMigrationTable","docs","find","collection","limit","sort","Number","batch","m","confirm","runMigrations","name","type","initial","message","onCancel","process","exit","newBatch","migration","alreadyRan","existing","runMigrationFile","start","Date","now","req","adapter","db","sessions","transactionID","drizzle","up","create","data","err","error"],"mappings":"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"}},
    {"offset": {"line": 4820, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 4826, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/@payloadcms/db-postgres/node_modules/@payloadcms/drizzle/src/migrateDown.ts"],"sourcesContent":["import type { PayloadRequest } from 'payload'\n\nimport {\n  commitTransaction,\n  getMigrations,\n  initTransaction,\n  killTransaction,\n  readMigrationFiles,\n} from 'payload'\n\nimport type { DrizzleAdapter } from './types.js'\n\nimport { migrationTableExists } from './utilities/migrationTableExists.js'\nimport { parseError } from './utilities/parseError.js'\n\nexport async function migrateDown(this: DrizzleAdapter): Promise<void> {\n  const { payload } = this\n  const migrationFiles = await readMigrationFiles({ payload })\n\n  const { existingMigrations, latestBatch } = await getMigrations({\n    payload,\n  })\n\n  if (!existingMigrations?.length) {\n    payload.logger.info({ msg: 'No migrations to rollback.' })\n    return\n  }\n\n  payload.logger.info({\n    msg: `Rolling back batch ${latestBatch} consisting of ${existingMigrations.length} migration(s).`,\n  })\n\n  const latestBatchMigrations = existingMigrations.filter(({ batch }) => batch === latestBatch)\n\n  for (const migration of latestBatchMigrations) {\n    const migrationFile = migrationFiles.find((m) => m.name === migration.name)\n    if (!migrationFile) {\n      throw new Error(`Migration ${migration.name} not found locally.`)\n    }\n\n    const start = Date.now()\n    const req = { payload } as PayloadRequest\n\n    try {\n      payload.logger.info({ msg: `Migrating down: ${migrationFile.name}` })\n      await initTransaction(req)\n      await migrationFile.down({ payload, req })\n      payload.logger.info({\n        msg: `Migrated down:  ${migrationFile.name} (${Date.now() - start}ms)`,\n      })\n\n      const tableExists = await migrationTableExists(this)\n      if (tableExists) {\n        await payload.delete({\n          id: migration.id,\n          collection: 'payload-migrations',\n          req,\n        })\n      }\n\n      await commitTransaction(req)\n    } catch (err: unknown) {\n      await killTransaction(req)\n\n      payload.logger.error({\n        err,\n        msg: parseError(err, `Error migrating down ${migrationFile.name}. Rolling back.`),\n      })\n      process.exit(1)\n    }\n  }\n}\n"],"names":["commitTransaction","getMigrations","initTransaction","killTransaction","readMigrationFiles","migrationTableExists","parseError","migrateDown","payload","migrationFiles","existingMigrations","latestBatch","length","logger","info","msg","latestBatchMigrations","filter","batch","migration","migrationFile","find","m","name","Error","start","Date","now","req","down","tableExists","delete","id","collection","err","error","process","exit"],"mappings":";;;AAYA,SAASK,oBAAoB,QAAQ,sCAAqC;AAC1E,SAASC,UAAU,QAAQ,4BAA2B;AAXtD,SACEN,iBAAiB,EACjBC,aAAa,EACbC,eAAe,EACfC,eAAe,EACfC,kBAAkB,QACb,UAAS;;;;;;;;AAOT,eAAeG;IACpB,MAAM,EAAEC,OAAO,EAAE,GAAG,IAAI;IACxB,MAAMC,iBAAiB,yLAAML,sBAAAA,EAAmB;QAAEI;IAAQ;IAE1D,MAAM,EAAEE,kBAAkB,EAAEC,WAAW,EAAE,GAAG,qLAAMV,gBAAAA,EAAc;QAC9DO;IACF;IAEA,IAAI,CAACE,oBAAoBE,QAAQ;QAC/BJ,QAAQK,MAAM,CAACC,IAAI,CAAC;YAAEC,KAAK;QAA6B;QACxD;IACF;IAEAP,QAAQK,MAAM,CAACC,IAAI,CAAC;QAClBC,KAAK,CAAC,mBAAmB,EAAEJ,YAAY,eAAe,EAAED,mBAAmBE,MAAM,CAAC,cAAc,CAAC;IACnG;IAEA,MAAMI,wBAAwBN,mBAAmBO,MAAM,CAAC,CAAC,EAAEC,KAAK,EAAE,GAAKA,UAAUP;IAEjF,KAAK,MAAMQ,aAAaH,sBAAuB;QAC7C,MAAMI,gBAAgBX,eAAeY,IAAI,CAAC,CAACC,IAAMA,EAAEC,IAAI,KAAKJ,UAAUI,IAAI;QAC1E,IAAI,CAACH,eAAe;YAClB,MAAM,IAAII,MAAM,CAAC,UAAU,EAAEL,UAAUI,IAAI,CAAC,mBAAmB,CAAC;QAClE;QAEA,MAAME,QAAQC,KAAKC,GAAG;QACtB,MAAMC,MAAM;YAAEpB;QAAQ;QAEtB,IAAI;YACFA,QAAQK,MAAM,CAACC,IAAI,CAAC;gBAAEC,KAAK,CAAC,gBAAgB,EAAEK,cAAcG,IAAI,CAAC,CAAC;YAAC;YACnE,MAAMrB,sLAAAA,EAAgB0B;YACtB,MAAMR,cAAcS,IAAI,CAAC;gBAAErB;gBAASoB;YAAI;YACxCpB,QAAQK,MAAM,CAACC,IAAI,CAAC;gBAClBC,KAAK,CAAC,gBAAgB,EAAEK,cAAcG,IAAI,CAAC,EAAE,EAAEG,KAAKC,GAAG,KAAKF,MAAM,GAAG,CAAC;YACxE;YAEA,MAAMK,cAAc,iPAAMzB,uBAAAA,EAAqB,IAAI;YACnD,IAAIyB,aAAa;gBACf,MAAMtB,QAAQuB,MAAM,CAAC;oBACnBC,IAAIb,UAAUa,EAAE;oBAChBC,YAAY;oBACZL;gBACF;YACF;YAEA,4KAAM5B,oBAAAA,EAAkB4B;QAC1B,EAAE,OAAOM,KAAc;YACrB,0KAAM/B,kBAAAA,EAAgByB;YAEtBpB,QAAQK,MAAM,CAACsB,KAAK,CAAC;gBACnBD;gBACAnB,sOAAKT,aAAAA,EAAW4B,KAAK,CAAC,qBAAqB,EAAEd,cAAcG,IAAI,CAAC,eAAe,CAAC;YAClF;YACAa,QAAQC,IAAI,CAAC;QACf;IACF;AACF"}},
    {"offset": {"line": 4897, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 4903, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/@payloadcms/db-postgres/node_modules/@payloadcms/drizzle/src/migrateFresh.ts"],"sourcesContent":["import type { PayloadRequest } from 'payload'\n\nimport { commitTransaction, initTransaction, killTransaction, readMigrationFiles } from 'payload'\nimport prompts from 'prompts'\n\nimport type { DrizzleAdapter, Migration } from './types.js'\n\nimport { parseError } from './utilities/parseError.js'\n\n/**\n * Drop the current database and run all migrate up functions\n */\nexport async function migrateFresh(\n  this: DrizzleAdapter,\n  { forceAcceptWarning = false },\n): Promise<void> {\n  const { payload } = this\n\n  if (forceAcceptWarning === false) {\n    const { confirm: acceptWarning } = await prompts(\n      {\n        name: 'confirm',\n        type: 'confirm',\n        initial: false,\n        message: `WARNING: This will drop your database and run all migrations. Are you sure you want to proceed?`,\n      },\n      {\n        onCancel: () => {\n          process.exit(0)\n        },\n      },\n    )\n\n    if (!acceptWarning) {\n      process.exit(0)\n    }\n  }\n\n  payload.logger.info({\n    msg: `Dropping database.`,\n  })\n\n  await this.dropDatabase({ adapter: this })\n\n  const migrationFiles = await readMigrationFiles({ payload })\n  payload.logger.debug({\n    msg: `Found ${migrationFiles.length} migration files.`,\n  })\n\n  const req = { payload } as PayloadRequest\n  // Run all migrate up\n  for (const migration of migrationFiles) {\n    payload.logger.info({ msg: `Migrating: ${migration.name}` })\n    try {\n      const start = Date.now()\n      await initTransaction(req)\n      const adapter = payload.db as DrizzleAdapter\n      const db = adapter?.sessions[await req.transactionID]?.db || adapter.drizzle\n      await migration.up({ db, payload, req })\n      await payload.create({\n        collection: 'payload-migrations',\n        data: {\n          name: migration.name,\n          batch: 1,\n        },\n        req,\n      })\n      await commitTransaction(req)\n\n      payload.logger.info({ msg: `Migrated:  ${migration.name} (${Date.now() - start}ms)` })\n    } catch (err: unknown) {\n      await killTransaction(req)\n      payload.logger.error({\n        err,\n        msg: parseError(err, `Error running migration ${migration.name}. Rolling back`),\n      })\n      process.exit(1)\n    }\n  }\n}\n"],"names":["commitTransaction","initTransaction","killTransaction","readMigrationFiles","prompts","parseError","migrateFresh","forceAcceptWarning","payload","confirm","acceptWarning","name","type","initial","message","onCancel","process","exit","logger","info","msg","dropDatabase","adapter","migrationFiles","debug","length","req","migration","start","Date","now","db","sessions","transactionID","drizzle","up","create","collection","data","batch","err","error"],"mappings":";;;AAGA,OAAOI,aAAa,UAAS;AAI7B,SAASC,UAAU,QAAQ,4BAA2B;AALtD,SAASL,iBAAiB,EAAEC,eAAe,EAAEC,eAAe,EAAEC,kBAAkB,QAAQ,UAAS;;;;;;;AAU1F,eAAeG,aAEpB,EAAEC,qBAAqB,KAAK,EAAE;IAE9B,MAAM,EAAEC,OAAO,EAAE,GAAG,IAAI;IAExB,IAAID,uBAAuB,OAAO;QAChC,MAAM,EAAEE,SAASC,aAAa,EAAE,GAAG,2IAAMN,UAAAA,EACvC;YACEO,MAAM;YACNC,MAAM;YACNC,SAAS;YACTC,SAAS,CAAC,+FAA+F,CAAC;QAC5G,GACA;YACEC,UAAU;gBACRC,QAAQC,IAAI,CAAC;YACf;QACF;QAGF,IAAI,CAACP,eAAe;YAClBM,QAAQC,IAAI,CAAC;QACf;IACF;IAEAT,QAAQU,MAAM,CAACC,IAAI,CAAC;QAClBC,KAAK,CAAC,kBAAkB,CAAC;IAC3B;IAEA,MAAM,IAAI,CAACC,YAAY,CAAC;QAAEC,SAAS,IAAI;IAAC;IAExC,MAAMC,iBAAiB,0LAAMpB,qBAAAA,EAAmB;QAAEK;IAAQ;IAC1DA,QAAQU,MAAM,CAACM,KAAK,CAAC;QACnBJ,KAAK,CAAC,MAAM,EAAEG,eAAeE,MAAM,CAAC,iBAAiB,CAAC;IACxD;IAEA,MAAMC,MAAM;QAAElB;IAAQ;IACtB,qBAAqB;IACrB,KAAK,MAAMmB,aAAaJ,eAAgB;QACtCf,QAAQU,MAAM,CAACC,IAAI,CAAC;YAAEC,KAAK,CAAC,WAAW,EAAEO,UAAUhB,IAAI,CAAC,CAAC;QAAC;QAC1D,IAAI;YACF,MAAMiB,QAAQC,KAAKC,GAAG;YACtB,OAAM7B,qLAAAA,EAAgByB;YACtB,MAAMJ,UAAUd,QAAQuB,EAAE;YAC1B,MAAMA,KAAKT,SAASU,QAAQ,CAAC,MAAMN,IAAIO,aAAa,CAAC,EAAEF,MAAMT,QAAQY,OAAO;YAC5E,MAAMP,UAAUQ,EAAE,CAAC;gBAAEJ;gBAAIvB;gBAASkB;YAAI;YACtC,MAAMlB,QAAQ4B,MAAM,CAAC;gBACnBC,YAAY;gBACZC,MAAM;oBACJ3B,MAAMgB,UAAUhB,IAAI;oBACpB4B,OAAO;gBACT;gBACAb;YACF;YACA,4KAAM1B,oBAAAA,EAAkB0B;YAExBlB,QAAQU,MAAM,CAACC,IAAI,CAAC;gBAAEC,KAAK,CAAC,WAAW,EAAEO,UAAUhB,IAAI,CAAC,EAAE,EAAEkB,KAAKC,GAAG,KAAKF,MAAM,GAAG,CAAC;YAAC;QACtF,EAAE,OAAOY,KAAc;YACrB,0KAAMtC,kBAAAA,EAAgBwB;YACtBlB,QAAQU,MAAM,CAACuB,KAAK,CAAC;gBACnBD;gBACApB,sOAAKf,aAAAA,EAAWmC,KAAK,CAAC,wBAAwB,EAAEb,UAAUhB,IAAI,CAAC,cAAc,CAAC;YAChF;YACAK,QAAQC,IAAI,CAAC;QACf;IACF;AACF"}},
    {"offset": {"line": 4984, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 4990, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/@payloadcms/db-postgres/node_modules/@payloadcms/drizzle/src/migrateRefresh.ts"],"sourcesContent":["import type { PayloadRequest } from 'payload'\n\nimport {\n  commitTransaction,\n  getMigrations,\n  initTransaction,\n  killTransaction,\n  readMigrationFiles,\n} from 'payload'\n\nimport type { DrizzleAdapter } from './types.js'\n\nimport { migrationTableExists } from './utilities/migrationTableExists.js'\nimport { parseError } from './utilities/parseError.js'\n\n/**\n * Run all migration down functions before running up\n */\nexport async function migrateRefresh(this: DrizzleAdapter) {\n  const { payload } = this\n  const migrationFiles = await readMigrationFiles({ payload })\n\n  const { existingMigrations, latestBatch } = await getMigrations({\n    payload,\n  })\n\n  if (!existingMigrations?.length) {\n    payload.logger.info({ msg: 'No migrations to rollback.' })\n    return\n  }\n\n  payload.logger.info({\n    msg: `Rolling back batch ${latestBatch} consisting of ${existingMigrations.length} migration(s).`,\n  })\n\n  const req = { payload } as PayloadRequest\n\n  // Reverse order of migrations to rollback\n  existingMigrations.reverse()\n\n  for (const migration of existingMigrations) {\n    try {\n      const migrationFile = migrationFiles.find((m) => m.name === migration.name)\n      if (!migrationFile) {\n        throw new Error(`Migration ${migration.name} not found locally.`)\n      }\n\n      payload.logger.info({ msg: `Migrating down: ${migration.name}` })\n      const start = Date.now()\n      await initTransaction(req)\n      await migrationFile.down({ payload, req })\n      payload.logger.info({\n        msg: `Migrated down:  ${migration.name} (${Date.now() - start}ms)`,\n      })\n\n      const tableExists = await migrationTableExists(this)\n      if (tableExists) {\n        await payload.delete({\n          collection: 'payload-migrations',\n          req,\n          where: {\n            name: {\n              equals: migration.name,\n            },\n          },\n        })\n      }\n      await commitTransaction(req)\n    } catch (err: unknown) {\n      await killTransaction(req)\n      payload.logger.error({\n        err,\n        msg: parseError(err, `Error running migration ${migration.name}. Rolling back.`),\n      })\n      process.exit(1)\n    }\n  }\n\n  // Run all migrate up\n  for (const migration of migrationFiles) {\n    payload.logger.info({ msg: `Migrating: ${migration.name}` })\n    try {\n      const start = Date.now()\n      await initTransaction(req)\n      await migration.up({ payload, req })\n      await payload.create({\n        collection: 'payload-migrations',\n        data: {\n          name: migration.name,\n          executed: true,\n        },\n        req,\n      })\n      await commitTransaction(req)\n\n      payload.logger.info({ msg: `Migrated:  ${migration.name} (${Date.now() - start}ms)` })\n    } catch (err: unknown) {\n      await killTransaction(req)\n      payload.logger.error({\n        err,\n        msg: parseError(err, `Error running migration ${migration.name}. Rolling back.`),\n      })\n      process.exit(1)\n    }\n  }\n}\n"],"names":["commitTransaction","getMigrations","initTransaction","killTransaction","readMigrationFiles","migrationTableExists","parseError","migrateRefresh","payload","migrationFiles","existingMigrations","latestBatch","length","logger","info","msg","req","reverse","migration","migrationFile","find","m","name","Error","start","Date","now","down","tableExists","delete","collection","where","equals","err","error","process","exit","up","create","data","executed"],"mappings":"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"}},
    {"offset": {"line": 5099, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 5105, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/@payloadcms/db-postgres/node_modules/@payloadcms/drizzle/src/migrateReset.ts"],"sourcesContent":["import type { PayloadRequest } from 'payload'\n\nimport {\n  commitTransaction,\n  getMigrations,\n  initTransaction,\n  killTransaction,\n  readMigrationFiles,\n} from 'payload'\n\nimport type { DrizzleAdapter } from './types.js'\n\nimport { migrationTableExists } from './utilities/migrationTableExists.js'\n\n/**\n * Run all migrate down functions\n */\nexport async function migrateReset(this: DrizzleAdapter): Promise<void> {\n  const { payload } = this\n  const migrationFiles = await readMigrationFiles({ payload })\n\n  const { existingMigrations } = await getMigrations({ payload })\n\n  if (!existingMigrations?.length) {\n    payload.logger.info({ msg: 'No migrations to reset.' })\n    return\n  }\n\n  const req = { payload } as PayloadRequest\n\n  // Rollback all migrations in order\n  for (const migration of existingMigrations) {\n    const migrationFile = migrationFiles.find((m) => m.name === migration.name)\n    try {\n      if (!migrationFile) {\n        throw new Error(`Migration ${migration.name} not found locally.`)\n      }\n\n      const start = Date.now()\n      payload.logger.info({ msg: `Migrating down: ${migrationFile.name}` })\n      await initTransaction(req)\n      await migrationFile.down({ payload, req })\n      payload.logger.info({\n        msg: `Migrated down:  ${migrationFile.name} (${Date.now() - start}ms)`,\n      })\n\n      const tableExists = await migrationTableExists(this)\n      if (tableExists) {\n        await payload.delete({\n          id: migration.id,\n          collection: 'payload-migrations',\n          req,\n        })\n      }\n\n      await commitTransaction(req)\n    } catch (err: unknown) {\n      let msg = `Error running migration ${migrationFile.name}.`\n\n      if (err instanceof Error) {\n        msg += ` ${err.message}`\n      }\n\n      await killTransaction(req)\n      payload.logger.error({\n        err,\n        msg,\n      })\n      process.exit(1)\n    }\n  }\n\n  // Delete dev migration\n\n  const tableExists = await migrationTableExists(this)\n  if (tableExists) {\n    try {\n      await payload.delete({\n        collection: 'payload-migrations',\n        where: {\n          batch: {\n            equals: -1,\n          },\n        },\n      })\n    } catch (err: unknown) {\n      payload.logger.error({ err, msg: 'Error deleting dev migration' })\n    }\n  }\n}\n"],"names":["commitTransaction","getMigrations","initTransaction","killTransaction","readMigrationFiles","migrationTableExists","migrateReset","payload","migrationFiles","existingMigrations","length","logger","info","msg","req","migration","migrationFile","find","m","name","Error","start","Date","now","down","tableExists","delete","id","collection","err","message","error","process","exit","where","batch","equals"],"mappings":";;;AAYA,SAASK,oBAAoB,QAAQ,sCAAqC;AAV1E,SACEL,iBAAiB,EACjBC,aAAa,EACbC,eAAe,EACfC,eAAe,EACfC,kBAAkB,QACb,UAAS;;;;;;;AAST,eAAeE;IACpB,MAAM,EAAEC,OAAO,EAAE,GAAG,IAAI;IACxB,MAAMC,iBAAiB,0LAAMJ,qBAAAA,EAAmB;QAAEG;IAAQ;IAE1D,MAAM,EAAEE,kBAAkB,EAAE,GAAG,qLAAMR,gBAAAA,EAAc;QAAEM;IAAQ;IAE7D,IAAI,CAACE,oBAAoBC,QAAQ;QAC/BH,QAAQI,MAAM,CAACC,IAAI,CAAC;YAAEC,KAAK;QAA0B;QACrD;IACF;IAEA,MAAMC,MAAM;QAAEP;IAAQ;IAEtB,mCAAmC;IACnC,KAAK,MAAMQ,aAAaN,mBAAoB;QAC1C,MAAMO,gBAAgBR,eAAeS,IAAI,CAAC,CAACC,IAAMA,EAAEC,IAAI,KAAKJ,UAAUI,IAAI;QAC1E,IAAI;YACF,IAAI,CAACH,eAAe;gBAClB,MAAM,IAAII,MAAM,CAAC,UAAU,EAAEL,UAAUI,IAAI,CAAC,mBAAmB,CAAC;YAClE;YAEA,MAAME,QAAQC,KAAKC,GAAG;YACtBhB,QAAQI,MAAM,CAACC,IAAI,CAAC;gBAAEC,KAAK,CAAC,gBAAgB,EAAEG,cAAcG,IAAI,CAAC,CAAC;YAAC;YACnE,0KAAMjB,kBAAAA,EAAgBY;YACtB,MAAME,cAAcQ,IAAI,CAAC;gBAAEjB;gBAASO;YAAI;YACxCP,QAAQI,MAAM,CAACC,IAAI,CAAC;gBAClBC,KAAK,CAAC,gBAAgB,EAAEG,cAAcG,IAAI,CAAC,EAAE,EAAEG,KAAKC,GAAG,KAAKF,MAAM,GAAG,CAAC;YACxE;YAEA,MAAMI,cAAc,MAAMpB,kQAAAA,EAAqB,IAAI;YACnD,IAAIoB,aAAa;gBACf,MAAMlB,QAAQmB,MAAM,CAAC;oBACnBC,IAAIZ,UAAUY,EAAE;oBAChBC,YAAY;oBACZd;gBACF;YACF;YAEA,4KAAMd,oBAAAA,EAAkBc;QAC1B,EAAE,OAAOe,KAAc;YACrB,IAAIhB,MAAM,CAAC,wBAAwB,EAAEG,cAAcG,IAAI,CAAC,CAAC,CAAC;YAE1D,IAAIU,eAAeT,OAAO;gBACxBP,OAAO,CAAC,CAAC,EAAEgB,IAAIC,OAAO,CAAC,CAAC;YAC1B;YAEA,0KAAM3B,kBAAAA,EAAgBW;YACtBP,QAAQI,MAAM,CAACoB,KAAK,CAAC;gBACnBF;gBACAhB;YACF;YACAmB,QAAQC,IAAI,CAAC;QACf;IACF;IAEA,uBAAuB;IAEvB,MAAMR,cAAc,OAAMpB,iQAAAA,EAAqB,IAAI;IACnD,IAAIoB,aAAa;QACf,IAAI;YACF,MAAMlB,QAAQmB,MAAM,CAAC;gBACnBE,YAAY;gBACZM,OAAO;oBACLC,OAAO;wBACLC,QAAQ,CAAC;oBACX;gBACF;YACF;QACF,EAAE,OAAOP,KAAc;YACrBtB,QAAQI,MAAM,CAACoB,KAAK,CAAC;gBAAEF;gBAAKhB,KAAK;YAA+B;QAClE;IACF;AACF"}},
    {"offset": {"line": 5194, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 5200, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/@payloadcms/db-postgres/node_modules/@payloadcms/drizzle/src/migrateStatus.ts"],"sourcesContent":["import { Table } from 'console-table-printer'\nimport { getMigrations, readMigrationFiles } from 'payload'\n\nimport type { DrizzleAdapter } from './types.js'\n\nimport { migrationTableExists } from './utilities/migrationTableExists.js'\n\nexport async function migrateStatus(this: DrizzleAdapter): Promise<void> {\n  const { payload } = this\n  const migrationFiles = await readMigrationFiles({ payload })\n\n  payload.logger.debug({\n    msg: `Found ${migrationFiles.length} migration files.`,\n  })\n\n  let existingMigrations = []\n  const hasMigrationTable = await migrationTableExists(this)\n\n  if (hasMigrationTable) {\n    ;({ existingMigrations } = await getMigrations({ payload }))\n  }\n\n  if (!migrationFiles.length) {\n    payload.logger.info({ msg: 'No migrations found.' })\n    return\n  }\n\n  // Compare migration files to existing migrations\n  const statuses = migrationFiles.map((migration) => {\n    const existingMigration = existingMigrations.find((m) => m.name === migration.name)\n    return {\n      Name: migration.name,\n\n      Batch: existingMigration?.batch,\n      Ran: existingMigration ? 'Yes' : 'No',\n    }\n  })\n\n  const p = new Table()\n\n  statuses.forEach((s) => {\n    p.addRow(s, {\n      color: s.Ran === 'Yes' ? 'green' : 'red',\n    })\n  })\n  p.printTable()\n}\n"],"names":["Table","getMigrations","readMigrationFiles","migrationTableExists","migrateStatus","payload","migrationFiles","logger","debug","msg","length","existingMigrations","hasMigrationTable","info","statuses","map","migration","existingMigration","find","m","name","Name","Batch","batch","Ran","p","forEach","s","addRow","color","printTable"],"mappings":";;;AAAA,SAASA,KAAK,QAAQ,wBAAuB;AAK7C,SAASG,oBAAoB,QAAQ,sCAAqC;AAJ1E,SAASF,aAAa,EAAEC,kBAAkB,QAAQ,UAAS;;;;;AAMpD,eAAeE;IACpB,MAAM,EAAEC,OAAO,EAAE,GAAG,IAAI;IACxB,MAAMC,iBAAiB,0LAAMJ,qBAAAA,EAAmB;QAAEG;IAAQ;IAE1DA,QAAQE,MAAM,CAACC,KAAK,CAAC;QACnBC,KAAK,CAAC,MAAM,EAAEH,eAAeI,MAAM,CAAC,iBAAiB,CAAC;IACxD;IAEA,IAAIC,qBAAqB,EAAE;IAC3B,MAAMC,oBAAoB,MAAMT,kQAAAA,EAAqB,IAAI;IAEzD,IAAIS,mBAAmB;QACnB,CAAA,EAAED,kBAAkB,EAAE,GAAG,MAAMV,+LAAAA,EAAc;YAAEI;QAAQ,EAAC;IAC5D;IAEA,IAAI,CAACC,eAAeI,MAAM,EAAE;QAC1BL,QAAQE,MAAM,CAACM,IAAI,CAAC;YAAEJ,KAAK;QAAuB;QAClD;IACF;IAEA,iDAAiD;IACjD,MAAMK,WAAWR,eAAeS,GAAG,CAAC,CAACC;QACnC,MAAMC,oBAAoBN,mBAAmBO,IAAI,CAAC,CAACC,IAAMA,EAAEC,IAAI,KAAKJ,UAAUI,IAAI;QAClF,OAAO;YACLC,MAAML,UAAUI,IAAI;YAEpBE,OAAOL,mBAAmBM;YAC1BC,KAAKP,oBAAoB,QAAQ;QACnC;IACF;IAEA,MAAMQ,IAAI,iKAAIzB,QAAAA;IAEdc,SAASY,OAAO,CAAC,CAACC;QAChBF,EAAEG,MAAM,CAACD,GAAG;YACVE,OAAOF,EAAEH,GAAG,KAAK,QAAQ,UAAU;QACrC;IACF;IACAC,EAAEK,UAAU;AACd"}},
    {"offset": {"line": 5248, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 5254, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/@payloadcms/db-postgres/node_modules/@payloadcms/drizzle/src/queries/operatorMap.ts"],"sourcesContent":["import {\n  and,\n  type Column,\n  eq,\n  gt,\n  gte,\n  ilike,\n  inArray,\n  isNotNull,\n  isNull,\n  lt,\n  lte,\n  ne,\n  notInArray,\n  or,\n  type SQL,\n  type SQLWrapper,\n} from 'drizzle-orm'\n\ntype OperatorKeys =\n  | 'and'\n  | 'contains'\n  | 'equals'\n  | 'exists'\n  | 'greater_than'\n  | 'greater_than_equal'\n  | 'in'\n  | 'isNull'\n  | 'less_than'\n  | 'less_than_equal'\n  | 'like'\n  | 'not_equals'\n  | 'not_in'\n  | 'or'\n\nexport type Operators = Record<OperatorKeys, (column: Column, value: SQLWrapper | unknown) => SQL>\n\nexport const operatorMap: Operators = {\n  and,\n  contains: ilike,\n  equals: eq,\n  exists: isNotNull,\n  greater_than: gt,\n  greater_than_equal: gte,\n  in: inArray,\n  isNull, // handles exists: false\n  less_than: lt,\n  less_than_equal: lte,\n  like: ilike,\n  not_equals: ne,\n  // TODO: geojson queries\n  // intersects: intersects,\n  // near: near,\n  // within: within,\n  // all: all,\n  not_in: notInArray,\n  or,\n}\n"],"names":["and","eq","gt","gte","ilike","inArray","isNotNull","isNull","lt","lte","ne","notInArray","or","operatorMap","contains","equals","exists","greater_than","greater_than_equal","in","less_than","less_than_equal","like","not_equals","not_in"],"mappings":";;;AAAA,SACEA,GAAG,EAEHC,EAAE,EACFC,EAAE,EACFC,GAAG,EACHC,KAAK,EACLC,OAAO,EACPC,SAAS,EACTC,MAAM,EACNC,EAAE,EACFC,GAAG,EACHC,EAAE,EACFC,UAAU,EACVC,EAAE,QAGG,cAAa;;AAoBb,MAAMC,cAAyB;8NACpCb,MAAAA;IACAc,+NAAUV,QAAAA;IACVW,6NAAQd,KAAAA;IACRe,6NAAQV,YAAAA;IACRW,mOAAcf,KAAAA;IACdgB,yOAAoBf,MAAAA;IACpBgB,yNAAId,UAAAA;iOACJE,SAAAA;IACAa,gOAAWZ,KAAAA;IACXa,sOAAiBZ,MAAAA;IACjBa,2NAAMlB,QAAAA;IACNmB,iOAAYb,KAAAA;IACZ,wBAAwB;IACxB,0BAA0B;IAC1B,cAAc;IACd,kBAAkB;IAClB,YAAY;IACZc,6NAAQb,aAAAA;6NACRC,KAAAA;AACF,EAAC"}},
    {"offset": {"line": 5280, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 5286, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/@payloadcms/db-postgres/node_modules/@payloadcms/drizzle/src/queryDrafts.ts"],"sourcesContent":["import type { JoinQuery, PayloadRequest, QueryDrafts, SanitizedCollectionConfig } from 'payload'\n\nimport { buildVersionCollectionFields, combineQueries } from 'payload'\nimport toSnakeCase from 'to-snake-case'\n\nimport type { DrizzleAdapter } from './types.js'\n\nimport { findMany } from './find/findMany.js'\n\nexport const queryDrafts: QueryDrafts = async function queryDrafts(\n  this: DrizzleAdapter,\n  {\n    collection,\n    joins,\n    limit,\n    locale,\n    page = 1,\n    pagination,\n    req = {} as PayloadRequest,\n    sort,\n    where,\n  },\n) {\n  const collectionConfig: SanitizedCollectionConfig = this.payload.collections[collection].config\n  const tableName = this.tableNameMap.get(\n    `_${toSnakeCase(collectionConfig.slug)}${this.versionsSuffix}`,\n  )\n  const fields = buildVersionCollectionFields(this.payload.config, collectionConfig)\n\n  const combinedWhere = combineQueries({ latest: { equals: true } }, where)\n\n  const result = await findMany({\n    adapter: this,\n    fields,\n    joins,\n    limit,\n    locale,\n    page,\n    pagination,\n    req,\n    sort,\n    tableName,\n    versions: true,\n    where: combinedWhere,\n  })\n\n  return {\n    ...result,\n    docs: result.docs.map((doc) => {\n      doc = {\n        id: doc.parent,\n        ...doc.version,\n      }\n\n      return doc\n    }),\n  }\n}\n"],"names":["buildVersionCollectionFields","combineQueries","toSnakeCase","findMany","queryDrafts","collection","joins","limit","locale","page","pagination","req","sort","where","collectionConfig","payload","collections","config","tableName","tableNameMap","get","slug","versionsSuffix","fields","combinedWhere","latest","equals","result","adapter","versions","docs","map","doc","id","parent","version"],"mappings":";;;AAGA,OAAOE,iBAAiB,gBAAe;AAIvC,SAASC,QAAQ,QAAQ,qBAAoB;AAL7C,SAASH,4BAA4B,EAAEC,cAAc,QAAQ,UAAS;;;;;AAO/D,MAAMG,cAA2B,eAAeA,YAErD,EACEC,UAAU,EACVC,KAAK,EACLC,KAAK,EACLC,MAAM,EACNC,OAAO,CAAC,EACRC,UAAU,EACVC,MAAM,CAAC,CAAmB,EAC1BC,IAAI,EACJC,KAAK,EACN;IAED,MAAMC,mBAA8C,IAAI,CAACC,OAAO,CAACC,WAAW,CAACX,WAAW,CAACY,MAAM;IAC/F,MAAMC,YAAY,IAAI,CAACC,YAAY,CAACC,GAAG,CACrC,CAAC,CAAC,mJAAElB,UAAAA,EAAYY,iBAAiBO,IAAI,EAAE,EAAE,IAAI,CAACC,cAAc,CAAC,CAAC;IAEhE,MAAMC,kLAASvB,+BAAAA,EAA6B,IAAI,CAACe,OAAO,CAACE,MAAM,EAAEH;IAEjE,MAAMU,gBAAgBvB,mLAAAA,EAAe;QAAEwB,QAAQ;YAAEC,QAAQ;QAAK;IAAE,GAAGb;IAEnE,MAAMc,SAAS,OAAMxB,oOAAAA,EAAS;QAC5ByB,SAAS,IAAI;QACbL;QACAjB;QACAC;QACAC;QACAC;QACAC;QACAC;QACAC;QACAM;QACAW,UAAU;QACVhB,OAAOW;IACT;IAEA,OAAO;QACL,GAAGG,MAAM;QACTG,MAAMH,OAAOG,IAAI,CAACC,GAAG,CAAC,CAACC;YACrBA,MAAM;gBACJC,IAAID,IAAIE,MAAM;gBACd,GAAGF,IAAIG,OAAO;YAChB;YAEA,OAAOH;QACT;IACF;AACF,EAAC"}},
    {"offset": {"line": 5330, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 5336, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/@payloadcms/db-postgres/node_modules/@payloadcms/drizzle/src/transactions/beginTransaction.ts"],"sourcesContent":["import type { BeginTransaction } from 'payload'\n\nimport { v4 as uuid } from 'uuid'\n\nimport type { DrizzleAdapter, DrizzleTransaction } from '../types.js'\n\nexport const beginTransaction: BeginTransaction = async function beginTransaction(\n  this: DrizzleAdapter,\n  options: DrizzleAdapter['transactionOptions'],\n) {\n  let id\n  try {\n    id = uuid()\n\n    let reject: () => Promise<void>\n    let resolve: () => Promise<void>\n    let transaction: DrizzleTransaction\n\n    let transactionReady: () => void\n\n    // Await initialization here\n    // Prevent race conditions where the adapter may be\n    // re-initializing, and `this.drizzle` is potentially undefined\n    await this.initializing\n\n    // Drizzle only exposes a transactions API that is sufficient if you\n    // can directly pass around the `tx` argument. But our operations are spread\n    // over many files and we don't want to pass the `tx` around like that,\n    // so instead, we \"lift\" up the `resolve` and `reject` methods\n    // and will call them in our respective transaction methods\n    const done = this.drizzle\n      .transaction(async (tx) => {\n        transaction = tx\n        await new Promise<void>((res, rej) => {\n          resolve = () => {\n            res()\n            return done\n          }\n          reject = () => {\n            // eslint-disable-next-line @typescript-eslint/prefer-promise-reject-errors\n            rej()\n            return done\n          }\n          transactionReady()\n        })\n      }, options || this.transactionOptions)\n      .catch(() => {\n        // swallow\n      })\n\n    // Need to wait until the transaction is ready\n    // before binding its `resolve` and `reject` methods below\n    await new Promise<void>((resolve) => (transactionReady = resolve))\n\n    this.sessions[id] = {\n      db: transaction,\n      reject,\n      resolve,\n    }\n  } catch (err) {\n    this.payload.logger.error({ err, msg: `Error: cannot begin transaction: ${err.message}` })\n    process.exit(1)\n  }\n\n  return id\n}\n"],"names":["v4","uuid","beginTransaction","options","id","reject","resolve","transaction","transactionReady","initializing","done","drizzle","tx","Promise","res","rej","transactionOptions","catch","sessions","db","err","payload","logger","error","msg","message","process","exit"],"mappings":";;;AAEA,SAASA,MAAMC,IAAI,QAAQ,OAAM;;AAI1B,MAAMC,mBAAqC,eAAeA,iBAE/DC,OAA6C;IAE7C,IAAIC;IACJ,IAAI;QACFA,yRAAKH,KAAAA;QAEL,IAAII;QACJ,IAAIC;QACJ,IAAIC;QAEJ,IAAIC;QAEJ,4BAA4B;QAC5B,mDAAmD;QACnD,+DAA+D;QAC/D,MAAM,IAAI,CAACC,YAAY;QAEvB,oEAAoE;QACpE,4EAA4E;QAC5E,uEAAuE;QACvE,8DAA8D;QAC9D,2DAA2D;QAC3D,MAAMC,OAAO,IAAI,CAACC,OAAO,CACtBJ,WAAW,CAAC,OAAOK;YAClBL,cAAcK;YACd,MAAM,IAAIC,QAAc,CAACC,KAAKC;gBAC5BT,UAAU;oBACRQ;oBACA,OAAOJ;gBACT;gBACAL,SAAS;oBACP,2EAA2E;oBAC3EU;oBACA,OAAOL;gBACT;gBACAF;YACF;QACF,GAAGL,WAAW,IAAI,CAACa,kBAAkB,EACpCC,KAAK,CAAC;QACL,UAAU;QACZ;QAEF,8CAA8C;QAC9C,0DAA0D;QAC1D,MAAM,IAAIJ,QAAc,CAACP,UAAaE,mBAAmBF;QAEzD,IAAI,CAACY,QAAQ,CAACd,GAAG,GAAG;YAClBe,IAAIZ;YACJF;YACAC;QACF;IACF,EAAE,OAAOc,KAAK;QACZ,IAAI,CAACC,OAAO,CAACC,MAAM,CAACC,KAAK,CAAC;YAAEH;YAAKI,KAAK,CAAC,iCAAiC,EAAEJ,IAAIK,OAAO,CAAC,CAAC;QAAC;QACxFC,QAAQC,IAAI,CAAC;IACf;IAEA,OAAOvB;AACT,EAAC"}},
    {"offset": {"line": 5392, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 5398, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/@payloadcms/db-postgres/node_modules/@payloadcms/drizzle/src/transactions/commitTransaction.ts"],"sourcesContent":["import type { CommitTransaction } from 'payload'\n\nexport const commitTransaction: CommitTransaction = async function commitTransaction(id) {\n  if (id instanceof Promise) {\n    return\n  }\n\n  // if the session was deleted it has already been aborted\n  if (!this.sessions[id]) {\n    return\n  }\n\n  try {\n    await this.sessions[id].resolve()\n  } catch (err: unknown) {\n    await this.sessions[id].reject()\n  }\n\n  delete this.sessions[id]\n}\n"],"names":["commitTransaction","id","Promise","sessions","resolve","err","reject"],"mappings":";;;AAEO,MAAMA,oBAAuC,eAAeA,kBAAkBC,EAAE;IACrF,IAAIA,cAAcC,SAAS;QACzB;IACF;IAEA,yDAAyD;IACzD,IAAI,CAAC,IAAI,CAACC,QAAQ,CAACF,GAAG,EAAE;QACtB;IACF;IAEA,IAAI;QACF,MAAM,IAAI,CAACE,QAAQ,CAACF,GAAG,CAACG,OAAO;IACjC,EAAE,OAAOC,KAAc;QACrB,MAAM,IAAI,CAACF,QAAQ,CAACF,GAAG,CAACK,MAAM;IAChC;IAEA,OAAO,IAAI,CAACH,QAAQ,CAACF,GAAG;AAC1B,EAAC"}},
    {"offset": {"line": 5416, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 5422, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/@payloadcms/db-postgres/node_modules/@payloadcms/drizzle/src/transactions/rollbackTransaction.ts"],"sourcesContent":["import type { RollbackTransaction } from 'payload'\n\nexport const rollbackTransaction: RollbackTransaction = async function rollbackTransaction(\n  incomingID = '',\n) {\n  const transactionID = incomingID instanceof Promise ? await incomingID : incomingID\n\n  // if multiple operations are using the same transaction, the first will flow through and delete the session.\n  // subsequent calls should be ignored.\n  if (!this.sessions[transactionID]) {\n    return\n  }\n\n  // end the session promise in failure by calling reject\n  await this.sessions[transactionID].reject()\n\n  // delete the session causing any other operations with the same transaction to fail\n  delete this.sessions[transactionID]\n}\n"],"names":["rollbackTransaction","incomingID","transactionID","Promise","sessions","reject"],"mappings":";;;AAEO,MAAMA,sBAA2C,eAAeA,oBACrEC,aAAa,EAAE;IAEf,MAAMC,gBAAgBD,sBAAsBE,UAAU,MAAMF,aAAaA;IAEzE,6GAA6G;IAC7G,sCAAsC;IACtC,IAAI,CAAC,IAAI,CAACG,QAAQ,CAACF,cAAc,EAAE;QACjC;IACF;IAEA,uDAAuD;IACvD,MAAM,IAAI,CAACE,QAAQ,CAACF,cAAc,CAACG,MAAM;IAEzC,oFAAoF;IACpF,OAAO,IAAI,CAACD,QAAQ,CAACF,cAAc;AACrC,EAAC"}},
    {"offset": {"line": 5437, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 5443, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/@payloadcms/db-postgres/node_modules/@payloadcms/drizzle/src/update.ts"],"sourcesContent":["import type { UpdateOne } from 'payload'\n\nimport toSnakeCase from 'to-snake-case'\n\nimport type { DrizzleAdapter } from './types.js'\n\nimport buildQuery from './queries/buildQuery.js'\nimport { selectDistinct } from './queries/selectDistinct.js'\nimport { upsertRow } from './upsertRow/index.js'\n\nexport const updateOne: UpdateOne = async function updateOne(\n  this: DrizzleAdapter,\n  { id, collection: collectionSlug, data, draft, joins: joinQuery, locale, req, where: whereArg },\n) {\n  const db = this.sessions[await req?.transactionID]?.db || this.drizzle\n  const collection = this.payload.collections[collectionSlug].config\n  const tableName = this.tableNameMap.get(toSnakeCase(collection.slug))\n  const whereToUse = whereArg || { id: { equals: id } }\n  let idToUpdate = id\n\n  const { joins, selectFields, where } = buildQuery({\n    adapter: this,\n    fields: collection.fields,\n    locale,\n    tableName,\n    where: whereToUse,\n  })\n\n  const selectDistinctResult = await selectDistinct({\n    adapter: this,\n    chainedMethods: [{ args: [1], method: 'limit' }],\n    db,\n    joins,\n    selectFields,\n    tableName,\n    where,\n  })\n\n  if (selectDistinctResult?.[0]?.id) {\n    idToUpdate = selectDistinctResult?.[0]?.id\n  }\n\n  const result = await upsertRow({\n    id: idToUpdate,\n    adapter: this,\n    data,\n    db,\n    fields: collection.fields,\n    joinQuery,\n    operation: 'update',\n    req,\n    tableName,\n  })\n\n  return result\n}\n"],"names":["toSnakeCase","buildQuery","selectDistinct","upsertRow","updateOne","id","collection","collectionSlug","data","draft","joins","joinQuery","locale","req","where","whereArg","db","sessions","transactionID","drizzle","payload","collections","config","tableName","tableNameMap","get","slug","whereToUse","equals","idToUpdate","selectFields","adapter","fields","selectDistinctResult","chainedMethods","args","method","result","operation"],"mappings":";;;AAEA,OAAOA,iBAAiB,gBAAe;AAIvC,OAAOC,gBAAgB,0BAAyB;AAChD,SAASC,cAAc,QAAQ,8BAA6B;AAC5D,SAASC,SAAS,QAAQ,uBAAsB;;;;;AAEzC,MAAMC,YAAuB,eAAeA,UAEjD,EAAEC,EAAE,EAAEC,YAAYC,cAAc,EAAEC,IAAI,EAAEC,KAAK,EAAEC,OAAOC,SAAS,EAAEC,MAAM,EAAEC,GAAG,EAAEC,OAAOC,QAAQ,EAAE;IAE/F,MAAMC,KAAK,IAAI,CAACC,QAAQ,CAAC,MAAMJ,KAAKK,cAAc,EAAEF,MAAM,IAAI,CAACG,OAAO;IACtE,MAAMb,aAAa,IAAI,CAACc,OAAO,CAACC,WAAW,CAACd,eAAe,CAACe,MAAM;IAClE,MAAMC,YAAY,IAAI,CAACC,YAAY,CAACC,GAAG,kJAACzB,UAAAA,EAAYM,WAAWoB,IAAI;IACnE,MAAMC,aAAaZ,YAAY;QAAEV,IAAI;YAAEuB,QAAQvB;QAAG;IAAE;IACpD,IAAIwB,aAAaxB;IAEjB,MAAM,EAAEK,KAAK,EAAEoB,YAAY,EAAEhB,KAAK,EAAE,kOAAGb,UAAAA,EAAW;QAChD8B,SAAS,IAAI;QACbC,QAAQ1B,WAAW0B,MAAM;QACzBpB;QACAW;QACAT,OAAOa;IACT;IAEA,MAAMM,uBAAuB,yOAAM/B,iBAAAA,EAAe;QAChD6B,SAAS,IAAI;QACbG,gBAAgB;YAAC;gBAAEC,MAAM;oBAAC;iBAAE;gBAAEC,QAAQ;YAAQ;SAAE;QAChDpB;QACAN;QACAoB;QACAP;QACAT;IACF;IAEA,IAAImB,sBAAsB,CAAC,EAAE,EAAE5B,IAAI;QACjCwB,aAAaI,sBAAsB,CAAC,EAAE,EAAE5B;IAC1C;IAEA,MAAMgC,SAAS,kOAAMlC,YAAAA,EAAU;QAC7BE,IAAIwB;QACJE,SAAS,IAAI;QACbvB;QACAQ;QACAgB,QAAQ1B,WAAW0B,MAAM;QACzBrB;QACA2B,WAAW;QACXzB;QACAU;IACF;IAEA,OAAOc;AACT,EAAC"}},
    {"offset": {"line": 5503, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 5509, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/@payloadcms/db-postgres/node_modules/@payloadcms/drizzle/src/updateGlobal.ts"],"sourcesContent":["import type { PayloadRequest, UpdateGlobalArgs } from 'payload'\n\nimport toSnakeCase from 'to-snake-case'\n\nimport type { DrizzleAdapter } from './types.js'\n\nimport { upsertRow } from './upsertRow/index.js'\n\nexport async function updateGlobal<T extends Record<string, unknown>>(\n  this: DrizzleAdapter,\n  { slug, data, req = {} as PayloadRequest }: UpdateGlobalArgs,\n): Promise<T> {\n  const db = this.sessions[await req?.transactionID]?.db || this.drizzle\n  const globalConfig = this.payload.globals.config.find((config) => config.slug === slug)\n  const tableName = this.tableNameMap.get(toSnakeCase(globalConfig.slug))\n\n  const existingGlobal = await db.query[tableName].findFirst({})\n\n  const result = await upsertRow<T>({\n    ...(existingGlobal ? { id: existingGlobal.id, operation: 'update' } : { operation: 'create' }),\n    adapter: this,\n    data,\n    db,\n    fields: globalConfig.fields,\n    req,\n    tableName,\n  })\n\n  return result\n}\n"],"names":["toSnakeCase","upsertRow","updateGlobal","slug","data","req","db","sessions","transactionID","drizzle","globalConfig","payload","globals","config","find","tableName","tableNameMap","get","existingGlobal","query","findFirst","result","id","operation","adapter","fields"],"mappings":";;;AAEA,OAAOA,iBAAiB,gBAAe;AAIvC,SAASC,SAAS,QAAQ,uBAAsB;;;AAEzC,eAAeC,aAEpB,EAAEC,IAAI,EAAEC,IAAI,EAAEC,MAAM,CAAC,CAAmB,EAAoB;IAE5D,MAAMC,KAAK,IAAI,CAACC,QAAQ,CAAC,MAAMF,KAAKG,cAAc,EAAEF,MAAM,IAAI,CAACG,OAAO;IACtE,MAAMC,eAAe,IAAI,CAACC,OAAO,CAACC,OAAO,CAACC,MAAM,CAACC,IAAI,CAAC,CAACD,SAAWA,OAAOV,IAAI,KAAKA;IAClF,MAAMY,YAAY,IAAI,CAACC,YAAY,CAACC,GAAG,kJAACjB,UAAAA,EAAYU,aAAaP,IAAI;IAErE,MAAMe,iBAAiB,MAAMZ,GAAGa,KAAK,CAACJ,UAAU,CAACK,SAAS,CAAC,CAAC;IAE5D,MAAMC,SAAS,kOAAMpB,YAAAA,EAAa;QAChC,GAAIiB,iBAAiB;YAAEI,IAAIJ,eAAeI,EAAE;YAAEC,WAAW;QAAS,IAAI;YAAEA,WAAW;QAAS,CAAC;QAC7FC,SAAS,IAAI;QACbpB;QACAE;QACAmB,QAAQf,aAAae,MAAM;QAC3BpB;QACAU;IACF;IAEA,OAAOM;AACT"}},
    {"offset": {"line": 5537, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 5543, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/@payloadcms/db-postgres/node_modules/@payloadcms/drizzle/src/updateGlobalVersion.ts"],"sourcesContent":["import type {\n  PayloadRequest,\n  SanitizedGlobalConfig,\n  TypeWithID,\n  TypeWithVersion,\n  UpdateGlobalVersionArgs,\n} from 'payload'\n\nimport { buildVersionGlobalFields } from 'payload'\nimport toSnakeCase from 'to-snake-case'\n\nimport type { DrizzleAdapter } from './types.js'\n\nimport buildQuery from './queries/buildQuery.js'\nimport { upsertRow } from './upsertRow/index.js'\n\nexport async function updateGlobalVersion<T extends TypeWithID>(\n  this: DrizzleAdapter,\n  {\n    id,\n    global,\n    locale,\n    req = {} as PayloadRequest,\n    versionData,\n    where: whereArg,\n  }: UpdateGlobalVersionArgs<T>,\n) {\n  const db = this.sessions[await req?.transactionID]?.db || this.drizzle\n  const globalConfig: SanitizedGlobalConfig = this.payload.globals.config.find(\n    ({ slug }) => slug === global,\n  )\n  const whereToUse = whereArg || { id: { equals: id } }\n\n  const tableName = this.tableNameMap.get(\n    `_${toSnakeCase(globalConfig.slug)}${this.versionsSuffix}`,\n  )\n\n  const fields = buildVersionGlobalFields(this.payload.config, globalConfig)\n\n  const { where } = buildQuery({\n    adapter: this,\n    fields,\n    locale,\n    tableName,\n    where: whereToUse,\n  })\n\n  const result = await upsertRow<TypeWithVersion<T>>({\n    id,\n    adapter: this,\n    data: versionData,\n    db,\n    fields,\n    operation: 'update',\n    req,\n    tableName,\n    where,\n  })\n\n  return result\n}\n"],"names":["buildVersionGlobalFields","toSnakeCase","buildQuery","upsertRow","updateGlobalVersion","id","global","locale","req","versionData","where","whereArg","db","sessions","transactionID","drizzle","globalConfig","payload","globals","config","find","slug","whereToUse","equals","tableName","tableNameMap","get","versionsSuffix","fields","adapter","result","data","operation"],"mappings":";;;AASA,OAAOC,iBAAiB,gBAAe;AAIvC,OAAOC,gBAAgB,0BAAyB;AAChD,SAASC,SAAS,QAAQ,uBAAsB;AANhD,SAASH,wBAAwB,QAAQ,UAAS;;;;;AAQ3C,eAAeI,oBAEpB,EACEC,EAAE,EACFC,MAAM,EACNC,MAAM,EACNC,MAAM,CAAC,CAAmB,EAC1BC,WAAW,EACXC,OAAOC,QAAQ,EACY;IAE7B,MAAMC,KAAK,IAAI,CAACC,QAAQ,CAAC,MAAML,KAAKM,cAAc,EAAEF,MAAM,IAAI,CAACG,OAAO;IACtE,MAAMC,eAAsC,IAAI,CAACC,OAAO,CAACC,OAAO,CAACC,MAAM,CAACC,IAAI,CAC1E,CAAC,EAAEC,IAAI,EAAE,GAAKA,SAASf;IAEzB,MAAMgB,aAAaX,YAAY;QAAEN,IAAI;YAAEkB,QAAQlB;QAAG;IAAE;IAEpD,MAAMmB,YAAY,IAAI,CAACC,YAAY,CAACC,GAAG,CACrC,CAAC,CAAC,mJAAEzB,UAAAA,EAAYe,aAAaK,IAAI,EAAE,EAAE,IAAI,CAACM,cAAc,CAAC,CAAC;IAG5D,MAAMC,8KAAS5B,2BAAAA,EAAyB,IAAI,CAACiB,OAAO,CAACE,MAAM,EAAEH;IAE7D,MAAM,EAAEN,KAAK,EAAE,kOAAGR,UAAAA,EAAW;QAC3B2B,SAAS,IAAI;QACbD;QACArB;QACAiB;QACAd,OAAOY;IACT;IAEA,MAAMQ,SAAS,kOAAM3B,YAAAA,EAA8B;QACjDE;QACAwB,SAAS,IAAI;QACbE,MAAMtB;QACNG;QACAgB;QACAI,WAAW;QACXxB;QACAgB;QACAd;IACF;IAEA,OAAOoB;AACT"}},
    {"offset": {"line": 5584, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 5590, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/@payloadcms/db-postgres/node_modules/@payloadcms/drizzle/src/updateVersion.ts"],"sourcesContent":["import type {\n  PayloadRequest,\n  SanitizedCollectionConfig,\n  TypeWithID,\n  TypeWithVersion,\n  UpdateVersionArgs,\n} from 'payload'\n\nimport { buildVersionCollectionFields } from 'payload'\nimport toSnakeCase from 'to-snake-case'\n\nimport type { DrizzleAdapter } from './types.js'\n\nimport buildQuery from './queries/buildQuery.js'\nimport { upsertRow } from './upsertRow/index.js'\n\nexport async function updateVersion<T extends TypeWithID>(\n  this: DrizzleAdapter,\n  {\n    id,\n    collection,\n    locale,\n    req = {} as PayloadRequest,\n    versionData,\n    where: whereArg,\n  }: UpdateVersionArgs<T>,\n) {\n  const db = this.sessions[await req?.transactionID]?.db || this.drizzle\n  const collectionConfig: SanitizedCollectionConfig = this.payload.collections[collection].config\n  const whereToUse = whereArg || { id: { equals: id } }\n  const tableName = this.tableNameMap.get(\n    `_${toSnakeCase(collectionConfig.slug)}${this.versionsSuffix}`,\n  )\n\n  const fields = buildVersionCollectionFields(this.payload.config, collectionConfig)\n\n  const { where } = buildQuery({\n    adapter: this,\n    fields,\n    locale,\n    tableName,\n    where: whereToUse,\n  })\n\n  const result = await upsertRow<TypeWithVersion<T>>({\n    id,\n    adapter: this,\n    data: versionData,\n    db,\n    fields,\n    operation: 'update',\n    req,\n    tableName,\n    where,\n  })\n\n  return result\n}\n"],"names":["buildVersionCollectionFields","toSnakeCase","buildQuery","upsertRow","updateVersion","id","collection","locale","req","versionData","where","whereArg","db","sessions","transactionID","drizzle","collectionConfig","payload","collections","config","whereToUse","equals","tableName","tableNameMap","get","slug","versionsSuffix","fields","adapter","result","data","operation"],"mappings":";;;AASA,OAAOC,iBAAiB,gBAAe;AAIvC,OAAOC,gBAAgB,0BAAyB;AAChD,SAASC,SAAS,QAAQ,uBAAsB;AANhD,SAASH,4BAA4B,QAAQ,UAAS;;;;;AAQ/C,eAAeI,cAEpB,EACEC,EAAE,EACFC,UAAU,EACVC,MAAM,EACNC,MAAM,CAAC,CAAmB,EAC1BC,WAAW,EACXC,OAAOC,QAAQ,EACM;IAEvB,MAAMC,KAAK,IAAI,CAACC,QAAQ,CAAC,MAAML,KAAKM,cAAc,EAAEF,MAAM,IAAI,CAACG,OAAO;IACtE,MAAMC,mBAA8C,IAAI,CAACC,OAAO,CAACC,WAAW,CAACZ,WAAW,CAACa,MAAM;IAC/F,MAAMC,aAAaT,YAAY;QAAEN,IAAI;YAAEgB,QAAQhB;QAAG;IAAE;IACpD,MAAMiB,YAAY,IAAI,CAACC,YAAY,CAACC,GAAG,CACrC,CAAC,CAAC,mJAAEvB,UAAAA,EAAYe,iBAAiBS,IAAI,EAAE,EAAE,IAAI,CAACC,cAAc,CAAC,CAAC;IAGhE,MAAMC,kLAAS3B,+BAAAA,EAA6B,IAAI,CAACiB,OAAO,CAACE,MAAM,EAAEH;IAEjE,MAAM,EAAEN,KAAK,EAAE,kOAAGR,UAAAA,EAAW;QAC3B0B,SAAS,IAAI;QACbD;QACApB;QACAe;QACAZ,OAAOU;IACT;IAEA,MAAMS,SAAS,kOAAM1B,YAAAA,EAA8B;QACjDE;QACAuB,SAAS,IAAI;QACbE,MAAMrB;QACNG;QACAe;QACAI,WAAW;QACXvB;QACAc;QACAZ;IACF;IAEA,OAAOmB;AACT"}},
    {"offset": {"line": 5631, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 5637, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/@payloadcms/db-postgres/node_modules/@payloadcms/drizzle/src/utilities/buildIndexName.ts"],"sourcesContent":["import type { DrizzleAdapter } from '../types.js'\n\nexport const buildIndexName = ({\n  name,\n  adapter,\n  number = 0,\n}: {\n  adapter: DrizzleAdapter\n  name: string\n  number?: number\n}): string => {\n  const indexName = `${name}${number ? `_${number}` : ''}_idx`\n\n  if (!adapter.indexes.has(indexName)) {\n    adapter.indexes.add(indexName)\n    return indexName\n  }\n\n  return buildIndexName({\n    name,\n    adapter,\n    number: number + 1,\n  })\n}\n"],"names":["buildIndexName","name","adapter","number","indexName","indexes","has","add"],"mappings":";;;AAEO,MAAMA,iBAAiB,CAAC,EAC7BC,IAAI,EACJC,OAAO,EACPC,SAAS,CAAC,EAKX;IACC,MAAMC,YAAY,CAAC,EAAEH,KAAK,EAAEE,SAAS,CAAC,CAAC,EAAEA,OAAO,CAAC,GAAG,GAAG,IAAI,CAAC;IAE5D,IAAI,CAACD,QAAQG,OAAO,CAACC,GAAG,CAACF,YAAY;QACnCF,QAAQG,OAAO,CAACE,GAAG,CAACH;QACpB,OAAOA;IACT;IAEA,OAAOJ,eAAe;QACpBC;QACAC;QACAC,QAAQA,SAAS;IACnB;AACF,EAAC"}},
    {"offset": {"line": 5652, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 5658, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/@payloadcms/db-postgres/node_modules/@payloadcms/drizzle/src/utilities/extendDrizzleTable.ts"],"sourcesContent":["/**\n * Implemented from:\n * https://github.com/drizzle-team/drizzle-orm/blob/main/drizzle-orm/src/pg-core/table.ts#L73\n * Drizzle uses @internal JSDoc to remove their internal methods from types, for example\n * Table.Symbol, columnBuilder.build - but they actually exist.\n */\nimport type { ColumnBuilderBase } from 'drizzle-orm'\n\nimport { Table } from 'drizzle-orm'\nimport { APIError } from 'payload'\n\nconst { Symbol: DrizzleSymbol } = Table as unknown as {\n  Symbol: {\n    Columns: symbol\n    ExtraConfigBuilder: symbol\n    ExtraConfigColumns: symbol\n  }\n}\n\ntype Args = {\n  columns?: Record<string, ColumnBuilderBase<any>>\n  extraConfig?: (self: Record<string, any>) => object\n  table: Table\n}\n\n/**\n * Extends the passed table with additional columns / extra config\n */\nexport const extendDrizzleTable = ({ columns, extraConfig, table }: Args): void => {\n  const InlineForeignKeys = Object.getOwnPropertySymbols(table).find((symbol) => {\n    return symbol.description?.includes('InlineForeignKeys')\n  })\n\n  if (!InlineForeignKeys) {\n    throw new APIError(`Error when finding InlineForeignKeys Symbol`, 500)\n  }\n\n  if (columns) {\n    for (const [name, columnBuilder] of Object.entries(columns) as [string, any][]) {\n      const column = columnBuilder.build(table)\n\n      table[name] = column\n      table[InlineForeignKeys].push(...columnBuilder.buildForeignKeys(column, table))\n      table[DrizzleSymbol.Columns][name] = column\n\n      table[DrizzleSymbol.ExtraConfigColumns][name] =\n        'buildExtraConfigColumn' in columnBuilder\n          ? columnBuilder.buildExtraConfigColumn(table)\n          : column\n    }\n  }\n\n  if (extraConfig) {\n    const originalExtraConfigBuilder = table[DrizzleSymbol.ExtraConfigBuilder]\n\n    table[DrizzleSymbol.ExtraConfigBuilder] = (t) => {\n      return {\n        ...originalExtraConfigBuilder(t),\n        ...extraConfig(t),\n      }\n    }\n  }\n}\n"],"names":["Table","APIError","Symbol","DrizzleSymbol","extendDrizzleTable","columns","extraConfig","table","InlineForeignKeys","Object","getOwnPropertySymbols","find","symbol","description","includes","name","columnBuilder","entries","column","build","push","buildForeignKeys","Columns","ExtraConfigColumns","buildExtraConfigColumn","originalExtraConfigBuilder","ExtraConfigBuilder","t"],"mappings":"AAAA;;;;;CAKC;;;AAGD,SAASA,KAAK,QAAQ,cAAa;AACnC,SAASC,QAAQ,QAAQ,UAAS;;;AAElC,MAAM,EAAEC,QAAQC,aAAa,EAAE,6LAAGH,QAAAA;AAiB3B,MAAMI,qBAAqB,CAAC,EAAEC,OAAO,EAAEC,WAAW,EAAEC,KAAK,EAAQ;IACtE,MAAMC,oBAAoBC,OAAOC,qBAAqB,CAACH,OAAOI,IAAI,CAAC,CAACC;QAClE,OAAOA,OAAOC,WAAW,EAAEC,SAAS;IACtC;IAEA,IAAI,CAACN,mBAAmB;QACtB,MAAM,0JAAIP,WAAAA,CAAS,CAAC,2CAA2C,CAAC,EAAE;IACpE;IAEA,IAAII,SAAS;QACX,KAAK,MAAM,CAACU,MAAMC,cAAc,IAAIP,OAAOQ,OAAO,CAACZ,SAA6B;YAC9E,MAAMa,SAASF,cAAcG,KAAK,CAACZ;YAEnCA,KAAK,CAACQ,KAAK,GAAGG;YACdX,KAAK,CAACC,kBAAkB,CAACY,IAAI,IAAIJ,cAAcK,gBAAgB,CAACH,QAAQX;YACxEA,KAAK,CAACJ,cAAcmB,OAAO,CAAC,CAACP,KAAK,GAAGG;YAErCX,KAAK,CAACJ,cAAcoB,kBAAkB,CAAC,CAACR,KAAK,GAC3C,4BAA4BC,gBACxBA,cAAcQ,sBAAsB,CAACjB,SACrCW;QACR;IACF;IAEA,IAAIZ,aAAa;QACf,MAAMmB,6BAA6BlB,KAAK,CAACJ,cAAcuB,kBAAkB,CAAC;QAE1EnB,KAAK,CAACJ,cAAcuB,kBAAkB,CAAC,GAAG,CAACC;YACzC,OAAO;gBACL,GAAGF,2BAA2BE,EAAE;gBAChC,GAAGrB,YAAYqB,EAAE;YACnB;QACF;IACF;AACF,EAAC"}},
    {"offset": {"line": 5697, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 5703, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/@payloadcms/db-postgres/node_modules/@payloadcms/drizzle/src/utilities/executeSchemaHooks.ts"],"sourcesContent":["import type { DrizzleAdapter } from '../types.js'\n\nimport { extendDrizzleTable } from './extendDrizzleTable.js'\n\ntype DatabaseSchema = {\n  enums?: DrizzleAdapter['enums']\n  relations: Record<string, any>\n  tables: DrizzleAdapter['tables']\n}\n\ntype Adapter = {\n  afterSchemaInit: DatabaseSchemaHook[]\n  beforeSchemaInit: DatabaseSchemaHook[]\n} & DatabaseSchema\n\ntype DatabaseSchemaHookArgs = {\n  adapter: Record<string, unknown>\n  extendTable: typeof extendDrizzleTable\n  schema: DatabaseSchema\n}\n\ntype DatabaseSchemaHook = (args: DatabaseSchemaHookArgs) => DatabaseSchema | Promise<DatabaseSchema>\n\ntype Args = {\n  adapter: Adapter\n  type: 'afterSchemaInit' | 'beforeSchemaInit'\n}\n\nexport const executeSchemaHooks = async ({ type, adapter }: Args): Promise<void> => {\n  for (const hook of adapter[type]) {\n    const result = await hook({\n      adapter,\n      extendTable: extendDrizzleTable,\n      schema: {\n        enums: adapter.enums,\n        relations: adapter.relations,\n        tables: adapter.tables,\n      },\n    })\n    if (result.enums) {\n      adapter.enums = result.enums\n    }\n\n    adapter.tables = result.tables\n    adapter.relations = result.relations\n  }\n}\n"],"names":["extendDrizzleTable","executeSchemaHooks","type","adapter","hook","result","extendTable","schema","enums","relations","tables"],"mappings":";;;AAEA,SAASA,kBAAkB,QAAQ,0BAAyB;;AA0BrD,MAAMC,qBAAqB,OAAO,EAAEC,IAAI,EAAEC,OAAO,EAAQ;IAC9D,KAAK,MAAMC,QAAQD,OAAO,CAACD,KAAK,CAAE;QAChC,MAAMG,SAAS,MAAMD,KAAK;YACxBD;YACAG,kPAAaN,qBAAAA;YACbO,QAAQ;gBACNC,OAAOL,QAAQK,KAAK;gBACpBC,WAAWN,QAAQM,SAAS;gBAC5BC,QAAQP,QAAQO,MAAM;YACxB;QACF;QACA,IAAIL,OAAOG,KAAK,EAAE;YAChBL,QAAQK,KAAK,GAAGH,OAAOG,KAAK;QAC9B;QAEAL,QAAQO,MAAM,GAAGL,OAAOK,MAAM;QAC9BP,QAAQM,SAAS,GAAGJ,OAAOI,SAAS;IACtC;AACF,EAAC"}},
    {"offset": {"line": 5726, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 5732, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/@payloadcms/db-postgres/node_modules/@payloadcms/drizzle/src/utilities/hasLocalesTable.ts"],"sourcesContent":["import type { Field } from 'payload'\n\nimport { fieldAffectsData, fieldHasSubFields } from 'payload/shared'\n\nexport const hasLocalesTable = (fields: Field[]): boolean => {\n  return fields.some((field) => {\n    // arrays always get a separate table\n    if (field.type === 'array') {\n      return false\n    }\n    if (fieldAffectsData(field) && field.localized) {\n      return true\n    }\n    if (fieldHasSubFields(field)) {\n      return hasLocalesTable(field.fields)\n    }\n    if (field.type === 'tabs') {\n      return field.tabs.some((tab) => hasLocalesTable(tab.fields))\n    }\n    return false\n  })\n}\n"],"names":["fieldAffectsData","fieldHasSubFields","hasLocalesTable","fields","some","field","type","localized","tabs","tab"],"mappings":";;;AAEA,SAASA,gBAAgB,EAAEC,iBAAiB,QAAQ,iBAAgB;;AAE7D,MAAMC,kBAAkB,CAACC;IAC9B,OAAOA,OAAOC,IAAI,CAAC,CAACC;QAClB,qCAAqC;QACrC,IAAIA,MAAMC,IAAI,KAAK,SAAS;YAC1B,OAAO;QACT;QACA,qKAAIN,mBAAAA,EAAiBK,UAAUA,MAAME,SAAS,EAAE;YAC9C,OAAO;QACT;QACA,KAAIN,oLAAAA,EAAkBI,QAAQ;YAC5B,OAAOH,gBAAgBG,MAAMF,MAAM;QACrC;QACA,IAAIE,MAAMC,IAAI,KAAK,QAAQ;YACzB,OAAOD,MAAMG,IAAI,CAACJ,IAAI,CAAC,CAACK,MAAQP,gBAAgBO,IAAIN,MAAM;QAC5D;QACA,OAAO;IACT;AACF,EAAC"}},
    {"offset": {"line": 5755, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 5761, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/@payloadcms/db-postgres/node_modules/@payloadcms/drizzle/src/utilities/pushDevSchema.ts"],"sourcesContent":["import prompts from 'prompts'\n\nimport type { DrizzleAdapter } from '../types.js'\n\n/**\n * Pushes the development schema to the database using Drizzle.\n *\n * @param {DrizzleAdapter} adapter - The PostgresAdapter instance connected to the database.\n * @returns {Promise<void>} - A promise that resolves once the schema push is complete.\n */\nexport const pushDevSchema = async (adapter: DrizzleAdapter) => {\n  const { pushSchema } = adapter.requireDrizzleKit()\n\n  // This will prompt if clarifications are needed for Drizzle to push new schema\n  const { apply, hasDataLoss, warnings } = await pushSchema(\n    adapter.schema,\n    adapter.drizzle,\n    adapter.schemaName ? [adapter.schemaName] : undefined,\n  )\n\n  if (warnings.length) {\n    let message = `Warnings detected during schema push: \\n\\n${warnings.join('\\n')}\\n\\n`\n\n    if (hasDataLoss) {\n      message += `DATA LOSS WARNING: Possible data loss detected if schema is pushed.\\n\\n`\n    }\n\n    message += `Accept warnings and push schema to database?`\n\n    const { confirm: acceptWarnings } = await prompts(\n      {\n        name: 'confirm',\n        type: 'confirm',\n        initial: false,\n        message,\n      },\n      {\n        onCancel: () => {\n          process.exit(0)\n        },\n      },\n    )\n\n    // Exit if user does not accept warnings.\n    // Q: Is this the right type of exit for this interaction?\n    if (!acceptWarnings) {\n      process.exit(0)\n    }\n  }\n\n  await apply()\n  const migrationsTable = adapter.schemaName\n    ? `\"${adapter.schemaName}\".\"payload_migrations\"`\n    : '\"payload_migrations\"'\n\n  const result = await adapter.execute({\n    drizzle: adapter.drizzle,\n    raw: `SELECT * FROM ${migrationsTable} WHERE batch = '-1'`,\n  })\n\n  const devPush = result.rows\n\n  if (!devPush.length) {\n    await adapter.execute({\n      drizzle: adapter.drizzle,\n      raw: `INSERT INTO ${migrationsTable} (name, batch) VALUES ('dev', '-1')`,\n    })\n  } else {\n    await adapter.execute({\n      drizzle: adapter.drizzle,\n      raw: `UPDATE ${migrationsTable} SET updated_at = CURRENT_TIMESTAMP WHERE batch = '-1'`,\n    })\n  }\n}\n"],"names":["prompts","pushDevSchema","adapter","pushSchema","requireDrizzleKit","apply","hasDataLoss","warnings","schema","drizzle","schemaName","undefined","length","message","join","confirm","acceptWarnings","name","type","initial","onCancel","process","exit","migrationsTable","result","execute","raw","devPush","rows"],"mappings":";;;AAAA,OAAOA,aAAa,UAAS;;AAUtB,MAAMC,gBAAgB,OAAOC;IAClC,MAAM,EAAEC,UAAU,EAAE,GAAGD,QAAQE,iBAAiB;IAEhD,+EAA+E;IAC/E,MAAM,EAAEC,KAAK,EAAEC,WAAW,EAAEC,QAAQ,EAAE,GAAG,MAAMJ,WAC7CD,QAAQM,MAAM,EACdN,QAAQO,OAAO,EACfP,QAAQQ,UAAU,GAAG;QAACR,QAAQQ,UAAU;KAAC,GAAGC;IAG9C,IAAIJ,SAASK,MAAM,EAAE;QACnB,IAAIC,UAAU,CAAC,0CAA0C,EAAEN,SAASO,IAAI,CAAC,MAAM,IAAI,CAAC;QAEpF,IAAIR,aAAa;YACfO,WAAW,CAAC,uEAAuE,CAAC;QACtF;QAEAA,WAAW,CAAC,4CAA4C,CAAC;QAEzD,MAAM,EAAEE,SAASC,cAAc,EAAE,GAAG,2IAAMhB,UAAAA,EACxC;YACEiB,MAAM;YACNC,MAAM;YACNC,SAAS;YACTN;QACF,GACA;YACEO,UAAU;gBACRC,QAAQC,IAAI,CAAC;YACf;QACF;QAGF,yCAAyC;QACzC,0DAA0D;QAC1D,IAAI,CAACN,gBAAgB;YACnBK,QAAQC,IAAI,CAAC;QACf;IACF;IAEA,MAAMjB;IACN,MAAMkB,kBAAkBrB,QAAQQ,UAAU,GACtC,CAAC,CAAC,EAAER,QAAQQ,UAAU,CAAC,sBAAsB,CAAC,GAC9C;IAEJ,MAAMc,SAAS,MAAMtB,QAAQuB,OAAO,CAAC;QACnChB,SAASP,QAAQO,OAAO;QACxBiB,KAAK,CAAC,cAAc,EAAEH,gBAAgB,mBAAmB,CAAC;IAC5D;IAEA,MAAMI,UAAUH,OAAOI,IAAI;IAE3B,IAAI,CAACD,QAAQf,MAAM,EAAE;QACnB,MAAMV,QAAQuB,OAAO,CAAC;YACpBhB,SAASP,QAAQO,OAAO;YACxBiB,KAAK,CAAC,YAAY,EAAEH,gBAAgB,mCAAmC,CAAC;QAC1E;IACF,OAAO;QACL,MAAMrB,QAAQuB,OAAO,CAAC;YACpBhB,SAASP,QAAQO,OAAO;YACxBiB,KAAK,CAAC,OAAO,EAAEH,gBAAgB,sDAAsD,CAAC;QACxF;IACF;AACF,EAAC"}},
    {"offset": {"line": 5813, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 5819, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/@payloadcms/db-postgres/node_modules/@payloadcms/drizzle/src/utilities/validateExistingBlockIsIdentical.ts"],"sourcesContent":["import type { Block, Field } from 'payload'\n\nimport { InvalidConfiguration } from 'payload'\nimport { fieldAffectsData, fieldHasSubFields, tabHasName } from 'payload/shared'\n\ntype Args = {\n  block: Block\n  localized: boolean\n  rootTableName: string\n  table: Record<string, unknown>\n  tableLocales?: Record<string, unknown>\n}\n\nconst getFlattenedFieldNames = (\n  fields: Field[],\n  prefix: string = '',\n): { localized?: boolean; name: string }[] => {\n  return fields.reduce((fieldsToUse, field) => {\n    let fieldPrefix = prefix\n\n    if (\n      ['array', 'blocks', 'relationship', 'upload'].includes(field.type) ||\n      ('hasMany' in field && field.hasMany === true)\n    ) {\n      return fieldsToUse\n    }\n\n    if (fieldHasSubFields(field)) {\n      fieldPrefix = 'name' in field ? `${prefix}${field.name}_` : prefix\n      return [...fieldsToUse, ...getFlattenedFieldNames(field.fields, fieldPrefix)]\n    }\n\n    if (field.type === 'tabs') {\n      return [\n        ...fieldsToUse,\n        ...field.tabs.reduce((tabFields, tab) => {\n          fieldPrefix = 'name' in tab ? `${prefix}_${tab.name}` : prefix\n          return [\n            ...tabFields,\n            ...(tabHasName(tab)\n              ? [{ ...tab, type: 'tab' }]\n              : getFlattenedFieldNames(tab.fields, fieldPrefix)),\n          ]\n        }, []),\n      ]\n    }\n\n    if (fieldAffectsData(field)) {\n      return [\n        ...fieldsToUse,\n        {\n          name: `${fieldPrefix}${field.name}`,\n          localized: field.localized,\n        },\n      ]\n    }\n\n    return fieldsToUse\n  }, [])\n}\n\nexport const validateExistingBlockIsIdentical = ({\n  block,\n  localized,\n  rootTableName,\n  table,\n  tableLocales,\n}: Args): void => {\n  const fieldNames = getFlattenedFieldNames(block.fields)\n\n  const missingField =\n    // ensure every field from the config is in the matching table\n    fieldNames.find(({ name, localized }) => {\n      const fieldTable = localized && tableLocales ? tableLocales : table\n      return Object.keys(fieldTable).indexOf(name) === -1\n    }) ||\n    // ensure every table column is matched for every field from the config\n    Object.keys(table).find((fieldName) => {\n      if (!['_locale', '_order', '_parentID', '_path', '_uuid'].includes(fieldName)) {\n        return fieldNames.findIndex((field) => field.name) === -1\n      }\n    })\n\n  if (missingField) {\n    throw new InvalidConfiguration(\n      `The table ${rootTableName} has multiple blocks with slug ${\n        block.slug\n      }, but the schemas do not match. One block includes the field ${\n        typeof missingField === 'string' ? missingField : missingField.name\n      }, while the other block does not.`,\n    )\n  }\n\n  if (Boolean(localized) !== Boolean(table._locale)) {\n    throw new InvalidConfiguration(\n      `The table ${rootTableName} has multiple blocks with slug ${block.slug}, but the schemas do not match. One is localized, but another is not. Block schemas of the same name must match exactly.`,\n    )\n  }\n}\n"],"names":["InvalidConfiguration","fieldAffectsData","fieldHasSubFields","tabHasName","getFlattenedFieldNames","fields","prefix","reduce","fieldsToUse","field","fieldPrefix","includes","type","hasMany","name","tabs","tabFields","tab","localized","validateExistingBlockIsIdentical","block","rootTableName","table","tableLocales","fieldNames","missingField","find","fieldTable","Object","keys","indexOf","fieldName","findIndex","slug","Boolean","_locale"],"mappings":";;;AAGA,SAASC,gBAAgB,EAAEC,iBAAiB,EAAEC,UAAU,QAAQ,iBAAgB;AADhF,SAASH,oBAAoB,QAAQ,UAAS;;;AAW9C,MAAMI,yBAAyB,CAC7BC,QACAC,SAAiB,EAAE;IAEnB,OAAOD,OAAOE,MAAM,CAAC,CAACC,aAAaC;QACjC,IAAIC,cAAcJ;QAElB,IACE;YAAC;YAAS;YAAU;YAAgB;SAAS,CAACK,QAAQ,CAACF,MAAMG,IAAI,KAChE,aAAaH,SAASA,MAAMI,OAAO,KAAK,MACzC;YACA,OAAOL;QACT;QAEA,qKAAIN,oBAAAA,EAAkBO,QAAQ;YAC5BC,cAAc,UAAUD,QAAQ,CAAC,EAAEH,OAAO,EAAEG,MAAMK,IAAI,CAAC,CAAC,CAAC,GAAGR;YAC5D,OAAO;mBAAIE;mBAAgBJ,uBAAuBK,MAAMJ,MAAM,EAAEK;aAAa;QAC/E;QAEA,IAAID,MAAMG,IAAI,KAAK,QAAQ;YACzB,OAAO;mBACFJ;mBACAC,MAAMM,IAAI,CAACR,MAAM,CAAC,CAACS,WAAWC;oBAC/BP,cAAc,UAAUO,MAAM,CAAC,EAAEX,OAAO,CAAC,EAAEW,IAAIH,IAAI,CAAC,CAAC,GAAGR;oBACxD,OAAO;2BACFU;4LACCb,aAAAA,EAAWc,OACX;4BAAC;gCAAE,GAAGA,GAAG;gCAAEL,MAAM;4BAAM;yBAAE,GACzBR,uBAAuBa,IAAIZ,MAAM,EAAEK;qBACxC;gBACH,GAAG,EAAE;aACN;QACH;QAEA,KAAIT,mLAAAA,EAAiBQ,QAAQ;YAC3B,OAAO;mBACFD;gBACH;oBACEM,MAAM,CAAC,EAAEJ,YAAY,EAAED,MAAMK,IAAI,CAAC,CAAC;oBACnCI,WAAWT,MAAMS,SAAS;gBAC5B;aACD;QACH;QAEA,OAAOV;IACT,GAAG,EAAE;AACP;AAEO,MAAMW,mCAAmC,CAAC,EAC/CC,KAAK,EACLF,SAAS,EACTG,aAAa,EACbC,KAAK,EACLC,YAAY,EACP;IACL,MAAMC,aAAapB,uBAAuBgB,MAAMf,MAAM;IAEtD,MAAMoB,eAEJD,AADA,WACWE,IAAI,CAAC,CAAC,EAAEZ,IAAI,EAAEI,SAAS,EAAE,0BAD0B;QAE5D,MAAMS,aAAaT,aAAaK,eAAeA,eAAeD;QAC9D,OAAOM,OAAOC,IAAI,CAACF,YAAYG,OAAO,CAAChB,UAAU,CAAC;IACpD,MACA,uEAAuE;IACvEc,OAAOC,IAAI,CAACP,OAAOI,IAAI,CAAC,CAACK;QACvB,IAAI,CAAC;YAAC;YAAW;YAAU;YAAa;YAAS;SAAQ,CAACpB,QAAQ,CAACoB,YAAY;YAC7E,OAAOP,WAAWQ,SAAS,CAAC,CAACvB,QAAUA,MAAMK,IAAI,MAAM,CAAC;QAC1D;IACF;IAEF,IAAIW,cAAc;QAChB,MAAM,sKAAIzB,uBAAAA,CACR,CAAC,UAAU,EAAEqB,cAAc,+BAA+B,EACxDD,MAAMa,IAAI,CACX,6DAA6D,EAC5D,OAAOR,iBAAiB,WAAWA,eAAeA,aAAaX,IAAI,CACpE,iCAAiC,CAAC;IAEvC;IAEA,IAAIoB,QAAQhB,eAAegB,QAAQZ,MAAMa,OAAO,GAAG;QACjD,MAAM,sKAAInC,uBAAAA,CACR,CAAC,UAAU,EAAEqB,cAAc,+BAA+B,EAAED,MAAMa,IAAI,CAAC,wHAAwH,CAAC;IAEpM;AACF,EAAC"}},
    {"offset": {"line": 5897, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 5903, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/@payloadcms/db-postgres/node_modules/@payloadcms/drizzle/src/index.ts"],"sourcesContent":["export { count } from './count.js'\nexport { create } from './create.js'\nexport { createGlobal } from './createGlobal.js'\nexport { createGlobalVersion } from './createGlobalVersion.js'\nexport { createTableName } from './createTableName.js'\nexport { createVersion } from './createVersion.js'\nexport { deleteMany } from './deleteMany.js'\nexport { deleteOne } from './deleteOne.js'\nexport { deleteVersions } from './deleteVersions.js'\nexport { destroy } from './destroy.js'\nexport { find } from './find.js'\nexport { chainMethods } from './find/chainMethods.js'\nexport { findGlobal } from './findGlobal.js'\nexport { findGlobalVersions } from './findGlobalVersions.js'\nexport { findMigrationDir } from './findMigrationDir.js'\nexport { findOne } from './findOne.js'\nexport { findVersions } from './findVersions.js'\nexport { migrate } from './migrate.js'\nexport { migrateDown } from './migrateDown.js'\nexport { migrateFresh } from './migrateFresh.js'\nexport { migrateRefresh } from './migrateRefresh.js'\nexport { migrateReset } from './migrateReset.js'\nexport { migrateStatus } from './migrateStatus.js'\nexport { operatorMap } from './queries/operatorMap.js'\nexport type { Operators } from './queries/operatorMap.js'\nexport { queryDrafts } from './queryDrafts.js'\nexport { beginTransaction } from './transactions/beginTransaction.js'\nexport { commitTransaction } from './transactions/commitTransaction.js'\nexport { rollbackTransaction } from './transactions/rollbackTransaction.js'\nexport { updateOne } from './update.js'\nexport { updateGlobal } from './updateGlobal.js'\nexport { updateGlobalVersion } from './updateGlobalVersion.js'\nexport { updateVersion } from './updateVersion.js'\nexport { upsertRow } from './upsertRow/index.js'\nexport { buildIndexName } from './utilities/buildIndexName.js'\nexport { executeSchemaHooks } from './utilities/executeSchemaHooks.js'\nexport { extendDrizzleTable } from './utilities/extendDrizzleTable.js'\nexport { hasLocalesTable } from './utilities/hasLocalesTable.js'\nexport { pushDevSchema } from './utilities/pushDevSchema.js'\nexport { validateExistingBlockIsIdentical } from './utilities/validateExistingBlockIsIdentical.js'\n"],"names":["count","create","createGlobal","createGlobalVersion","createTableName","createVersion","deleteMany","deleteOne","deleteVersions","destroy","find","chainMethods","findGlobal","findGlobalVersions","findMigrationDir","findOne","findVersions","migrate","migrateDown","migrateFresh","migrateRefresh","migrateReset","migrateStatus","operatorMap","queryDrafts","beginTransaction","commitTransaction","rollbackTransaction","updateOne","updateGlobal","updateGlobalVersion","updateVersion","upsertRow","buildIndexName","executeSchemaHooks","extendDrizzleTable","hasLocalesTable","pushDevSchema","validateExistingBlockIsIdentical"],"mappings":""}},
    {"offset": {"line": 5944, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 5997, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/@payloadcms/db-postgres/node_modules/@payloadcms/drizzle/src/postgres/countDistinct.ts"],"sourcesContent":["import { count } from 'drizzle-orm'\n\nimport type { ChainedMethods, TransactionPg } from '../types.js'\nimport type { BasePostgresAdapter, CountDistinct } from './types.js'\n\nimport { chainMethods } from '../find/chainMethods.js'\n\nexport const countDistinct: CountDistinct = async function countDistinct(\n  this: BasePostgresAdapter,\n  { db, joins, tableName, where },\n) {\n  const chainedMethods: ChainedMethods = []\n\n  joins.forEach(({ condition, table }) => {\n    chainedMethods.push({\n      args: [table, condition],\n      method: 'leftJoin',\n    })\n  })\n\n  const countResult = await chainMethods({\n    methods: chainedMethods,\n    query: (db as TransactionPg)\n      .select({\n        count: count(),\n      })\n      .from(this.tables[tableName])\n      .where(where),\n  })\n\n  return Number(countResult[0].count)\n}\n"],"names":["count","chainMethods","countDistinct","db","joins","tableName","where","chainedMethods","forEach","condition","table","push","args","method","countResult","methods","query","select","from","tables","Number"],"mappings":";;;AAKA,SAASC,YAAY,QAAQ,0BAAyB;AALtD,SAASD,KAAK,QAAQ,cAAa;;;AAO5B,MAAME,gBAA+B,eAAeA,cAEzD,EAAEC,EAAE,EAAEC,KAAK,EAAEC,SAAS,EAAEC,KAAK,EAAE;IAE/B,MAAMC,iBAAiC,EAAE;IAEzCH,MAAMI,OAAO,CAAC,CAAC,EAAEC,SAAS,EAAEC,KAAK,EAAE;QACjCH,eAAeI,IAAI,CAAC;YAClBC,MAAM;gBAACF;gBAAOD;aAAU;YACxBI,QAAQ;QACV;IACF;IAEA,MAAMC,cAAc,OAAMb,4OAAAA,EAAa;QACrCc,SAASR;QACTS,OAAQb,GACLc,MAAM,CAAC;YACNjB,6NAAOA,QAAAA;QACT,GACCkB,IAAI,CAAC,IAAI,CAACC,MAAM,CAACd,UAAU,EAC3BC,KAAK,CAACA;IACX;IAEA,OAAOc,OAAON,WAAW,CAAC,EAAE,CAACd,KAAK;AACpC,EAAC"}},
    {"offset": {"line": 6023, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 6029, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/@payloadcms/db-postgres/node_modules/@payloadcms/drizzle/src/postgres/createDatabase.ts"],"sourcesContent":["import type { ClientConfig } from 'pg'\n\nimport type { BasePostgresAdapter } from './types.js'\n\nconst setConnectionStringDatabase = ({\n  connectionString,\n  database,\n}: {\n  connectionString: string\n  database: string\n}): string => {\n  const connectionURL = new URL(connectionString)\n  const newConnectionURL = new URL(connectionURL)\n  newConnectionURL.pathname = `/${database}`\n\n  return newConnectionURL.toString()\n}\n\ntype Args = {\n  /**\n   * Name of a database, defaults to the current one\n   */\n  name?: string\n  /**\n   * Schema to create in addition to 'public'. Defaults to adapter.schemaName if exists.\n   */\n  schemaName?: string\n}\nexport const createDatabase = async function (this: BasePostgresAdapter, args: Args = {}) {\n  // DATABASE_URL - default Vercel env\n  const connectionString = this.poolOptions?.connectionString ?? process.env.DATABASE_URL\n  let managementClientConfig: ClientConfig = {}\n  let dbName = args.name\n  const schemaName = this.schemaName || 'public'\n\n  if (connectionString) {\n    if (!dbName) {\n      dbName = new URL(connectionString).pathname.slice(1)\n    }\n\n    managementClientConfig.connectionString = setConnectionStringDatabase({\n      connectionString,\n      database: 'postgres',\n    })\n  } else {\n    if (!dbName) {\n      dbName = this.poolOptions.database\n    }\n\n    managementClientConfig = {\n      ...this.poolOptions,\n      database: 'postgres',\n    }\n  }\n\n  // import pg only when createDatabase is used\n  const pg = await import('pg').then((mod) => mod.default)\n\n  const managementClient = new pg.Client(managementClientConfig)\n\n  try {\n    await managementClient.connect()\n    await managementClient.query(`CREATE DATABASE ${dbName}`)\n\n    this.payload.logger.info(`Created database \"${dbName}\"`)\n\n    if (schemaName !== 'public') {\n      let createdDatabaseConfig: ClientConfig = {}\n\n      if (connectionString) {\n        createdDatabaseConfig.connectionString = setConnectionStringDatabase({\n          connectionString,\n          database: dbName,\n        })\n      } else {\n        createdDatabaseConfig = {\n          ...this.poolOptions,\n          database: dbName,\n        }\n      }\n\n      const createdDatabaseClient = new pg.Client(createdDatabaseConfig)\n\n      try {\n        await createdDatabaseClient.connect()\n\n        await createdDatabaseClient.query(`CREATE SCHEMA ${schemaName}`)\n        this.payload.logger.info(`Created schema \"${dbName}.${schemaName}\"`)\n      } catch (err) {\n        this.payload.logger.error({\n          err,\n          msg: `Error: failed to create schema \"${dbName}.${schemaName}\". Details: ${err.message}`,\n        })\n      } finally {\n        await createdDatabaseClient.end()\n      }\n    }\n\n    return true\n  } catch (err) {\n    this.payload.logger.error({\n      err,\n      msg: `Error: failed to create database ${dbName}. Details: ${err.message}`,\n    })\n\n    return false\n  } finally {\n    await managementClient.end()\n  }\n}\n"],"names":["setConnectionStringDatabase","connectionString","database","connectionURL","URL","newConnectionURL","pathname","toString","createDatabase","args","poolOptions","process","env","DATABASE_URL","managementClientConfig","dbName","name","schemaName","slice","pg","then","mod","default","managementClient","Client","connect","query","payload","logger","info","createdDatabaseConfig","createdDatabaseClient","err","error","msg","message","end"],"mappings":";;;AAIA,MAAMA,8BAA8B,CAAC,EACnCC,gBAAgB,EAChBC,QAAQ,EAIT;IACC,MAAMC,gBAAgB,IAAIC,IAAIH;IAC9B,MAAMI,mBAAmB,IAAID,IAAID;IACjCE,iBAAiBC,QAAQ,GAAG,CAAC,CAAC,EAAEJ,SAAS,CAAC;IAE1C,OAAOG,iBAAiBE,QAAQ;AAClC;AAYO,MAAMC,iBAAiB,eAA2CC,OAAa,CAAC,CAAC;IACtF,oCAAoC;IACpC,MAAMR,mBAAmB,IAAI,CAACS,WAAW,EAAET,oBAAoBU,QAAQC,GAAG,CAACC,YAAY;IACvF,IAAIC,yBAAuC,CAAC;IAC5C,IAAIC,SAASN,KAAKO,IAAI;IACtB,MAAMC,aAAa,IAAI,CAACA,UAAU,IAAI;IAEtC,IAAIhB,kBAAkB;QACpB,IAAI,CAACc,QAAQ;YACXA,SAAS,IAAIX,IAAIH,kBAAkBK,QAAQ,CAACY,KAAK,CAAC;QACpD;QAEAJ,uBAAuBb,gBAAgB,GAAGD,4BAA4B;YACpEC;YACAC,UAAU;QACZ;IACF,OAAO;QACL,IAAI,CAACa,QAAQ;YACXA,SAAS,IAAI,CAACL,WAAW,CAACR,QAAQ;QACpC;QAEAY,yBAAyB;YACvB,GAAG,IAAI,CAACJ,WAAW;YACnBR,UAAU;QACZ;IACF;IAEA,6CAA6C;IAC7C,MAAMiB,KAAK,MAAM,MAAM,CAAC,wFAAMC,IAAI,CAAC,CAACC,MAAQA,IAAIC,OAAO;IAEvD,MAAMC,mBAAmB,IAAIJ,GAAGK,MAAM,CAACV;IAEvC,IAAI;QACF,MAAMS,iBAAiBE,OAAO;QAC9B,MAAMF,iBAAiBG,KAAK,CAAC,CAAC,gBAAgB,EAAEX,OAAO,CAAC;QAExD,IAAI,CAACY,OAAO,CAACC,MAAM,CAACC,IAAI,CAAC,CAAC,kBAAkB,EAAEd,OAAO,CAAC,CAAC;QAEvD,IAAIE,eAAe,UAAU;YAC3B,IAAIa,wBAAsC,CAAC;YAE3C,IAAI7B,kBAAkB;gBACpB6B,sBAAsB7B,gBAAgB,GAAGD,4BAA4B;oBACnEC;oBACAC,UAAUa;gBACZ;YACF,OAAO;gBACLe,wBAAwB;oBACtB,GAAG,IAAI,CAACpB,WAAW;oBACnBR,UAAUa;gBACZ;YACF;YAEA,MAAMgB,wBAAwB,IAAIZ,GAAGK,MAAM,CAACM;YAE5C,IAAI;gBACF,MAAMC,sBAAsBN,OAAO;gBAEnC,MAAMM,sBAAsBL,KAAK,CAAC,CAAC,cAAc,EAAET,WAAW,CAAC;gBAC/D,IAAI,CAACU,OAAO,CAACC,MAAM,CAACC,IAAI,CAAC,CAAC,gBAAgB,EAAEd,OAAO,CAAC,EAAEE,WAAW,CAAC,CAAC;YACrE,EAAE,OAAOe,KAAK;gBACZ,IAAI,CAACL,OAAO,CAACC,MAAM,CAACK,KAAK,CAAC;oBACxBD;oBACAE,KAAK,CAAC,gCAAgC,EAAEnB,OAAO,CAAC,EAAEE,WAAW,YAAY,EAAEe,IAAIG,OAAO,CAAC,CAAC;gBAC1F;YACF,SAAU;gBACR,MAAMJ,sBAAsBK,GAAG;YACjC;QACF;QAEA,OAAO;IACT,EAAE,OAAOJ,KAAK;QACZ,IAAI,CAACL,OAAO,CAACC,MAAM,CAACK,KAAK,CAAC;YACxBD;YACAE,KAAK,CAAC,iCAAiC,EAAEnB,OAAO,WAAW,EAAEiB,IAAIG,OAAO,CAAC,CAAC;QAC5E;QAEA,OAAO;IACT,SAAU;QACR,MAAMZ,iBAAiBa,GAAG;IAC5B;AACF,EAAC"}},
    {"offset": {"line": 6106, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 6112, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/@payloadcms/db-postgres/node_modules/@payloadcms/drizzle/src/postgres/createJSONQuery/formatJSONPathSegment.ts"],"sourcesContent":["export const formatJSONPathSegment = (segment: string) => {\n  return Number.isNaN(parseInt(segment)) ? `'${segment}'` : segment\n}\n"],"names":["formatJSONPathSegment","segment","Number","isNaN","parseInt"],"mappings":";;;AAAO,MAAMA,wBAAwB,CAACC;IACpC,OAAOC,OAAOC,KAAK,CAACC,SAASH,YAAY,CAAC,CAAC,EAAEA,QAAQ,CAAC,CAAC,GAAGA;AAC5D,EAAC"}},
    {"offset": {"line": 6118, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 6124, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/@payloadcms/db-postgres/node_modules/@payloadcms/drizzle/src/postgres/createJSONQuery/convertPathToJSONTraversal.ts"],"sourcesContent":["import { formatJSONPathSegment } from './formatJSONPathSegment.js'\n\nexport const convertPathToJSONTraversal = (incomingSegments: string[]) => {\n  const segments = [...incomingSegments]\n  segments.shift()\n\n  return segments.reduce((res, segment, i) => {\n    const formattedSegment = formatJSONPathSegment(segment)\n\n    if (i + 1 === segments.length) {\n      return `${res}->>${formattedSegment}`\n    }\n    return `${res}->${formattedSegment}`\n  }, '')\n}\n"],"names":["formatJSONPathSegment","convertPathToJSONTraversal","incomingSegments","segments","shift","reduce","res","segment","i","formattedSegment","length"],"mappings":";;;AAAA,SAASA,qBAAqB,QAAQ,6BAA4B;;AAE3D,MAAMC,6BAA6B,CAACC;IACzC,MAAMC,WAAW;WAAID;KAAiB;IACtCC,SAASC,KAAK;IAEd,OAAOD,SAASE,MAAM,CAAC,CAACC,KAAKC,SAASC;QACpC,MAAMC,iRAAmBT,wBAAAA,EAAsBO;QAE/C,IAAIC,IAAI,MAAML,SAASO,MAAM,EAAE;YAC7B,OAAO,CAAC,EAAEJ,IAAI,GAAG,EAAEG,iBAAiB,CAAC;QACvC;QACA,OAAO,CAAC,EAAEH,IAAI,EAAE,EAAEG,iBAAiB,CAAC;IACtC,GAAG;AACL,EAAC"}},
    {"offset": {"line": 6142, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 6148, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/@payloadcms/db-postgres/node_modules/@payloadcms/drizzle/src/postgres/createJSONQuery/index.ts"],"sourcesContent":["import { convertPathToJSONTraversal } from './convertPathToJSONTraversal.js'\nimport { formatJSONPathSegment } from './formatJSONPathSegment.js'\n\nconst operatorMap = {\n  contains: '~*',\n  equals: '=',\n  like: '~*',\n}\n\ntype FromArrayArgs = {\n  isRoot?: true\n  operator: string\n  pathSegments: string[]\n  treatAsArray?: string[]\n  value: unknown\n}\n\nconst fromArray = ({ isRoot, operator, pathSegments, treatAsArray, value }: FromArrayArgs) => {\n  const newPathSegments = pathSegments.slice(isRoot ? 1 : 2)\n  const alias = `${pathSegments[isRoot ? 0 : 1]}_alias_${newPathSegments.length}`\n\n  newPathSegments.unshift(alias)\n\n  const arrayElements = isRoot\n    ? pathSegments[0]\n    : `${pathSegments[0]} -> ${formatJSONPathSegment(pathSegments[1])}`\n\n  return `EXISTS (\n    SELECT 1\n    FROM jsonb_array_elements(${arrayElements}) AS ${alias}\n    WHERE ${createJSONQuery({\n      operator,\n      pathSegments: newPathSegments,\n      treatAsArray,\n      value,\n    })}\n  )`\n}\n\ntype CreateConstraintArgs = {\n  operator: string\n  pathSegments: string[]\n  treatAsArray?: string[]\n  value: unknown\n}\n\nconst createConstraint = ({ operator, pathSegments, value }: CreateConstraintArgs): string => {\n  const jsonQuery = convertPathToJSONTraversal(pathSegments)\n  return `${pathSegments[0]}${jsonQuery} ${operatorMap[operator]} '${value}'`\n}\n\ntype Args = {\n  operator: string\n  pathSegments: string[]\n  treatAsArray?: string[]\n  treatRootAsArray?: boolean\n  value: unknown\n}\n\nexport const createJSONQuery = ({\n  operator,\n  pathSegments,\n  treatAsArray,\n  treatRootAsArray,\n  value,\n}: Args): string => {\n  if (treatRootAsArray) {\n    return fromArray({\n      isRoot: true,\n      operator,\n      pathSegments,\n      treatAsArray,\n      value,\n    })\n  }\n\n  if (treatAsArray.includes(pathSegments[1])) {\n    return fromArray({\n      operator,\n      pathSegments,\n      treatAsArray,\n      value,\n    })\n  }\n\n  return createConstraint({ operator, pathSegments, treatAsArray, value })\n}\n"],"names":["convertPathToJSONTraversal","formatJSONPathSegment","operatorMap","contains","equals","like","fromArray","isRoot","operator","pathSegments","treatAsArray","value","newPathSegments","slice","alias","length","unshift","arrayElements","createJSONQuery","createConstraint","jsonQuery","treatRootAsArray","includes"],"mappings":";;;AAAA,SAASA,0BAA0B,QAAQ,kCAAiC;AAC5E,SAASC,qBAAqB,QAAQ,6BAA4B;;;AAElE,MAAMC,cAAc;IAClBC,UAAU;IACVC,QAAQ;IACRC,MAAM;AACR;AAUA,MAAMC,YAAY,CAAC,EAAEC,MAAM,EAAEC,QAAQ,EAAEC,YAAY,EAAEC,YAAY,EAAEC,KAAK,EAAiB;IACvF,MAAMC,kBAAkBH,aAAaI,KAAK,CAACN,SAAS,IAAI;IACxD,MAAMO,QAAQ,CAAC,EAAEL,YAAY,CAACF,SAAS,IAAI,EAAE,CAAC,OAAO,EAAEK,gBAAgBG,MAAM,CAAC,CAAC;IAE/EH,gBAAgBI,OAAO,CAACF;IAExB,MAAMG,gBAAgBV,SAClBE,YAAY,CAAC,EAAE,GACf,CAAC,EAAEA,YAAY,CAAC,EAAE,CAAC,IAAI,gQAAER,wBAAAA,EAAsBQ,YAAY,CAAC,EAAE,EAAE,CAAC;IAErE,OAAO,CAAC;;8BAEoB,EAAEQ,cAAc,KAAK,EAAEH,MAAM;UACjD,EAAEI,gBAAgB;QACtBV;QACAC,cAAcG;QACdF;QACAC;IACF,GAAG;GACJ,CAAC;AACJ;AASA,MAAMQ,mBAAmB,CAAC,EAAEX,QAAQ,EAAEC,YAAY,EAAEE,KAAK,EAAwB;IAC/E,MAAMS,+QAAYpB,6BAAAA,EAA2BS;IAC7C,OAAO,CAAC,EAAEA,YAAY,CAAC,EAAE,CAAC,EAAEW,UAAU,CAAC,EAAElB,WAAW,CAACM,SAAS,CAAC,EAAE,EAAEG,MAAM,CAAC,CAAC;AAC7E;AAUO,MAAMO,kBAAkB,CAAC,EAC9BV,QAAQ,EACRC,YAAY,EACZC,YAAY,EACZW,gBAAgB,EAChBV,KAAK,EACA;IACL,IAAIU,kBAAkB;QACpB,OAAOf,UAAU;YACfC,QAAQ;YACRC;YACAC;YACAC;YACAC;QACF;IACF;IAEA,IAAID,aAAaY,QAAQ,CAACb,YAAY,CAAC,EAAE,GAAG;QAC1C,OAAOH,UAAU;YACfE;YACAC;YACAC;YACAC;QACF;IACF;IAEA,OAAOQ,iBAAiB;QAAEX;QAAUC;QAAcC;QAAcC;IAAM;AACxE,EAAC"}},
    {"offset": {"line": 6205, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 6211, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/@payloadcms/db-postgres/node_modules/@payloadcms/drizzle/src/postgres/defaultSnapshot.ts"],"sourcesContent":["import type { DrizzleSnapshotJSON } from 'drizzle-kit/api'\n\nexport const defaultDrizzleSnapshot: DrizzleSnapshotJSON = {\n  id: '00000000-0000-0000-0000-000000000000',\n  _meta: {\n    columns: {},\n    schemas: {},\n    tables: {},\n  },\n  dialect: 'postgresql',\n  enums: {},\n  prevId: '00000000-0000-0000-0000-00000000000',\n  schemas: {},\n  sequences: {},\n  tables: {},\n  version: '7',\n  views: {},\n}\n"],"names":["defaultDrizzleSnapshot","id","_meta","columns","schemas","tables","dialect","enums","prevId","sequences","version","views"],"mappings":";;;AAEO,MAAMA,yBAA8C;IACzDC,IAAI;IACJC,OAAO;QACLC,SAAS,CAAC;QACVC,SAAS,CAAC;QACVC,QAAQ,CAAC;IACX;IACAC,SAAS;IACTC,OAAO,CAAC;IACRC,QAAQ;IACRJ,SAAS,CAAC;IACVK,WAAW,CAAC;IACZJ,QAAQ,CAAC;IACTK,SAAS;IACTC,OAAO,CAAC;AACV,EAAC"}},
    {"offset": {"line": 6230, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 6236, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/@payloadcms/db-postgres/node_modules/@payloadcms/drizzle/src/postgres/getMigrationTemplate.ts"],"sourcesContent":["import type { MigrationTemplateArgs } from 'payload'\n\nexport const indent = (text: string) =>\n  text\n    .split('\\n')\n    .map((line) => `  ${line}`)\n    .join('\\n')\n\nexport const getMigrationTemplate = ({\n  downSQL,\n  imports,\n  packageName,\n  upSQL,\n}: MigrationTemplateArgs): string => `import { MigrateUpArgs, MigrateDownArgs, sql } from '${packageName}'\n${imports ? `${imports}\\n` : ''}\nexport async function up({ payload, req }: MigrateUpArgs): Promise<void> {\n${indent(upSQL)}\n}\n\nexport async function down({ payload, req }: MigrateDownArgs): Promise<void> {\n${indent(downSQL)}\n}\n`\n"],"names":["indent","text","split","map","line","join","getMigrationTemplate","downSQL","imports","packageName","upSQL"],"mappings":";;;;AAEO,MAAMA,SAAS,CAACC,OACrBA,KACGC,KAAK,CAAC,MACNC,GAAG,CAAC,CAACC,OAAS,CAAC,EAAE,EAAEA,KAAK,CAAC,EACzBC,IAAI,CAAC,MAAK;AAER,MAAMC,uBAAuB,CAAC,EACnCC,OAAO,EACPC,OAAO,EACPC,WAAW,EACXC,KAAK,EACiB,GAAa,CAAC,qDAAqD,EAAED,YAAY;AACzG,EAAED,UAAU,CAAC,EAAEA,QAAQ,EAAE,CAAC,GAAG,GAAG;;AAEhC,EAAER,OAAOU,OAAO;;;;AAIhB,EAAEV,OAAOO,SAAS;;AAElB,CAAC,CAAA"}},
    {"offset": {"line": 6251, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 6257, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/@payloadcms/db-postgres/node_modules/@payloadcms/drizzle/src/postgres/createMigration.ts"],"sourcesContent":["import type { CreateMigration } from 'payload'\n\nimport fs from 'fs'\nimport { createRequire } from 'module'\nimport path from 'path'\nimport { getPredefinedMigration, writeMigrationIndex } from 'payload'\nimport prompts from 'prompts'\nimport { fileURLToPath } from 'url'\n\nimport type { BasePostgresAdapter } from './types.js'\n\nimport { defaultDrizzleSnapshot } from './defaultSnapshot.js'\nimport { getMigrationTemplate } from './getMigrationTemplate.js'\n\nconst require = createRequire(import.meta.url)\n\nexport const createMigration: CreateMigration = async function createMigration(\n  this: BasePostgresAdapter,\n  { file, forceAcceptWarning, migrationName, payload },\n) {\n  const filename = fileURLToPath(import.meta.url)\n  const dirname = path.dirname(filename)\n  const dir = payload.db.migrationDir\n  if (!fs.existsSync(dir)) {\n    fs.mkdirSync(dir)\n  }\n  const { generateDrizzleJson, generateMigration, upPgSnapshot } = require('drizzle-kit/api')\n  const drizzleJsonAfter = generateDrizzleJson(this.schema)\n  const [yyymmdd, hhmmss] = new Date().toISOString().split('T')\n  const formattedDate = yyymmdd.replace(/\\D/g, '')\n  const formattedTime = hhmmss.split('.')[0].replace(/\\D/g, '')\n  let imports: string = ''\n  let downSQL: string\n  let upSQL: string\n  ;({ downSQL, imports, upSQL } = await getPredefinedMigration({\n    dirname,\n    file,\n    migrationName,\n    payload,\n  }))\n\n  const timestamp = `${formattedDate}_${formattedTime}`\n\n  const name = migrationName || file?.split('/').slice(2).join('/')\n  const fileName = `${timestamp}${name ? `_${name.replace(/\\W/g, '_')}` : ''}`\n\n  const filePath = `${dir}/${fileName}`\n\n  let drizzleJsonBefore = defaultDrizzleSnapshot\n\n  if (this.schemaName) {\n    drizzleJsonBefore.schemas = {\n      [this.schemaName]: this.schemaName,\n    }\n  }\n\n  if (!upSQL) {\n    // Get latest migration snapshot\n    const latestSnapshot = fs\n      .readdirSync(dir)\n      .filter((file) => file.endsWith('.json'))\n      .sort()\n      .reverse()?.[0]\n\n    if (latestSnapshot) {\n      drizzleJsonBefore = JSON.parse(fs.readFileSync(`${dir}/${latestSnapshot}`, 'utf8'))\n\n      if (drizzleJsonBefore.version < drizzleJsonAfter.version) {\n        drizzleJsonBefore = upPgSnapshot(drizzleJsonBefore)\n      }\n    }\n\n    const sqlStatementsUp = await generateMigration(drizzleJsonBefore, drizzleJsonAfter)\n    const sqlStatementsDown = await generateMigration(drizzleJsonAfter, drizzleJsonBefore)\n    const sqlExecute = 'await payload.db.drizzle.execute(sql`'\n\n    if (sqlStatementsUp?.length) {\n      upSQL = `${sqlExecute}\\n ${sqlStatementsUp?.join('\\n')}\\`)`\n    }\n    if (sqlStatementsDown?.length) {\n      downSQL = `${sqlExecute}\\n ${sqlStatementsDown?.join('\\n')}\\`)`\n    }\n\n    if (!upSQL?.length && !downSQL?.length && !forceAcceptWarning) {\n      const { confirm: shouldCreateBlankMigration } = await prompts(\n        {\n          name: 'confirm',\n          type: 'confirm',\n          initial: false,\n          message: 'No schema changes detected. Would you like to create a blank migration file?',\n        },\n        {\n          onCancel: () => {\n            process.exit(0)\n          },\n        },\n      )\n\n      if (!shouldCreateBlankMigration) {\n        process.exit(0)\n      }\n    }\n\n    // write schema\n    fs.writeFileSync(`${filePath}.json`, JSON.stringify(drizzleJsonAfter, null, 2))\n  }\n\n  // write migration\n  fs.writeFileSync(\n    `${filePath}.ts`,\n    getMigrationTemplate({\n      downSQL: downSQL || `  // Migration code`,\n      imports,\n      packageName: payload.db.packageName,\n      upSQL: upSQL || `  // Migration code`,\n    }),\n  )\n\n  writeMigrationIndex({ migrationsDir: payload.db.migrationDir })\n\n  payload.logger.info({ msg: `Migration created at ${filePath}.ts` })\n}\n"],"names":["fs","createRequire","path","getPredefinedMigration","writeMigrationIndex","prompts","fileURLToPath","defaultDrizzleSnapshot","getMigrationTemplate","require","url","createMigration","file","forceAcceptWarning","migrationName","payload","filename","dirname","dir","db","migrationDir","existsSync","mkdirSync","generateDrizzleJson","generateMigration","upPgSnapshot","drizzleJsonAfter","schema","yyymmdd","hhmmss","Date","toISOString","split","formattedDate","replace","formattedTime","imports","downSQL","upSQL","timestamp","name","slice","join","fileName","filePath","drizzleJsonBefore","schemaName","schemas","latestSnapshot","readdirSync","filter","endsWith","sort","reverse","JSON","parse","readFileSync","version","sqlStatementsUp","sqlStatementsDown","sqlExecute","length","confirm","shouldCreateBlankMigration","type","initial","message","onCancel","process","exit","writeFileSync","stringify","packageName","migrationsDir","logger","info","msg"],"mappings":"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"}},
    {"offset": {"line": 6364, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 6370, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/@payloadcms/db-postgres/node_modules/@payloadcms/drizzle/src/postgres/deleteWhere.ts"],"sourcesContent":["import type { TransactionPg } from '../types.js'\nimport type { DeleteWhere } from './types.js'\n\nexport const deleteWhere: DeleteWhere = async function deleteWhere({ db, tableName, where }) {\n  const table = this.tables[tableName]\n  await (db as TransactionPg).delete(table).where(where)\n}\n"],"names":["deleteWhere","db","tableName","where","table","tables","delete"],"mappings":";;;AAGO,MAAMA,cAA2B,eAAeA,YAAY,EAAEC,EAAE,EAAEC,SAAS,EAAEC,KAAK,EAAE;IACzF,MAAMC,QAAQ,IAAI,CAACC,MAAM,CAACH,UAAU;IACpC,MAAOD,GAAqBK,MAAM,CAACF,OAAOD,KAAK,CAACA;AAClD,EAAC"}},
    {"offset": {"line": 6377, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 6383, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/@payloadcms/db-postgres/node_modules/@payloadcms/drizzle/src/postgres/dropDatabase.ts"],"sourcesContent":["import type { DropDatabase } from './types.js'\n\nexport const dropDatabase: DropDatabase = async function dropDatabase({ adapter }) {\n  await adapter.execute({\n    drizzle: adapter.drizzle,\n    raw: `drop schema if exists ${this.schemaName || 'public'} cascade;\n    create schema ${this.schemaName || 'public'};`,\n  })\n}\n"],"names":["dropDatabase","adapter","execute","drizzle","raw","schemaName"],"mappings":";;;AAEO,MAAMA,eAA6B,eAAeA,aAAa,EAAEC,OAAO,EAAE;IAC/E,MAAMA,QAAQC,OAAO,CAAC;QACpBC,SAASF,QAAQE,OAAO;QACxBC,KAAK,CAAC,sBAAsB,EAAE,IAAI,CAACC,UAAU,IAAI,SAAS;kBAC5C,EAAE,IAAI,CAACA,UAAU,IAAI,SAAS,CAAC,CAAC;IAChD;AACF,EAAC"}},
    {"offset": {"line": 6393, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 6399, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/@payloadcms/db-postgres/node_modules/@payloadcms/drizzle/src/postgres/execute.ts"],"sourcesContent":["import { sql } from 'drizzle-orm'\n\nimport type { Execute } from './types.js'\n\nexport const execute: Execute<any> = function execute({ db, drizzle, raw, sql: statement }) {\n  const executeFrom = db ?? drizzle\n\n  if (raw) {\n    return executeFrom.execute(sql.raw(raw))\n  } else {\n    return executeFrom.execute(sql`${statement}`)\n  }\n}\n"],"names":["sql","execute","db","drizzle","raw","statement","executeFrom"],"mappings":";;;AAAA,SAASA,GAAG,QAAQ,cAAa;;AAI1B,MAAMC,UAAwB,SAASA,QAAQ,EAAEC,EAAE,EAAEC,OAAO,EAAEC,GAAG,EAAEJ,KAAKK,SAAS,EAAE;IACxF,MAAMC,cAAcJ,MAAMC;IAE1B,IAAIC,KAAK;QACP,OAAOE,YAAYL,OAAO,gMAACD,MAAAA,CAAII,GAAG,CAACA;IACrC,OAAO;QACL,OAAOE,YAAYL,OAAO,gMAACD,MAAG,CAAC,EAAEK,UAAU,CAAC;IAC9C;AACF,EAAC"}},
    {"offset": {"line": 6412, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 6418, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/@payloadcms/db-postgres/node_modules/@payloadcms/drizzle/src/postgres/schema/createIndex.ts"],"sourcesContent":["import { index, uniqueIndex } from 'drizzle-orm/pg-core'\n\nimport type { GenericColumn } from '../types.js'\n\ntype CreateIndexArgs = {\n  indexName: string\n  name: string | string[]\n  unique?: boolean\n}\n\nexport const createIndex = ({ name, indexName, unique }: CreateIndexArgs) => {\n  return (table: { [x: string]: GenericColumn }) => {\n    let columns\n    if (Array.isArray(name)) {\n      columns = name\n        .map((columnName) => table[columnName])\n        // exclude fields were included in compound indexes but do not exist on the table\n        .filter((col) => typeof col !== 'undefined')\n    } else {\n      columns = [table[name]]\n    }\n    if (unique) {\n      return uniqueIndex(indexName).on(columns[0], ...columns.slice(1))\n    }\n    return index(indexName).on(columns[0], ...columns.slice(1))\n  }\n}\n"],"names":["index","uniqueIndex","createIndex","name","indexName","unique","table","columns","Array","isArray","map","columnName","filter","col","on","slice"],"mappings":";;;AAAA,SAASA,KAAK,EAAEC,WAAW,QAAQ,sBAAqB;;AAUjD,MAAMC,cAAc,CAAC,EAAEC,IAAI,EAAEC,SAAS,EAAEC,MAAM,EAAmB;IACtE,OAAO,CAACC;QACN,IAAIC;QACJ,IAAIC,MAAMC,OAAO,CAACN,OAAO;YACvBI,UAAUJ,KACPO,GAAG,CAAC,CAACC,aAAeL,KAAK,CAACK,WAAW,EACtC,iFAAiF;aAChFC,MAAM,CAAC,CAACC,MAAQ,OAAOA,QAAQ;QACpC,OAAO;YACLN,UAAU;gBAACD,KAAK,CAACH,KAAK;aAAC;QACzB;QACA,IAAIE,QAAQ;YACV,qNAAOJ,cAAAA,EAAYG,WAAWU,EAAE,CAACP,OAAO,CAAC,EAAE,KAAKA,QAAQQ,KAAK,CAAC;QAChE;QACA,qNAAOf,QAAAA,EAAMI,WAAWU,EAAE,CAACP,OAAO,CAAC,EAAE,KAAKA,QAAQQ,KAAK,CAAC;IAC1D;AACF,EAAC"}},
    {"offset": {"line": 6440, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 6446, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/@payloadcms/db-postgres/node_modules/@payloadcms/drizzle/src/postgres/schema/parentIDColumnMap.ts"],"sourcesContent":["import { integer, numeric, uuid, varchar } from 'drizzle-orm/pg-core'\n\nimport type { IDType } from '../types.js'\n\nexport const parentIDColumnMap: Record<\n  IDType,\n  typeof integer<string> | typeof numeric<string> | typeof uuid<string> | typeof varchar\n> = {\n  integer,\n  numeric,\n  uuid,\n  varchar,\n}\n"],"names":["integer","numeric","uuid","varchar","parentIDColumnMap"],"mappings":";;;;;;AAAA,SAASA,OAAO,EAAEC,OAAO,EAAEC,IAAI,EAAEC,OAAO,QAAQ,sBAAqB;;AAI9D,MAAMC,oBAGT;kOACFJ,UAAAA;kOACAC,UAAAA;4NACAC,OAAAA;kOACAC,UAAAA;AACF,EAAC"}},
    {"offset": {"line": 6460, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 6466, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/@payloadcms/db-postgres/node_modules/@payloadcms/drizzle/src/postgres/schema/setColumnID.ts"],"sourcesContent":["import type { PgColumnBuilder } from 'drizzle-orm/pg-core'\n\nimport { numeric, serial, uuid, varchar } from 'drizzle-orm/pg-core'\nimport { type Field, flattenTopLevelFields } from 'payload'\nimport { fieldAffectsData } from 'payload/shared'\n\nimport type { BasePostgresAdapter, IDType } from '../types.js'\n\ntype Args = {\n  adapter: BasePostgresAdapter\n  columns: Record<string, PgColumnBuilder>\n  fields: Field[]\n}\nexport const setColumnID = ({ adapter, columns, fields }: Args): IDType => {\n  const idField = flattenTopLevelFields(fields).find(\n    (field) => fieldAffectsData(field) && field.name === 'id',\n  )\n  if (idField) {\n    if (idField.type === 'number') {\n      columns.id = numeric('id').primaryKey()\n      return 'numeric'\n    }\n\n    if (idField.type === 'text') {\n      columns.id = varchar('id').primaryKey()\n      return 'varchar'\n    }\n  }\n\n  if (adapter.idType === 'uuid') {\n    columns.id = uuid('id').defaultRandom().primaryKey()\n    return 'uuid'\n  }\n\n  columns.id = serial('id').primaryKey()\n  return 'integer'\n}\n"],"names":["numeric","serial","uuid","varchar","flattenTopLevelFields","fieldAffectsData","setColumnID","adapter","columns","fields","idField","find","field","name","type","id","primaryKey","idType","defaultRandom"],"mappings":";;;AAGA,SAAqBI,qBAAqB,QAAQ,UAAS;AAC3D,SAASC,gBAAgB,QAAQ,iBAAgB;AAFjD,SAASL,OAAO,EAAEC,MAAM,EAAEC,IAAI,EAAEC,OAAO,QAAQ,sBAAqB;;;;;;;AAW7D,MAAMG,cAAc,CAAC,EAAEC,OAAO,EAAEC,OAAO,EAAEC,MAAM,EAAQ;IAC5D,MAAMC,cAAUN,kPAAAA,EAAsBK,QAAQE,IAAI,CAChD,CAACC,yKAAUP,mBAAAA,EAAiBO,UAAUA,MAAMC,IAAI,KAAK;IAEvD,IAAIH,SAAS;QACX,IAAIA,QAAQI,IAAI,KAAK,UAAU;YAC7BN,QAAQO,EAAE,4NAAGf,UAAAA,EAAQ,MAAMgB,UAAU;YACrC,OAAO;QACT;QAEA,IAAIN,QAAQI,IAAI,KAAK,QAAQ;YAC3BN,QAAQO,EAAE,4NAAGZ,UAAAA,EAAQ,MAAMa,UAAU;YACrC,OAAO;QACT;IACF;IAEA,IAAIT,QAAQU,MAAM,KAAK,QAAQ;QAC7BT,QAAQO,EAAE,yNAAGb,OAAAA,EAAK,MAAMgB,aAAa,GAAGF,UAAU;QAClD,OAAO;IACT;IAEAR,QAAQO,EAAE,2NAAGd,SAAAA,EAAO,MAAMe,UAAU;IACpC,OAAO;AACT,EAAC"}},
    {"offset": {"line": 6497, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 6503, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/@payloadcms/db-postgres/node_modules/@payloadcms/drizzle/src/postgres/schema/idToUUID.ts"],"sourcesContent":["import type { Field } from 'payload'\n\nexport const idToUUID = (fields: Field[]): Field[] =>\n  fields.map((field) => {\n    if ('name' in field && field.name === 'id') {\n      return {\n        ...field,\n        name: '_uuid',\n      }\n    }\n\n    return field\n  })\n"],"names":["idToUUID","fields","map","field","name"],"mappings":";;;AAEO,MAAMA,WAAW,CAACC,SACvBA,OAAOC,GAAG,CAAC,CAACC;QACV,IAAI,UAAUA,SAASA,MAAMC,IAAI,KAAK,MAAM;YAC1C,OAAO;gBACL,GAAGD,KAAK;gBACRC,MAAM;YACR;QACF;QAEA,OAAOD;IACT,GAAE"}},
    {"offset": {"line": 6515, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 6521, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/@payloadcms/db-postgres/node_modules/@payloadcms/drizzle/src/postgres/schema/withDefault.ts"],"sourcesContent":["import type { PgColumnBuilder } from 'drizzle-orm/pg-core'\nimport type { FieldAffectingData } from 'payload'\n\nexport const withDefault = (\n  column: PgColumnBuilder,\n  field: FieldAffectingData,\n): PgColumnBuilder => {\n  if (typeof field.defaultValue === 'undefined' || typeof field.defaultValue === 'function') {\n    return column\n  }\n\n  if (typeof field.defaultValue === 'string' && field.defaultValue.includes(\"'\")) {\n    const escapedString = field.defaultValue.replaceAll(\"'\", \"''\")\n    return column.default(escapedString)\n  }\n\n  return column.default(field.defaultValue)\n}\n"],"names":["withDefault","column","field","defaultValue","includes","escapedString","replaceAll","default"],"mappings":";;;AAGO,MAAMA,cAAc,CACzBC,QACAC;IAEA,IAAI,OAAOA,MAAMC,YAAY,KAAK,eAAe,OAAOD,MAAMC,YAAY,KAAK,YAAY;QACzF,OAAOF;IACT;IAEA,IAAI,OAAOC,MAAMC,YAAY,KAAK,YAAYD,MAAMC,YAAY,CAACC,QAAQ,CAAC,MAAM;QAC9E,MAAMC,gBAAgBH,MAAMC,YAAY,CAACG,UAAU,CAAC,KAAK;QACzD,OAAOL,OAAOM,OAAO,CAACF;IACxB;IAEA,OAAOJ,OAAOM,OAAO,CAACL,MAAMC,YAAY;AAC1C,EAAC"}},
    {"offset": {"line": 6534, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 6540, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/@payloadcms/db-postgres/node_modules/@payloadcms/drizzle/src/postgres/schema/traverseFields.ts"],"sourcesContent":["import type { Relation } from 'drizzle-orm'\nimport type { IndexBuilder, PgColumnBuilder } from 'drizzle-orm/pg-core'\nimport type { Field, SanitizedJoins, TabAsField } from 'payload'\n\nimport { relations } from 'drizzle-orm'\nimport {\n  boolean,\n  foreignKey,\n  index,\n  integer,\n  jsonb,\n  numeric,\n  PgNumericBuilder,\n  PgUUIDBuilder,\n  PgVarcharBuilder,\n  text,\n  timestamp,\n  varchar,\n} from 'drizzle-orm/pg-core'\nimport { InvalidConfiguration } from 'payload'\nimport { fieldAffectsData, fieldIsVirtual, optionIsObject } from 'payload/shared'\nimport toSnakeCase from 'to-snake-case'\n\nimport type {\n  BaseExtraConfig,\n  BasePostgresAdapter,\n  GenericColumns,\n  IDType,\n  RelationMap,\n} from '../types.js'\n\nimport { createTableName } from '../../createTableName.js'\nimport { buildIndexName } from '../../utilities/buildIndexName.js'\nimport { hasLocalesTable } from '../../utilities/hasLocalesTable.js'\nimport { validateExistingBlockIsIdentical } from '../../utilities/validateExistingBlockIsIdentical.js'\nimport { buildTable } from './build.js'\nimport { createIndex } from './createIndex.js'\nimport { idToUUID } from './idToUUID.js'\nimport { parentIDColumnMap } from './parentIDColumnMap.js'\nimport { withDefault } from './withDefault.js'\n\ntype Args = {\n  adapter: BasePostgresAdapter\n  columnPrefix?: string\n  columns: Record<string, PgColumnBuilder>\n  disableNotNull: boolean\n  disableRelsTableUnique?: boolean\n  disableUnique?: boolean\n  fieldPrefix?: string\n  fields: (Field | TabAsField)[]\n  forceLocalized?: boolean\n  indexes: Record<string, (cols: GenericColumns) => IndexBuilder>\n  localesColumns: Record<string, PgColumnBuilder>\n  localesIndexes: Record<string, (cols: GenericColumns) => IndexBuilder>\n  newTableName: string\n  parentTableName: string\n  relationships: Set<string>\n  relationsToBuild: RelationMap\n  rootRelationsToBuild?: RelationMap\n  rootTableIDColType: string\n  rootTableName: string\n  uniqueRelationships: Set<string>\n  versions: boolean\n  /**\n   * Tracks whether or not this table is built\n   * from the result of a localized array or block field at some point\n   */\n  withinLocalizedArrayOrBlock?: boolean\n}\n\ntype Result = {\n  hasLocalizedField: boolean\n  hasLocalizedManyNumberField: boolean\n  hasLocalizedManyTextField: boolean\n  hasLocalizedRelationshipField: boolean\n  hasManyNumberField: 'index' | boolean\n  hasManyTextField: 'index' | boolean\n}\n\nexport const traverseFields = ({\n  adapter,\n  columnPrefix,\n  columns,\n  disableNotNull,\n  disableRelsTableUnique,\n  disableUnique = false,\n  fieldPrefix,\n  fields,\n  forceLocalized,\n  indexes,\n  localesColumns,\n  localesIndexes,\n  newTableName,\n  parentTableName,\n  relationships,\n  relationsToBuild,\n  rootRelationsToBuild,\n  rootTableIDColType,\n  rootTableName,\n  uniqueRelationships,\n  versions,\n  withinLocalizedArrayOrBlock,\n}: Args): Result => {\n  const throwValidationError = true\n  let hasLocalizedField = false\n  let hasLocalizedRelationshipField = false\n  let hasManyTextField: 'index' | boolean = false\n  let hasLocalizedManyTextField = false\n  let hasManyNumberField: 'index' | boolean = false\n  let hasLocalizedManyNumberField = false\n\n  let parentIDColType: IDType = 'integer'\n  if (columns.id instanceof PgUUIDBuilder) {\n    parentIDColType = 'uuid'\n  }\n  if (columns.id instanceof PgNumericBuilder) {\n    parentIDColType = 'numeric'\n  }\n  if (columns.id instanceof PgVarcharBuilder) {\n    parentIDColType = 'varchar'\n  }\n\n  fields.forEach((field) => {\n    if ('name' in field && field.name === 'id') {\n      return\n    }\n    if (fieldIsVirtual(field)) {\n      return\n    }\n\n    let columnName: string\n    let fieldName: string\n\n    let targetTable = columns\n    let targetIndexes = indexes\n\n    if (fieldAffectsData(field)) {\n      columnName = `${columnPrefix || ''}${field.name[0] === '_' ? '_' : ''}${toSnakeCase(\n        field.name,\n      )}`\n      fieldName = `${fieldPrefix?.replace('.', '_') || ''}${field.name}`\n\n      // If field is localized,\n      // add the column to the locale table instead of main table\n      if (\n        adapter.payload.config.localization &&\n        (field.localized || forceLocalized) &&\n        field.type !== 'array' &&\n        field.type !== 'blocks' &&\n        (('hasMany' in field && field.hasMany !== true) || !('hasMany' in field))\n      ) {\n        hasLocalizedField = true\n        targetTable = localesColumns\n        targetIndexes = localesIndexes\n      }\n\n      if (\n        (field.unique || field.index || ['relationship', 'upload'].includes(field.type)) &&\n        !['array', 'blocks', 'group', 'point'].includes(field.type) &&\n        !('hasMany' in field && field.hasMany === true) &&\n        !('relationTo' in field && Array.isArray(field.relationTo))\n      ) {\n        const unique = disableUnique !== true && field.unique\n        if (unique) {\n          const constraintValue = `${fieldPrefix || ''}${field.name}`\n          if (!adapter.fieldConstraints?.[rootTableName]) {\n            adapter.fieldConstraints[rootTableName] = {}\n          }\n          adapter.fieldConstraints[rootTableName][`${columnName}_idx`] = constraintValue\n        }\n\n        const indexName = buildIndexName({ name: `${newTableName}_${columnName}`, adapter })\n\n        targetIndexes[indexName] = createIndex({\n          name: field.localized ? [fieldName, '_locale'] : fieldName,\n          indexName,\n          unique,\n        })\n      }\n    }\n\n    switch (field.type) {\n      case 'text': {\n        if (field.hasMany) {\n          const isLocalized =\n            Boolean(field.localized && adapter.payload.config.localization) ||\n            withinLocalizedArrayOrBlock ||\n            forceLocalized\n\n          if (isLocalized) {\n            hasLocalizedManyTextField = true\n          }\n\n          if (field.index) {\n            hasManyTextField = 'index'\n          } else if (!hasManyTextField) {\n            hasManyTextField = true\n          }\n\n          if (field.unique) {\n            throw new InvalidConfiguration(\n              'Unique is not supported in Postgres for hasMany text fields.',\n            )\n          }\n        } else {\n          targetTable[fieldName] = withDefault(varchar(columnName), field)\n        }\n        break\n      }\n      case 'email':\n      case 'code':\n      case 'textarea': {\n        targetTable[fieldName] = withDefault(varchar(columnName), field)\n        break\n      }\n\n      case 'number': {\n        if (field.hasMany) {\n          const isLocalized =\n            Boolean(field.localized && adapter.payload.config.localization) ||\n            withinLocalizedArrayOrBlock ||\n            forceLocalized\n\n          if (isLocalized) {\n            hasLocalizedManyNumberField = true\n          }\n\n          if (field.index) {\n            hasManyNumberField = 'index'\n          } else if (!hasManyNumberField) {\n            hasManyNumberField = true\n          }\n\n          if (field.unique) {\n            throw new InvalidConfiguration(\n              'Unique is not supported in Postgres for hasMany number fields.',\n            )\n          }\n        } else {\n          targetTable[fieldName] = withDefault(numeric(columnName), field)\n        }\n        break\n      }\n\n      case 'richText':\n      case 'json': {\n        targetTable[fieldName] = withDefault(jsonb(columnName), field)\n        break\n      }\n\n      case 'date': {\n        targetTable[fieldName] = withDefault(\n          timestamp(columnName, {\n            mode: 'string',\n            precision: 3,\n            withTimezone: true,\n          }),\n          field,\n        )\n        break\n      }\n\n      case 'point': {\n        break\n      }\n\n      case 'radio':\n      case 'select': {\n        const enumName = createTableName({\n          adapter,\n          config: field,\n          parentTableName: newTableName,\n          prefix: `enum_${newTableName}_`,\n          target: 'enumName',\n          throwValidationError,\n        })\n\n        adapter.enums[enumName] = adapter.pgSchema.enum(\n          enumName,\n          field.options.map((option) => {\n            if (optionIsObject(option)) {\n              return option.value\n            }\n\n            return option\n          }) as [string, ...string[]],\n        )\n\n        if (field.type === 'select' && field.hasMany) {\n          const selectTableName = createTableName({\n            adapter,\n            config: field,\n            parentTableName: newTableName,\n            prefix: `${newTableName}_`,\n            throwValidationError,\n            versionsCustomName: versions,\n          })\n          const baseColumns: Record<string, PgColumnBuilder> = {\n            order: integer('order').notNull(),\n            parent: parentIDColumnMap[parentIDColType]('parent_id').notNull(),\n            value: adapter.enums[enumName]('value'),\n          }\n\n          const baseExtraConfig: BaseExtraConfig = {\n            orderIdx: (cols) => index(`${selectTableName}_order_idx`).on(cols.order),\n            parentFk: (cols) =>\n              foreignKey({\n                name: `${selectTableName}_parent_fk`,\n                columns: [cols.parent],\n                foreignColumns: [adapter.tables[parentTableName].id],\n              }).onDelete('cascade'),\n            parentIdx: (cols) => index(`${selectTableName}_parent_idx`).on(cols.parent),\n          }\n\n          const isLocalized =\n            Boolean(field.localized && adapter.payload.config.localization) ||\n            withinLocalizedArrayOrBlock ||\n            forceLocalized\n\n          if (isLocalized) {\n            baseColumns.locale = adapter.enums.enum__locales('locale').notNull()\n            baseExtraConfig.localeIdx = (cols) =>\n              index(`${selectTableName}_locale_idx`).on(cols.locale)\n          }\n\n          if (field.index) {\n            baseExtraConfig.value = (cols) => index(`${selectTableName}_value_idx`).on(cols.value)\n          }\n\n          buildTable({\n            adapter,\n            baseColumns,\n            baseExtraConfig,\n            disableNotNull,\n            disableUnique,\n            fields: [],\n            rootTableName,\n            tableName: selectTableName,\n            versions,\n          })\n\n          relationsToBuild.set(fieldName, {\n            type: 'many',\n            // selects have their own localized table, independent of the base table.\n            localized: false,\n            target: selectTableName,\n          })\n\n          adapter.relations[`relations_${selectTableName}`] = relations(\n            adapter.tables[selectTableName],\n            ({ one }) => ({\n              parent: one(adapter.tables[parentTableName], {\n                fields: [adapter.tables[selectTableName].parent],\n                references: [adapter.tables[parentTableName].id],\n                relationName: fieldName,\n              }),\n            }),\n          )\n        } else {\n          targetTable[fieldName] = withDefault(adapter.enums[enumName](columnName), field)\n        }\n        break\n      }\n\n      case 'checkbox': {\n        targetTable[fieldName] = withDefault(boolean(columnName), field)\n        break\n      }\n\n      case 'array': {\n        const disableNotNullFromHere = Boolean(field.admin?.condition) || disableNotNull\n\n        const arrayTableName = createTableName({\n          adapter,\n          config: field,\n          parentTableName: newTableName,\n          prefix: `${newTableName}_`,\n          throwValidationError,\n          versionsCustomName: versions,\n        })\n\n        const baseColumns: Record<string, PgColumnBuilder> = {\n          _order: integer('_order').notNull(),\n          _parentID: parentIDColumnMap[parentIDColType]('_parent_id').notNull(),\n        }\n\n        const baseExtraConfig: BaseExtraConfig = {\n          _orderIdx: (cols) => index(`${arrayTableName}_order_idx`).on(cols._order),\n          _parentIDFk: (cols) =>\n            foreignKey({\n              name: `${arrayTableName}_parent_id_fk`,\n              columns: [cols['_parentID']],\n              foreignColumns: [adapter.tables[parentTableName].id],\n            }).onDelete('cascade'),\n          _parentIDIdx: (cols) => index(`${arrayTableName}_parent_id_idx`).on(cols._parentID),\n        }\n\n        const isLocalized =\n          Boolean(field.localized && adapter.payload.config.localization) ||\n          withinLocalizedArrayOrBlock ||\n          forceLocalized\n\n        if (isLocalized) {\n          baseColumns._locale = adapter.enums.enum__locales('_locale').notNull()\n          baseExtraConfig._localeIdx = (cols) =>\n            index(`${arrayTableName}_locale_idx`).on(cols._locale)\n        }\n\n        const {\n          hasLocalizedManyNumberField: subHasLocalizedManyNumberField,\n          hasLocalizedManyTextField: subHasLocalizedManyTextField,\n          hasLocalizedRelationshipField: subHasLocalizedRelationshipField,\n          hasManyNumberField: subHasManyNumberField,\n          hasManyTextField: subHasManyTextField,\n          relationsToBuild: subRelationsToBuild,\n        } = buildTable({\n          adapter,\n          baseColumns,\n          baseExtraConfig,\n          disableNotNull: disableNotNullFromHere,\n          disableRelsTableUnique: true,\n          disableUnique,\n          fields: disableUnique ? idToUUID(field.fields) : field.fields,\n          rootRelationships: relationships,\n          rootRelationsToBuild,\n          rootTableIDColType,\n          rootTableName,\n          rootUniqueRelationships: uniqueRelationships,\n          tableName: arrayTableName,\n          versions,\n          withinLocalizedArrayOrBlock: isLocalized,\n        })\n\n        if (subHasLocalizedManyNumberField) {\n          hasLocalizedManyNumberField = subHasLocalizedManyNumberField\n        }\n\n        if (subHasLocalizedRelationshipField) {\n          hasLocalizedRelationshipField = subHasLocalizedRelationshipField\n        }\n\n        if (subHasLocalizedManyTextField) {\n          hasLocalizedManyTextField = subHasLocalizedManyTextField\n        }\n\n        if (subHasManyTextField) {\n          if (!hasManyTextField || subHasManyTextField === 'index') {\n            hasManyTextField = subHasManyTextField\n          }\n        }\n        if (subHasManyNumberField) {\n          if (!hasManyNumberField || subHasManyNumberField === 'index') {\n            hasManyNumberField = subHasManyNumberField\n          }\n        }\n\n        relationsToBuild.set(fieldName, {\n          type: 'many',\n          // arrays have their own localized table, independent of the base table.\n          localized: false,\n          target: arrayTableName,\n        })\n\n        adapter.relations[`relations_${arrayTableName}`] = relations(\n          adapter.tables[arrayTableName],\n          ({ many, one }) => {\n            const result: Record<string, Relation<string>> = {\n              _parentID: one(adapter.tables[parentTableName], {\n                fields: [adapter.tables[arrayTableName]._parentID],\n                references: [adapter.tables[parentTableName].id],\n                relationName: fieldName,\n              }),\n            }\n\n            if (hasLocalesTable(field.fields)) {\n              result._locales = many(adapter.tables[`${arrayTableName}${adapter.localesSuffix}`], {\n                relationName: '_locales',\n              })\n            }\n\n            subRelationsToBuild.forEach(({ type, localized, target }, key) => {\n              if (type === 'one') {\n                const arrayWithLocalized = localized\n                  ? `${arrayTableName}${adapter.localesSuffix}`\n                  : arrayTableName\n                result[key] = one(adapter.tables[target], {\n                  fields: [adapter.tables[arrayWithLocalized][key]],\n                  references: [adapter.tables[target].id],\n                  relationName: key,\n                })\n              }\n              if (type === 'many') {\n                result[key] = many(adapter.tables[target], { relationName: key })\n              }\n            })\n\n            return result\n          },\n        )\n\n        break\n      }\n\n      case 'blocks': {\n        const disableNotNullFromHere = Boolean(field.admin?.condition) || disableNotNull\n\n        field.blocks.forEach((block) => {\n          const blockTableName = createTableName({\n            adapter,\n            config: block,\n            parentTableName: rootTableName,\n            prefix: `${rootTableName}_blocks_`,\n            throwValidationError,\n            versionsCustomName: versions,\n          })\n          if (!adapter.tables[blockTableName]) {\n            const baseColumns: Record<string, PgColumnBuilder> = {\n              _order: integer('_order').notNull(),\n              _parentID: parentIDColumnMap[rootTableIDColType]('_parent_id').notNull(),\n              _path: text('_path').notNull(),\n            }\n\n            const baseExtraConfig: BaseExtraConfig = {\n              _orderIdx: (cols) => index(`${blockTableName}_order_idx`).on(cols._order),\n              _parentIdFk: (cols) =>\n                foreignKey({\n                  name: `${blockTableName}_parent_id_fk`,\n                  columns: [cols._parentID],\n                  foreignColumns: [adapter.tables[rootTableName].id],\n                }).onDelete('cascade'),\n              _parentIDIdx: (cols) => index(`${blockTableName}_parent_id_idx`).on(cols._parentID),\n              _pathIdx: (cols) => index(`${blockTableName}_path_idx`).on(cols._path),\n            }\n\n            const isLocalized =\n              Boolean(field.localized && adapter.payload.config.localization) ||\n              withinLocalizedArrayOrBlock ||\n              forceLocalized\n\n            if (isLocalized) {\n              baseColumns._locale = adapter.enums.enum__locales('_locale').notNull()\n              baseExtraConfig._localeIdx = (cols) =>\n                index(`${blockTableName}_locale_idx`).on(cols._locale)\n            }\n\n            const {\n              hasLocalizedManyNumberField: subHasLocalizedManyNumberField,\n              hasLocalizedManyTextField: subHasLocalizedManyTextField,\n              hasLocalizedRelationshipField: subHasLocalizedRelationshipField,\n              hasManyNumberField: subHasManyNumberField,\n              hasManyTextField: subHasManyTextField,\n              relationsToBuild: subRelationsToBuild,\n            } = buildTable({\n              adapter,\n              baseColumns,\n              baseExtraConfig,\n              disableNotNull: disableNotNullFromHere,\n              disableRelsTableUnique: true,\n              disableUnique,\n              fields: disableUnique ? idToUUID(block.fields) : block.fields,\n              rootRelationships: relationships,\n              rootRelationsToBuild,\n              rootTableIDColType,\n              rootTableName,\n              rootUniqueRelationships: uniqueRelationships,\n              tableName: blockTableName,\n              versions,\n              withinLocalizedArrayOrBlock: isLocalized,\n            })\n\n            if (subHasLocalizedManyNumberField) {\n              hasLocalizedManyNumberField = subHasLocalizedManyNumberField\n            }\n\n            if (subHasLocalizedRelationshipField) {\n              hasLocalizedRelationshipField = subHasLocalizedRelationshipField\n            }\n\n            if (subHasLocalizedManyTextField) {\n              hasLocalizedManyTextField = subHasLocalizedManyTextField\n            }\n\n            if (subHasManyTextField) {\n              if (!hasManyTextField || subHasManyTextField === 'index') {\n                hasManyTextField = subHasManyTextField\n              }\n            }\n\n            if (subHasManyNumberField) {\n              if (!hasManyNumberField || subHasManyNumberField === 'index') {\n                hasManyNumberField = subHasManyNumberField\n              }\n            }\n\n            adapter.relations[`relations_${blockTableName}`] = relations(\n              adapter.tables[blockTableName],\n              ({ many, one }) => {\n                const result: Record<string, Relation<string>> = {\n                  _parentID: one(adapter.tables[rootTableName], {\n                    fields: [adapter.tables[blockTableName]._parentID],\n                    references: [adapter.tables[rootTableName].id],\n                    relationName: `_blocks_${block.slug}`,\n                  }),\n                }\n\n                if (hasLocalesTable(block.fields)) {\n                  result._locales = many(\n                    adapter.tables[`${blockTableName}${adapter.localesSuffix}`],\n                    { relationName: '_locales' },\n                  )\n                }\n\n                subRelationsToBuild.forEach(({ type, localized, target }, key) => {\n                  if (type === 'one') {\n                    const blockWithLocalized = localized\n                      ? `${blockTableName}${adapter.localesSuffix}`\n                      : blockTableName\n                    result[key] = one(adapter.tables[target], {\n                      fields: [adapter.tables[blockWithLocalized][key]],\n                      references: [adapter.tables[target].id],\n                      relationName: key,\n                    })\n                  }\n                  if (type === 'many') {\n                    result[key] = many(adapter.tables[target], { relationName: key })\n                  }\n                })\n\n                return result\n              },\n            )\n          } else if (process.env.NODE_ENV !== 'production' && !versions) {\n            validateExistingBlockIsIdentical({\n              block,\n              localized: field.localized,\n              rootTableName,\n              table: adapter.tables[blockTableName],\n              tableLocales: adapter.tables[`${blockTableName}${adapter.localesSuffix}`],\n            })\n          }\n          // blocks relationships are defined from the collection or globals table down to the block, bypassing any subBlocks\n          rootRelationsToBuild.set(`_blocks_${block.slug}`, {\n            type: 'many',\n            // blocks are not localized on the parent table\n            localized: false,\n            target: blockTableName,\n          })\n        })\n\n        break\n      }\n\n      case 'tab':\n      case 'group': {\n        if (!('name' in field)) {\n          const {\n            hasLocalizedField: groupHasLocalizedField,\n            hasLocalizedManyNumberField: groupHasLocalizedManyNumberField,\n            hasLocalizedManyTextField: groupHasLocalizedManyTextField,\n            hasLocalizedRelationshipField: groupHasLocalizedRelationshipField,\n            hasManyNumberField: groupHasManyNumberField,\n            hasManyTextField: groupHasManyTextField,\n          } = traverseFields({\n            adapter,\n            columnPrefix,\n            columns,\n            disableNotNull,\n            disableUnique,\n            fieldPrefix,\n            fields: field.fields,\n            forceLocalized,\n            indexes,\n            localesColumns,\n            localesIndexes,\n            newTableName,\n            parentTableName,\n            relationships,\n            relationsToBuild,\n            rootRelationsToBuild,\n            rootTableIDColType,\n            rootTableName,\n            uniqueRelationships,\n            versions,\n            withinLocalizedArrayOrBlock,\n          })\n\n          if (groupHasLocalizedField) {\n            hasLocalizedField = true\n          }\n          if (groupHasLocalizedRelationshipField) {\n            hasLocalizedRelationshipField = true\n          }\n          if (groupHasManyTextField) {\n            hasManyTextField = true\n          }\n          if (groupHasLocalizedManyTextField) {\n            hasLocalizedManyTextField = true\n          }\n          if (groupHasManyNumberField) {\n            hasManyNumberField = true\n          }\n          if (groupHasLocalizedManyNumberField) {\n            hasLocalizedManyNumberField = true\n          }\n          break\n        }\n\n        const disableNotNullFromHere = Boolean(field.admin?.condition) || disableNotNull\n\n        const {\n          hasLocalizedField: groupHasLocalizedField,\n          hasLocalizedManyNumberField: groupHasLocalizedManyNumberField,\n          hasLocalizedManyTextField: groupHasLocalizedManyTextField,\n          hasLocalizedRelationshipField: groupHasLocalizedRelationshipField,\n          hasManyNumberField: groupHasManyNumberField,\n          hasManyTextField: groupHasManyTextField,\n        } = traverseFields({\n          adapter,\n          columnPrefix: `${columnName}_`,\n          columns,\n          disableNotNull: disableNotNullFromHere,\n          disableUnique,\n          fieldPrefix: `${fieldName}.`,\n          fields: field.fields,\n          forceLocalized: field.localized,\n          indexes,\n          localesColumns,\n          localesIndexes,\n          newTableName: `${parentTableName}_${columnName}`,\n          parentTableName,\n          relationships,\n          relationsToBuild,\n          rootRelationsToBuild,\n          rootTableIDColType,\n          rootTableName,\n          uniqueRelationships,\n          versions,\n          withinLocalizedArrayOrBlock: withinLocalizedArrayOrBlock || field.localized,\n        })\n\n        if (groupHasLocalizedField) {\n          hasLocalizedField = true\n        }\n        if (groupHasLocalizedRelationshipField) {\n          hasLocalizedRelationshipField = true\n        }\n        if (groupHasManyTextField) {\n          hasManyTextField = true\n        }\n        if (groupHasLocalizedManyTextField) {\n          hasLocalizedManyTextField = true\n        }\n        if (groupHasManyNumberField) {\n          hasManyNumberField = true\n        }\n        if (groupHasLocalizedManyNumberField) {\n          hasLocalizedManyNumberField = true\n        }\n        break\n      }\n\n      case 'tabs': {\n        const disableNotNullFromHere = Boolean(field.admin?.condition) || disableNotNull\n\n        const {\n          hasLocalizedField: tabHasLocalizedField,\n          hasLocalizedManyNumberField: tabHasLocalizedManyNumberField,\n          hasLocalizedManyTextField: tabHasLocalizedManyTextField,\n          hasLocalizedRelationshipField: tabHasLocalizedRelationshipField,\n          hasManyNumberField: tabHasManyNumberField,\n          hasManyTextField: tabHasManyTextField,\n        } = traverseFields({\n          adapter,\n          columnPrefix,\n          columns,\n          disableNotNull: disableNotNullFromHere,\n          disableUnique,\n          fieldPrefix,\n          fields: field.tabs.map((tab) => ({ ...tab, type: 'tab' })),\n          forceLocalized,\n          indexes,\n          localesColumns,\n          localesIndexes,\n          newTableName,\n          parentTableName,\n          relationships,\n          relationsToBuild,\n          rootRelationsToBuild,\n          rootTableIDColType,\n          rootTableName,\n          uniqueRelationships,\n          versions,\n          withinLocalizedArrayOrBlock,\n        })\n\n        if (tabHasLocalizedField) {\n          hasLocalizedField = true\n        }\n        if (tabHasLocalizedRelationshipField) {\n          hasLocalizedRelationshipField = true\n        }\n        if (tabHasManyTextField) {\n          hasManyTextField = true\n        }\n        if (tabHasLocalizedManyTextField) {\n          hasLocalizedManyTextField = true\n        }\n        if (tabHasManyNumberField) {\n          hasManyNumberField = true\n        }\n        if (tabHasLocalizedManyNumberField) {\n          hasLocalizedManyNumberField = true\n        }\n        break\n      }\n\n      case 'row':\n      case 'collapsible': {\n        const disableNotNullFromHere = Boolean(field.admin?.condition) || disableNotNull\n        const {\n          hasLocalizedField: rowHasLocalizedField,\n          hasLocalizedManyNumberField: rowHasLocalizedManyNumberField,\n          hasLocalizedManyTextField: rowHasLocalizedManyTextField,\n          hasLocalizedRelationshipField: rowHasLocalizedRelationshipField,\n          hasManyNumberField: rowHasManyNumberField,\n          hasManyTextField: rowHasManyTextField,\n        } = traverseFields({\n          adapter,\n          columnPrefix,\n          columns,\n          disableNotNull: disableNotNullFromHere,\n          disableUnique,\n          fieldPrefix,\n          fields: field.fields,\n          forceLocalized,\n          indexes,\n          localesColumns,\n          localesIndexes,\n          newTableName,\n          parentTableName,\n          relationships,\n          relationsToBuild,\n          rootRelationsToBuild,\n          rootTableIDColType,\n          rootTableName,\n          uniqueRelationships,\n          versions,\n          withinLocalizedArrayOrBlock,\n        })\n\n        if (rowHasLocalizedField) {\n          hasLocalizedField = true\n        }\n        if (rowHasLocalizedRelationshipField) {\n          hasLocalizedRelationshipField = true\n        }\n        if (rowHasManyTextField) {\n          hasManyTextField = true\n        }\n        if (rowHasLocalizedManyTextField) {\n          hasLocalizedManyTextField = true\n        }\n        if (rowHasManyNumberField) {\n          hasManyNumberField = true\n        }\n        if (rowHasLocalizedManyNumberField) {\n          hasLocalizedManyNumberField = true\n        }\n        break\n      }\n\n      case 'relationship':\n      case 'upload':\n        if (Array.isArray(field.relationTo)) {\n          field.relationTo.forEach((relation) => {\n            relationships.add(relation)\n            if (field.unique && !disableUnique && !disableRelsTableUnique) {\n              uniqueRelationships.add(relation)\n            }\n          })\n        } else if (field.hasMany) {\n          relationships.add(field.relationTo)\n          if (field.unique && !disableUnique && !disableRelsTableUnique) {\n            uniqueRelationships.add(field.relationTo)\n          }\n        } else {\n          // simple relationships get a column on the targetTable with a foreign key to the relationTo table\n          const relationshipConfig = adapter.payload.collections[field.relationTo].config\n\n          const tableName = adapter.tableNameMap.get(toSnakeCase(field.relationTo))\n\n          // get the id type of the related collection\n          let colType = adapter.idType === 'uuid' ? 'uuid' : 'integer'\n          const relatedCollectionCustomID = relationshipConfig.fields.find(\n            (field) => fieldAffectsData(field) && field.name === 'id',\n          )\n          if (relatedCollectionCustomID?.type === 'number') {\n            colType = 'numeric'\n          }\n          if (relatedCollectionCustomID?.type === 'text') {\n            colType = 'varchar'\n          }\n\n          // make the foreign key column for relationship using the correct id column type\n          targetTable[fieldName] = parentIDColumnMap[colType](`${columnName}_id`).references(\n            () => adapter.tables[tableName].id,\n            { onDelete: 'set null' },\n          )\n\n          // add relationship to table\n          relationsToBuild.set(fieldName, {\n            type: 'one',\n            localized: adapter.payload.config.localization && (field.localized || forceLocalized),\n            target: tableName,\n          })\n\n          // add notNull when not required\n          if (!disableNotNull && field.required && !field.admin?.condition) {\n            targetTable[fieldName].notNull()\n          }\n          break\n        }\n\n        if (\n          Boolean(field.localized && adapter.payload.config.localization) ||\n          withinLocalizedArrayOrBlock\n        ) {\n          hasLocalizedRelationshipField = true\n        }\n\n        break\n\n      default:\n        break\n    }\n\n    const condition = field.admin && field.admin.condition\n\n    if (\n      !disableNotNull &&\n      targetTable[fieldName] &&\n      'required' in field &&\n      field.required &&\n      !condition\n    ) {\n      targetTable[fieldName].notNull()\n    }\n  })\n\n  return {\n    hasLocalizedField,\n    hasLocalizedManyNumberField,\n    hasLocalizedManyTextField,\n    hasLocalizedRelationshipField,\n    hasManyNumberField,\n    hasManyTextField,\n  }\n}\n"],"names":["relations","boolean","foreignKey","index","integer","jsonb","numeric","PgNumericBuilder","PgUUIDBuilder","PgVarcharBuilder","text","timestamp","varchar","InvalidConfiguration","fieldAffectsData","fieldIsVirtual","optionIsObject","toSnakeCase","createTableName","buildIndexName","hasLocalesTable","validateExistingBlockIsIdentical","buildTable","createIndex","idToUUID","parentIDColumnMap","withDefault","traverseFields","adapter","columnPrefix","columns","disableNotNull","disableRelsTableUnique","disableUnique","fieldPrefix","fields","forceLocalized","indexes","localesColumns","localesIndexes","newTableName","parentTableName","relationships","relationsToBuild","rootRelationsToBuild","rootTableIDColType","rootTableName","uniqueRelationships","versions","withinLocalizedArrayOrBlock","throwValidationError","hasLocalizedField","hasLocalizedRelationshipField","hasManyTextField","hasLocalizedManyTextField","hasManyNumberField","hasLocalizedManyNumberField","parentIDColType","id","forEach","field","name","columnName","fieldName","targetTable","targetIndexes","replace","payload","config","localization","localized","type","hasMany","unique","includes","Array","isArray","relationTo","constraintValue","fieldConstraints","indexName","isLocalized","Boolean","mode","precision","withTimezone","enumName","prefix","target","enums","pgSchema","enum","options","map","option","value","selectTableName","versionsCustomName","baseColumns","order","notNull","parent","baseExtraConfig","orderIdx","cols","on","parentFk","foreignColumns","tables","onDelete","parentIdx","locale","enum__locales","localeIdx","tableName","set","one","references","relationName","disableNotNullFromHere","admin","condition","arrayTableName","_order","_parentID","_orderIdx","_parentIDFk","_parentIDIdx","_locale","_localeIdx","subHasLocalizedManyNumberField","subHasLocalizedManyTextField","subHasLocalizedRelationshipField","subHasManyNumberField","subHasManyTextField","subRelationsToBuild","rootRelationships","rootUniqueRelationships","many","result","_locales","localesSuffix","key","arrayWithLocalized","blocks","block","blockTableName","_path","_parentIdFk","_pathIdx","slug","blockWithLocalized","process","env","NODE_ENV","table","tableLocales","groupHasLocalizedField","groupHasLocalizedManyNumberField","groupHasLocalizedManyTextField","groupHasLocalizedRelationshipField","groupHasManyNumberField","groupHasManyTextField","tabHasLocalizedField","tabHasLocalizedManyNumberField","tabHasLocalizedManyTextField","tabHasLocalizedRelationshipField","tabHasManyNumberField","tabHasManyTextField","tabs","tab","rowHasLocalizedField","rowHasLocalizedManyNumberField","rowHasLocalizedManyTextField","rowHasLocalizedRelationshipField","rowHasManyNumberField","rowHasManyTextField","relation","add","relationshipConfig","collections","tableNameMap","get","colType","idType","relatedCollectionCustomID","find","required"],"mappings":"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"}},
    {"offset": {"line": 7303, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 7309, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/@payloadcms/db-postgres/node_modules/@payloadcms/drizzle/src/postgres/schema/build.ts"],"sourcesContent":["import type { Relation } from 'drizzle-orm'\nimport type {\n  ForeignKeyBuilder,\n  IndexBuilder,\n  PgColumnBuilder,\n  PgTableWithColumns,\n} from 'drizzle-orm/pg-core'\nimport type { Field, SanitizedJoins } from 'payload'\n\nimport { relations } from 'drizzle-orm'\nimport {\n  foreignKey,\n  index,\n  integer,\n  numeric,\n  serial,\n  timestamp,\n  unique,\n  varchar,\n} from 'drizzle-orm/pg-core'\nimport toSnakeCase from 'to-snake-case'\n\nimport type {\n  BaseExtraConfig,\n  BasePostgresAdapter,\n  GenericColumns,\n  GenericTable,\n  IDType,\n  RelationMap,\n} from '../types.js'\n\nimport { createTableName } from '../../createTableName.js'\nimport { buildIndexName } from '../../utilities/buildIndexName.js'\nimport { createIndex } from './createIndex.js'\nimport { parentIDColumnMap } from './parentIDColumnMap.js'\nimport { setColumnID } from './setColumnID.js'\nimport { traverseFields } from './traverseFields.js'\n\ntype Args = {\n  adapter: BasePostgresAdapter\n  baseColumns?: Record<string, PgColumnBuilder>\n  /**\n   * After table is created, run these functions to add extra config to the table\n   * ie. indexes, multiple columns, etc\n   */\n  baseExtraConfig?: BaseExtraConfig\n  buildNumbers?: boolean\n  buildRelationships?: boolean\n  disableNotNull: boolean\n  disableRelsTableUnique?: boolean\n  disableUnique: boolean\n  fields: Field[]\n  rootRelationships?: Set<string>\n  rootRelationsToBuild?: RelationMap\n  rootTableIDColType?: string\n  rootTableName?: string\n  rootUniqueRelationships?: Set<string>\n  tableName: string\n  timestamps?: boolean\n  versions: boolean\n  /**\n   * Tracks whether or not this table is built\n   * from the result of a localized array or block field at some point\n   */\n  withinLocalizedArrayOrBlock?: boolean\n}\n\ntype Result = {\n  hasLocalizedManyNumberField: boolean\n  hasLocalizedManyTextField: boolean\n  hasLocalizedRelationshipField: boolean\n  hasManyNumberField: 'index' | boolean\n  hasManyTextField: 'index' | boolean\n  relationsToBuild: RelationMap\n}\n\nexport const buildTable = ({\n  adapter,\n  baseColumns = {},\n  baseExtraConfig = {},\n  disableNotNull,\n  disableRelsTableUnique = false,\n  disableUnique = false,\n  fields,\n  rootRelationships,\n  rootRelationsToBuild,\n  rootTableIDColType,\n  rootTableName: incomingRootTableName,\n  rootUniqueRelationships,\n  tableName,\n  timestamps,\n  versions,\n  withinLocalizedArrayOrBlock,\n}: Args): Result => {\n  const isRoot = !incomingRootTableName\n  const rootTableName = incomingRootTableName || tableName\n  const columns: Record<string, PgColumnBuilder> = baseColumns\n  const indexes: Record<string, (cols: GenericColumns) => IndexBuilder> = {}\n\n  const localesColumns: Record<string, PgColumnBuilder> = {}\n  const localesIndexes: Record<string, (cols: GenericColumns) => IndexBuilder> = {}\n  let localesTable: GenericTable | PgTableWithColumns<any>\n  let textsTable: GenericTable | PgTableWithColumns<any>\n  let numbersTable: GenericTable | PgTableWithColumns<any>\n\n  // Relationships to the base collection\n  const relationships: Set<string> = rootRelationships || new Set()\n\n  // Unique relationships to the base collection\n  const uniqueRelationships: Set<string> = rootUniqueRelationships || new Set()\n\n  let relationshipsTable: GenericTable | PgTableWithColumns<any>\n\n  // Drizzle relations\n  const relationsToBuild: RelationMap = new Map()\n\n  const idColType: IDType = setColumnID({ adapter, columns, fields })\n\n  const {\n    hasLocalizedField,\n    hasLocalizedManyNumberField,\n    hasLocalizedManyTextField,\n    hasLocalizedRelationshipField,\n    hasManyNumberField,\n    hasManyTextField,\n  } = traverseFields({\n    adapter,\n    columns,\n    disableNotNull,\n    disableRelsTableUnique,\n    disableUnique,\n    fields,\n    indexes,\n    localesColumns,\n    localesIndexes,\n    newTableName: tableName,\n    parentTableName: tableName,\n    relationships,\n    relationsToBuild,\n    rootRelationsToBuild: rootRelationsToBuild || relationsToBuild,\n    rootTableIDColType: rootTableIDColType || idColType,\n    rootTableName,\n    uniqueRelationships,\n    versions,\n    withinLocalizedArrayOrBlock,\n  })\n\n  // split the relationsToBuild by localized and non-localized\n  const localizedRelations = new Map()\n  const nonLocalizedRelations = new Map()\n\n  relationsToBuild.forEach(({ type, localized, relationName, target }, key) => {\n    const map = localized ? localizedRelations : nonLocalizedRelations\n    map.set(key, { type, relationName, target })\n  })\n\n  if (timestamps) {\n    columns.createdAt = timestamp('created_at', {\n      mode: 'string',\n      precision: 3,\n      withTimezone: true,\n    })\n      .defaultNow()\n      .notNull()\n    columns.updatedAt = timestamp('updated_at', {\n      mode: 'string',\n      precision: 3,\n      withTimezone: true,\n    })\n      .defaultNow()\n      .notNull()\n  }\n\n  const table = adapter.pgSchema.table(tableName, columns, (cols) => {\n    const extraConfig = Object.entries(baseExtraConfig).reduce((config, [key, func]) => {\n      config[key] = func(cols)\n      return config\n    }, {})\n\n    const result = Object.entries(indexes).reduce((acc, [colName, func]) => {\n      acc[colName] = func(cols)\n      return acc\n    }, extraConfig)\n\n    return result\n  })\n\n  adapter.tables[tableName] = table\n\n  if (hasLocalizedField || localizedRelations.size) {\n    const localeTableName = `${tableName}${adapter.localesSuffix}`\n    localesColumns.id = serial('id').primaryKey()\n    localesColumns._locale = adapter.enums.enum__locales('_locale').notNull()\n    localesColumns._parentID = parentIDColumnMap[idColType]('_parent_id').notNull()\n\n    localesTable = adapter.pgSchema.table(localeTableName, localesColumns, (cols) => {\n      return Object.entries(localesIndexes).reduce(\n        (acc, [colName, func]) => {\n          acc[colName] = func(cols)\n          return acc\n        },\n        {\n          _localeParent: unique(`${localeTableName}_locale_parent_id_unique`).on(\n            cols._locale,\n            cols._parentID,\n          ),\n          _parentIdFk: foreignKey({\n            name: `${localeTableName}_parent_id_fk`,\n            columns: [cols._parentID],\n            foreignColumns: [table.id],\n          }).onDelete('cascade'),\n        },\n      )\n    })\n\n    adapter.tables[localeTableName] = localesTable\n\n    adapter.relations[`relations_${localeTableName}`] = relations(localesTable, ({ many, one }) => {\n      const result: Record<string, Relation<string>> = {}\n\n      result._parentID = one(table, {\n        fields: [localesTable._parentID],\n        references: [table.id],\n        // name the relationship by what the many() relationName is\n        relationName: '_locales',\n      })\n\n      localizedRelations.forEach(({ type, target }, key) => {\n        if (type === 'one') {\n          result[key] = one(adapter.tables[target], {\n            fields: [localesTable[key]],\n            references: [adapter.tables[target].id],\n            relationName: key,\n          })\n        }\n        if (type === 'many') {\n          result[key] = many(adapter.tables[target], {\n            relationName: key,\n          })\n        }\n      })\n\n      return result\n    })\n  }\n\n  if (isRoot) {\n    if (hasManyTextField) {\n      const textsTableName = `${rootTableName}_texts`\n      const columns: Record<string, PgColumnBuilder> = {\n        id: serial('id').primaryKey(),\n        order: integer('order').notNull(),\n        parent: parentIDColumnMap[idColType]('parent_id').notNull(),\n        path: varchar('path').notNull(),\n        text: varchar('text'),\n      }\n\n      if (hasLocalizedManyTextField) {\n        columns.locale = adapter.enums.enum__locales('locale')\n      }\n\n      textsTable = adapter.pgSchema.table(textsTableName, columns, (cols) => {\n        const config: Record<string, ForeignKeyBuilder | IndexBuilder> = {\n          orderParentIdx: index(`${textsTableName}_order_parent_idx`).on(cols.order, cols.parent),\n          parentFk: foreignKey({\n            name: `${textsTableName}_parent_fk`,\n            columns: [cols.parent],\n            foreignColumns: [table.id],\n          }).onDelete('cascade'),\n        }\n\n        if (hasManyTextField === 'index') {\n          config.text_idx = index(`${textsTableName}_text_idx`).on(cols.text)\n        }\n\n        if (hasLocalizedManyTextField) {\n          config.localeParent = index(`${textsTableName}_locale_parent`).on(\n            cols.locale,\n            cols.parent,\n          )\n        }\n\n        return config\n      })\n\n      adapter.tables[textsTableName] = textsTable\n\n      adapter.relations[`relations_${textsTableName}`] = relations(textsTable, ({ one }) => ({\n        parent: one(table, {\n          fields: [textsTable.parent],\n          references: [table.id],\n          relationName: '_texts',\n        }),\n      }))\n    }\n\n    if (hasManyNumberField) {\n      const numbersTableName = `${rootTableName}_numbers`\n      const columns: Record<string, PgColumnBuilder> = {\n        id: serial('id').primaryKey(),\n        number: numeric('number'),\n        order: integer('order').notNull(),\n        parent: parentIDColumnMap[idColType]('parent_id').notNull(),\n        path: varchar('path').notNull(),\n      }\n\n      if (hasLocalizedManyNumberField) {\n        columns.locale = adapter.enums.enum__locales('locale')\n      }\n\n      numbersTable = adapter.pgSchema.table(numbersTableName, columns, (cols) => {\n        const config: Record<string, ForeignKeyBuilder | IndexBuilder> = {\n          orderParentIdx: index(`${numbersTableName}_order_parent_idx`).on(cols.order, cols.parent),\n          parentFk: foreignKey({\n            name: `${numbersTableName}_parent_fk`,\n            columns: [cols.parent],\n            foreignColumns: [table.id],\n          }).onDelete('cascade'),\n        }\n\n        if (hasManyNumberField === 'index') {\n          config.numberIdx = index(`${numbersTableName}_number_idx`).on(cols.number)\n        }\n\n        if (hasLocalizedManyNumberField) {\n          config.localeParent = index(`${numbersTableName}_locale_parent`).on(\n            cols.locale,\n            cols.parent,\n          )\n        }\n\n        return config\n      })\n\n      adapter.tables[numbersTableName] = numbersTable\n\n      adapter.relations[`relations_${numbersTableName}`] = relations(numbersTable, ({ one }) => ({\n        parent: one(table, {\n          fields: [numbersTable.parent],\n          references: [table.id],\n          relationName: '_numbers',\n        }),\n      }))\n    }\n\n    if (relationships.size) {\n      const relationshipColumns: Record<string, PgColumnBuilder> = {\n        id: serial('id').primaryKey(),\n        order: integer('order'),\n        parent: parentIDColumnMap[idColType]('parent_id').notNull(),\n        path: varchar('path').notNull(),\n      }\n\n      if (hasLocalizedRelationshipField) {\n        relationshipColumns.locale = adapter.enums.enum__locales('locale')\n      }\n\n      const relationExtraConfig: BaseExtraConfig = {}\n      const relationshipsTableName = `${tableName}${adapter.relationshipsSuffix}`\n\n      relationships.forEach((relationTo) => {\n        const relationshipConfig = adapter.payload.collections[relationTo].config\n        const formattedRelationTo = createTableName({\n          adapter,\n          config: relationshipConfig,\n          throwValidationError: true,\n        })\n        let colType = adapter.idType === 'uuid' ? 'uuid' : 'integer'\n        const relatedCollectionCustomIDType =\n          adapter.payload.collections[relationshipConfig.slug]?.customIDType\n\n        if (relatedCollectionCustomIDType === 'number') {\n          colType = 'numeric'\n        }\n        if (relatedCollectionCustomIDType === 'text') {\n          colType = 'varchar'\n        }\n\n        const colName = `${relationTo}ID`\n\n        relationshipColumns[colName] = parentIDColumnMap[colType](`${formattedRelationTo}_id`)\n\n        relationExtraConfig[`${relationTo}IdFk`] = (cols) =>\n          foreignKey({\n            name: `${relationshipsTableName}_${toSnakeCase(relationTo)}_fk`,\n            columns: [cols[colName]],\n            foreignColumns: [adapter.tables[formattedRelationTo].id],\n          }).onDelete('cascade')\n\n        const indexColumns = [colName]\n\n        const unique = !disableUnique && uniqueRelationships.has(relationTo)\n\n        if (unique) {\n          indexColumns.push('path')\n        }\n        if (hasLocalizedRelationshipField) {\n          indexColumns.push('locale')\n        }\n\n        const indexName = buildIndexName({\n          name: `${relationshipsTableName}_${formattedRelationTo}_id`,\n          adapter,\n        })\n\n        relationExtraConfig[indexName] = createIndex({\n          name: indexColumns,\n          indexName,\n          unique,\n        })\n      })\n\n      relationshipsTable = adapter.pgSchema.table(\n        relationshipsTableName,\n        relationshipColumns,\n        (cols) => {\n          const result: Record<string, ForeignKeyBuilder | IndexBuilder> = Object.entries(\n            relationExtraConfig,\n          ).reduce(\n            (config, [key, func]) => {\n              config[key] = func(cols)\n              return config\n            },\n            {\n              order: index(`${relationshipsTableName}_order_idx`).on(cols.order),\n              parentFk: foreignKey({\n                name: `${relationshipsTableName}_parent_fk`,\n                columns: [cols.parent],\n                foreignColumns: [table.id],\n              }).onDelete('cascade'),\n              parentIdx: index(`${relationshipsTableName}_parent_idx`).on(cols.parent),\n              pathIdx: index(`${relationshipsTableName}_path_idx`).on(cols.path),\n            },\n          )\n\n          if (hasLocalizedRelationshipField) {\n            result.localeIdx = index(`${relationshipsTableName}_locale_idx`).on(cols.locale)\n          }\n\n          return result\n        },\n      )\n\n      adapter.tables[relationshipsTableName] = relationshipsTable\n\n      adapter.relations[`relations_${relationshipsTableName}`] = relations(\n        relationshipsTable,\n        ({ one }) => {\n          const result: Record<string, Relation<string>> = {\n            parent: one(table, {\n              fields: [relationshipsTable.parent],\n              references: [table.id],\n              relationName: '_rels',\n            }),\n          }\n\n          relationships.forEach((relationTo) => {\n            const relatedTableName = createTableName({\n              adapter,\n              config: adapter.payload.collections[relationTo].config,\n              throwValidationError: true,\n            })\n            const idColumnName = `${relationTo}ID`\n            result[idColumnName] = one(adapter.tables[relatedTableName], {\n              fields: [relationshipsTable[idColumnName]],\n              references: [adapter.tables[relatedTableName].id],\n              relationName: relationTo,\n            })\n          })\n\n          return result\n        },\n      )\n    }\n  }\n\n  adapter.relations[`relations_${tableName}`] = relations(table, ({ many, one }) => {\n    const result: Record<string, Relation<string>> = {}\n\n    nonLocalizedRelations.forEach(({ type, relationName, target }, key) => {\n      if (type === 'one') {\n        result[key] = one(adapter.tables[target], {\n          fields: [table[key]],\n          references: [adapter.tables[target].id],\n          relationName: key,\n        })\n      }\n      if (type === 'many') {\n        result[key] = many(adapter.tables[target], { relationName: relationName || key })\n      }\n    })\n\n    if (hasLocalizedField) {\n      result._locales = many(localesTable, { relationName: '_locales' })\n    }\n\n    if (hasManyTextField) {\n      result._texts = many(textsTable, { relationName: '_texts' })\n    }\n\n    if (hasManyNumberField) {\n      result._numbers = many(numbersTable, { relationName: '_numbers' })\n    }\n\n    if (relationships.size && relationshipsTable) {\n      result._rels = many(relationshipsTable, {\n        relationName: '_rels',\n      })\n    }\n\n    return result\n  })\n\n  return {\n    hasLocalizedManyNumberField,\n    hasLocalizedManyTextField,\n    hasLocalizedRelationshipField,\n    hasManyNumberField,\n    hasManyTextField,\n    relationsToBuild,\n  }\n}\n"],"names":["relations","foreignKey","index","integer","numeric","serial","timestamp","unique","varchar","toSnakeCase","createTableName","buildIndexName","createIndex","parentIDColumnMap","setColumnID","traverseFields","buildTable","adapter","baseColumns","baseExtraConfig","disableNotNull","disableRelsTableUnique","disableUnique","fields","rootRelationships","rootRelationsToBuild","rootTableIDColType","rootTableName","incomingRootTableName","rootUniqueRelationships","tableName","timestamps","versions","withinLocalizedArrayOrBlock","isRoot","columns","indexes","localesColumns","localesIndexes","localesTable","textsTable","numbersTable","relationships","Set","uniqueRelationships","relationshipsTable","relationsToBuild","Map","idColType","hasLocalizedField","hasLocalizedManyNumberField","hasLocalizedManyTextField","hasLocalizedRelationshipField","hasManyNumberField","hasManyTextField","newTableName","parentTableName","localizedRelations","nonLocalizedRelations","forEach","type","localized","relationName","target","key","map","set","createdAt","mode","precision","withTimezone","defaultNow","notNull","updatedAt","table","pgSchema","cols","extraConfig","Object","entries","reduce","config","func","result","acc","colName","tables","size","localeTableName","localesSuffix","id","primaryKey","_locale","enums","enum__locales","_parentID","_localeParent","on","_parentIdFk","name","foreignColumns","onDelete","many","one","references","textsTableName","order","parent","path","text","locale","orderParentIdx","parentFk","text_idx","localeParent","numbersTableName","number","numberIdx","relationshipColumns","relationExtraConfig","relationshipsTableName","relationshipsSuffix","relationTo","relationshipConfig","payload","collections","formattedRelationTo","throwValidationError","colType","idType","relatedCollectionCustomIDType","slug","customIDType","indexColumns","has","push","indexName","parentIdx","pathIdx","localeIdx","relatedTableName","idColumnName","_locales","_texts","_numbers","_rels"],"mappings":"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"}},
    {"offset": {"line": 7730, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 7736, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/@payloadcms/db-postgres/node_modules/@payloadcms/drizzle/src/postgres/init.ts"],"sourcesContent":["import type { Init, SanitizedCollectionConfig } from 'payload'\n\nimport { uniqueIndex } from 'drizzle-orm/pg-core'\nimport { buildVersionCollectionFields, buildVersionGlobalFields } from 'payload'\nimport toSnakeCase from 'to-snake-case'\n\nimport type { BaseExtraConfig, BasePostgresAdapter } from './types.js'\n\nimport { createTableName } from '../createTableName.js'\nimport { executeSchemaHooks } from '../utilities/executeSchemaHooks.js'\nimport { buildTable } from './schema/build.js'\n\nexport const init: Init = async function init(this: BasePostgresAdapter) {\n  await executeSchemaHooks({ type: 'beforeSchemaInit', adapter: this })\n\n  if (this.payload.config.localization) {\n    this.enums.enum__locales = this.pgSchema.enum(\n      '_locales',\n      this.payload.config.localization.locales.map(({ code }) => code) as [string, ...string[]],\n    )\n  }\n\n  this.payload.config.collections.forEach((collection: SanitizedCollectionConfig) => {\n    createTableName({\n      adapter: this,\n      config: collection,\n    })\n\n    if (collection.versions) {\n      createTableName({\n        adapter: this,\n        config: collection,\n        versions: true,\n        versionsCustomName: true,\n      })\n    }\n  })\n  this.payload.config.collections.forEach((collection: SanitizedCollectionConfig) => {\n    const tableName = this.tableNameMap.get(toSnakeCase(collection.slug))\n\n    const baseExtraConfig: BaseExtraConfig = {}\n\n    if (collection.upload.filenameCompoundIndex) {\n      const indexName = `${tableName}_filename_compound_idx`\n\n      baseExtraConfig.filename_compound_index = (cols) => {\n        const colsConstraint = collection.upload.filenameCompoundIndex.map((f) => {\n          return cols[f]\n        })\n        return uniqueIndex(indexName).on(colsConstraint[0], ...colsConstraint.slice(1))\n      }\n    }\n\n    buildTable({\n      adapter: this,\n      baseExtraConfig,\n      disableNotNull: !!collection?.versions?.drafts,\n      disableUnique: false,\n      fields: collection.fields,\n      tableName,\n      timestamps: collection.timestamps,\n      versions: false,\n    })\n\n    if (collection.versions) {\n      const versionsTableName = this.tableNameMap.get(\n        `_${toSnakeCase(collection.slug)}${this.versionsSuffix}`,\n      )\n      const versionFields = buildVersionCollectionFields(this.payload.config, collection)\n\n      buildTable({\n        adapter: this,\n        disableNotNull: !!collection.versions?.drafts,\n        disableUnique: true,\n        fields: versionFields,\n        tableName: versionsTableName,\n        timestamps: true,\n        versions: true,\n      })\n    }\n  })\n\n  this.payload.config.globals.forEach((global) => {\n    const tableName = createTableName({ adapter: this, config: global })\n\n    buildTable({\n      adapter: this,\n      disableNotNull: !!global?.versions?.drafts,\n      disableUnique: false,\n      fields: global.fields,\n      tableName,\n      timestamps: false,\n      versions: false,\n    })\n\n    if (global.versions) {\n      const versionsTableName = createTableName({\n        adapter: this,\n        config: global,\n        versions: true,\n        versionsCustomName: true,\n      })\n      const versionFields = buildVersionGlobalFields(this.payload.config, global)\n\n      buildTable({\n        adapter: this,\n        disableNotNull: !!global.versions?.drafts,\n        disableUnique: true,\n        fields: versionFields,\n        tableName: versionsTableName,\n        timestamps: true,\n        versions: true,\n      })\n    }\n  })\n\n  await executeSchemaHooks({ type: 'afterSchemaInit', adapter: this })\n}\n"],"names":["uniqueIndex","buildVersionCollectionFields","buildVersionGlobalFields","toSnakeCase","createTableName","executeSchemaHooks","buildTable","init","type","adapter","payload","config","localization","enums","enum__locales","pgSchema","enum","locales","map","code","collections","forEach","collection","versions","versionsCustomName","tableName","tableNameMap","get","slug","baseExtraConfig","upload","filenameCompoundIndex","indexName","filename_compound_index","cols","colsConstraint","f","on","slice","disableNotNull","drafts","disableUnique","fields","timestamps","versionsTableName","versionsSuffix","versionFields","globals","global"],"mappings":"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"}},
    {"offset": {"line": 7848, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 7854, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/@payloadcms/db-postgres/node_modules/@payloadcms/drizzle/src/postgres/insert.ts"],"sourcesContent":["import type { TransactionPg } from '../types.js'\nimport type { Insert } from './types.js'\n\nexport const insert: Insert = async function insert({\n  db,\n  onConflictDoUpdate,\n  tableName,\n  values,\n}): Promise<Record<string, unknown>[]> {\n  const table = this.tables[tableName]\n  let result\n\n  if (onConflictDoUpdate) {\n    result = await (db as TransactionPg)\n      .insert(table)\n      .values(values)\n      .onConflictDoUpdate(onConflictDoUpdate)\n      .returning()\n  } else {\n    result = await (db as TransactionPg).insert(table).values(values).returning()\n  }\n\n  return result\n}\n"],"names":["insert","db","onConflictDoUpdate","tableName","values","table","tables","result","returning"],"mappings":";;;AAGO,MAAMA,SAAiB,eAAeA,OAAO,EAClDC,EAAE,EACFC,kBAAkB,EAClBC,SAAS,EACTC,MAAM,EACP;IACC,MAAMC,QAAQ,IAAI,CAACC,MAAM,CAACH,UAAU;IACpC,IAAII;IAEJ,IAAIL,oBAAoB;QACtBK,SAAS,MAAON,GACbD,MAAM,CAACK,OACPD,MAAM,CAACA,QACPF,kBAAkB,CAACA,oBACnBM,SAAS;IACd,OAAO;QACLD,SAAS,MAAON,GAAqBD,MAAM,CAACK,OAAOD,MAAM,CAACA,QAAQI,SAAS;IAC7E;IAEA,OAAOD;AACT,EAAC"}},
    {"offset": {"line": 7867, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 7873, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/@payloadcms/db-postgres/node_modules/@payloadcms/drizzle/src/postgres/requireDrizzleKit.ts"],"sourcesContent":["import { createRequire } from 'module'\n\nimport type { RequireDrizzleKit } from '../types.js'\n\nconst require = createRequire(import.meta.url)\nexport const requireDrizzleKit: RequireDrizzleKit = () => require('drizzle-kit/api')\n"],"names":["createRequire","require","url","requireDrizzleKit"],"mappings":";;;AAAA,SAASA,aAAa,QAAQ,SAAQ;;;;;;;AAItC,MAAMC,8GAAUD,gBAAAA,EAAc,8BAAYE,GAAG;AACtC,MAAMC,oBAAuC,IAAMF,QAAQ,mBAAkB"}},
    {"offset": {"line": 7885, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 7891, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/@payloadcms/db-postgres/node_modules/@payloadcms/drizzle/src/postgres/types.ts"],"sourcesContent":["import type { DrizzleSnapshotJSON } from 'drizzle-kit/api'\nimport type {\n  ColumnBaseConfig,\n  ColumnDataType,\n  DrizzleConfig,\n  Relation,\n  Relations,\n  SQL,\n} from 'drizzle-orm'\nimport type { NodePgDatabase } from 'drizzle-orm/node-postgres'\nimport type {\n  ForeignKeyBuilder,\n  IndexBuilder,\n  PgColumn,\n  PgEnum,\n  pgEnum,\n  PgInsertOnConflictDoUpdateConfig,\n  PgSchema,\n  PgTableWithColumns,\n  UniqueConstraintBuilder,\n} from 'drizzle-orm/pg-core'\nimport type { PgTableFn } from 'drizzle-orm/pg-core/table'\nimport type { Payload, PayloadRequest } from 'payload'\nimport type { ClientConfig, QueryResult } from 'pg'\n\nimport type { extendDrizzleTable, Operators } from '../index.js'\nimport type { BuildQueryJoinAliases, DrizzleAdapter, TransactionPg } from '../types.js'\n\nexport type BaseExtraConfig = Record<\n  string,\n  (cols: GenericColumns) => ForeignKeyBuilder | IndexBuilder | UniqueConstraintBuilder\n>\n\nexport type RelationMap = Map<\n  string,\n  {\n    localized: boolean\n    relationName?: string\n    target: string\n    type: 'many' | 'one'\n  }\n>\n\nexport type GenericColumn = PgColumn<\n  ColumnBaseConfig<ColumnDataType, string>,\n  Record<string, unknown>\n>\n\nexport type GenericColumns = {\n  [x: string]: GenericColumn\n}\n\nexport type GenericTable = PgTableWithColumns<{\n  columns: GenericColumns\n  dialect: string\n  name: string\n  schema: string\n}>\n\nexport type GenericEnum = PgEnum<[string, ...string[]]>\n\nexport type GenericRelation = Relations<string, Record<string, Relation<string>>>\n\nexport type PostgresDB = NodePgDatabase<Record<string, unknown>>\n\nexport type CountDistinct = (args: {\n  db: PostgresDB | TransactionPg\n  joins: BuildQueryJoinAliases\n  tableName: string\n  where: SQL\n}) => Promise<number>\n\nexport type DeleteWhere = (args: {\n  db: PostgresDB | TransactionPg\n  tableName: string\n  where: SQL\n}) => Promise<void>\n\nexport type DropDatabase = (args: { adapter: BasePostgresAdapter }) => Promise<void>\n\nexport type Execute<T> = (args: {\n  db?: PostgresDB | TransactionPg\n  drizzle?: PostgresDB\n  raw?: string\n  sql?: SQL<unknown>\n}) => Promise<QueryResult<Record<string, T>>>\n\nexport type Insert = (args: {\n  db: PostgresDB | TransactionPg\n  onConflictDoUpdate?: PgInsertOnConflictDoUpdateConfig<any>\n  tableName: string\n  values: Record<string, unknown> | Record<string, unknown>[]\n}) => Promise<Record<string, unknown>[]>\n\nexport type CreateDatabase = (args?: {\n  /**\n   * Name of a database, defaults to the current one\n   */\n  name?: string\n  /**\n   * Schema to create in addition to 'public'. Defaults from adapter.schemaName if exists.\n   */\n  schemaName?: string\n}) => Promise<boolean>\n\ntype Schema =\n  | {\n      enum: typeof pgEnum\n      table: PgTableFn<string>\n    }\n  | PgSchema\n\ntype PostgresSchema = {\n  enums: Record<string, GenericEnum>\n  relations: Record<string, GenericRelation>\n  tables: Record<string, PgTableWithColumns<any>>\n}\n\ntype PostgresSchemaHookArgs = {\n  adapter: PostgresDrizzleAdapter\n  extendTable: typeof extendDrizzleTable\n  schema: PostgresSchema\n}\n\nexport type PostgresSchemaHook = (\n  args: PostgresSchemaHookArgs,\n) => PostgresSchema | Promise<PostgresSchema>\n\nexport type BasePostgresAdapter = {\n  afterSchemaInit: PostgresSchemaHook[]\n  beforeSchemaInit: PostgresSchemaHook[]\n  countDistinct: CountDistinct\n  createDatabase: CreateDatabase\n  defaultDrizzleSnapshot: DrizzleSnapshotJSON\n  deleteWhere: DeleteWhere\n  disableCreateDatabase: boolean\n  drizzle: PostgresDB\n  dropDatabase: DropDatabase\n  enums: Record<string, GenericEnum>\n  execute: Execute<unknown>\n  /**\n   * An object keyed on each table, with a key value pair where the constraint name is the key, followed by the dot-notation field name\n   * Used for returning properly formed errors from unique fields\n   */\n  fieldConstraints: Record<string, Record<string, string>>\n  idType: 'serial' | 'uuid'\n  initializing: Promise<void>\n  insert: Insert\n  localesSuffix?: string\n  logger: DrizzleConfig['logger']\n  operators: Operators\n  pgSchema: Schema\n  poolOptions?: ClientConfig\n  prodMigrations?: {\n    down: (args: MigrateDownArgs) => Promise<void>\n    name: string\n    up: (args: MigrateUpArgs) => Promise<void>\n  }[]\n  push: boolean\n  rejectInitializing: () => void\n  relations: Record<string, GenericRelation>\n  relationshipsSuffix?: string\n  resolveInitializing: () => void\n  schemaName?: string\n  sessions: {\n    [id: string]: {\n      db: PostgresDB | TransactionPg\n      reject: () => Promise<void>\n      resolve: () => Promise<void>\n    }\n  }\n  tableNameMap: Map<string, string>\n  tables: Record<string, GenericTable>\n  versionsSuffix?: string\n} & PostgresDrizzleAdapter\n\nexport type PostgresDrizzleAdapter = Omit<\n  DrizzleAdapter,\n  | 'countDistinct'\n  | 'deleteWhere'\n  | 'drizzle'\n  | 'dropDatabase'\n  | 'execute'\n  | 'insert'\n  | 'operators'\n  | 'relations'\n>\n\nexport type IDType = 'integer' | 'numeric' | 'uuid' | 'varchar'\n\nexport type MigrateUpArgs = { payload: Payload; req: PayloadRequest }\nexport type MigrateDownArgs = { payload: Payload; req: PayloadRequest }\n"],"names":[],"mappings":""}},
    {"offset": {"line": 7894, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 7900, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/@payloadcms/db-postgres/node_modules/@payloadcms/drizzle/src/exports/postgres.ts"],"sourcesContent":["export { countDistinct } from '../postgres/countDistinct.js'\nexport { createDatabase } from '../postgres/createDatabase.js'\nexport { convertPathToJSONTraversal } from '../postgres/createJSONQuery/convertPathToJSONTraversal.js'\nexport { createJSONQuery } from '../postgres/createJSONQuery/index.js'\nexport { createMigration } from '../postgres/createMigration.js'\nexport { defaultDrizzleSnapshot } from '../postgres/defaultSnapshot.js'\nexport { deleteWhere } from '../postgres/deleteWhere.js'\nexport { dropDatabase } from '../postgres/dropDatabase.js'\nexport { execute } from '../postgres/execute.js'\nexport { getMigrationTemplate } from '../postgres/getMigrationTemplate.js'\nexport { init } from '../postgres/init.js'\nexport { insert } from '../postgres/insert.js'\nexport { requireDrizzleKit } from '../postgres/requireDrizzleKit.js'\nexport * from '../postgres/types.js'\n"],"names":["countDistinct","createDatabase","convertPathToJSONTraversal","createJSONQuery","createMigration","defaultDrizzleSnapshot","deleteWhere","dropDatabase","execute","getMigrationTemplate","init","insert","requireDrizzleKit"],"mappings":""}},
    {"offset": {"line": 7916, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}}]
}