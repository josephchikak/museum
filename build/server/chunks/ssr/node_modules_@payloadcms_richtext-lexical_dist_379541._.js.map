{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 7, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/@payloadcms/richtext-lexical/dist/lexical/theme/EditorTheme.js/proxy.js"],"sourcesContent":["import { registerClientReference } from \"react-server-dom-turbopack/server.edge\";\nexport const LexicalEditorTheme = registerClientReference(\n    function() { throw new Error(\"Attempted to call LexicalEditorTheme() from the server but LexicalEditorTheme is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/node_modules/@payloadcms/richtext-lexical/dist/lexical/theme/EditorTheme.js <module evaluation>\",\n    \"LexicalEditorTheme\",\n);\n"],"names":[],"mappings":";;;AAAA;;AACO,MAAM,qBAAqB,CAAA,GAAA,qPAAA,CAAA,0BAAuB,AAAD,EACpD;IAAa,MAAM,IAAI,MAAM;AAAoP,GACjR,6GACA"}},
    {"offset": {"line": 15, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 21, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/@payloadcms/richtext-lexical/dist/lexical/theme/EditorTheme.js/proxy.js"],"sourcesContent":["import { registerClientReference } from \"react-server-dom-turbopack/server.edge\";\nexport const LexicalEditorTheme = registerClientReference(\n    function() { throw new Error(\"Attempted to call LexicalEditorTheme() from the server but LexicalEditorTheme is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/node_modules/@payloadcms/richtext-lexical/dist/lexical/theme/EditorTheme.js\",\n    \"LexicalEditorTheme\",\n);\n"],"names":[],"mappings":";;;AAAA;;AACO,MAAM,qBAAqB,CAAA,GAAA,qPAAA,CAAA,0BAAuB,AAAD,EACpD;IAAa,MAAM,IAAI,MAAM;AAAoP,GACjR,yFACA"}},
    {"offset": {"line": 29, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 35, "column": 0}, "map": {"version":3,"file":"EditorTheme.js","sources":["turbopack://[project]/node_modules/@payloadcms/richtext-lexical/src/lexical/theme/EditorTheme.tsx"],"sourcesContent":["'use client'\nimport type { EditorThemeClasses } from 'lexical'\n\nexport const LexicalEditorTheme: EditorThemeClasses = {\n  block: 'LexicalEditorTheme__block',\n  blockCursor: 'LexicalEditorTheme__blockCursor',\n  characterLimit: 'LexicalEditorTheme__characterLimit',\n  code: 'LexicalEditorTheme__code',\n  codeHighlight: {\n    atrule: 'LexicalEditorTheme__tokenAttr',\n    attr: 'LexicalEditorTheme__tokenAttr',\n    boolean: 'LexicalEditorTheme__tokenProperty',\n    builtin: 'LexicalEditorTheme__tokenSelector',\n    cdata: 'LexicalEditorTheme__tokenComment',\n    char: 'LexicalEditorTheme__tokenSelector',\n    class: 'LexicalEditorTheme__tokenFunction',\n    'class-name': 'LexicalEditorTheme__tokenFunction',\n    comment: 'LexicalEditorTheme__tokenComment',\n    constant: 'LexicalEditorTheme__tokenProperty',\n    deleted: 'LexicalEditorTheme__tokenProperty',\n    doctype: 'LexicalEditorTheme__tokenComment',\n    entity: 'LexicalEditorTheme__tokenOperator',\n    function: 'LexicalEditorTheme__tokenFunction',\n    important: 'LexicalEditorTheme__tokenVariable',\n    inserted: 'LexicalEditorTheme__tokenSelector',\n    keyword: 'LexicalEditorTheme__tokenAttr',\n    namespace: 'LexicalEditorTheme__tokenVariable',\n    number: 'LexicalEditorTheme__tokenProperty',\n    operator: 'LexicalEditorTheme__tokenOperator',\n    prolog: 'LexicalEditorTheme__tokenComment',\n    property: 'LexicalEditorTheme__tokenProperty',\n    punctuation: 'LexicalEditorTheme__tokenPunctuation',\n    regex: 'LexicalEditorTheme__tokenVariable',\n    selector: 'LexicalEditorTheme__tokenSelector',\n    string: 'LexicalEditorTheme__tokenSelector',\n    symbol: 'LexicalEditorTheme__tokenProperty',\n    tag: 'LexicalEditorTheme__tokenProperty',\n    url: 'LexicalEditorTheme__tokenOperator',\n    variable: 'LexicalEditorTheme__tokenVariable',\n  },\n  embedBlock: {\n    base: 'LexicalEditorTheme__embedBlock',\n    focus: 'LexicalEditorTheme__embedBlockFocus',\n  },\n  hashtag: 'LexicalEditorTheme__hashtag',\n  heading: {\n    h1: 'LexicalEditorTheme__h1',\n    h2: 'LexicalEditorTheme__h2',\n    h3: 'LexicalEditorTheme__h3',\n    h4: 'LexicalEditorTheme__h4',\n    h5: 'LexicalEditorTheme__h5',\n    h6: 'LexicalEditorTheme__h6',\n  },\n  hr: 'LexicalEditorTheme__hr',\n  indent: 'LexicalEditorTheme__indent',\n  inlineImage: 'LexicalEditor__inline-image',\n  link: 'LexicalEditorTheme__link',\n  list: {\n    checklist: 'LexicalEditorTheme__checklist',\n    listitem: 'LexicalEditorTheme__listItem',\n    listitemChecked: 'LexicalEditorTheme__listItemChecked',\n    listitemUnchecked: 'LexicalEditorTheme__listItemUnchecked',\n    nested: {\n      listitem: 'LexicalEditorTheme__nestedListItem',\n    },\n    olDepth: [\n      'LexicalEditorTheme__ol1',\n      'LexicalEditorTheme__ol2',\n      'LexicalEditorTheme__ol3',\n      'LexicalEditorTheme__ol4',\n      'LexicalEditorTheme__ol5',\n    ],\n    ul: 'LexicalEditorTheme__ul',\n  },\n  ltr: 'LexicalEditorTheme__ltr',\n  mark: 'LexicalEditorTheme__mark',\n  markOverlap: 'LexicalEditorTheme__markOverlap',\n  paragraph: 'LexicalEditorTheme__paragraph',\n  quote: 'LexicalEditorTheme__quote',\n  relationship: 'LexicalEditorTheme__relationship',\n  rtl: 'LexicalEditorTheme__rtl',\n  table: 'LexicalEditorTheme__table',\n  tableAddColumns: 'LexicalEditorTheme__tableAddColumns',\n  tableAddRows: 'LexicalEditorTheme__tableAddRows',\n  tableCell: 'LexicalEditorTheme__tableCell',\n  tableCellActionButton: 'LexicalEditorTheme__tableCellActionButton',\n  tableCellActionButtonContainer: 'LexicalEditorTheme__tableCellActionButtonContainer',\n  tableCellEditing: 'LexicalEditorTheme__tableCellEditing',\n  tableCellHeader: 'LexicalEditorTheme__tableCellHeader',\n  tableCellPrimarySelected: 'LexicalEditorTheme__tableCellPrimarySelected',\n  tableCellResizer: 'LexicalEditorTheme__tableCellResizer',\n  tableCellSelected: 'LexicalEditorTheme__tableCellSelected',\n  tableCellSortedIndicator: 'LexicalEditorTheme__tableCellSortedIndicator',\n  tableResizeRuler: 'LexicalEditorTheme__tableCellResizeRuler',\n  tableRowStriping: 'LexicalEditorTheme__tableRowStriping',\n  tableSelected: 'LexicalEditorTheme__tableSelected',\n  text: {\n    bold: 'LexicalEditorTheme__textBold',\n    code: 'LexicalEditorTheme__textCode',\n    italic: 'LexicalEditorTheme__textItalic',\n    strikethrough: 'LexicalEditorTheme__textStrikethrough',\n    subscript: 'LexicalEditorTheme__textSubscript',\n    superscript: 'LexicalEditorTheme__textSuperscript',\n    underline: 'LexicalEditorTheme__textUnderline',\n    underlineStrikethrough: 'LexicalEditorTheme__textUnderlineStrikethrough',\n  },\n  upload: 'editor-upload',\n}\n"],"names":["LexicalEditorTheme","block","blockCursor","characterLimit","code","codeHighlight","atrule","attr","boolean","builtin","cdata","char","class","comment","constant","deleted","doctype","entity","function","important","inserted","keyword","namespace","number","operator","prolog","property","punctuation","regex","selector","string","symbol","tag","url","variable","embedBlock","base","focus","hashtag","heading","h1","h2","h3","h4","h5","h6","hr","indent","inlineImage","link","list","checklist","listitem","listitemChecked","listitemUnchecked","nested","olDepth","ul","ltr","mark","markOverlap","paragraph","quote","relationship","rtl","table","tableAddColumns","tableAddRows","tableCell","tableCellActionButton","tableCellActionButtonContainer","tableCellEditing","tableCellHeader","tableCellPrimarySelected","tableCellResizer","tableCellSelected","tableCellSortedIndicator","tableResizeRuler","tableRowStriping","tableSelected","text","bold","italic","strikethrough","subscript","superscript","underline","underlineStrikethrough","upload"],"mappings":""}},
    {"offset": {"line": 39, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 45, "column": 0}, "map": {"version":3,"file":"createServerFeature.js","sources":["turbopack://[project]/node_modules/@payloadcms/richtext-lexical/src/utilities/createServerFeature.ts"],"sourcesContent":["import type { SanitizedConfig } from 'payload'\n\nimport type {\n  FeatureProviderProviderServer,\n  FeatureProviderServer,\n  ResolvedServerFeatureMap,\n  ServerFeature,\n  ServerFeatureProviderMap,\n} from '../features/typesServer.js'\nimport type { ServerEditorConfig } from '../lexical/config/types.js'\n\nexport type CreateServerFeatureArgs<UnSanitizedProps, SanitizedProps, ClientProps> = {\n  feature:\n    | ((props: {\n        config: SanitizedConfig\n        /** unSanitizedEditorConfig.features, but mapped */\n        featureProviderMap: ServerFeatureProviderMap\n        isRoot?: boolean\n        parentIsLocalized: boolean\n        props: UnSanitizedProps\n        // other resolved features, which have been loaded before this one. All features declared in 'dependencies' should be available here\n        resolvedFeatures: ResolvedServerFeatureMap\n        // unSanitized EditorConfig,\n        unSanitizedEditorConfig: ServerEditorConfig\n      }) =>\n        | Promise<ServerFeature<SanitizedProps, ClientProps>>\n        | ServerFeature<SanitizedProps, ClientProps>)\n    | Omit<ServerFeature<SanitizedProps, ClientProps>, 'sanitizedServerFeatureProps'>\n} & Pick<\n  FeatureProviderServer<UnSanitizedProps, ClientProps>,\n  'dependencies' | 'dependenciesPriority' | 'dependenciesSoft' | 'key'\n>\n\nexport const createServerFeature: <\n  UnSanitizedProps = undefined,\n  SanitizedProps = UnSanitizedProps,\n  ClientProps = undefined,\n>(\n  args: CreateServerFeatureArgs<UnSanitizedProps, SanitizedProps, ClientProps>,\n) => FeatureProviderProviderServer<UnSanitizedProps, SanitizedProps, ClientProps> = ({\n  dependencies,\n  dependenciesPriority,\n  dependenciesSoft,\n  feature,\n  key,\n}) => {\n  const featureProviderProviderServer: FeatureProviderProviderServer<any, any, any> = (props) => {\n    const featureProviderServer: Partial<FeatureProviderServer<any, any, any>> = {\n      dependencies,\n      dependenciesPriority,\n      dependenciesSoft,\n      key,\n      serverFeatureProps: props,\n    }\n\n    if (typeof feature === 'function') {\n      featureProviderServer.feature = async ({\n        config,\n        featureProviderMap,\n        isRoot,\n        parentIsLocalized,\n        resolvedFeatures,\n        unSanitizedEditorConfig,\n      }) => {\n        const toReturn = await feature({\n          config,\n          featureProviderMap,\n          isRoot,\n          parentIsLocalized,\n          props,\n          resolvedFeatures,\n          unSanitizedEditorConfig,\n        })\n\n        if (toReturn.sanitizedServerFeatureProps === null) {\n          toReturn.sanitizedServerFeatureProps = props\n        }\n        return toReturn\n      }\n    } else {\n      // For explanation why we have to spread feature, see createClientFeature.ts\n      const newFeature: ServerFeature<any, any> = { ...feature }\n\n      newFeature.sanitizedServerFeatureProps = props\n      featureProviderServer.feature = newFeature\n    }\n    return featureProviderServer as FeatureProviderServer<any, any, any>\n  }\n\n  return featureProviderProviderServer\n}\n"],"names":["createServerFeature","dependencies","dependenciesPriority","dependenciesSoft","feature","key","featureProviderProviderServer","props","featureProviderServer","serverFeatureProps","config","featureProviderMap","isRoot","parentIsLocalized","resolvedFeatures","unSanitizedEditorConfig","toReturn","sanitizedServerFeatureProps","newFeature"],"mappings":";;;AAiCO,MAAMA,mBAAA,GAMuEA,CAAC,EACnFC,YAAY,EACZC,oBAAoB,EACpBC,gBAAgB,EAChBC,OAAO,EACPC,GAAAA,EACD;IACC,MAAMC,6BAAA,IAA+EC,KAAA;QACnF,MAAMC,qBAAA,GAAuE;YAC3EP,YAAA;YACAC,oBAAA;YACAC,gBAAA;YACAE,GAAA;YACAI,kBAAA,EAAoBF;QACtB;QAEA,IAAI,OAAOH,OAAA,KAAY,YAAY;YACjCI,qBAAA,CAAsBJ,OAAO,GAAG,OAAO,EACrCM,MAAM,EACNC,kBAAkB,EAClBC,MAAM,EACNC,iBAAiB,EACjBC,gBAAgB,EAChBC,uBAAAA,EACD;gBACC,MAAMC,QAAA,GAAW,MAAMZ,OAAA,CAAQ;oBAC7BM,MAAA;oBACAC,kBAAA;oBACAC,MAAA;oBACAC,iBAAA;oBACAN,KAAA;oBACAO,gBAAA;oBACAC;gBACF;gBAEA,IAAIC,QAAA,CAASC,2BAA2B,KAAK,MAAM;oBACjDD,QAAA,CAASC,2BAA2B,GAAGV,KAAA;gBACzC;gBACA,OAAOS,QAAA;YACT;QACF,OAAO;YACL,4EAAA;YACA,MAAME,UAAA,GAAsC;gBAAE,GAAGd,OAAAA;YAAQ;YAEzDc,UAAA,CAAWD,2BAA2B,GAAGV,KAAA;YACzCC,qBAAA,CAAsBJ,OAAO,GAAGc,UAAA;QAClC;QACA,OAAOV,qBAAA;IACT;IAEA,OAAOF,6BAAA;AACT"}},
    {"offset": {"line": 85, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 91, "column": 0}, "map": {"version":3,"file":"markdownTransformers.js","sources":["turbopack://[project]/node_modules/@payloadcms/richtext-lexical/src/features/format/bold/markdownTransformers.ts"],"sourcesContent":["import type { TextFormatTransformer } from '@lexical/markdown'\n\nexport const BOLD_ITALIC_STAR: TextFormatTransformer = {\n  type: 'text-format',\n  format: ['bold', 'italic'],\n  tag: '***',\n}\n\nexport const BOLD_ITALIC_UNDERSCORE: TextFormatTransformer = {\n  type: 'text-format',\n  format: ['bold', 'italic'],\n  intraword: false,\n  tag: '___',\n}\n\nexport const BOLD_STAR: TextFormatTransformer = {\n  type: 'text-format',\n  format: ['bold'],\n  tag: '**',\n}\n\nexport const BOLD_UNDERSCORE: TextFormatTransformer = {\n  type: 'text-format',\n  format: ['bold'],\n  intraword: false,\n  tag: '__',\n}\n"],"names":["BOLD_ITALIC_STAR","type","format","tag","BOLD_ITALIC_UNDERSCORE","intraword","BOLD_STAR","BOLD_UNDERSCORE"],"mappings":";;;;;;AAEO,MAAMA,gBAAA,GAA0C;IACrDC,IAAA,EAAM;IACNC,MAAA,EAAQ;QAAC;QAAQ;KAAS;IAC1BC,GAAA,EAAK;AACP;AAEO,MAAMC,sBAAA,GAAgD;IAC3DH,IAAA,EAAM;IACNC,MAAA,EAAQ;QAAC;QAAQ;KAAS;IAC1BG,SAAA,EAAW;IACXF,GAAA,EAAK;AACP;AAEO,MAAMG,SAAA,GAAmC;IAC9CL,IAAA,EAAM;IACNC,MAAA,EAAQ;QAAC;KAAO;IAChBC,GAAA,EAAK;AACP;AAEO,MAAMI,eAAA,GAAyC;IACpDN,IAAA,EAAM;IACNC,MAAA,EAAQ;QAAC;KAAO;IAChBG,SAAA,EAAW;IACXF,GAAA,EAAK;AACP"}},
    {"offset": {"line": 129, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 135, "column": 0}, "map": {"version":3,"file":"feature.server.js","sources":["turbopack://[project]/node_modules/@payloadcms/richtext-lexical/src/features/format/bold/feature.server.ts"],"sourcesContent":["import { createServerFeature } from '../../../utilities/createServerFeature.js'\nimport {\n  BOLD_ITALIC_STAR,\n  BOLD_ITALIC_UNDERSCORE,\n  BOLD_STAR,\n  BOLD_UNDERSCORE,\n} from './markdownTransformers.js'\n\nexport const BoldFeature = createServerFeature({\n  dependenciesSoft: ['italic'],\n  feature: ({ featureProviderMap }) => {\n    const markdownTransformers = [BOLD_STAR, BOLD_UNDERSCORE]\n    if (featureProviderMap.get('italic')) {\n      markdownTransformers.push(BOLD_ITALIC_UNDERSCORE, BOLD_ITALIC_STAR)\n    }\n\n    return {\n      ClientFeature: '@payloadcms/richtext-lexical/client#BoldFeatureClient',\n      markdownTransformers,\n    }\n  },\n  key: 'bold',\n})\n"],"names":["createServerFeature","BOLD_ITALIC_STAR","BOLD_ITALIC_UNDERSCORE","BOLD_STAR","BOLD_UNDERSCORE","BoldFeature","dependenciesSoft","feature","featureProviderMap","markdownTransformers","get","push","ClientFeature","key"],"mappings":";;;AAAA,SAASA,mBAAmB,QAAQ;AACpC,SACEC,gBAAgB,EAChBC,sBAAsB,EACtBC,SAAS,EACTC,eAAe,QACV;;;AAEA,MAAMC,WAAA,uMAAcL,sBAAAA,AAAA,EAAoB;IAC7CM,gBAAA,EAAkB;QAAC;KAAS;IAC5BC,OAAA,EAASA,CAAC,EAAEC,kBAAAA,EAAoB;QAC9B,MAAMC,oBAAA,GAAuB;8NAACN,YAAA;8NAAWC,kBAAA;SAAgB;QACzD,IAAII,kBAAA,CAAmBE,GAAG,CAAC,WAAW;YACpCD,oBAAA,CAAqBE,IAAI,mNAACT,yBAAA,oNAAwBD,mBAAA;QACpD;QAEA,OAAO;YACLW,aAAA,EAAe;YACfH;QACF;IACF;IACAI,GAAA,EAAK;AACP"}},
    {"offset": {"line": 161, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 167, "column": 0}, "map": {"version":3,"file":"markdownTransformers.js","sources":["turbopack://[project]/node_modules/@payloadcms/richtext-lexical/src/features/format/italic/markdownTransformers.ts"],"sourcesContent":["import type { TextFormatTransformer } from '@lexical/markdown'\n\nexport const ITALIC_STAR: TextFormatTransformer = {\n  type: 'text-format',\n  format: ['italic'],\n  tag: '*',\n}\n\nexport const ITALIC_UNDERSCORE: TextFormatTransformer = {\n  type: 'text-format',\n  format: ['italic'],\n  intraword: false,\n  tag: '_',\n}\n"],"names":["ITALIC_STAR","type","format","tag","ITALIC_UNDERSCORE","intraword"],"mappings":";;;;AAEO,MAAMA,WAAA,GAAqC;IAChDC,IAAA,EAAM;IACNC,MAAA,EAAQ;QAAC;KAAS;IAClBC,GAAA,EAAK;AACP;AAEO,MAAMC,iBAAA,GAA2C;IACtDH,IAAA,EAAM;IACNC,MAAA,EAAQ;QAAC;KAAS;IAClBG,SAAA,EAAW;IACXF,GAAA,EAAK;AACP"}},
    {"offset": {"line": 186, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 192, "column": 0}, "map": {"version":3,"file":"feature.server.js","sources":["turbopack://[project]/node_modules/@payloadcms/richtext-lexical/src/features/format/italic/feature.server.ts"],"sourcesContent":["import { createServerFeature } from '../../../utilities/createServerFeature.js'\nimport { ITALIC_STAR, ITALIC_UNDERSCORE } from './markdownTransformers.js'\n\nexport const ItalicFeature = createServerFeature({\n  feature: {\n    ClientFeature: '@payloadcms/richtext-lexical/client#ItalicFeatureClient',\n    markdownTransformers: [ITALIC_STAR, ITALIC_UNDERSCORE],\n  },\n  key: 'italic',\n})\n"],"names":["createServerFeature","ITALIC_STAR","ITALIC_UNDERSCORE","ItalicFeature","feature","ClientFeature","markdownTransformers","key"],"mappings":";;;AAAA,SAASA,mBAAmB,QAAQ;AACpC,SAASC,WAAW,EAAEC,iBAAiB,QAAQ;;;AAExC,MAAMC,aAAA,uMAAgBH,sBAAAA,AAAA,EAAoB;IAC/CI,OAAA,EAAS;QACPC,aAAA,EAAe;QACfC,oBAAA,EAAsB;gOAACL,cAAA;gOAAaC,oBAAA;SAAA;IACtC;IACAK,GAAA,EAAK;AACP"}},
    {"offset": {"line": 209, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 215, "column": 0}, "map": {"version":3,"file":"feature.server.js","sources":["turbopack://[project]/node_modules/@payloadcms/richtext-lexical/src/features/format/underline/feature.server.ts"],"sourcesContent":["import { createServerFeature } from '../../../utilities/createServerFeature.js'\n\nexport const UnderlineFeature = createServerFeature({\n  feature: {\n    ClientFeature: '@payloadcms/richtext-lexical/client#UnderlineFeatureClient',\n  },\n  key: 'underline',\n})\n"],"names":["createServerFeature","UnderlineFeature","feature","ClientFeature","key"],"mappings":";;;AAAA,SAASA,mBAAmB,QAAQ;;AAE7B,MAAMC,gBAAA,uMAAmBD,sBAAAA,AAAA,EAAoB;IAClDE,OAAA,EAAS;QACPC,aAAA,EAAe;IACjB;IACAC,GAAA,EAAK;AACP"}},
    {"offset": {"line": 226, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 232, "column": 0}, "map": {"version":3,"file":"markdownTransformers.js","sources":["turbopack://[project]/node_modules/@payloadcms/richtext-lexical/src/features/format/strikethrough/markdownTransformers.ts"],"sourcesContent":["import type { TextFormatTransformer } from '@lexical/markdown'\n\nexport const STRIKETHROUGH: TextFormatTransformer = {\n  type: 'text-format',\n  format: ['strikethrough'],\n  tag: '~~',\n}\n"],"names":["STRIKETHROUGH","type","format","tag"],"mappings":";;;AAEO,MAAMA,aAAA,GAAuC;IAClDC,IAAA,EAAM;IACNC,MAAA,EAAQ;QAAC;KAAgB;IACzBC,GAAA,EAAK;AACP"}},
    {"offset": {"line": 242, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 248, "column": 0}, "map": {"version":3,"file":"feature.server.js","sources":["turbopack://[project]/node_modules/@payloadcms/richtext-lexical/src/features/format/strikethrough/feature.server.ts"],"sourcesContent":["import { createServerFeature } from '../../../utilities/createServerFeature.js'\nimport { STRIKETHROUGH } from './markdownTransformers.js'\n\nexport const StrikethroughFeature = createServerFeature({\n  feature: {\n    ClientFeature: '@payloadcms/richtext-lexical/client#StrikethroughFeatureClient',\n\n    markdownTransformers: [STRIKETHROUGH],\n  },\n  key: 'strikethrough',\n})\n"],"names":["createServerFeature","STRIKETHROUGH","StrikethroughFeature","feature","ClientFeature","markdownTransformers","key"],"mappings":";;;AAAA,SAASA,mBAAmB,QAAQ;AACpC,SAASC,aAAa,QAAQ;;;AAEvB,MAAMC,oBAAA,uMAAuBF,sBAAAA,AAAA,EAAoB;IACtDG,OAAA,EAAS;QACPC,aAAA,EAAe;QAEfC,oBAAA,EAAsB;uOAACJ,gBAAA;SAAA;IACzB;IACAK,GAAA,EAAK;AACP"}},
    {"offset": {"line": 264, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 270, "column": 0}, "map": {"version":3,"file":"feature.server.js","sources":["turbopack://[project]/node_modules/@payloadcms/richtext-lexical/src/features/format/subscript/feature.server.ts"],"sourcesContent":["import { createServerFeature } from '../../../utilities/createServerFeature.js'\n\nexport const SubscriptFeature = createServerFeature({\n  feature: {\n    ClientFeature: '@payloadcms/richtext-lexical/client#SubscriptFeatureClient',\n  },\n  key: 'subscript',\n})\n"],"names":["createServerFeature","SubscriptFeature","feature","ClientFeature","key"],"mappings":";;;AAAA,SAASA,mBAAmB,QAAQ;;AAE7B,MAAMC,gBAAA,uMAAmBD,sBAAAA,AAAA,EAAoB;IAClDE,OAAA,EAAS;QACPC,aAAA,EAAe;IACjB;IACAC,GAAA,EAAK;AACP"}},
    {"offset": {"line": 281, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 287, "column": 0}, "map": {"version":3,"file":"feature.server.js","sources":["turbopack://[project]/node_modules/@payloadcms/richtext-lexical/src/features/format/superscript/feature.server.ts"],"sourcesContent":["import { createServerFeature } from '../../../utilities/createServerFeature.js'\n\nexport const SuperscriptFeature = createServerFeature({\n  feature: {\n    ClientFeature: '@payloadcms/richtext-lexical/client#SuperscriptFeatureClient',\n  },\n  key: 'superscript',\n})\n"],"names":["createServerFeature","SuperscriptFeature","feature","ClientFeature","key"],"mappings":";;;AAAA,SAASA,mBAAmB,QAAQ;;AAE7B,MAAMC,kBAAA,uMAAqBD,sBAAAA,AAAA,EAAoB;IACpDE,OAAA,EAAS;QACPC,aAAA,EAAe;IACjB;IACAC,GAAA,EAAK;AACP"}},
    {"offset": {"line": 298, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 304, "column": 0}, "map": {"version":3,"file":"markdownTransformers.js","sources":["turbopack://[project]/node_modules/@payloadcms/richtext-lexical/src/features/format/inlineCode/markdownTransformers.ts"],"sourcesContent":["import type { TextFormatTransformer } from '@lexical/markdown'\n\nexport const INLINE_CODE: TextFormatTransformer = {\n  type: 'text-format',\n  format: ['code'],\n  tag: '`',\n}\n"],"names":["INLINE_CODE","type","format","tag"],"mappings":";;;AAEO,MAAMA,WAAA,GAAqC;IAChDC,IAAA,EAAM;IACNC,MAAA,EAAQ;QAAC;KAAO;IAChBC,GAAA,EAAK;AACP"}},
    {"offset": {"line": 314, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 320, "column": 0}, "map": {"version":3,"file":"feature.server.js","sources":["turbopack://[project]/node_modules/@payloadcms/richtext-lexical/src/features/format/inlineCode/feature.server.ts"],"sourcesContent":["import { createServerFeature } from '../../../utilities/createServerFeature.js'\nimport { INLINE_CODE } from './markdownTransformers.js'\n\nexport const InlineCodeFeature = createServerFeature({\n  feature: {\n    ClientFeature: '@payloadcms/richtext-lexical/client#InlineCodeFeatureClient',\n    markdownTransformers: [INLINE_CODE],\n  },\n  key: 'inlineCode',\n})\n"],"names":["createServerFeature","INLINE_CODE","InlineCodeFeature","feature","ClientFeature","markdownTransformers","key"],"mappings":";;;AAAA,SAASA,mBAAmB,QAAQ;AACpC,SAASC,WAAW,QAAQ;;;AAErB,MAAMC,iBAAA,uMAAoBF,sBAAAA,AAAA,EAAoB;IACnDG,OAAA,EAAS;QACPC,aAAA,EAAe;QACfC,oBAAA,EAAsB;oOAACJ,cAAA;SAAA;IACzB;IACAK,GAAA,EAAK;AACP"}},
    {"offset": {"line": 336, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 342, "column": 0}, "map": {"version":3,"file":"i18n.js","sources":["turbopack://[project]/node_modules/@payloadcms/richtext-lexical/src/features/paragraph/server/i18n.ts"],"sourcesContent":["import type { GenericLanguages } from '@payloadcms/translations'\n\nexport const i18n: Partial<GenericLanguages> = {\n  ar: {\n    label: 'فقرة',\n    label2: 'نص عادي',\n  },\n  az: {\n    label: 'Paraqraf',\n    label2: 'Normal Mətn',\n  },\n  bg: {\n    label: 'Параграф',\n    label2: 'Нормален текст',\n  },\n  cs: {\n    label: 'Odstavec',\n    label2: 'Normální text',\n  },\n  de: {\n    label: 'Paragraph',\n    label2: 'Normaler Text',\n  },\n  en: {\n    label: 'Paragraph',\n    label2: 'Normal Text',\n  },\n  es: {\n    label: 'Párrafo',\n    label2: 'Texto normal',\n  },\n  fa: {\n    label: 'پاراگراف',\n    label2: 'متن عادی',\n  },\n  fr: {\n    label: 'Paragraphe',\n    label2: 'Texte normal',\n  },\n  he: {\n    label: 'פסקה',\n    label2: 'טקסט רגיל',\n  },\n  hr: {\n    label: 'Odlomak',\n    label2: 'Normalan tekst',\n  },\n  hu: {\n    label: 'Bekezdés',\n    label2: 'Normál szöveg',\n  },\n  it: {\n    label: 'Paragrafo',\n    label2: 'Testo normale',\n  },\n  ja: {\n    label: '段落',\n    label2: '通常のテキスト',\n  },\n  ko: {\n    label: '문단',\n    label2: '일반 텍스트',\n  },\n  my: {\n    label: 'Perenggan',\n    label2: 'ပုံမှန်စာသား',\n  },\n  nb: {\n    label: 'Avsnitt',\n    label2: 'Normal tekst',\n  },\n  nl: {\n    label: 'Paragraaf',\n    label2: 'Normale tekst',\n  },\n  pl: {\n    label: 'Akapit',\n    label2: 'Normalny tekst',\n  },\n  pt: {\n    label: 'Parágrafo',\n    label2: 'Texto Normal',\n  },\n  ro: {\n    label: 'Paragraf',\n    label2: 'Text normal',\n  },\n  rs: {\n    label: 'Paragraf',\n    label2: 'Normalan tekst',\n  },\n  'rs-latin': {\n    label: 'Paragraf',\n    label2: 'Normalan tekst',\n  },\n  ru: {\n    label: 'Параграф',\n    label2: 'Нормальный текст',\n  },\n  sk: {\n    label: 'Odsek',\n    label2: 'Normálny text',\n  },\n  sv: {\n    label: 'Stycke',\n    label2: 'Normal Text',\n  },\n  th: {\n    label: 'ย่อหน้า',\n    label2: 'ข้อความธรรมดา',\n  },\n  tr: {\n    label: 'Paragraf',\n    label2: 'Normal Metin',\n  },\n  uk: {\n    label: 'Абзац',\n    label2: 'Звичайний текст',\n  },\n  vi: {\n    label: 'Đoạn văn',\n    label2: 'Văn bản bình thường',\n  },\n  zh: {\n    label: '段落',\n    label2: '正常文本',\n  },\n  'zh-TW': {\n    label: '段落',\n    label2: '正常文本',\n  },\n}\n"],"names":["i18n","ar","label","label2","az","bg","cs","de","en","es","fa","fr","he","hr","hu","it","ja","ko","my","nb","nl","pl","pt","ro","rs","ru","sk","sv","th","tr","uk","vi","zh"],"mappings":";;;AAEO,MAAMA,IAAA,GAAkC;IAC7CC,EAAA,EAAI;QACFC,KAAA,EAAO;QACPC,MAAA,EAAQ;IACV;IACAC,EAAA,EAAI;QACFF,KAAA,EAAO;QACPC,MAAA,EAAQ;IACV;IACAE,EAAA,EAAI;QACFH,KAAA,EAAO;QACPC,MAAA,EAAQ;IACV;IACAG,EAAA,EAAI;QACFJ,KAAA,EAAO;QACPC,MAAA,EAAQ;IACV;IACAI,EAAA,EAAI;QACFL,KAAA,EAAO;QACPC,MAAA,EAAQ;IACV;IACAK,EAAA,EAAI;QACFN,KAAA,EAAO;QACPC,MAAA,EAAQ;IACV;IACAM,EAAA,EAAI;QACFP,KAAA,EAAO;QACPC,MAAA,EAAQ;IACV;IACAO,EAAA,EAAI;QACFR,KAAA,EAAO;QACPC,MAAA,EAAQ;IACV;IACAQ,EAAA,EAAI;QACFT,KAAA,EAAO;QACPC,MAAA,EAAQ;IACV;IACAS,EAAA,EAAI;QACFV,KAAA,EAAO;QACPC,MAAA,EAAQ;IACV;IACAU,EAAA,EAAI;QACFX,KAAA,EAAO;QACPC,MAAA,EAAQ;IACV;IACAW,EAAA,EAAI;QACFZ,KAAA,EAAO;QACPC,MAAA,EAAQ;IACV;IACAY,EAAA,EAAI;QACFb,KAAA,EAAO;QACPC,MAAA,EAAQ;IACV;IACAa,EAAA,EAAI;QACFd,KAAA,EAAO;QACPC,MAAA,EAAQ;IACV;IACAc,EAAA,EAAI;QACFf,KAAA,EAAO;QACPC,MAAA,EAAQ;IACV;IACAe,EAAA,EAAI;QACFhB,KAAA,EAAO;QACPC,MAAA,EAAQ;IACV;IACAgB,EAAA,EAAI;QACFjB,KAAA,EAAO;QACPC,MAAA,EAAQ;IACV;IACAiB,EAAA,EAAI;QACFlB,KAAA,EAAO;QACPC,MAAA,EAAQ;IACV;IACAkB,EAAA,EAAI;QACFnB,KAAA,EAAO;QACPC,MAAA,EAAQ;IACV;IACAmB,EAAA,EAAI;QACFpB,KAAA,EAAO;QACPC,MAAA,EAAQ;IACV;IACAoB,EAAA,EAAI;QACFrB,KAAA,EAAO;QACPC,MAAA,EAAQ;IACV;IACAqB,EAAA,EAAI;QACFtB,KAAA,EAAO;QACPC,MAAA,EAAQ;IACV;IACA,YAAY;QACVD,KAAA,EAAO;QACPC,MAAA,EAAQ;IACV;IACAsB,EAAA,EAAI;QACFvB,KAAA,EAAO;QACPC,MAAA,EAAQ;IACV;IACAuB,EAAA,EAAI;QACFxB,KAAA,EAAO;QACPC,MAAA,EAAQ;IACV;IACAwB,EAAA,EAAI;QACFzB,KAAA,EAAO;QACPC,MAAA,EAAQ;IACV;IACAyB,EAAA,EAAI;QACF1B,KAAA,EAAO;QACPC,MAAA,EAAQ;IACV;IACA0B,EAAA,EAAI;QACF3B,KAAA,EAAO;QACPC,MAAA,EAAQ;IACV;IACA2B,EAAA,EAAI;QACF5B,KAAA,EAAO;QACPC,MAAA,EAAQ;IACV;IACA4B,EAAA,EAAI;QACF7B,KAAA,EAAO;QACPC,MAAA,EAAQ;IACV;IACA6B,EAAA,EAAI;QACF9B,KAAA,EAAO;QACPC,MAAA,EAAQ;IACV;IACA,SAAS;QACPD,KAAA,EAAO;QACPC,MAAA,EAAQ;IACV;AACF"}},
    {"offset": {"line": 475, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 481, "column": 0}, "map": {"version":3,"file":"index.js","sources":["turbopack://[project]/node_modules/@payloadcms/richtext-lexical/src/features/paragraph/server/index.ts"],"sourcesContent":["import { createServerFeature } from '../../../utilities/createServerFeature.js'\nimport { i18n } from './i18n.js'\n\nexport const ParagraphFeature = createServerFeature({\n  feature: {\n    ClientFeature: '@payloadcms/richtext-lexical/client#ParagraphFeatureClient',\n    clientFeatureProps: null,\n    i18n,\n  },\n  key: 'paragraph',\n})\n"],"names":["createServerFeature","i18n","ParagraphFeature","feature","ClientFeature","clientFeatureProps","key"],"mappings":";;;AAAA,SAASA,mBAAmB,QAAQ;AACpC,SAASC,IAAI,QAAQ;;;AAEd,MAAMC,gBAAA,uMAAmBF,sBAAAA,AAAA,EAAoB;IAClDG,OAAA,EAAS;QACPC,aAAA,EAAe;QACfC,kBAAA,EAAoB;qNACpBJ,OAAAA;IACF;IACAK,GAAA,EAAK;AACP"}},
    {"offset": {"line": 496, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 502, "column": 0}, "map": {"version":3,"file":"i18n.js","sources":["turbopack://[project]/node_modules/@payloadcms/richtext-lexical/src/features/heading/server/i18n.ts"],"sourcesContent":["import type { GenericLanguages } from '@payloadcms/translations'\n\nexport const i18n: Partial<GenericLanguages> = {\n  ar: {\n    label: 'العنوان {{headingLevel}}',\n  },\n  az: {\n    label: 'Başlıq {{headingLevel}}',\n  },\n  bg: {\n    label: 'Заглавие {{headingLevel}}',\n  },\n  cs: {\n    label: 'Nadpis {{headingLevel}}',\n  },\n  de: {\n    label: 'Überschrift {{headingLevel}}',\n  },\n  en: {\n    label: 'Heading {{headingLevel}}',\n  },\n  es: {\n    label: 'Encabezado {{headingLevel}}',\n  },\n  fa: {\n    label: '[SKIPPED]',\n  },\n  fr: {\n    label: 'En-tête {{headingLevel}}',\n  },\n  he: {\n    label: 'כותרת {{רמת כותרת}}',\n  },\n  hr: {\n    label: 'Naslov {{headingLevel}}',\n  },\n  hu: {\n    label: 'Címsor {{headingLevel}}',\n  },\n  it: {\n    label: 'Intestazione {{headingLevel}}',\n  },\n  ja: {\n    label: '見出し{{headingLevel}}',\n  },\n  ko: {\n    label: '제목 {{headingLevel}}',\n  },\n  my: {\n    label: '[SURAT]\\n\\nKepala {{headingLevel}}',\n  },\n  nb: {\n    label: 'Overskrift {{headingLevel}}',\n  },\n  nl: {\n    label: 'Kop {{headingLevel}}',\n  },\n  pl: {\n    label: 'Nagłówek {{headingLevel}}',\n  },\n  pt: {\n    label: 'Cabeçalho {{headingLevel}}',\n  },\n  ro: {\n    label: 'Titlu {{headingLevel}}',\n  },\n  rs: {\n    label: 'Naslov {{headingLevel}}',\n  },\n  'rs-latin': {\n    label: 'Naslov {{headingLevel}}',\n  },\n  ru: {\n    label: 'Заголовок {{headingLevel}}',\n  },\n  sk: {\n    label: 'Nadpis {{headingLevel}}',\n  },\n  sv: {\n    label: 'Rubrik {{headingLevel}}',\n  },\n  th: {\n    label: 'หัวข้อ {{headingLevel}}',\n  },\n  tr: {\n    label: 'Başlık {{headingLevel}}',\n  },\n  uk: {\n    label: 'Заголовок {{headingLevel}}',\n  },\n  vi: {\n    label: 'Tiêu đề {{headingLevel}}',\n  },\n  zh: {\n    label: '标题 {{headingLevel}}',\n  },\n  'zh-TW': {\n    label: '標題 {{headingLevel}}',\n  },\n}\n"],"names":["i18n","ar","label","az","bg","cs","de","en","es","fa","fr","he","hr","hu","it","ja","ko","my","nb","nl","pl","pt","ro","rs","ru","sk","sv","th","tr","uk","vi","zh"],"mappings":";;;AAEO,MAAMA,IAAA,GAAkC;IAC7CC,EAAA,EAAI;QACFC,KAAA,EAAO;IACT;IACAC,EAAA,EAAI;QACFD,KAAA,EAAO;IACT;IACAE,EAAA,EAAI;QACFF,KAAA,EAAO;IACT;IACAG,EAAA,EAAI;QACFH,KAAA,EAAO;IACT;IACAI,EAAA,EAAI;QACFJ,KAAA,EAAO;IACT;IACAK,EAAA,EAAI;QACFL,KAAA,EAAO;IACT;IACAM,EAAA,EAAI;QACFN,KAAA,EAAO;IACT;IACAO,EAAA,EAAI;QACFP,KAAA,EAAO;IACT;IACAQ,EAAA,EAAI;QACFR,KAAA,EAAO;IACT;IACAS,EAAA,EAAI;QACFT,KAAA,EAAO;IACT;IACAU,EAAA,EAAI;QACFV,KAAA,EAAO;IACT;IACAW,EAAA,EAAI;QACFX,KAAA,EAAO;IACT;IACAY,EAAA,EAAI;QACFZ,KAAA,EAAO;IACT;IACAa,EAAA,EAAI;QACFb,KAAA,EAAO;IACT;IACAc,EAAA,EAAI;QACFd,KAAA,EAAO;IACT;IACAe,EAAA,EAAI;QACFf,KAAA,EAAO;IACT;IACAgB,EAAA,EAAI;QACFhB,KAAA,EAAO;IACT;IACAiB,EAAA,EAAI;QACFjB,KAAA,EAAO;IACT;IACAkB,EAAA,EAAI;QACFlB,KAAA,EAAO;IACT;IACAmB,EAAA,EAAI;QACFnB,KAAA,EAAO;IACT;IACAoB,EAAA,EAAI;QACFpB,KAAA,EAAO;IACT;IACAqB,EAAA,EAAI;QACFrB,KAAA,EAAO;IACT;IACA,YAAY;QACVA,KAAA,EAAO;IACT;IACAsB,EAAA,EAAI;QACFtB,KAAA,EAAO;IACT;IACAuB,EAAA,EAAI;QACFvB,KAAA,EAAO;IACT;IACAwB,EAAA,EAAI;QACFxB,KAAA,EAAO;IACT;IACAyB,EAAA,EAAI;QACFzB,KAAA,EAAO;IACT;IACA0B,EAAA,EAAI;QACF1B,KAAA,EAAO;IACT;IACA2B,EAAA,EAAI;QACF3B,KAAA,EAAO;IACT;IACA4B,EAAA,EAAI;QACF5B,KAAA,EAAO;IACT;IACA6B,EAAA,EAAI;QACF7B,KAAA,EAAO;IACT;IACA,SAAS;QACPA,KAAA,EAAO;IACT;AACF"}},
    {"offset": {"line": 603, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 609, "column": 0}, "map": {"version":3,"file":"createBlockNode.js","sources":["turbopack://[project]/node_modules/@payloadcms/richtext-lexical/src/lexical/utils/markdown/createBlockNode.ts"],"sourcesContent":["import type { ElementTransformer } from '@lexical/markdown'\nimport type { ElementNode } from 'lexical'\n\nexport const createBlockNode = (\n  createNode: (match: Array<string>) => ElementNode,\n): ElementTransformer['replace'] => {\n  return (parentNode, children, match) => {\n    const node = createNode(match)\n    if (node) {\n      node.append(...children)\n      parentNode.replace(node)\n      node.select(0, 0)\n    }\n  }\n}\n"],"names":["createBlockNode","createNode","parentNode","children","match","node","append","replace","select"],"mappings":";;;AAGO,MAAMA,eAAA,IACXC,UAAA;IAEA,OAAO,CAACC,UAAA,EAAYC,QAAA,EAAUC,KAAA;QAC5B,MAAMC,IAAA,GAAOJ,UAAA,CAAWG,KAAA;QACxB,IAAIC,IAAA,EAAM;YACRA,IAAA,CAAKC,MAAM,IAAIH,QAAA;YACfD,UAAA,CAAWK,OAAO,CAACF,IAAA;YACnBA,IAAA,CAAKG,MAAM,CAAC,GAAG;QACjB;IACF;AACF"}},
    {"offset": {"line": 622, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 628, "column": 0}, "map": {"version":3,"file":"markdownTransformer.js","sources":["turbopack://[project]/node_modules/@payloadcms/richtext-lexical/src/features/heading/markdownTransformer.ts"],"sourcesContent":["import type { ElementTransformer } from '@lexical/markdown'\nimport type { HeadingTagType } from '@lexical/rich-text'\n\nimport { $createHeadingNode, $isHeadingNode, HeadingNode } from '@lexical/rich-text'\n\nimport { createBlockNode } from '../../lexical/utils/markdown/createBlockNode.js'\n\nexport const MarkdownTransformer: (enabledHeadingSizes: HeadingTagType[]) => ElementTransformer = (\n  enabledHeadingSizes,\n) => {\n  // Convert enabledHeadingSizes to a list of numbers (1 for h1, 2 for h2, etc.)\n  const enabledSizes = enabledHeadingSizes.map((tag) => Number(tag.slice(1)))\n\n  // Create a regex pattern that matches any of the enabled sizes\n  const pattern = `^(${enabledSizes.map((size) => `#{${size}}`).join('|')})\\\\s`\n  const regExp = new RegExp(pattern)\n\n  return {\n    type: 'element',\n    dependencies: [HeadingNode],\n    export: (node, exportChildren) => {\n      if (!$isHeadingNode(node)) {\n        return null\n      }\n      const level = Number(node.getTag().slice(1))\n      return '#'.repeat(level) + ' ' + exportChildren(node)\n    },\n    regExp,\n    replace: createBlockNode((match) => {\n      const tag = ('h' + match[1].length) as HeadingTagType\n      return $createHeadingNode(tag)\n    }),\n  }\n}\n"],"names":["$createHeadingNode","$isHeadingNode","HeadingNode","createBlockNode","MarkdownTransformer","enabledHeadingSizes","enabledSizes","map","tag","Number","slice","pattern","size","join","regExp","RegExp","type","dependencies","export","node","exportChildren","level","getTag","repeat","replace","match","length"],"mappings":";;;AAGA,SAASA,kBAAkB,EAAEC,cAAc,EAAEC,WAAW,QAAQ;AAEhE,SAASC,eAAe,QAAQ;;;AAEzB,MAAMC,mBAAA,IACXC,mBAAA;IAEA,8EAAA;IACA,MAAMC,YAAA,GAAeD,mBAAA,CAAoBE,GAAG,EAAEC,GAAA,GAAQC,MAAA,CAAOD,GAAA,CAAIE,KAAK,CAAC;IAEvE,+DAAA;IACA,MAAMC,OAAA,GAAU,CAAA,EAAA,EAAKL,YAAA,CAAaC,GAAG,EAAEK,IAAA,GAAS,CAAA,EAAA,EAAKA,IAAA,CAAA,CAAA,CAAO,EAAEC,IAAI,CAAC,KAAA,IAAA,CAAU;IAC7E,MAAMC,MAAA,GAAS,IAAIC,MAAA,CAAOJ,OAAA;IAE1B,OAAO;QACLK,IAAA,EAAM;QACNC,YAAA,EAAc;iLAACf,cAAA;SAAY;QAC3BgB,MAAA,EAAQA,CAACC,IAAA,EAAMC,cAAA;YACb,IAAI,0KAACnB,iBAAAA,AAAA,EAAekB,IAAA,GAAO;gBACzB,OAAO;YACT;YACA,MAAME,KAAA,GAAQZ,MAAA,CAAOU,IAAA,CAAKG,MAAM,GAAGZ,KAAK,CAAC;YACzC,OAAO,IAAIa,MAAM,CAACF,KAAA,IAAS,MAAMD,cAAA,CAAeD,IAAA;QAClD;QACAL,MAAA;QACAU,OAAA,qNAASrB,kBAAAA,AAAA,GAAiBsB,KAAA;YACxB,MAAMjB,GAAA,GAAO,MAAMiB,KAAK,CAAC,EAAE,CAACC,MAAM;YAClC,gLAAO1B,qBAAAA,AAAA,EAAmBQ,GAAA;QAC5B;IACF;AACF"}},
    {"offset": {"line": 660, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 666, "column": 0}, "map": {"version":3,"file":"typeUtilities.js","sources":["turbopack://[project]/node_modules/@payloadcms/richtext-lexical/src/features/typeUtilities.ts"],"sourcesContent":["import type { LexicalNode } from 'lexical'\n\nimport type { NodeWithHooks } from './typesServer.js'\n\n/**\n * Utility function to create a node with hooks. You don't have to use this utility, but it improves type inference\n * @param node the node\n */\nexport function createNode<Node extends LexicalNode>(\n  node: NodeWithHooks<Node>,\n): NodeWithHooks<Node> {\n  return node\n}\n"],"names":["createNode","node"],"mappings":"AAIA;;;GAIA;;;AAAO,SAASA,WACdC,IAAyB;IAEzB,OAAOA,IAAA;AACT"}},
    {"offset": {"line": 675, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 681, "column": 0}, "map": {"version":3,"file":"index.js","sources":["turbopack://[project]/node_modules/@payloadcms/richtext-lexical/src/features/converters/html/converter/index.ts"],"sourcesContent":["import type { SerializedEditorState, SerializedLexicalNode } from 'lexical'\nimport type { Payload, PayloadRequest } from 'payload'\n\nimport { createLocalReq } from 'payload'\n\nimport type { HTMLConverter, SerializedLexicalNodeWithParent } from './types.js'\n\nexport type ConvertLexicalToHTMLArgs = {\n  converters: HTMLConverter[]\n  currentDepth?: number\n  data: SerializedEditorState\n  depth?: number\n  draft?: boolean // default false\n  overrideAccess?: boolean // default false\n  showHiddenFields?: boolean // default false\n} & (\n  | {\n      /**\n       * This payload property will only be used if req is undefined.\n       */\n      payload?: never\n      /**\n       * When the converter is called, req CAN be passed in depending on where it's run.\n       * If this is undefined and config is passed through, lexical will create a new req object for you. If this is null or\n       * config is undefined, lexical will not create a new req object for you and local API / server-side-only\n       * functionality will be disabled.\n       */\n      req: PayloadRequest\n    }\n  | {\n      /**\n       * This payload property will only be used if req is undefined.\n       */\n      payload?: Payload\n      /**\n       * When the converter is called, req CAN be passed in depending on where it's run.\n       * If this is undefined and config is passed through, lexical will create a new req object for you. If this is null or\n       * config is undefined, lexical will not create a new req object for you and local API / server-side-only\n       * functionality will be disabled.\n       */\n      req?: null | undefined\n    }\n)\n\nexport async function convertLexicalToHTML({\n  converters,\n  currentDepth,\n  data,\n  depth,\n  draft,\n  overrideAccess,\n  payload,\n  req,\n  showHiddenFields,\n}: ConvertLexicalToHTMLArgs): Promise<string> {\n  if (data?.root?.children?.length) {\n    if (req === undefined && payload) {\n      req = await createLocalReq({}, payload)\n    }\n\n    if (!currentDepth) {\n      currentDepth = 0\n    }\n\n    if (!depth) {\n      depth = req?.payload?.config?.defaultDepth\n    }\n\n    return await convertLexicalNodesToHTML({\n      converters,\n      currentDepth,\n      depth: depth!,\n      draft: draft === undefined ? false : draft,\n      lexicalNodes: data?.root?.children,\n      overrideAccess: overrideAccess === undefined ? false : overrideAccess,\n      parent: data?.root,\n      req: req!,\n      showHiddenFields: showHiddenFields === undefined ? false : showHiddenFields,\n    })\n  }\n  return ''\n}\n\nexport async function convertLexicalNodesToHTML({\n  converters,\n  currentDepth,\n  depth,\n  draft,\n  lexicalNodes,\n  overrideAccess,\n  parent,\n  req,\n  showHiddenFields,\n}: {\n  converters: HTMLConverter[]\n  currentDepth: number\n  depth: number\n  draft: boolean\n  lexicalNodes: SerializedLexicalNode[]\n  overrideAccess: boolean\n  parent: SerializedLexicalNodeWithParent\n  /**\n   * When the converter is called, req CAN be passed in depending on where it's run.\n   */\n  req: null | PayloadRequest\n  showHiddenFields: boolean\n}): Promise<string> {\n  const unknownConverter = converters.find((converter) => converter.nodeTypes.includes('unknown'))\n\n  const htmlArray = await Promise.all(\n    lexicalNodes.map(async (node, i) => {\n      const converterForNode = converters.find((converter) =>\n        converter.nodeTypes.includes(node.type),\n      )\n      try {\n        if (!converterForNode) {\n          if (unknownConverter) {\n            return await unknownConverter.converter({\n              childIndex: i,\n              converters,\n              currentDepth,\n              depth,\n              draft,\n              node,\n              overrideAccess,\n              parent,\n              req,\n              showHiddenFields,\n            })\n          }\n          return '<span>unknown node</span>'\n        }\n        return await converterForNode.converter({\n          childIndex: i,\n          converters,\n          currentDepth,\n          depth,\n          draft,\n          node,\n          overrideAccess,\n          parent,\n          req,\n          showHiddenFields,\n        })\n      } catch (error) {\n        console.error('Error converting lexical node to HTML:', error, 'node:', node)\n        return ''\n      }\n    }),\n  )\n\n  return htmlArray.join('') || ''\n}\n"],"names":["createLocalReq","convertLexicalToHTML","converters","currentDepth","data","depth","draft","overrideAccess","payload","req","showHiddenFields","root","children","length","undefined","config","defaultDepth","convertLexicalNodesToHTML","lexicalNodes","parent","unknownConverter","find","converter","nodeTypes","includes","htmlArray","Promise","all","map","node","i","converterForNode","type","childIndex","error","console","join"],"mappings":";;;;AAGA,SAASA,cAAc,QAAQ;;AAyCxB,eAAeC,qBAAqB,EACzCC,UAAU,EACVC,YAAY,EACZC,IAAI,EACJC,KAAK,EACLC,KAAK,EACLC,cAAc,EACdC,OAAO,EACPC,GAAG,EACHC,gBAAAA,EACyB;IACzB,IAAIN,IAAA,EAAMO,IAAA,EAAMC,QAAA,EAAUC,MAAA,EAAQ;QAChC,IAAIJ,GAAA,KAAQK,SAAA,IAAaN,OAAA,EAAS;YAChCC,GAAA,GAAM,yKAAMT,iBAAAA,AAAA,EAAe,CAAC,GAAGQ,OAAA;QACjC;QAEA,IAAI,CAACL,YAAA,EAAc;YACjBA,YAAA,GAAe;QACjB;QAEA,IAAI,CAACE,KAAA,EAAO;YACVA,KAAA,GAAQI,GAAA,EAAKD,OAAA,EAASO,MAAA,EAAQC,YAAA;QAChC;QAEA,OAAO,MAAMC,yBAAA,CAA0B;YACrCf,UAAA;YACAC,YAAA;YACAE,KAAA,EAAOA,KAAA;YACPC,KAAA,EAAOA,KAAA,KAAUQ,SAAA,GAAY,QAAQR,KAAA;YACrCY,YAAA,EAAcd,IAAA,EAAMO,IAAA,EAAMC,QAAA;YAC1BL,cAAA,EAAgBA,cAAA,KAAmBO,SAAA,GAAY,QAAQP,cAAA;YACvDY,MAAA,EAAQf,IAAA,EAAMO,IAAA;YACdF,GAAA,EAAKA,GAAA;YACLC,gBAAA,EAAkBA,gBAAA,KAAqBI,SAAA,GAAY,QAAQJ;QAC7D;IACF;IACA,OAAO;AACT;AAEO,eAAeO,0BAA0B,EAC9Cf,UAAU,EACVC,YAAY,EACZE,KAAK,EACLC,KAAK,EACLY,YAAY,EACZX,cAAc,EACdY,MAAM,EACNV,GAAG,EACHC,gBAAAA,EAcD;IACC,MAAMU,gBAAA,GAAmBlB,UAAA,CAAWmB,IAAI,EAAEC,SAAA,GAAcA,SAAA,CAAUC,SAAS,CAACC,QAAQ,CAAC;IAErF,MAAMC,SAAA,GAAY,MAAMC,OAAA,CAAQC,GAAG,CACjCT,YAAA,CAAaU,GAAG,CAAC,OAAOC,IAAA,EAAMC,CAAA;QAC5B,MAAMC,gBAAA,GAAmB7B,UAAA,CAAWmB,IAAI,EAAEC,SAAA,GACxCA,SAAA,CAAUC,SAAS,CAACC,QAAQ,CAACK,IAAA,CAAKG,IAAI;QAExC,IAAI;YACF,IAAI,CAACD,gBAAA,EAAkB;gBACrB,IAAIX,gBAAA,EAAkB;oBACpB,OAAO,MAAMA,gBAAA,CAAiBE,SAAS,CAAC;wBACtCW,UAAA,EAAYH,CAAA;wBACZ5B,UAAA;wBACAC,YAAA;wBACAE,KAAA;wBACAC,KAAA;wBACAuB,IAAA;wBACAtB,cAAA;wBACAY,MAAA;wBACAV,GAAA;wBACAC;oBACF;gBACF;gBACA,OAAO;YACT;YACA,OAAO,MAAMqB,gBAAA,CAAiBT,SAAS,CAAC;gBACtCW,UAAA,EAAYH,CAAA;gBACZ5B,UAAA;gBACAC,YAAA;gBACAE,KAAA;gBACAC,KAAA;gBACAuB,IAAA;gBACAtB,cAAA;gBACAY,MAAA;gBACAV,GAAA;gBACAC;YACF;QACF,EAAE,OAAOwB,KAAA,EAAO;YACdC,OAAA,CAAQD,KAAK,CAAC,0CAA0CA,KAAA,EAAO,SAASL,IAAA;YACxE,OAAO;QACT;IACF;IAGF,OAAOJ,SAAA,CAAUW,IAAI,CAAC,OAAO;AAC/B"}},
    {"offset": {"line": 753, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 759, "column": 0}, "map": {"version":3,"file":"index.js","sources":["turbopack://[project]/node_modules/@payloadcms/richtext-lexical/src/features/heading/server/index.ts"],"sourcesContent":["import type {\n  SerializedHeadingNode as _SerializedHeadingNode,\n  HeadingTagType,\n} from '@lexical/rich-text'\nimport type { Spread } from 'lexical'\n\nimport { HeadingNode } from '@lexical/rich-text'\n\nimport { createServerFeature } from '../../../utilities/createServerFeature.js'\nimport { convertLexicalNodesToHTML } from '../../converters/html/converter/index.js'\nimport { createNode } from '../../typeUtilities.js'\nimport { MarkdownTransformer } from '../markdownTransformer.js'\nimport { i18n } from './i18n.js'\n\nexport type SerializedHeadingNode = Spread<\n  {\n    type: 'heading'\n  },\n  _SerializedHeadingNode\n>\n\nexport type HeadingFeatureProps = {\n  enabledHeadingSizes?: HeadingTagType[]\n}\n\nexport const HeadingFeature = createServerFeature<\n  HeadingFeatureProps,\n  HeadingFeatureProps,\n  HeadingFeatureProps\n>({\n  feature: ({ props }) => {\n    if (!props) {\n      props = {}\n    }\n\n    const { enabledHeadingSizes = ['h1', 'h2', 'h3', 'h4', 'h5', 'h6'] } = props\n\n    return {\n      ClientFeature: '@payloadcms/richtext-lexical/client#HeadingFeatureClient',\n      clientFeatureProps: props,\n      i18n,\n      markdownTransformers: [MarkdownTransformer(enabledHeadingSizes)],\n      nodes: [\n        createNode({\n          converters: {\n            html: {\n              converter: async ({\n                converters,\n                currentDepth,\n                depth,\n                draft,\n                node,\n                overrideAccess,\n                parent,\n                req,\n                showHiddenFields,\n              }) => {\n                const childrenText = await convertLexicalNodesToHTML({\n                  converters,\n                  currentDepth,\n                  depth,\n                  draft,\n                  lexicalNodes: node.children,\n                  overrideAccess,\n                  parent: {\n                    ...node,\n                    parent,\n                  },\n                  req,\n                  showHiddenFields,\n                })\n\n                return '<' + node?.tag + '>' + childrenText + '</' + node?.tag + '>'\n              },\n              nodeTypes: [HeadingNode.getType()],\n            },\n          },\n          node: HeadingNode,\n        }),\n      ],\n      sanitizedServerFeatureProps: props,\n    }\n  },\n  key: 'heading',\n})\n"],"names":["HeadingNode","createServerFeature","convertLexicalNodesToHTML","createNode","MarkdownTransformer","i18n","HeadingFeature","feature","props","enabledHeadingSizes","ClientFeature","clientFeatureProps","markdownTransformers","nodes","converters","html","converter","currentDepth","depth","draft","node","overrideAccess","parent","req","showHiddenFields","childrenText","lexicalNodes","children","tag","nodeTypes","getType","sanitizedServerFeatureProps","key"],"mappings":";;;AAQA,SAASC,mBAAmB,QAAQ;AAIpC,SAASI,IAAI,QAAQ;AADrB,SAASD,mBAAmB,QAAQ;AADpC,SAASD,UAAU,QAAQ;AAD3B,SAASD,yBAAyB,QAAQ;AAH1C,SAASF,WAAW,QAAQ;;;;;;;AAmBrB,MAAMM,cAAA,uMAAiBL,sBAAAA,AAAA,EAI5B;IACAM,OAAA,EAASA,CAAC,EAAEC,KAAAA,EAAO;QACjB,IAAI,CAACA,KAAA,EAAO;YACVA,KAAA,GAAQ,CAAC;QACX;QAEA,MAAM,EAAEC,mBAAA,GAAsB;YAAC;YAAM;YAAM;YAAM;YAAM;YAAM;SAAA,EAAO,GAAGD,KAAA;QAEvE,OAAO;YACLE,aAAA,EAAe;YACfC,kBAAA,EAAoBH,KAAA;kBACpBH,4MAAA;YACAO,oBAAA,EAAsB;8NAACR,sBAAAA,AAAA,EAAoBK,mBAAA;aAAqB;YAChEI,KAAA,EAAO;iBACLV,yMAAAA,AAAA,EAAW;oBACTW,UAAA,EAAY;wBACVC,IAAA,EAAM;4BACJC,SAAA,EAAW,MAAAA,CAAO,EAChBF,UAAU,EACVG,YAAY,EACZC,KAAK,EACLC,KAAK,EACLC,IAAI,EACJC,cAAc,EACdC,MAAM,EACNC,GAAG,EACHC,gBAAAA,EACD;gCACC,MAAMC,YAAA,GAAe,8NAAMvB,4BAAAA,AAAA,EAA0B;oCACnDY,UAAA;oCACAG,YAAA;oCACAC,KAAA;oCACAC,KAAA;oCACAO,YAAA,EAAcN,IAAA,CAAKO,QAAQ;oCAC3BN,cAAA;oCACAC,MAAA,EAAQ;wCACN,GAAGF,IAAI;wCACPE;oCACF;oCACAC,GAAA;oCACAC;gCACF;gCAEA,OAAO,MAAMJ,IAAA,EAAMQ,GAAA,GAAM,MAAMH,YAAA,GAAe,OAAOL,IAAA,EAAMQ,GAAA,GAAM;4BACnE;4BACAC,SAAA,EAAW;qMAAC7B,cAAA,CAAY8B,OAAO;6BAAA;wBACjC;oBACF;oBACAV,IAAA,uKAAMpB,cAAAA;gBACR;aACD;YACD+B,2BAAA,EAA6BvB;QAC/B;IACF;IACAwB,GAAA,EAAK;AACP"}},
    {"offset": {"line": 828, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 834, "column": 0}, "map": {"version":3,"file":"i18n.js","sources":["turbopack://[project]/node_modules/@payloadcms/richtext-lexical/src/features/align/server/i18n.ts"],"sourcesContent":["import type { GenericLanguages } from '@payloadcms/translations'\n\nexport const i18n: Partial<GenericLanguages> = {\n  ar: {\n    alignCenterLabel: 'محاذاة في الوسط',\n    alignJustifyLabel: 'محاذاة التبرير',\n    alignLeftLabel: 'محاذاة إلى اليسار',\n    alignRightLabel: 'محاذاة إلى اليمين',\n  },\n  az: {\n    alignCenterLabel: 'Mərkəzə Düzəlt',\n    alignJustifyLabel: 'Düzəldin Səsləndirin',\n    alignLeftLabel: 'Sola Doğru Hizalama',\n    alignRightLabel: 'Sağa Doğru Hizalama',\n  },\n  bg: {\n    alignCenterLabel: 'Центрирай',\n    alignJustifyLabel: 'Подравняване по двата края',\n    alignLeftLabel: 'Подравняване отляво',\n    alignRightLabel: 'Подравняване вдясно',\n  },\n  cs: {\n    alignCenterLabel: 'Zarovnat na střed',\n    alignJustifyLabel: 'Zarovnat do bloku',\n    alignLeftLabel: 'Zarovnat vlevo',\n    alignRightLabel: 'Zarovnat vpravo',\n  },\n  de: {\n    alignCenterLabel: 'Zentrieren',\n    alignJustifyLabel: 'Blocksatz',\n    alignLeftLabel: 'Linksbündig',\n    alignRightLabel: 'Rechtsbündig',\n  },\n  en: {\n    alignCenterLabel: 'Align Center',\n    alignJustifyLabel: 'Align Justify',\n    alignLeftLabel: 'Align Left',\n    alignRightLabel: 'Align Right',\n  },\n  es: {\n    alignCenterLabel: 'Alinear al centro',\n    alignJustifyLabel: 'Alinear Justificar',\n    alignLeftLabel: 'Alinear a la izquierda',\n    alignRightLabel: 'Alinear a la derecha',\n  },\n  fa: {\n    alignCenterLabel: 'تراز در مرکز',\n    alignJustifyLabel: 'تراز کردن از دو طرف',\n    alignLeftLabel: 'چپ تراز',\n    alignRightLabel: 'راست چین',\n  },\n  fr: {\n    alignCenterLabel: 'Aligner au centre',\n    alignJustifyLabel: 'Aligner Justifier',\n    alignLeftLabel: 'Aligner à gauche',\n    alignRightLabel: 'Aligner à droite',\n  },\n  he: {\n    alignCenterLabel: 'ממורכז',\n    alignJustifyLabel: 'יישור דו-צדדי',\n    alignLeftLabel: 'הסב לשמאל',\n    alignRightLabel: 'יישור לימין',\n  },\n  hr: {\n    alignCenterLabel: 'Poravnaj središnje',\n    alignJustifyLabel: 'Poravnaj opravdaj',\n    alignLeftLabel: 'Poravnaj lijevo',\n    alignRightLabel: 'Poravnaj desno',\n  },\n  hu: {\n    alignCenterLabel: 'Középre igazítás',\n    alignJustifyLabel: 'Igazítás Sorkizárás',\n    alignLeftLabel: 'Igazítás balra',\n    alignRightLabel: 'Igazítás jobbra',\n  },\n  it: {\n    alignCenterLabel: 'Allinea al centro',\n    alignJustifyLabel: 'Allinea Giustifica',\n    alignLeftLabel: 'Allinea a sinistra',\n    alignRightLabel: 'Allinea a destra',\n  },\n  ja: {\n    alignCenterLabel: '中央揃え',\n    alignJustifyLabel: '両端揃え',\n    alignLeftLabel: '左揃え',\n    alignRightLabel: '右揃え',\n  },\n  ko: {\n    alignCenterLabel: '중앙 정렬',\n    alignJustifyLabel: '정렬 맞춤',\n    alignLeftLabel: '왼쪽 정렬',\n    alignRightLabel: '오른쪽 정렬',\n  },\n  my: {\n    alignCenterLabel: 'Pusat Selaras',\n    alignJustifyLabel: 'Penjajaran Justify',\n    alignLeftLabel: 'ဘယ်ဘက်ဦးတည်ခြင်း',\n    alignRightLabel: 'Penjajaran Kanan',\n  },\n  nb: {\n    alignCenterLabel: 'Sentrer tekst',\n    alignJustifyLabel: 'Juster linje',\n    alignLeftLabel: 'Juster til venstre',\n    alignRightLabel: 'Juster til høyre',\n  },\n  nl: {\n    alignCenterLabel: 'Centreer uitlijnen',\n    alignJustifyLabel: 'Uitlijnen Rechtvaardigen',\n    alignLeftLabel: 'Links uitlijnen',\n    alignRightLabel: 'Rechts uitlijnen',\n  },\n  pl: {\n    alignCenterLabel: 'Wyśrodkuj',\n    alignJustifyLabel: 'Wyjustuj wyrównanie',\n    alignLeftLabel: 'Wyrównaj do lewej',\n    alignRightLabel: 'Wyrównaj do prawej',\n  },\n  pt: {\n    alignCenterLabel: 'Alinhar ao Centro',\n    alignJustifyLabel: 'Alinhar Justificar',\n    alignLeftLabel: 'Alinhar à Esquerda',\n    alignRightLabel: 'Alinhar à Direita',\n  },\n  ro: {\n    alignCenterLabel: 'Aliniați Centrul',\n    alignJustifyLabel: 'Aliniaza Justifica',\n    alignLeftLabel: 'Aliniați la stânga',\n    alignRightLabel: 'Aliniați la dreapta',\n  },\n  rs: {\n    alignCenterLabel: 'Centriraj',\n    alignJustifyLabel: 'Poravnaj opravdaj',\n    alignLeftLabel: 'Poravnaj levo',\n    alignRightLabel: 'Poravnaj desno',\n  },\n  'rs-latin': {\n    alignCenterLabel: 'Poravnaj centar',\n    alignJustifyLabel: 'Poravnaj opravdanje',\n    alignLeftLabel: 'Poravnaj levo',\n    alignRightLabel: 'Poravnaj desno',\n  },\n  ru: {\n    alignCenterLabel: 'Выровнять по центру',\n    alignJustifyLabel: 'Выровнять по ширине',\n    alignLeftLabel: 'Выровнять по левому краю',\n    alignRightLabel: 'Выровнять по правому краю',\n  },\n  sk: {\n    alignCenterLabel: 'Vycentrovať',\n    alignJustifyLabel: 'Zarovnať do bloku',\n    alignLeftLabel: 'Zarovnať doľava',\n    alignRightLabel: 'Zarovnať doprava',\n  },\n  sv: {\n    alignCenterLabel: 'Centrera',\n    alignJustifyLabel: 'Justera Justify',\n    alignLeftLabel: 'Justera till vänster',\n    alignRightLabel: 'Justera till höger',\n  },\n  th: {\n    alignCenterLabel: 'จัดแนวกึ่งกลาง',\n    alignJustifyLabel: 'จัดแนวตรง',\n    alignLeftLabel: 'จัดชิดซ้าย',\n    alignRightLabel: 'จัดชิดขวา',\n  },\n  tr: {\n    alignCenterLabel: 'Ortaya Hizala',\n    alignJustifyLabel: 'Hizala Yasla',\n    alignLeftLabel: 'Sola Hizala',\n    alignRightLabel: 'Sağa Hizala',\n  },\n  uk: {\n    alignCenterLabel: 'Вирівняти по центру',\n    alignJustifyLabel: 'Вирівняти за шириною',\n    alignLeftLabel: 'Вирівняти по лівому краю',\n    alignRightLabel: 'Вирівняти по правому краю',\n  },\n  vi: {\n    alignCenterLabel: 'Căn giữa',\n    alignJustifyLabel: 'Căn đều',\n    alignLeftLabel: 'Căn lề trái',\n    alignRightLabel: 'Căn phải',\n  },\n  zh: {\n    alignCenterLabel: '居中对齐',\n    alignJustifyLabel: '对齐调整',\n    alignLeftLabel: '向左对齐',\n    alignRightLabel: '向右对齐',\n  },\n  'zh-TW': {\n    alignCenterLabel: '對齊中心',\n    alignJustifyLabel: '對齊並排列',\n    alignLeftLabel: '向左對齊',\n    alignRightLabel: '向右對齊',\n  },\n}\n"],"names":["i18n","ar","alignCenterLabel","alignJustifyLabel","alignLeftLabel","alignRightLabel","az","bg","cs","de","en","es","fa","fr","he","hr","hu","it","ja","ko","my","nb","nl","pl","pt","ro","rs","ru","sk","sv","th","tr","uk","vi","zh"],"mappings":"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"}},
    {"offset": {"line": 1031, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1037, "column": 0}, "map": {"version":3,"file":"index.js","sources":["turbopack://[project]/node_modules/@payloadcms/richtext-lexical/src/features/align/server/index.ts"],"sourcesContent":["import { createServerFeature } from '../../../utilities/createServerFeature.js'\nimport { i18n } from './i18n.js'\n\nexport const AlignFeature = createServerFeature({\n  feature: {\n    ClientFeature: '@payloadcms/richtext-lexical/client#AlignFeatureClient',\n    i18n,\n  },\n  key: 'align',\n})\n"],"names":["createServerFeature","i18n","AlignFeature","feature","ClientFeature","key"],"mappings":";;;AAAA,SAASA,mBAAmB,QAAQ;AACpC,SAASC,IAAI,QAAQ;;;AAEd,MAAMC,YAAA,uMAAeF,sBAAAA,AAAA,EAAoB;IAC9CG,OAAA,EAAS;QACPC,aAAA,EAAe;iNACfH,OAAAA;IACF;IACAI,GAAA,EAAK;AACP"}},
    {"offset": {"line": 1051, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1057, "column": 0}, "map": {"version":3,"file":"i18n.js","sources":["turbopack://[project]/node_modules/@payloadcms/richtext-lexical/src/features/indent/server/i18n.ts"],"sourcesContent":["import type { GenericLanguages } from '@payloadcms/translations'\n\nexport const i18n: Partial<GenericLanguages> = {\n  ar: {\n    decreaseLabel: 'تقليل المسافة البادئة',\n    increaseLabel: 'زيادة المسافة البادئة',\n  },\n  az: {\n    decreaseLabel: 'İntervalı Azaltın',\n    increaseLabel: 'Girintiyi Artırın',\n  },\n  bg: {\n    decreaseLabel: 'Намали отстоянието',\n    increaseLabel: 'Увеличете отстоянието',\n  },\n  cs: {\n    decreaseLabel: 'Zmenšit odsazení',\n    increaseLabel: 'Zvětšit odsazení',\n  },\n  de: {\n    decreaseLabel: 'Einzug verkleinern',\n    increaseLabel: 'Einzug erhöhen',\n  },\n  en: {\n    decreaseLabel: 'Decrease Indent',\n    increaseLabel: 'Increase Indent',\n  },\n  es: {\n    decreaseLabel: 'Disminuir Sangría',\n    increaseLabel: 'Aumentar Sangría',\n  },\n  fa: {\n    decreaseLabel: 'کاهش تورفتگی',\n    increaseLabel: 'افزایش تورفتگی',\n  },\n  fr: {\n    decreaseLabel: \"Diminuer l'indentation\",\n    increaseLabel: \"Augmenter l'indentation\",\n  },\n  he: {\n    decreaseLabel: 'הקטן הזחה',\n    increaseLabel: 'הגדל כניסה',\n  },\n  hr: {\n    decreaseLabel: 'Smanji uvlačenje',\n    increaseLabel: 'Povećaj uvlačenje',\n  },\n  hu: {\n    decreaseLabel: 'Csökkentse a behúzást',\n    increaseLabel: 'Behúzás növelése',\n  },\n  it: {\n    decreaseLabel: 'Diminuisci rientro',\n    increaseLabel: 'Aumenta Rientro',\n  },\n  ja: {\n    decreaseLabel: 'インデントを減らす',\n    increaseLabel: 'インデントを増やす',\n  },\n  ko: {\n    decreaseLabel: '들여쓰기 줄이기',\n    increaseLabel: '들여쓰기 늘리기',\n  },\n  my: {\n    decreaseLabel: 'Kurangkan Inden',\n    increaseLabel: 'Tingkatkan Inden',\n  },\n  nb: {\n    decreaseLabel: 'Reduser innrykk',\n    increaseLabel: 'Øke innrykk',\n  },\n  nl: {\n    decreaseLabel: 'Verminder Inspringing',\n    increaseLabel: 'Inspring verhogen',\n  },\n  pl: {\n    decreaseLabel: 'Zmniejsz wcięcie',\n    increaseLabel: 'Zwiększ wcięcie',\n  },\n  pt: {\n    decreaseLabel: 'Diminuir recuo',\n    increaseLabel: 'Aumentar Indentação',\n  },\n  ro: {\n    decreaseLabel: 'Reducere indentare',\n    increaseLabel: 'Crește indentarea',\n  },\n  rs: {\n    decreaseLabel: 'Smanji uvlačenje',\n    increaseLabel: 'Povećaj uvlačenje',\n  },\n  'rs-latin': {\n    decreaseLabel: 'Smanji uvlačenje',\n    increaseLabel: 'Povećaj uvlačenje',\n  },\n  ru: {\n    decreaseLabel: 'Уменьшить отступ',\n    increaseLabel: 'Увеличить отступ',\n  },\n  sk: {\n    decreaseLabel: 'Znížiť odsadenie',\n    increaseLabel: 'Zväčšiť odsadenie',\n  },\n  sv: {\n    decreaseLabel: 'Minska indrag',\n    increaseLabel: 'Öka indrag',\n  },\n  th: {\n    decreaseLabel: 'ลดการเยื้อง',\n    increaseLabel: 'เพิ่มการเยื้อง',\n  },\n  tr: {\n    decreaseLabel: 'Girintiyi Azalt',\n    increaseLabel: 'Girintiyi Artır',\n  },\n  uk: {\n    decreaseLabel: 'Зменшити відступ',\n    increaseLabel: 'Збільшити відступ',\n  },\n  vi: {\n    decreaseLabel: 'Giảm lề',\n    increaseLabel: 'Tăng lề',\n  },\n  zh: {\n    decreaseLabel: '减少缩进',\n    increaseLabel: '增加缩进',\n  },\n  'zh-TW': {\n    decreaseLabel: '減少縮排',\n    increaseLabel: '增加縮排',\n  },\n}\n"],"names":["i18n","ar","decreaseLabel","increaseLabel","az","bg","cs","de","en","es","fa","fr","he","hr","hu","it","ja","ko","my","nb","nl","pl","pt","ro","rs","ru","sk","sv","th","tr","uk","vi","zh"],"mappings":";;;AAEO,MAAMA,IAAA,GAAkC;IAC7CC,EAAA,EAAI;QACFC,aAAA,EAAe;QACfC,aAAA,EAAe;IACjB;IACAC,EAAA,EAAI;QACFF,aAAA,EAAe;QACfC,aAAA,EAAe;IACjB;IACAE,EAAA,EAAI;QACFH,aAAA,EAAe;QACfC,aAAA,EAAe;IACjB;IACAG,EAAA,EAAI;QACFJ,aAAA,EAAe;QACfC,aAAA,EAAe;IACjB;IACAI,EAAA,EAAI;QACFL,aAAA,EAAe;QACfC,aAAA,EAAe;IACjB;IACAK,EAAA,EAAI;QACFN,aAAA,EAAe;QACfC,aAAA,EAAe;IACjB;IACAM,EAAA,EAAI;QACFP,aAAA,EAAe;QACfC,aAAA,EAAe;IACjB;IACAO,EAAA,EAAI;QACFR,aAAA,EAAe;QACfC,aAAA,EAAe;IACjB;IACAQ,EAAA,EAAI;QACFT,aAAA,EAAe;QACfC,aAAA,EAAe;IACjB;IACAS,EAAA,EAAI;QACFV,aAAA,EAAe;QACfC,aAAA,EAAe;IACjB;IACAU,EAAA,EAAI;QACFX,aAAA,EAAe;QACfC,aAAA,EAAe;IACjB;IACAW,EAAA,EAAI;QACFZ,aAAA,EAAe;QACfC,aAAA,EAAe;IACjB;IACAY,EAAA,EAAI;QACFb,aAAA,EAAe;QACfC,aAAA,EAAe;IACjB;IACAa,EAAA,EAAI;QACFd,aAAA,EAAe;QACfC,aAAA,EAAe;IACjB;IACAc,EAAA,EAAI;QACFf,aAAA,EAAe;QACfC,aAAA,EAAe;IACjB;IACAe,EAAA,EAAI;QACFhB,aAAA,EAAe;QACfC,aAAA,EAAe;IACjB;IACAgB,EAAA,EAAI;QACFjB,aAAA,EAAe;QACfC,aAAA,EAAe;IACjB;IACAiB,EAAA,EAAI;QACFlB,aAAA,EAAe;QACfC,aAAA,EAAe;IACjB;IACAkB,EAAA,EAAI;QACFnB,aAAA,EAAe;QACfC,aAAA,EAAe;IACjB;IACAmB,EAAA,EAAI;QACFpB,aAAA,EAAe;QACfC,aAAA,EAAe;IACjB;IACAoB,EAAA,EAAI;QACFrB,aAAA,EAAe;QACfC,aAAA,EAAe;IACjB;IACAqB,EAAA,EAAI;QACFtB,aAAA,EAAe;QACfC,aAAA,EAAe;IACjB;IACA,YAAY;QACVD,aAAA,EAAe;QACfC,aAAA,EAAe;IACjB;IACAsB,EAAA,EAAI;QACFvB,aAAA,EAAe;QACfC,aAAA,EAAe;IACjB;IACAuB,EAAA,EAAI;QACFxB,aAAA,EAAe;QACfC,aAAA,EAAe;IACjB;IACAwB,EAAA,EAAI;QACFzB,aAAA,EAAe;QACfC,aAAA,EAAe;IACjB;IACAyB,EAAA,EAAI;QACF1B,aAAA,EAAe;QACfC,aAAA,EAAe;IACjB;IACA0B,EAAA,EAAI;QACF3B,aAAA,EAAe;QACfC,aAAA,EAAe;IACjB;IACA2B,EAAA,EAAI;QACF5B,aAAA,EAAe;QACfC,aAAA,EAAe;IACjB;IACA4B,EAAA,EAAI;QACF7B,aAAA,EAAe;QACfC,aAAA,EAAe;IACjB;IACA6B,EAAA,EAAI;QACF9B,aAAA,EAAe;QACfC,aAAA,EAAe;IACjB;IACA,SAAS;QACPD,aAAA,EAAe;QACfC,aAAA,EAAe;IACjB;AACF"}},
    {"offset": {"line": 1190, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1196, "column": 0}, "map": {"version":3,"file":"index.js","sources":["turbopack://[project]/node_modules/@payloadcms/richtext-lexical/src/features/indent/server/index.ts"],"sourcesContent":["import { createServerFeature } from '../../../utilities/createServerFeature.js'\nimport { i18n } from './i18n.js'\n\nexport const IndentFeature = createServerFeature({\n  feature: {\n    ClientFeature: '@payloadcms/richtext-lexical/client#IndentFeatureClient',\n    i18n,\n  },\n  key: 'indent',\n})\n"],"names":["createServerFeature","i18n","IndentFeature","feature","ClientFeature","key"],"mappings":";;;AAAA,SAASA,mBAAmB,QAAQ;AACpC,SAASC,IAAI,QAAQ;;;AAEd,MAAMC,aAAA,uMAAgBF,sBAAAA,AAAA,EAAoB;IAC/CG,OAAA,EAAS;QACPC,aAAA,EAAe;kNACfH,OAAAA;IACF;IACAI,GAAA,EAAK;AACP"}},
    {"offset": {"line": 1210, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1216, "column": 0}, "map": {"version":3,"file":"i18n.js","sources":["turbopack://[project]/node_modules/@payloadcms/richtext-lexical/src/features/lists/unorderedList/server/i18n.ts"],"sourcesContent":["import type { GenericLanguages } from '@payloadcms/translations'\n\nexport const i18n: Partial<GenericLanguages> = {\n  ar: {\n    label: 'قائمة غير مرتبة',\n  },\n  az: {\n    label: 'Sırasız Siyahı',\n  },\n  bg: {\n    label: 'Неподреден списък',\n  },\n  cs: {\n    label: 'Neuspořádaný seznam',\n  },\n  de: {\n    label: 'Ungeordnete Liste',\n  },\n  en: {\n    label: 'Unordered List',\n  },\n  es: {\n    label: 'Lista desordenada',\n  },\n  fa: {\n    label: 'لیست بدون ترتیب',\n  },\n  fr: {\n    label: 'Liste non ordonnée',\n  },\n  he: {\n    label: 'רשימה לא מסודרת',\n  },\n  hr: {\n    label: 'Neuređeni popis',\n  },\n  hu: {\n    label: 'Rendezetlen lista',\n  },\n  it: {\n    label: 'Elenco non ordinato',\n  },\n  ja: {\n    label: '順不同リスト',\n  },\n  ko: {\n    label: '비정렬 목록',\n  },\n  my: {\n    label: 'Senarai Tidak Tertib',\n  },\n  nb: {\n    label: 'Usortert liste',\n  },\n  nl: {\n    label: 'Ongeordende lijst',\n  },\n  pl: {\n    label: 'Nieuporządkowana lista',\n  },\n  pt: {\n    label: 'Lista Não Ordenada',\n  },\n  ro: {\n    label: 'Listă neordonată',\n  },\n  rs: {\n    label: 'Neporedani spisak',\n  },\n  'rs-latin': {\n    label: 'Neuređena Lista',\n  },\n  ru: {\n    label: 'Несортированный список',\n  },\n  sk: {\n    label: 'Neusporiadaný zoznam',\n  },\n  sv: {\n    label: 'Oordnad lista',\n  },\n  th: {\n    label: 'รายการที่ไม่ได้เรียงลำดับ',\n  },\n  tr: {\n    label: 'Sırasız Liste',\n  },\n  uk: {\n    label: 'Невпорядкований список',\n  },\n  vi: {\n    label: 'Danh sách không theo thứ tự',\n  },\n  zh: {\n    label: '无序列表',\n  },\n  'zh-TW': {\n    label: '無順序列表',\n  },\n}\n"],"names":["i18n","ar","label","az","bg","cs","de","en","es","fa","fr","he","hr","hu","it","ja","ko","my","nb","nl","pl","pt","ro","rs","ru","sk","sv","th","tr","uk","vi","zh"],"mappings":";;;AAEO,MAAMA,IAAA,GAAkC;IAC7CC,EAAA,EAAI;QACFC,KAAA,EAAO;IACT;IACAC,EAAA,EAAI;QACFD,KAAA,EAAO;IACT;IACAE,EAAA,EAAI;QACFF,KAAA,EAAO;IACT;IACAG,EAAA,EAAI;QACFH,KAAA,EAAO;IACT;IACAI,EAAA,EAAI;QACFJ,KAAA,EAAO;IACT;IACAK,EAAA,EAAI;QACFL,KAAA,EAAO;IACT;IACAM,EAAA,EAAI;QACFN,KAAA,EAAO;IACT;IACAO,EAAA,EAAI;QACFP,KAAA,EAAO;IACT;IACAQ,EAAA,EAAI;QACFR,KAAA,EAAO;IACT;IACAS,EAAA,EAAI;QACFT,KAAA,EAAO;IACT;IACAU,EAAA,EAAI;QACFV,KAAA,EAAO;IACT;IACAW,EAAA,EAAI;QACFX,KAAA,EAAO;IACT;IACAY,EAAA,EAAI;QACFZ,KAAA,EAAO;IACT;IACAa,EAAA,EAAI;QACFb,KAAA,EAAO;IACT;IACAc,EAAA,EAAI;QACFd,KAAA,EAAO;IACT;IACAe,EAAA,EAAI;QACFf,KAAA,EAAO;IACT;IACAgB,EAAA,EAAI;QACFhB,KAAA,EAAO;IACT;IACAiB,EAAA,EAAI;QACFjB,KAAA,EAAO;IACT;IACAkB,EAAA,EAAI;QACFlB,KAAA,EAAO;IACT;IACAmB,EAAA,EAAI;QACFnB,KAAA,EAAO;IACT;IACAoB,EAAA,EAAI;QACFpB,KAAA,EAAO;IACT;IACAqB,EAAA,EAAI;QACFrB,KAAA,EAAO;IACT;IACA,YAAY;QACVA,KAAA,EAAO;IACT;IACAsB,EAAA,EAAI;QACFtB,KAAA,EAAO;IACT;IACAuB,EAAA,EAAI;QACFvB,KAAA,EAAO;IACT;IACAwB,EAAA,EAAI;QACFxB,KAAA,EAAO;IACT;IACAyB,EAAA,EAAI;QACFzB,KAAA,EAAO;IACT;IACA0B,EAAA,EAAI;QACF1B,KAAA,EAAO;IACT;IACA2B,EAAA,EAAI;QACF3B,KAAA,EAAO;IACT;IACA4B,EAAA,EAAI;QACF5B,KAAA,EAAO;IACT;IACA6B,EAAA,EAAI;QACF7B,KAAA,EAAO;IACT;IACA,SAAS;QACPA,KAAA,EAAO;IACT;AACF"}},
    {"offset": {"line": 1317, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1323, "column": 0}, "map": {"version":3,"file":"markdown.js","sources":["turbopack://[project]/node_modules/@payloadcms/richtext-lexical/src/features/lists/shared/markdown.ts"],"sourcesContent":["// Copied from https://github.com/facebook/lexical/blob/176b8cf16ecb332ee5efe2c75219e223b7b019f2/packages/lexical-markdown/src/MarkdownTransformers.ts#L97C1-L172C1\n\nimport type { ListNode, ListType } from '@lexical/list'\nimport type { ElementTransformer } from '@lexical/markdown'\nimport type { ElementNode } from 'lexical'\n\nimport { $createListItemNode, $createListNode, $isListItemNode, $isListNode } from '@lexical/list'\n\n// Amount of spaces that define indentation level\nconst LIST_INDENT_SIZE = 4\n\nexport const listReplace = (listType: ListType): ElementTransformer['replace'] => {\n  return (parentNode, children, match) => {\n    const previousNode = parentNode.getPreviousSibling()\n    const nextNode = parentNode.getNextSibling()\n    const listItem = $createListItemNode(listType === 'check' ? match[3] === 'x' : undefined)\n    if ($isListNode(nextNode) && nextNode.getListType() === listType) {\n      const firstChild = nextNode.getFirstChild()\n      if (firstChild !== null) {\n        firstChild.insertBefore(listItem)\n      } else {\n        // should never happen, but let's handle gracefully, just in case.\n        nextNode.append(listItem)\n      }\n      parentNode.remove()\n    } else if ($isListNode(previousNode) && previousNode.getListType() === listType) {\n      previousNode.append(listItem)\n      parentNode.remove()\n    } else {\n      const list = $createListNode(listType, listType === 'number' ? Number(match[2]) : undefined)\n      list.append(listItem)\n      parentNode.replace(list)\n    }\n    listItem.append(...children)\n    listItem.select(0, 0)\n    const indent = Math.floor(match[1].length / LIST_INDENT_SIZE)\n    if (indent) {\n      listItem.setIndent(indent)\n    }\n  }\n}\n\nexport const listExport = (\n  listNode: ListNode,\n  exportChildren: (node: ElementNode) => string,\n  depth: number,\n): string => {\n  const output: string[] = []\n  const children = listNode.getChildren()\n  let index = 0\n  for (const listItemNode of children) {\n    if ($isListItemNode(listItemNode)) {\n      if (listItemNode.getChildrenSize() === 1) {\n        const firstChild = listItemNode.getFirstChild()\n        if ($isListNode(firstChild)) {\n          output.push(listExport(firstChild, exportChildren, depth + 1))\n          continue\n        }\n      }\n      const indent = ' '.repeat(depth * LIST_INDENT_SIZE)\n      const listType = listNode.getListType()\n      const prefix =\n        listType === 'number'\n          ? `${listNode.getStart() + index}. `\n          : listType === 'check'\n            ? `- [${listItemNode.getChecked() ? 'x' : ' '}] `\n            : '- '\n      output.push(indent + prefix + exportChildren(listItemNode))\n      index++\n    }\n  }\n\n  return output.join('\\n')\n}\n"],"names":["$createListItemNode","$createListNode","$isListItemNode","$isListNode","LIST_INDENT_SIZE","listReplace","listType","parentNode","children","match","previousNode","getPreviousSibling","nextNode","getNextSibling","listItem","undefined","getListType","firstChild","getFirstChild","insertBefore","append","remove","list","Number","replace","select","indent","Math","floor","length","setIndent","listExport","listNode","exportChildren","depth","output","getChildren","index","listItemNode","getChildrenSize","push","repeat","prefix","getStart","getChecked","join"],"mappings":"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"}},
    {"offset": {"line": 1384, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1390, "column": 0}, "map": {"version":3,"file":"markdownTransformer.js","sources":["turbopack://[project]/node_modules/@payloadcms/richtext-lexical/src/features/lists/unorderedList/markdownTransformer.ts"],"sourcesContent":["import type { ElementTransformer } from '@lexical/markdown'\n\nimport { $isListNode, ListItemNode, ListNode } from '@lexical/list'\n\nimport { listExport, listReplace } from '../shared/markdown.js'\n\nexport const UNORDERED_LIST: ElementTransformer = {\n  type: 'element',\n  dependencies: [ListNode, ListItemNode],\n  export: (node, exportChildren) => {\n    return $isListNode(node) ? listExport(node, exportChildren, 0) : null\n  },\n  regExp: /^(\\s*)[-*+]\\s/,\n  replace: listReplace('bullet'),\n}\n"],"names":["$isListNode","ListItemNode","ListNode","listExport","listReplace","UNORDERED_LIST","type","dependencies","export","node","exportChildren","regExp","replace"],"mappings":";;;AAEA,SAASA,WAAW,EAAEC,YAAY,EAAEC,QAAQ,QAAQ;AAEpD,SAASC,UAAU,EAAEC,WAAW,QAAQ;;;AAEjC,MAAMC,cAAA,GAAqC;IAChDC,IAAA,EAAM;IACNC,YAAA,EAAc;iKAACL,WAAA;iKAAUD,eAAA;KAAa;IACtCO,MAAA,EAAQA,CAACC,IAAA,EAAMC,cAAA;QACb,oKAAOV,cAAAA,AAAA,EAAYS,IAAA,+MAAQN,aAAAA,AAAA,EAAWM,IAAA,EAAMC,cAAA,EAAgB,KAAK;IACnE;IACAC,MAAA,EAAQ;IACRC,OAAA,6MAASR,cAAAA,AAAA,EAAY;AACvB"}},
    {"offset": {"line": 1409, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1415, "column": 0}, "map": {"version":3,"file":"htmlConverter.js","sources":["turbopack://[project]/node_modules/@payloadcms/richtext-lexical/src/features/lists/htmlConverter.ts"],"sourcesContent":["import { ListItemNode, ListNode } from '@lexical/list'\nimport { v4 as uuidv4 } from 'uuid'\n\nimport type { HTMLConverter } from '../converters/html/converter/types.js'\nimport type { SerializedListItemNode, SerializedListNode } from './plugin/index.js'\n\nimport { convertLexicalNodesToHTML } from '../converters/html/converter/index.js'\n\nexport const ListHTMLConverter: HTMLConverter<SerializedListNode> = {\n  converter: async ({\n    converters,\n    currentDepth,\n    depth,\n    draft,\n    node,\n    overrideAccess,\n    parent,\n    req,\n    showHiddenFields,\n  }) => {\n    const childrenText = await convertLexicalNodesToHTML({\n      converters,\n      currentDepth,\n      depth,\n      draft,\n      lexicalNodes: node.children,\n      overrideAccess,\n      parent: {\n        ...node,\n        parent,\n      },\n      req,\n      showHiddenFields,\n    })\n\n    return `<${node?.tag} class=\"list-${node?.listType}\">${childrenText}</${node?.tag}>`\n  },\n  nodeTypes: [ListNode.getType()],\n}\n\nexport const ListItemHTMLConverter: HTMLConverter<SerializedListItemNode> = {\n  converter: async ({\n    converters,\n    currentDepth,\n    depth,\n    draft,\n    node,\n    overrideAccess,\n    parent,\n    req,\n    showHiddenFields,\n  }) => {\n    const hasSubLists = node.children.some((child) => child.type === 'list')\n\n    const childrenText = await convertLexicalNodesToHTML({\n      converters,\n      currentDepth,\n      depth,\n      draft,\n      lexicalNodes: node.children,\n      overrideAccess,\n      parent: {\n        ...node,\n        parent,\n      },\n      req,\n      showHiddenFields,\n    })\n\n    if ('listType' in parent && parent?.listType === 'check') {\n      const uuid = uuidv4()\n\n      return `<li aria-checked=${node.checked ? 'true' : 'false'} class=\"${\n        'list-item-checkbox' +\n        (node.checked ? ' list-item-checkbox-checked' : ' list-item-checkbox-unchecked') +\n        (hasSubLists ? ' nestedListItem' : '')\n      }\"\n          role=\"checkbox\"\n          tabIndex=${-1}\n          value=${node?.value}\n      >\n      ${\n        hasSubLists\n          ? childrenText\n          : `\n        <input type=\"checkbox\" id=\"${uuid}\"${node.checked ? ' checked' : ''}>\n        <label for=\"${uuid}\">${childrenText}</label><br>\n      `\n      }\n\n\n          </li>`\n    } else {\n      return `<li ${hasSubLists ? `class=\"nestedListItem\" ` : ''}value=${node?.value}>${childrenText}</li>`\n    }\n  },\n  nodeTypes: [ListItemNode.getType()],\n}\n"],"names":["ListItemNode","ListNode","v4","uuidv4","convertLexicalNodesToHTML","ListHTMLConverter","converter","converters","currentDepth","depth","draft","node","overrideAccess","parent","req","showHiddenFields","childrenText","lexicalNodes","children","tag","listType","nodeTypes","getType","ListItemHTMLConverter","hasSubLists","some","child","type","uuid","checked","value"],"mappings":";;;;AAMA,SAASI,yBAAyB,QAAQ;AAN1C,SAASJ,YAAY,EAAEC,QAAQ,QAAQ;AACvC,SAASC,EAAA,IAAMC,MAAM,QAAQ;;;;AAOtB,MAAME,iBAAA,GAAuD;IAClEC,SAAA,EAAW,MAAAA,CAAO,EAChBC,UAAU,EACVC,YAAY,EACZC,KAAK,EACLC,KAAK,EACLC,IAAI,EACJC,cAAc,EACdC,MAAM,EACNC,GAAG,EACHC,gBAAAA,EACD;QACC,MAAMC,YAAA,GAAe,8NAAMZ,4BAAA,AAAAA,EAA0B;YACnDG,UAAA;YACAC,YAAA;YACAC,KAAA;YACAC,KAAA;YACAO,YAAA,EAAcN,IAAA,CAAKO,QAAQ;YAC3BN,cAAA;YACAC,MAAA,EAAQ;gBACN,GAAGF,IAAI;gBACPE;YACF;YACAC,GAAA;YACAC;QACF;QAEA,OAAO,CAAA,CAAA,EAAIJ,IAAA,EAAMQ,GAAA,CAAA,aAAA,EAAmBR,IAAA,EAAMS,QAAA,CAAA,EAAA,EAAaJ,YAAA,CAAA,EAAA,EAAiBL,IAAA,EAAMQ,GAAA,CAAA,CAAA,CAAM;IACtF;IACAE,SAAA,EAAW;gKAACpB,YAAA,CAASqB,OAAO;KAAA;AAC9B;AAEO,MAAMC,qBAAA,GAA+D;IAC1EjB,SAAA,EAAW,MAAAA,CAAO,EAChBC,UAAU,EACVC,YAAY,EACZC,KAAK,EACLC,KAAK,EACLC,IAAI,EACJC,cAAc,EACdC,MAAM,EACNC,GAAG,EACHC,gBAAAA,EACD;QACC,MAAMS,WAAA,GAAcb,IAAA,CAAKO,QAAQ,CAACO,IAAI,EAAEC,KAAA,GAAUA,KAAA,CAAMC,IAAI,KAAK;QAEjE,MAAMX,YAAA,GAAe,8NAAMZ,4BAAAA,AAAA,EAA0B;YACnDG,UAAA;YACAC,YAAA;YACAC,KAAA;YACAC,KAAA;YACAO,YAAA,EAAcN,IAAA,CAAKO,QAAQ;YAC3BN,cAAA;YACAC,MAAA,EAAQ;gBACN,GAAGF,IAAI;gBACPE;YACF;YACAC,GAAA;YACAC;QACF;QAEA,IAAI,cAAcF,MAAA,IAAUA,MAAA,EAAQO,QAAA,KAAa,SAAS;YACxD,MAAMQ,IAAA,0LAAOzB,KAAAA,AAAA;YAEb,OAAO,CAAA,iBAAA,EAAoBQ,IAAA,CAAKkB,OAAO,GAAG,SAAS,QAAA,QAAA,EACjD,uBAAA,CACClB,IAAA,CAAKkB,OAAO,GAAG,gCAAgC,+BAA8B,IAAA,CAC7EL,WAAA,GAAc,oBAAoB,EAAC,EAAA;;qBAGvB,CAAC,EAAA;kBACJb,IAAA,EAAMmB,KAAA,CAAA;;QAGhBN,WAAA,GACIR,YAAA,GACA,CAAA;qCACyBY,IAAA,CAAA,CAAA,EAAQjB,IAAA,CAAKkB,OAAO,GAAG,aAAa,GAAA;sBACnDD,IAAA,CAAA,EAAA,EAASZ,YAAA,CAAA;OACxB,CAAA;;;gBAIS;QACZ,OAAO;YACL,OAAO,CAAA,IAAA,EAAOQ,WAAA,GAAc,CAAA,uBAAA,CAAyB,GAAG,GAAA,MAAA,EAAWb,IAAA,EAAMmB,KAAA,CAAA,CAAA,EAASd,YAAA,CAAA,KAAA,CAAmB;QACvG;IACF;IACAK,SAAA,EAAW;iKAACrB,eAAA,CAAasB,OAAO;KAAA;AAClC"}},
    {"offset": {"line": 1486, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1492, "column": 0}, "map": {"version":3,"file":"index.js","sources":["turbopack://[project]/node_modules/@payloadcms/richtext-lexical/src/features/lists/unorderedList/server/index.ts"],"sourcesContent":["import { ListItemNode, ListNode } from '@lexical/list'\n\nimport { createServerFeature } from '../../../../utilities/createServerFeature.js'\nimport { createNode } from '../../../typeUtilities.js'\nimport { ListHTMLConverter, ListItemHTMLConverter } from '../../htmlConverter.js'\nimport { UNORDERED_LIST } from '../markdownTransformer.js'\nimport { i18n } from './i18n.js'\n\nexport const UnorderedListFeature = createServerFeature({\n  feature: {\n    ClientFeature: '@payloadcms/richtext-lexical/client#UnorderedListFeatureClient',\n    i18n,\n    markdownTransformers: [UNORDERED_LIST],\n    nodes: [\n      createNode({\n        converters: {\n          html: ListHTMLConverter,\n        },\n        node: ListNode,\n      }),\n      createNode({\n        converters: {\n          html: ListItemHTMLConverter as any,\n        },\n        node: ListItemNode,\n      }),\n    ],\n  },\n  key: 'unorderedList',\n})\n"],"names":["ListItemNode","ListNode","createServerFeature","createNode","ListHTMLConverter","ListItemHTMLConverter","UNORDERED_LIST","i18n","UnorderedListFeature","feature","ClientFeature","markdownTransformers","nodes","converters","html","node","key"],"mappings":";;;AAEA,SAASE,mBAAmB,QAAQ;AAIpC,SAASK,IAAI,QAAQ;AADrB,SAASD,cAAc,QAAQ;AAF/B,SAASH,UAAU,QAAQ;AAC3B,SAASC,iBAAiB,EAAEC,qBAAqB,QAAQ;AAJzD,SAASL,YAAY,EAAEC,QAAQ,QAAQ;;;;;;;AAQhC,MAAMO,oBAAA,uMAAuBN,sBAAAA,AAAA,EAAoB;IACtDO,OAAA,EAAS;QACPC,aAAA,EAAe;QACfH,iOAAA;QACAI,oBAAA,EAAsB;qOAACL,iBAAA;SAAe;QACtCM,KAAA,EAAO;yMACLT,aAAAA,AAAA,EAAW;gBACTU,UAAA,EAAY;oBACVC,IAAA,EAAMV,sNAAAA;gBACR;gBACAW,IAAA,2JAAMd,WAAAA;YACR;yMACAE,aAAAA,AAAA,EAAW;gBACTU,UAAA,EAAY;oBACVC,IAAA,oMAAMT,wBAAAA;gBACR;gBACAU,IAAA,2JAAMf,eAAAA;YACR;SAAA;IAEJ;IACAgB,GAAA,EAAK;AACP"}},
    {"offset": {"line": 1531, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1537, "column": 0}, "map": {"version":3,"file":"i18n.js","sources":["turbopack://[project]/node_modules/@payloadcms/richtext-lexical/src/features/lists/orderedList/server/i18n.ts"],"sourcesContent":["import type { GenericLanguages } from '@payloadcms/translations'\n\nexport const i18n: Partial<GenericLanguages> = {\n  ar: {\n    label: 'قائمة مرتبة',\n  },\n  az: {\n    label: 'Sıralı Siyahı',\n  },\n  bg: {\n    label: 'Подреден списък',\n  },\n  cs: {\n    label: 'Seřazený seznam',\n  },\n  de: {\n    label: 'Geordnete Liste',\n  },\n  en: {\n    label: 'Ordered List',\n  },\n  es: {\n    label: 'Lista ordenada',\n  },\n  fa: {\n    label: 'لیست مرتب شده',\n  },\n  fr: {\n    label: 'Liste ordonnée',\n  },\n  he: {\n    label: 'רשימה ממוינת',\n  },\n  hr: {\n    label: 'Naručeni popis',\n  },\n  hu: {\n    label: 'Rendelt lista',\n  },\n  it: {\n    label: 'Elenco ordinato',\n  },\n  ja: {\n    label: '順序付きリスト',\n  },\n  ko: {\n    label: '주문된 목록',\n  },\n  my: {\n    label: 'စီစဉ်ထားသော စာရင်း',\n  },\n  nb: {\n    label: 'Ordnet Liste',\n  },\n  nl: {\n    label: 'Geordende Lijst',\n  },\n  pl: {\n    label: 'Uporządkowana lista',\n  },\n  pt: {\n    label: 'Lista Ordenada',\n  },\n  ro: {\n    label: 'Lista ordonată',\n  },\n  rs: {\n    label: 'Naručeni Spisak',\n  },\n  'rs-latin': {\n    label: 'Naručeni spisak',\n  },\n  ru: {\n    label: 'Упорядоченный список',\n  },\n  sk: {\n    label: 'Zoradený zoznam',\n  },\n  sv: {\n    label: 'Ordnad Lista',\n  },\n  th: {\n    label: 'รายการที่ถูกจัดลำดับ',\n  },\n  tr: {\n    label: 'Sıralı Liste',\n  },\n  uk: {\n    label: 'Впорядкований список',\n  },\n  vi: {\n    label: 'Danh sách đã sắp xếp',\n  },\n  zh: {\n    label: '有序列表',\n  },\n  'zh-TW': {\n    label: '有序列表',\n  },\n}\n"],"names":["i18n","ar","label","az","bg","cs","de","en","es","fa","fr","he","hr","hu","it","ja","ko","my","nb","nl","pl","pt","ro","rs","ru","sk","sv","th","tr","uk","vi","zh"],"mappings":";;;AAEO,MAAMA,IAAA,GAAkC;IAC7CC,EAAA,EAAI;QACFC,KAAA,EAAO;IACT;IACAC,EAAA,EAAI;QACFD,KAAA,EAAO;IACT;IACAE,EAAA,EAAI;QACFF,KAAA,EAAO;IACT;IACAG,EAAA,EAAI;QACFH,KAAA,EAAO;IACT;IACAI,EAAA,EAAI;QACFJ,KAAA,EAAO;IACT;IACAK,EAAA,EAAI;QACFL,KAAA,EAAO;IACT;IACAM,EAAA,EAAI;QACFN,KAAA,EAAO;IACT;IACAO,EAAA,EAAI;QACFP,KAAA,EAAO;IACT;IACAQ,EAAA,EAAI;QACFR,KAAA,EAAO;IACT;IACAS,EAAA,EAAI;QACFT,KAAA,EAAO;IACT;IACAU,EAAA,EAAI;QACFV,KAAA,EAAO;IACT;IACAW,EAAA,EAAI;QACFX,KAAA,EAAO;IACT;IACAY,EAAA,EAAI;QACFZ,KAAA,EAAO;IACT;IACAa,EAAA,EAAI;QACFb,KAAA,EAAO;IACT;IACAc,EAAA,EAAI;QACFd,KAAA,EAAO;IACT;IACAe,EAAA,EAAI;QACFf,KAAA,EAAO;IACT;IACAgB,EAAA,EAAI;QACFhB,KAAA,EAAO;IACT;IACAiB,EAAA,EAAI;QACFjB,KAAA,EAAO;IACT;IACAkB,EAAA,EAAI;QACFlB,KAAA,EAAO;IACT;IACAmB,EAAA,EAAI;QACFnB,KAAA,EAAO;IACT;IACAoB,EAAA,EAAI;QACFpB,KAAA,EAAO;IACT;IACAqB,EAAA,EAAI;QACFrB,KAAA,EAAO;IACT;IACA,YAAY;QACVA,KAAA,EAAO;IACT;IACAsB,EAAA,EAAI;QACFtB,KAAA,EAAO;IACT;IACAuB,EAAA,EAAI;QACFvB,KAAA,EAAO;IACT;IACAwB,EAAA,EAAI;QACFxB,KAAA,EAAO;IACT;IACAyB,EAAA,EAAI;QACFzB,KAAA,EAAO;IACT;IACA0B,EAAA,EAAI;QACF1B,KAAA,EAAO;IACT;IACA2B,EAAA,EAAI;QACF3B,KAAA,EAAO;IACT;IACA4B,EAAA,EAAI;QACF5B,KAAA,EAAO;IACT;IACA6B,EAAA,EAAI;QACF7B,KAAA,EAAO;IACT;IACA,SAAS;QACPA,KAAA,EAAO;IACT;AACF"}},
    {"offset": {"line": 1638, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1644, "column": 0}, "map": {"version":3,"file":"markdownTransformer.js","sources":["turbopack://[project]/node_modules/@payloadcms/richtext-lexical/src/features/lists/orderedList/markdownTransformer.ts"],"sourcesContent":["import type { ElementTransformer } from '@lexical/markdown'\n\nimport { $isListNode, ListItemNode, ListNode } from '@lexical/list'\n\nimport { listExport, listReplace } from '../shared/markdown.js'\n\nexport const ORDERED_LIST: ElementTransformer = {\n  type: 'element',\n  dependencies: [ListNode, ListItemNode],\n  export: (node, exportChildren) => {\n    return $isListNode(node) ? listExport(node, exportChildren, 0) : null\n  },\n  regExp: /^(\\s*)(\\d+)\\.\\s/,\n  replace: listReplace('number'),\n}\n"],"names":["$isListNode","ListItemNode","ListNode","listExport","listReplace","ORDERED_LIST","type","dependencies","export","node","exportChildren","regExp","replace"],"mappings":";;;AAEA,SAASA,WAAW,EAAEC,YAAY,EAAEC,QAAQ,QAAQ;AAEpD,SAASC,UAAU,EAAEC,WAAW,QAAQ;;;AAEjC,MAAMC,YAAA,GAAmC;IAC9CC,IAAA,EAAM;IACNC,YAAA,EAAc;iKAACL,WAAA;iKAAUD,eAAA;KAAa;IACtCO,MAAA,EAAQA,CAACC,IAAA,EAAMC,cAAA;QACb,oKAAOV,cAAAA,AAAA,EAAYS,IAAA,+MAAQN,aAAAA,AAAA,EAAWM,IAAA,EAAMC,cAAA,EAAgB,KAAK;IACnE;IACAC,MAAA,EAAQ;IACRC,OAAA,6MAASR,cAAAA,AAAA,EAAY;AACvB"}},
    {"offset": {"line": 1663, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1669, "column": 0}, "map": {"version":3,"file":"index.js","sources":["turbopack://[project]/node_modules/@payloadcms/richtext-lexical/src/features/lists/orderedList/server/index.ts"],"sourcesContent":["import { ListItemNode, ListNode } from '@lexical/list'\n\nimport { createServerFeature } from '../../../../utilities/createServerFeature.js'\nimport { createNode } from '../../../typeUtilities.js'\nimport { ListHTMLConverter, ListItemHTMLConverter } from '../../htmlConverter.js'\nimport { ORDERED_LIST } from '../markdownTransformer.js'\nimport { i18n } from './i18n.js'\n\nexport const OrderedListFeature = createServerFeature({\n  feature: ({ featureProviderMap }) => {\n    return {\n      ClientFeature: '@payloadcms/richtext-lexical/client#OrderedListFeatureClient',\n      i18n,\n      markdownTransformers: [ORDERED_LIST],\n      nodes: featureProviderMap.has('unorderedList')\n        ? []\n        : [\n            createNode({\n              converters: {\n                html: ListHTMLConverter,\n              },\n              node: ListNode,\n            }),\n            createNode({\n              converters: {\n                html: ListItemHTMLConverter as any,\n              },\n              node: ListItemNode,\n            }),\n          ],\n    }\n  },\n  key: 'orderedList',\n})\n"],"names":["ListItemNode","ListNode","createServerFeature","createNode","ListHTMLConverter","ListItemHTMLConverter","ORDERED_LIST","i18n","OrderedListFeature","feature","featureProviderMap","ClientFeature","markdownTransformers","nodes","has","converters","html","node","key"],"mappings":";;;AAEA,SAASE,mBAAmB,QAAQ;AAIpC,SAASK,IAAI,QAAQ;AADrB,SAASD,YAAY,QAAQ;AAF7B,SAASH,UAAU,QAAQ;AAC3B,SAASC,iBAAiB,EAAEC,qBAAqB,QAAQ;AAJzD,SAASL,YAAY,EAAEC,QAAQ,QAAQ;;;;;;;AAQhC,MAAMO,kBAAA,uMAAqBN,sBAAAA,AAAA,EAAoB;IACpDO,OAAA,EAASA,CAAC,EAAEC,kBAAAA,EAAoB;QAC9B,OAAO;YACLC,aAAA,EAAe;YACfJ,+NAAA;YACAK,oBAAA,EAAsB;uOAACN,eAAA;aAAa;YACpCO,KAAA,EAAOH,kBAAA,CAAmBI,GAAG,CAAC,mBAC1B,EAAE,GACF;6MACEX,aAAAA,AAAA,EAAW;oBACTY,UAAA,EAAY;wBACVC,IAAA,oMAAMZ,oBAAAA;oBACR;oBACAa,IAAA,2JAAMhB,WAAAA;gBACR;gBACAE,0MAAAA,AAAA,EAAW;oBACTY,UAAA,EAAY;wBACVC,IAAA,oMAAMX,wBAAAA;oBACR;oBACAY,IAAA,2JAAMjB,eAAAA;gBACR;aAAA;QAER;IACF;IACAkB,GAAA,EAAK;AACP"}},
    {"offset": {"line": 1710, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1716, "column": 0}, "map": {"version":3,"file":"i18n.js","sources":["turbopack://[project]/node_modules/@payloadcms/richtext-lexical/src/features/lists/checklist/server/i18n.ts"],"sourcesContent":["import type { GenericLanguages } from '@payloadcms/translations'\n\nexport const i18n: Partial<GenericLanguages> = {\n  ar: {\n    label: 'قائمة التحقق',\n  },\n  az: {\n    label: 'Yoxlama Siyahısı',\n  },\n  bg: {\n    label: 'Списък за проверка',\n  },\n  cs: {\n    label: 'Seznam kontrol',\n  },\n  de: {\n    label: 'Checkliste',\n  },\n  en: {\n    label: 'Check List',\n  },\n  es: {\n    label: 'Lista de comprobación',\n  },\n  fa: {\n    label: 'لیست بررسی',\n  },\n  fr: {\n    label: 'Liste de contrôle',\n  },\n  he: {\n    label: 'רשימת בדיקה',\n  },\n  hr: {\n    label: 'Kontrolni popis',\n  },\n  hu: {\n    label: 'Ellenőrzőlista',\n  },\n  it: {\n    label: 'Lista di controllo',\n  },\n  ja: {\n    label: 'チェックリスト',\n  },\n  ko: {\n    label: '체크 리스트',\n  },\n  my: {\n    label: 'Senarai Semak',\n  },\n  nb: {\n    label: 'Sjekkliste',\n  },\n  nl: {\n    label: 'Checklist',\n  },\n  pl: {\n    label: 'Lista kontrolna',\n  },\n  pt: {\n    label: 'Lista de Verificação',\n  },\n  ro: {\n    label: 'Listă de verificare',\n  },\n  rs: {\n    label: 'Lista provere',\n  },\n  'rs-latin': {\n    label: 'Lista provere',\n  },\n  ru: {\n    label: 'Список Проверки',\n  },\n  sk: {\n    label: 'Kontrolný zoznam',\n  },\n  sv: {\n    label: 'Kontrollista',\n  },\n  th: {\n    label: 'รายการตรวจสอบ',\n  },\n  tr: {\n    label: 'Kontrol Listesi',\n  },\n  uk: {\n    label: 'Список перевірки',\n  },\n  vi: {\n    label: 'Danh sách kiểm tra',\n  },\n  zh: {\n    label: '检查清单',\n  },\n  'zh-TW': {\n    label: '檢查清單',\n  },\n}\n"],"names":["i18n","ar","label","az","bg","cs","de","en","es","fa","fr","he","hr","hu","it","ja","ko","my","nb","nl","pl","pt","ro","rs","ru","sk","sv","th","tr","uk","vi","zh"],"mappings":";;;AAEO,MAAMA,IAAA,GAAkC;IAC7CC,EAAA,EAAI;QACFC,KAAA,EAAO;IACT;IACAC,EAAA,EAAI;QACFD,KAAA,EAAO;IACT;IACAE,EAAA,EAAI;QACFF,KAAA,EAAO;IACT;IACAG,EAAA,EAAI;QACFH,KAAA,EAAO;IACT;IACAI,EAAA,EAAI;QACFJ,KAAA,EAAO;IACT;IACAK,EAAA,EAAI;QACFL,KAAA,EAAO;IACT;IACAM,EAAA,EAAI;QACFN,KAAA,EAAO;IACT;IACAO,EAAA,EAAI;QACFP,KAAA,EAAO;IACT;IACAQ,EAAA,EAAI;QACFR,KAAA,EAAO;IACT;IACAS,EAAA,EAAI;QACFT,KAAA,EAAO;IACT;IACAU,EAAA,EAAI;QACFV,KAAA,EAAO;IACT;IACAW,EAAA,EAAI;QACFX,KAAA,EAAO;IACT;IACAY,EAAA,EAAI;QACFZ,KAAA,EAAO;IACT;IACAa,EAAA,EAAI;QACFb,KAAA,EAAO;IACT;IACAc,EAAA,EAAI;QACFd,KAAA,EAAO;IACT;IACAe,EAAA,EAAI;QACFf,KAAA,EAAO;IACT;IACAgB,EAAA,EAAI;QACFhB,KAAA,EAAO;IACT;IACAiB,EAAA,EAAI;QACFjB,KAAA,EAAO;IACT;IACAkB,EAAA,EAAI;QACFlB,KAAA,EAAO;IACT;IACAmB,EAAA,EAAI;QACFnB,KAAA,EAAO;IACT;IACAoB,EAAA,EAAI;QACFpB,KAAA,EAAO;IACT;IACAqB,EAAA,EAAI;QACFrB,KAAA,EAAO;IACT;IACA,YAAY;QACVA,KAAA,EAAO;IACT;IACAsB,EAAA,EAAI;QACFtB,KAAA,EAAO;IACT;IACAuB,EAAA,EAAI;QACFvB,KAAA,EAAO;IACT;IACAwB,EAAA,EAAI;QACFxB,KAAA,EAAO;IACT;IACAyB,EAAA,EAAI;QACFzB,KAAA,EAAO;IACT;IACA0B,EAAA,EAAI;QACF1B,KAAA,EAAO;IACT;IACA2B,EAAA,EAAI;QACF3B,KAAA,EAAO;IACT;IACA4B,EAAA,EAAI;QACF5B,KAAA,EAAO;IACT;IACA6B,EAAA,EAAI;QACF7B,KAAA,EAAO;IACT;IACA,SAAS;QACPA,KAAA,EAAO;IACT;AACF"}},
    {"offset": {"line": 1817, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1823, "column": 0}, "map": {"version":3,"file":"markdownTransformers.js","sources":["turbopack://[project]/node_modules/@payloadcms/richtext-lexical/src/features/lists/checklist/markdownTransformers.ts"],"sourcesContent":["import type { ElementTransformer } from '@lexical/markdown'\n\nimport { $isListNode, ListItemNode, ListNode } from '@lexical/list'\n\nimport { listExport, listReplace } from '../shared/markdown.js'\n\nexport const CHECK_LIST: ElementTransformer = {\n  type: 'element',\n  dependencies: [ListNode, ListItemNode],\n  export: (node, exportChildren) => {\n    return $isListNode(node) ? listExport(node, exportChildren, 0) : null\n  },\n  regExp: /^(\\s*)(?:-\\s)?\\s?(\\[(\\s|x)?\\])\\s/i,\n  replace: listReplace('check'),\n}\n"],"names":["$isListNode","ListItemNode","ListNode","listExport","listReplace","CHECK_LIST","type","dependencies","export","node","exportChildren","regExp","replace"],"mappings":";;;AAEA,SAASA,WAAW,EAAEC,YAAY,EAAEC,QAAQ,QAAQ;AAEpD,SAASC,UAAU,EAAEC,WAAW,QAAQ;;;AAEjC,MAAMC,UAAA,GAAiC;IAC5CC,IAAA,EAAM;IACNC,YAAA,EAAc;iKAACL,WAAA;iKAAUD,eAAA;KAAa;IACtCO,MAAA,EAAQA,CAACC,IAAA,EAAMC,cAAA;QACb,oKAAOV,cAAAA,AAAA,EAAYS,IAAA,+MAAQN,aAAAA,AAAA,EAAWM,IAAA,EAAMC,cAAA,EAAgB,KAAK;IACnE;IACAC,MAAA,EAAQ;IACRC,OAAA,6MAASR,cAAAA,AAAA,EAAY;AACvB"}},
    {"offset": {"line": 1842, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1848, "column": 0}, "map": {"version":3,"file":"index.js","sources":["turbopack://[project]/node_modules/@payloadcms/richtext-lexical/src/features/lists/checklist/server/index.ts"],"sourcesContent":["import { ListItemNode, ListNode } from '@lexical/list'\n\nimport { createServerFeature } from '../../../../utilities/createServerFeature.js'\nimport { createNode } from '../../../typeUtilities.js'\nimport { ListHTMLConverter, ListItemHTMLConverter } from '../../htmlConverter.js'\nimport { CHECK_LIST } from '../markdownTransformers.js'\nimport { i18n } from './i18n.js'\n\nexport const ChecklistFeature = createServerFeature({\n  feature: ({ featureProviderMap }) => {\n    return {\n      ClientFeature: '@payloadcms/richtext-lexical/client#ChecklistFeatureClient',\n      i18n,\n      markdownTransformers: [CHECK_LIST],\n      nodes:\n        featureProviderMap.has('unorderedList') || featureProviderMap.has('orderedList')\n          ? []\n          : [\n              createNode({\n                converters: {\n                  html: ListHTMLConverter,\n                },\n                node: ListNode,\n              }),\n              createNode({\n                converters: {\n                  html: ListItemHTMLConverter as any,\n                },\n                node: ListItemNode,\n              }),\n            ],\n    }\n  },\n  key: 'checklist',\n})\n"],"names":["ListItemNode","ListNode","createServerFeature","createNode","ListHTMLConverter","ListItemHTMLConverter","CHECK_LIST","i18n","ChecklistFeature","feature","featureProviderMap","ClientFeature","markdownTransformers","nodes","has","converters","html","node","key"],"mappings":";;;AAEA,SAASE,mBAAmB,QAAQ;AAIpC,SAASK,IAAI,QAAQ;AADrB,SAASD,UAAU,QAAQ;AAF3B,SAASH,UAAU,QAAQ;AAC3B,SAASC,iBAAiB,EAAEC,qBAAqB,QAAQ;AAJzD,SAASL,YAAY,EAAEC,QAAQ,QAAQ;;;;;;;AAQhC,MAAMO,gBAAA,uMAAmBN,sBAAAA,AAAA,EAAoB;IAClDO,OAAA,EAASA,CAAC,EAAEC,kBAAAA,EAAoB;QAC9B,OAAO;YACLC,aAAA,EAAe;YACfJ,6NAAA;YACAK,oBAAA,EAAsB;sOAACN,aAAA;aAAW;YAClCO,KAAA,EACEH,kBAAA,CAAmBI,GAAG,CAAC,oBAAoBJ,kBAAA,CAAmBI,GAAG,CAAC,iBAC9D,EAAE,GACF;iBACEX,yMAAAA,AAAA,EAAW;oBACTY,UAAA,EAAY;wBACVC,IAAA,oMAAMZ,oBAAAA;oBACR;oBACAa,IAAA,2JAAMhB,WAAAA;gBACR;6MACAE,aAAAA,AAAA,EAAW;oBACTY,UAAA,EAAY;wBACVC,IAAA,oMAAMX,wBAAAA;oBACR;oBACAY,IAAA,2JAAMjB,eAAAA;gBACR;aAAA;QAEV;IACF;IACAkB,GAAA,EAAK;AACP"}},
    {"offset": {"line": 1889, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1895, "column": 0}, "map": {"version":3,"file":"url.js","sources":["turbopack://[project]/node_modules/@payloadcms/richtext-lexical/src/lexical/utils/url.ts"],"sourcesContent":["export function sanitizeUrl(url: string): string {\n  /** A pattern that matches safe  URLs. */\n  const SAFE_URL_PATTERN = /^(?:(?:https?|mailto|ftp|tel|file|sms):|[^&:/?#]*(?:[/?#]|$))/gi\n\n  /** A pattern that matches safe data URLs. */\n  const DATA_URL_PATTERN =\n    /^data:(?:image\\/(?:bmp|gif|jpeg|jpg|png|tiff|webp)|video\\/(?:mpeg|mp4|ogg|webm)|audio\\/(?:mp3|oga|ogg|opus));base64,[a-z\\d+/]+=*$/i\n\n  url = String(url).trim()\n\n  if (url.match(SAFE_URL_PATTERN) != null || url.match(DATA_URL_PATTERN) != null) {\n    return url\n  }\n\n  return 'https://'\n}\n\n// Source: https://stackoverflow.com/a/8234912/2013580\nconst absoluteRegExp =\n  /(?:[A-Za-z]{3,9}:(?:\\/\\/)?(?:[-;:&=+$,\\w]+@)?[A-Za-z\\d.-]+|(?:www.|[-;:&=+$,\\w]+@)[A-Za-z\\d.-]+)(?:\\/[+~%/.\\w-]*)?\\??[-+=&;%@.\\w]*#?\\w*/\n\n/**\n * This regex checks for relative URLs starting with / or anchor links starting with # in a string. Tested for the following use cases:\n * - /privacy-policy\n * - /privacy-policy#primary-terms\n * - #primary-terms\n *  */\nconst relativeOrAnchorRegExp = /^[\\w\\-./]*(?:#\\w[\\w-]*)?$/\n\n/**\n * Prevents unreasonable URLs from being inserted into the editor.\n * @param url\n */\nexport function validateUrlMinimal(url: string): boolean {\n  if (!url) {\n    return false\n  }\n\n  return !url.includes(' ')\n}\n\n// Do not keep validateUrl function too loose. This is run when pasting in text, to determine if links are in that text and if it should create AutoLinkNodes.\n// This is why we do not allow stuff like anchors here, as we don't want copied anchors to be turned into AutoLinkNodes.\nexport function validateUrl(url: string): boolean {\n  // TODO Fix UI for link insertion; it should never default to an invalid URL such as https://.\n  // Maybe show a dialog where they user can type the URL before inserting it.\n\n  if (!url) {\n    return false\n  }\n\n  if (url === 'https://') {\n    return true\n  }\n\n  // This makes sure URLs starting with www. instead of https are valid too\n  if (absoluteRegExp.test(url)) {\n    return true\n  }\n\n  // Check relative or anchor links\n  if (relativeOrAnchorRegExp.test(url)) {\n    return true\n  }\n\n  // While this doesn't allow URLs starting with www (which is why we use the regex above), it does properly handle tel: URLs\n  try {\n    new URL(url)\n    return true\n  } catch {\n    /* empty */\n  }\n\n  return false\n}\n"],"names":["sanitizeUrl","url","SAFE_URL_PATTERN","DATA_URL_PATTERN","String","trim","match","absoluteRegExp","relativeOrAnchorRegExp","validateUrlMinimal","includes","validateUrl","test","URL"],"mappings":";;;;;AAAO,SAASA,YAAYC,GAAW;IACrC,uCAAA,GACA,MAAMC,gBAAA,GAAmB;IAEzB,2CAAA,GACA,MAAMC,gBAAA,GACJ;IAEFF,GAAA,GAAMG,MAAA,CAAOH,GAAA,EAAKI,IAAI;IAEtB,IAAIJ,GAAA,CAAIK,KAAK,CAACJ,gBAAA,KAAqB,QAAQD,GAAA,CAAIK,KAAK,CAACH,gBAAA,KAAqB,MAAM;QAC9E,OAAOF,GAAA;IACT;IAEA,OAAO;AACT;AAEA,sDAAA;AACA,MAAMM,cAAA,GACJ;AAEF;;;;;OAMA,MAAMC,sBAAA,GAAyB;AAMxB,SAASC,mBAAmBR,GAAW;IAC5C,IAAI,CAACA,GAAA,EAAK;QACR,OAAO;IACT;IAEA,OAAO,CAACA,GAAA,CAAIS,QAAQ,CAAC;AACvB;AAIO,SAASC,YAAYV,GAAW;IACrC,8FAAA;IACA,4EAAA;IAEA,IAAI,CAACA,GAAA,EAAK;QACR,OAAO;IACT;IAEA,IAAIA,GAAA,KAAQ,YAAY;QACtB,OAAO;IACT;IAEA,yEAAA;IACA,IAAIM,cAAA,CAAeK,IAAI,CAACX,GAAA,GAAM;QAC5B,OAAO;IACT;IAEA,iCAAA;IACA,IAAIO,sBAAA,CAAuBI,IAAI,CAACX,GAAA,GAAM;QACpC,OAAO;IACT;IAEA,2HAAA;IACA,IAAI;QACF,IAAIY,GAAA,CAAIZ,GAAA;QACR,OAAO;IACT,EAAE,OAAM;IACN,SAAA,GAAA;IAGF,OAAO;AACT"}},
    {"offset": {"line": 1948, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1954, "column": 0}, "map": {"version":3,"file":"baseFields.js","sources":["turbopack://[project]/node_modules/@payloadcms/richtext-lexical/src/features/link/server/baseFields.ts"],"sourcesContent":["import type {\n  CollectionSlug,\n  FieldAffectingData,\n  RadioField,\n  SanitizedConfig,\n  TextField,\n  User,\n} from 'payload'\n\nimport { validateUrl, validateUrlMinimal } from '../../../lexical/utils/url.js'\n\nexport const getBaseFields = (\n  config: SanitizedConfig,\n  enabledCollections?: CollectionSlug[],\n  disabledCollections?: CollectionSlug[],\n  maxDepth?: number,\n): FieldAffectingData[] => {\n  let enabledRelations: CollectionSlug[]\n\n  /**\n   * Figure out which relations should be enabled (enabledRelations) based on a collection's admin.enableRichTextLink property,\n   * or the Link Feature's enabledCollections and disabledCollections properties which override it.\n   */\n  if (enabledCollections) {\n    enabledRelations = enabledCollections\n  } else if (disabledCollections) {\n    enabledRelations = config.collections\n      .filter(({ slug }) => !disabledCollections.includes(slug))\n      .map(({ slug }) => slug)\n  } else {\n    enabledRelations = config.collections\n      .filter(({ admin: { enableRichTextLink, hidden } }) => {\n        if (typeof hidden !== 'function' && hidden) {\n          return false\n        }\n        return enableRichTextLink\n      })\n      .map(({ slug }) => slug)\n  }\n\n  const baseFields: FieldAffectingData[] = [\n    {\n      name: 'text',\n      type: 'text',\n      label: ({ t }) => t('fields:textToDisplay'),\n      required: true,\n    },\n    {\n      name: 'linkType',\n      type: 'radio',\n      admin: {\n        description: ({ t }) => t('fields:chooseBetweenCustomTextOrDocument'),\n      },\n      defaultValue: 'custom',\n      label: ({ t }) => t('fields:linkType'),\n      options: [\n        {\n          label: ({ t }) => t('fields:customURL'),\n          value: 'custom',\n        },\n      ],\n      required: true,\n    } as RadioField,\n    {\n      name: 'url',\n      type: 'text',\n      hooks: {\n        beforeChange: [\n          ({ value }) => {\n            if (!validateUrl(value)) {\n              return encodeURIComponent(value)\n            }\n            return value\n          },\n        ],\n      },\n      label: ({ t }) => t('fields:enterURL'),\n      required: true,\n      // @ts-expect-error - TODO: fix this\n      validate: (value: string) => {\n        if (!validateUrlMinimal(value)) {\n          return 'Invalid URL'\n        }\n      },\n    },\n  ]\n\n  // Only display internal link-specific fields / options / conditions if there are enabled relations\n  if (enabledRelations?.length) {\n    ;(baseFields[1] as RadioField).options.push({\n      label: ({ t }) => t('fields:internalLink'),\n      value: 'internal',\n    })\n    ;(baseFields[2] as TextField).admin = {\n      condition: ({ linkType }) => linkType !== 'internal',\n    }\n\n    baseFields.push({\n      name: 'doc',\n      admin: {\n        condition: ({ linkType }) => {\n          return linkType === 'internal'\n        },\n      },\n      // when admin.hidden is a function we need to dynamically call hidden with the user to know if the collection should be shown\n      type: 'relationship',\n      filterOptions:\n        !enabledCollections && !disabledCollections\n          ? ({ relationTo, user }) => {\n              const hidden = config.collections.find(({ slug }) => slug === relationTo)?.admin\n                .hidden\n              if (typeof hidden === 'function' && hidden({ user } as { user: User })) {\n                return false\n              }\n              return true\n            }\n          : null,\n      label: ({ t }) => t('fields:chooseDocumentToLink'),\n      maxDepth,\n      relationTo: enabledRelations,\n      required: true,\n    })\n  }\n\n  baseFields.push({\n    name: 'newTab',\n    type: 'checkbox',\n    label: ({ t }) => t('fields:openInNewTab'),\n  })\n\n  return baseFields\n}\n"],"names":["validateUrl","validateUrlMinimal","getBaseFields","config","enabledCollections","disabledCollections","maxDepth","enabledRelations","collections","filter","slug","includes","map","admin","enableRichTextLink","hidden","baseFields","name","type","label","t","required","description","defaultValue","options","value","hooks","beforeChange","encodeURIComponent","validate","length","push","condition","linkType","filterOptions","relationTo","user","find"],"mappings":"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"}},
    {"offset": {"line": 2062, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2068, "column": 0}, "map": {"version":3,"file":"transformExtraFields.js","sources":["turbopack://[project]/node_modules/@payloadcms/richtext-lexical/src/features/link/server/transformExtraFields.ts"],"sourcesContent":["import type { CollectionSlug, Field, FieldAffectingData, SanitizedConfig } from 'payload'\n\nimport { getBaseFields } from './baseFields.js'\n\n/**\n * This function is run to enrich the basefields which every link has with potential, custom user-added fields.\n */\nexport function transformExtraFields(\n  customFieldSchema:\n    | ((args: {\n        config: SanitizedConfig\n        defaultFields: FieldAffectingData[]\n      }) => (Field | FieldAffectingData)[])\n    | Field[]\n    | null,\n  config: SanitizedConfig,\n  enabledCollections?: CollectionSlug[],\n  disabledCollections?: CollectionSlug[],\n  maxDepth?: number,\n): Field[] {\n  const baseFields: FieldAffectingData[] = getBaseFields(\n    config,\n    enabledCollections,\n    disabledCollections,\n    maxDepth,\n  )\n\n  let fields: (Field | FieldAffectingData)[]\n\n  if (typeof customFieldSchema === 'function') {\n    fields = customFieldSchema({ config, defaultFields: baseFields })\n  } else if (Array.isArray(customFieldSchema)) {\n    fields = customFieldSchema\n  } else {\n    fields = baseFields\n  }\n\n  return fields as Field[]\n}\n"],"names":["getBaseFields","transformExtraFields","customFieldSchema","config","enabledCollections","disabledCollections","maxDepth","baseFields","fields","defaultFields","Array","isArray"],"mappings":";;;AAEA,SAASA,aAAa,QAAQ;;AAKvB,SAASC,qBACdC,iBAMQ,EACRC,MAAuB,EACvBC,kBAAqC,EACrCC,mBAAsC,EACtCC,QAAiB;IAEjB,MAAMC,UAAA,+MAAmCP,gBAAAA,AAAA,EACvCG,MAAA,EACAC,kBAAA,EACAC,mBAAA,EACAC,QAAA;IAGF,IAAIE,MAAA;IAEJ,IAAI,OAAON,iBAAA,KAAsB,YAAY;QAC3CM,MAAA,GAASN,iBAAA,CAAkB;YAAEC,MAAA;YAAQM,aAAA,EAAeF;QAAW;IACjE,OAAO,IAAIG,KAAA,CAAMC,OAAO,CAACT,iBAAA,GAAoB;QAC3CM,MAAA,GAASN,iBAAA;IACX,OAAO;QACLM,MAAA,GAASD,UAAA;IACX;IAEA,OAAOC,MAAA;AACT"}},
    {"offset": {"line": 2088, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2094, "column": 0}, "map": {"version":3,"file":"i18n.js","sources":["turbopack://[project]/node_modules/@payloadcms/richtext-lexical/src/features/link/server/i18n.ts"],"sourcesContent":["import type { GenericLanguages } from '@payloadcms/translations'\n\nexport const i18n: Partial<GenericLanguages> = {\n  ar: {\n    label: 'رابط',\n  },\n  az: {\n    label: 'Keçid',\n  },\n  bg: {\n    label: 'Връзка',\n  },\n  cs: {\n    label: 'Odkaz',\n  },\n  de: {\n    label: 'Verknüpfung',\n  },\n  en: {\n    label: 'Link',\n  },\n  es: {\n    label: 'Enlace',\n  },\n  fa: {\n    label: 'پیوند',\n  },\n  fr: {\n    label: 'Lien',\n  },\n  he: {\n    label: 'קישור',\n  },\n  hr: {\n    label: 'Poveznica',\n  },\n  hu: {\n    label: 'Hivatkozás',\n  },\n  it: {\n    label: 'Collegamento',\n  },\n  ja: {\n    label: 'リンク',\n  },\n  ko: {\n    label: '링크',\n  },\n  my: {\n    label: 'လင့်',\n  },\n  nb: {\n    label: 'Lenke',\n  },\n  nl: {\n    label: 'Link',\n  },\n  pl: {\n    label: 'Łącze',\n  },\n  pt: {\n    label: 'Ligação',\n  },\n  ro: {\n    label: 'Legătură',\n  },\n  rs: {\n    label: 'Veza',\n  },\n  'rs-latin': {\n    label: 'Veza',\n  },\n  ru: {\n    label: 'Ссылка',\n  },\n  sk: {\n    label: 'Odkaz',\n  },\n  sv: {\n    label: 'Länk',\n  },\n  th: {\n    label: 'ลิงค์',\n  },\n  tr: {\n    label: 'Bağlantı',\n  },\n  uk: {\n    label: 'Посилання',\n  },\n  vi: {\n    label: 'Liên kết',\n  },\n  zh: {\n    label: '链接',\n  },\n  'zh-TW': {\n    label: '連結',\n  },\n}\n"],"names":["i18n","ar","label","az","bg","cs","de","en","es","fa","fr","he","hr","hu","it","ja","ko","my","nb","nl","pl","pt","ro","rs","ru","sk","sv","th","tr","uk","vi","zh"],"mappings":";;;AAEO,MAAMA,IAAA,GAAkC;IAC7CC,EAAA,EAAI;QACFC,KAAA,EAAO;IACT;IACAC,EAAA,EAAI;QACFD,KAAA,EAAO;IACT;IACAE,EAAA,EAAI;QACFF,KAAA,EAAO;IACT;IACAG,EAAA,EAAI;QACFH,KAAA,EAAO;IACT;IACAI,EAAA,EAAI;QACFJ,KAAA,EAAO;IACT;IACAK,EAAA,EAAI;QACFL,KAAA,EAAO;IACT;IACAM,EAAA,EAAI;QACFN,KAAA,EAAO;IACT;IACAO,EAAA,EAAI;QACFP,KAAA,EAAO;IACT;IACAQ,EAAA,EAAI;QACFR,KAAA,EAAO;IACT;IACAS,EAAA,EAAI;QACFT,KAAA,EAAO;IACT;IACAU,EAAA,EAAI;QACFV,KAAA,EAAO;IACT;IACAW,EAAA,EAAI;QACFX,KAAA,EAAO;IACT;IACAY,EAAA,EAAI;QACFZ,KAAA,EAAO;IACT;IACAa,EAAA,EAAI;QACFb,KAAA,EAAO;IACT;IACAc,EAAA,EAAI;QACFd,KAAA,EAAO;IACT;IACAe,EAAA,EAAI;QACFf,KAAA,EAAO;IACT;IACAgB,EAAA,EAAI;QACFhB,KAAA,EAAO;IACT;IACAiB,EAAA,EAAI;QACFjB,KAAA,EAAO;IACT;IACAkB,EAAA,EAAI;QACFlB,KAAA,EAAO;IACT;IACAmB,EAAA,EAAI;QACFnB,KAAA,EAAO;IACT;IACAoB,EAAA,EAAI;QACFpB,KAAA,EAAO;IACT;IACAqB,EAAA,EAAI;QACFrB,KAAA,EAAO;IACT;IACA,YAAY;QACVA,KAAA,EAAO;IACT;IACAsB,EAAA,EAAI;QACFtB,KAAA,EAAO;IACT;IACAuB,EAAA,EAAI;QACFvB,KAAA,EAAO;IACT;IACAwB,EAAA,EAAI;QACFxB,KAAA,EAAO;IACT;IACAyB,EAAA,EAAI;QACFzB,KAAA,EAAO;IACT;IACA0B,EAAA,EAAI;QACF1B,KAAA,EAAO;IACT;IACA2B,EAAA,EAAI;QACF3B,KAAA,EAAO;IACT;IACA4B,EAAA,EAAI;QACF5B,KAAA,EAAO;IACT;IACA6B,EAAA,EAAI;QACF7B,KAAA,EAAO;IACT;IACA,SAAS;QACPA,KAAA,EAAO;IACT;AACF"}},
    {"offset": {"line": 2195, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2201, "column": 0}, "map": {"version":3,"file":"LinkNode.js","sources":["turbopack://[project]/node_modules/@payloadcms/richtext-lexical/src/features/link/nodes/LinkNode.ts"],"sourcesContent":["import type {\n  BaseSelection,\n  DOMConversionMap,\n  DOMConversionOutput,\n  EditorConfig,\n  ElementNode as ElementNodeType,\n  LexicalCommand,\n  LexicalNode,\n  NodeKey,\n  RangeSelection,\n} from 'lexical'\n\nimport { addClassNamesToElement, isHTMLAnchorElement } from '@lexical/utils'\nimport ObjectID from 'bson-objectid'\nimport {\n  $applyNodeReplacement,\n  $createTextNode,\n  $getSelection,\n  $isElementNode,\n  $isRangeSelection,\n  createCommand,\n  ElementNode,\n} from 'lexical'\n\nimport type { LinkPayload } from '../client/plugins/floatingLinkEditor/types.js'\nimport type { LinkFields, SerializedLinkNode } from './types.js'\n\nconst SUPPORTED_URL_PROTOCOLS = new Set(['http:', 'https:', 'mailto:', 'sms:', 'tel:'])\n\n/** @noInheritDoc */\nexport class LinkNode extends ElementNode {\n  __fields: LinkFields\n  __id: string\n\n  constructor({\n    id,\n    fields = {\n      doc: null,\n      linkType: 'custom',\n      newTab: false,\n      url: '',\n    },\n    key,\n  }: {\n    fields: LinkFields\n    id: string\n    key?: NodeKey\n  }) {\n    super(key)\n    this.__fields = fields\n    this.__id = id\n  }\n\n  static clone(node: LinkNode): LinkNode {\n    return new LinkNode({\n      id: node.__id,\n      fields: node.__fields,\n      key: node.__key,\n    })\n  }\n\n  static getType(): string {\n    return 'link'\n  }\n\n  static importDOM(): DOMConversionMap | null {\n    return {\n      a: (node: Node) => ({\n        conversion: $convertAnchorElement,\n        priority: 1,\n      }),\n    }\n  }\n\n  static importJSON(serializedNode: SerializedLinkNode): LinkNode {\n    if (\n      serializedNode.version === 1 &&\n      typeof serializedNode.fields?.doc?.value === 'object' &&\n      serializedNode.fields?.doc?.value?.id\n    ) {\n      serializedNode.fields.doc.value = serializedNode.fields.doc.value.id\n      serializedNode.version = 2\n    }\n\n    if (serializedNode.version === 2 && !serializedNode.id) {\n      serializedNode.id = new ObjectID.default().toHexString()\n      serializedNode.version = 3\n    }\n\n    const node = $createLinkNode({\n      id: serializedNode.id,\n      fields: serializedNode.fields,\n    })\n    node.setFormat(serializedNode.format)\n    node.setIndent(serializedNode.indent)\n    node.setDirection(serializedNode.direction)\n    return node\n  }\n\n  canBeEmpty(): false {\n    return false\n  }\n\n  canInsertTextAfter(): false {\n    return false\n  }\n\n  canInsertTextBefore(): false {\n    return false\n  }\n\n  createDOM(config: EditorConfig): HTMLAnchorElement {\n    const element = document.createElement('a')\n    if (this.__fields?.linkType === 'custom') {\n      element.href = this.sanitizeUrl(this.__fields.url ?? '')\n    }\n    if (this.__fields?.newTab ?? false) {\n      element.target = '_blank'\n    }\n\n    if (this.__fields?.newTab === true && this.__fields?.linkType === 'custom') {\n      element.rel = manageRel(element.rel, 'add', 'noopener')\n    }\n\n    addClassNamesToElement(element, config.theme.link)\n    return element\n  }\n\n  exportJSON(): SerializedLinkNode {\n    const returnObject: SerializedLinkNode = {\n      ...super.exportJSON(),\n      type: 'link',\n      fields: this.getFields(),\n      version: 3,\n    }\n    const id = this.getID()\n    if (id) {\n      returnObject.id = id\n    }\n    return returnObject\n  }\n\n  extractWithChild(\n    child: LexicalNode,\n    selection: BaseSelection,\n    destination: 'clone' | 'html',\n  ): boolean {\n    if (!$isRangeSelection(selection)) {\n      return false\n    }\n\n    const anchorNode = selection.anchor.getNode()\n    const focusNode = selection.focus.getNode()\n\n    return (\n      this.isParentOf(anchorNode) &&\n      this.isParentOf(focusNode) &&\n      selection.getTextContent().length > 0\n    )\n  }\n\n  getFields(): LinkFields {\n    return this.getLatest().__fields\n  }\n\n  getID(): string {\n    return this.getLatest().__id\n  }\n\n  insertNewAfter(selection: RangeSelection, restoreSelection = true): ElementNodeType | null {\n    const element = this.getParentOrThrow().insertNewAfter(selection, restoreSelection)\n    if ($isElementNode(element)) {\n      const linkNode = $createLinkNode({ fields: this.__fields })\n      element.append(linkNode)\n      return linkNode\n    }\n    return null\n  }\n\n  isInline(): true {\n    return true\n  }\n\n  sanitizeUrl(url: string): string {\n    try {\n      const parsedUrl = new URL(url)\n\n      if (!SUPPORTED_URL_PROTOCOLS.has(parsedUrl.protocol)) {\n        return 'about:blank'\n      }\n    } catch (e) {\n      return 'https://'\n    }\n    return url\n  }\n\n  setFields(fields: LinkFields): void {\n    const writable = this.getWritable()\n    writable.__fields = fields\n  }\n\n  updateDOM(prevNode: LinkNode, anchor: HTMLAnchorElement, config: EditorConfig): boolean {\n    const url = this.__fields?.url\n    const newTab = this.__fields?.newTab\n    if (url != null && url !== prevNode.__fields?.url && this.__fields?.linkType === 'custom') {\n      anchor.href = url\n    }\n    if (this.__fields?.linkType === 'internal' && prevNode.__fields?.linkType === 'custom') {\n      anchor.removeAttribute('href')\n    }\n\n    // TODO: not 100% sure why we're settign rel to '' - revisit\n    // Start rel config here, then check newTab below\n    if (anchor.rel == null) {\n      anchor.rel = ''\n    }\n\n    if (newTab !== prevNode.__fields?.newTab) {\n      if (newTab ?? false) {\n        anchor.target = '_blank'\n        if (this.__fields?.linkType === 'custom') {\n          anchor.rel = manageRel(anchor.rel, 'add', 'noopener')\n        }\n      } else {\n        anchor.removeAttribute('target')\n        anchor.rel = manageRel(anchor.rel, 'remove', 'noopener')\n      }\n    }\n\n    return false\n  }\n}\n\nfunction $convertAnchorElement(domNode: Node): DOMConversionOutput {\n  let node: LinkNode | null = null\n  if (isHTMLAnchorElement(domNode)) {\n    const content = domNode.textContent\n    if (content !== null && content !== '') {\n      node = $createLinkNode({\n        id: new ObjectID.default().toHexString(),\n        fields: {\n          doc: null,\n          linkType: 'custom',\n          newTab: domNode.getAttribute('target') === '_blank',\n          url: domNode.getAttribute('href') ?? '',\n        },\n      })\n    }\n  }\n  return { node }\n}\n\nexport function $createLinkNode({ id, fields }: { fields: LinkFields; id?: string }): LinkNode {\n  return $applyNodeReplacement(\n    new LinkNode({\n      id: id ?? new ObjectID.default().toHexString(),\n      fields,\n    }),\n  )\n}\n\nexport function $isLinkNode(node: LexicalNode | null | undefined): node is LinkNode {\n  return node instanceof LinkNode\n}\n\nexport const TOGGLE_LINK_COMMAND: LexicalCommand<LinkPayload | null> =\n  createCommand('TOGGLE_LINK_COMMAND')\n\nexport function $toggleLink(payload: LinkPayload): void {\n  const selection = $getSelection()\n\n  if (!$isRangeSelection(selection) && !payload.selectedNodes?.length) {\n    return\n  }\n  const nodes = $isRangeSelection(selection) ? selection.extract() : payload.selectedNodes\n\n  if (payload === null) {\n    // Remove LinkNodes\n    nodes?.forEach((node) => {\n      const parent = node.getParent()\n\n      if ($isLinkNode(parent)) {\n        const children = parent.getChildren()\n\n        for (let i = 0; i < children.length; i += 1) {\n          parent.insertBefore(children[i])\n        }\n\n        parent.remove()\n      }\n    })\n  } else {\n    // Add or merge LinkNodes\n    if (nodes?.length === 1) {\n      const firstNode = nodes[0]\n      // if the first node is a LinkNode or if its\n      // parent is a LinkNode, we update the URL, target and rel.\n      const linkNode: LinkNode | null = $isLinkNode(firstNode)\n        ? firstNode\n        : $getLinkAncestor(firstNode)\n      if (linkNode !== null) {\n        linkNode.setFields(payload.fields)\n\n        if (payload.text != null && payload.text !== linkNode.getTextContent()) {\n          // remove all children and add child with new textcontent:\n          linkNode.append($createTextNode(payload.text))\n          linkNode.getChildren().forEach((child) => {\n            if (child !== linkNode.getLastChild()) {\n              child.remove()\n            }\n          })\n        }\n        return\n      }\n    }\n\n    let prevParent: ElementNodeType | LinkNode | null = null\n    let linkNode: LinkNode | null = null\n\n    nodes?.forEach((node) => {\n      const parent = node.getParent()\n\n      if (parent === linkNode || parent === null || ($isElementNode(node) && !node.isInline())) {\n        return\n      }\n\n      if ($isLinkNode(parent)) {\n        linkNode = parent\n        parent.setFields(payload.fields)\n        if (payload.text != null && payload.text !== parent.getTextContent()) {\n          // remove all children and add child with new textcontent:\n          parent.append($createTextNode(payload.text))\n          parent.getChildren().forEach((child) => {\n            if (child !== parent.getLastChild()) {\n              child.remove()\n            }\n          })\n        }\n        return\n      }\n\n      if (!parent.is(prevParent)) {\n        prevParent = parent\n        linkNode = $createLinkNode({ fields: payload.fields })\n\n        if ($isLinkNode(parent)) {\n          if (node.getPreviousSibling() === null) {\n            parent.insertBefore(linkNode)\n          } else {\n            parent.insertAfter(linkNode)\n          }\n        } else {\n          node.insertBefore(linkNode)\n        }\n      }\n\n      if ($isLinkNode(node)) {\n        if (node.is(linkNode)) {\n          return\n        }\n        if (linkNode !== null) {\n          const children = node.getChildren()\n\n          for (let i = 0; i < children.length; i += 1) {\n            linkNode.append(children[i])\n          }\n        }\n\n        node.remove()\n        return\n      }\n\n      if (linkNode !== null) {\n        linkNode.append(node)\n      }\n    })\n  }\n}\n\nfunction $getLinkAncestor(node: LexicalNode): LinkNode | null {\n  return $getAncestor(node, (ancestor) => $isLinkNode(ancestor)) as LinkNode\n}\n\nfunction $getAncestor(\n  node: LexicalNode,\n  predicate: (ancestor: LexicalNode) => boolean,\n): LexicalNode | null {\n  let parent: LexicalNode | null = node\n  while (parent !== null) {\n    parent = parent.getParent()\n    if (parent === null || predicate(parent)) {\n      break\n    }\n  }\n  return parent\n}\n\nfunction manageRel(input: string, action: 'add' | 'remove', value: string): string {\n  let result: string\n  let mutableInput = `${input}`\n  if (action === 'add') {\n    // if we somehow got out of sync - clean up\n    if (mutableInput.includes(value)) {\n      const re = new RegExp(value, 'g')\n      mutableInput = mutableInput.replace(re, '').trim()\n    }\n    mutableInput = mutableInput.trim()\n    result = mutableInput.length === 0 ? `${value}` : `${mutableInput} ${value}`\n  } else {\n    const re = new RegExp(value, 'g')\n    result = mutableInput.replace(re, '').trim()\n  }\n  return result\n}\n"],"names":["addClassNamesToElement","isHTMLAnchorElement","ObjectID","$applyNodeReplacement","$createTextNode","$getSelection","$isElementNode","$isRangeSelection","createCommand","ElementNode","SUPPORTED_URL_PROTOCOLS","Set","LinkNode","__fields","__id","constructor","id","fields","doc","linkType","newTab","url","key","clone","node","__key","getType","importDOM","a","conversion","$convertAnchorElement","priority","importJSON","serializedNode","version","value","default","toHexString","$createLinkNode","setFormat","format","setIndent","indent","setDirection","direction","canBeEmpty","canInsertTextAfter","canInsertTextBefore","createDOM","config","element","document","createElement","href","sanitizeUrl","target","rel","manageRel","theme","link","exportJSON","returnObject","type","getFields","getID","extractWithChild","child","selection","destination","anchorNode","anchor","getNode","focusNode","focus","isParentOf","getTextContent","length","getLatest","insertNewAfter","restoreSelection","getParentOrThrow","linkNode","append","isInline","parsedUrl","URL","has","protocol","e","setFields","writable","getWritable","updateDOM","prevNode","removeAttribute","domNode","content","textContent","getAttribute","$isLinkNode","TOGGLE_LINK_COMMAND","$toggleLink","payload","selectedNodes","nodes","extract","forEach","parent","getParent","children","getChildren","i","insertBefore","remove","firstNode","$getLinkAncestor","text","getLastChild","prevParent","is","getPreviousSibling","insertAfter","$getAncestor","ancestor","predicate","input","action","result","mutableInput","includes","re","RegExp","replace","trim"],"mappings":";;;;;;;AAaA,OAAOE,QAAA,MAAc;AADrB,SAASF,sBAAsB,EAAEC,mBAAmB,QAAQ;AAE5D,SACEE,qBAAqB,EACrBC,eAAe,EACfC,aAAa,EACbC,cAAc,EACdC,iBAAiB,EACjBC,aAAa,EACbC,WAAW,QACN;;;;AAKP,MAAMC,uBAAA,GAA0B,IAAIC,GAAA,CAAI;IAAC;IAAS;IAAU;IAAW;IAAQ;CAAO;AAG/E,MAAMC,QAAA,oJAAiBH,cAAA;IAC5BI,QAAA,CAAA;IACAC,IAAA,CAAA;IAEAC,YAAY,EACVC,EAAE,EACFC,MAAA,GAAS;QACPC,GAAA,EAAK;QACLC,QAAA,EAAU;QACVC,MAAA,EAAQ;QACRC,GAAA,EAAK;IACP,CAAC,EACDC,GAAAA,EAKD,CAAE;QACD,KAAK,CAACA,GAAA;QACN,IAAI,CAACT,QAAQ,GAAGI,MAAA;QAChB,IAAI,CAACH,IAAI,GAAGE,EAAA;IACd;IAEA,OAAOO,MAAMC,IAAc,EAAY;QACrC,OAAO,IAAIZ,QAAA,CAAS;YAClBI,EAAA,EAAIQ,IAAA,CAAKV,IAAI;YACbG,MAAA,EAAQO,IAAA,CAAKX,QAAQ;YACrBS,GAAA,EAAKE,IAAA,CAAKC,KAAAA;QACZ;IACF;IAEA,OAAOC,QAAA,EAAkB;QACvB,OAAO;IACT;IAEA,OAAOC,UAAA,EAAqC;QAC1C,OAAO;YACLC,CAAA,GAAIJ,IAAA,GAAA,CAAgB;oBAClBK,UAAA,EAAYC,qBAAA;oBACZC,QAAA,EAAU;gBACZ,CAAA;QACF;IACF;IAEA,OAAOC,WAAWC,cAAkC,EAAY;QAC9D,IACEA,cAAA,CAAeC,OAAO,KAAK,KAC3B,OAAOD,cAAA,CAAehB,MAAM,EAAEC,GAAA,EAAKiB,KAAA,KAAU,YAC7CF,cAAA,CAAehB,MAAM,EAAEC,GAAA,EAAKiB,KAAA,EAAOnB,EAAA,EACnC;YACAiB,cAAA,CAAehB,MAAM,CAACC,GAAG,CAACiB,KAAK,GAAGF,cAAA,CAAehB,MAAM,CAACC,GAAG,CAACiB,KAAK,CAACnB,EAAE;YACpEiB,cAAA,CAAeC,OAAO,GAAG;QAC3B;QAEA,IAAID,cAAA,CAAeC,OAAO,KAAK,KAAK,CAACD,cAAA,CAAejB,EAAE,EAAE;YACtDiB,cAAA,CAAejB,EAAE,GAAG,iJAAId,UAAA,CAASkC,OAAO,GAAGC,WAAW;YACtDJ,cAAA,CAAeC,OAAO,GAAG;QAC3B;QAEA,MAAMV,IAAA,GAAOc,eAAA,CAAgB;YAC3BtB,EAAA,EAAIiB,cAAA,CAAejB,EAAE;YACrBC,MAAA,EAAQgB,cAAA,CAAehB,MAAAA;QACzB;QACAO,IAAA,CAAKe,SAAS,CAACN,cAAA,CAAeO,MAAM;QACpChB,IAAA,CAAKiB,SAAS,CAACR,cAAA,CAAeS,MAAM;QACpClB,IAAA,CAAKmB,YAAY,CAACV,cAAA,CAAeW,SAAS;QAC1C,OAAOpB,IAAA;IACT;IAEAqB,WAAA,EAAoB;QAClB,OAAO;IACT;IAEAC,mBAAA,EAA4B;QAC1B,OAAO;IACT;IAEAC,oBAAA,EAA6B;QAC3B,OAAO;IACT;IAEAC,UAAUC,MAAoB,EAAqB;QACjD,MAAMC,OAAA,GAAUC,QAAA,CAASC,aAAa,CAAC;QACvC,IAAI,IAAI,CAACvC,QAAQ,EAAEM,QAAA,KAAa,UAAU;YACxC+B,OAAA,CAAQG,IAAI,GAAG,IAAI,CAACC,WAAW,CAAC,IAAI,CAACzC,QAAQ,CAACQ,GAAG,IAAI;QACvD;QACA,IAAI,IAAI,CAACR,QAAQ,EAAEO,MAAA,IAAU,OAAO;YAClC8B,OAAA,CAAQK,MAAM,GAAG;QACnB;QAEA,IAAI,IAAI,CAAC1C,QAAQ,EAAEO,MAAA,KAAW,QAAQ,IAAI,CAACP,QAAQ,EAAEM,QAAA,KAAa,UAAU;YAC1E+B,OAAA,CAAQM,GAAG,GAAGC,SAAA,CAAUP,OAAA,CAAQM,GAAG,EAAE,OAAO;QAC9C;uLAEAxD,yBAAAA,AAAA,EAAuBkD,OAAA,EAASD,MAAA,CAAOS,KAAK,CAACC,IAAI;QACjD,OAAOT,OAAA;IACT;IAEAU,WAAA,EAAiC;QAC/B,MAAMC,YAAA,GAAmC;YACvC,GAAG,KAAK,CAACD,UAAA,EAAY;YACrBE,IAAA,EAAM;YACN7C,MAAA,EAAQ,IAAI,CAAC8C,SAAS;YACtB7B,OAAA,EAAS;QACX;QACA,MAAMlB,EAAA,GAAK,IAAI,CAACgD,KAAK;QACrB,IAAIhD,EAAA,EAAI;YACN6C,YAAA,CAAa7C,EAAE,GAAGA,EAAA;QACpB;QACA,OAAO6C,YAAA;IACT;IAEAI,iBACEC,KAAkB,EAClBC,SAAwB,EACxBC,WAA6B,EACpB;QACT,IAAI,gJAAC7D,oBAAAA,AAAA,EAAkB4D,SAAA,GAAY;YACjC,OAAO;QACT;QAEA,MAAME,UAAA,GAAaF,SAAA,CAAUG,MAAM,CAACC,OAAO;QAC3C,MAAMC,SAAA,GAAYL,SAAA,CAAUM,KAAK,CAACF,OAAO;QAEzC,OACE,IAAI,CAACG,UAAU,CAACL,UAAA,KAChB,IAAI,CAACK,UAAU,CAACF,SAAA,KAChBL,SAAA,CAAUQ,cAAc,GAAGC,MAAM,GAAG;IAExC;IAEAb,UAAA,EAAwB;QACtB,OAAO,IAAI,CAACc,SAAS,GAAGhE,QAAQ;IAClC;IAEAmD,MAAA,EAAgB;QACd,OAAO,IAAI,CAACa,SAAS,GAAG/D,IAAI;IAC9B;IAEAgE,eAAeX,SAAyB,EAAEY,gBAAA,GAAmB,IAAI,EAA0B;QACzF,MAAM7B,OAAA,GAAU,IAAI,CAAC8B,gBAAgB,GAAGF,cAAc,CAACX,SAAA,EAAWY,gBAAA;QAClE,KAAIzE,+JAAAA,AAAA,EAAe4C,OAAA,GAAU;YAC3B,MAAM+B,QAAA,GAAW3C,eAAA,CAAgB;gBAAErB,MAAA,EAAQ,IAAI,CAACJ,QAAAA;YAAS;YACzDqC,OAAA,CAAQgC,MAAM,CAACD,QAAA;YACf,OAAOA,QAAA;QACT;QACA,OAAO;IACT;IAEAE,SAAA,EAAiB;QACf,OAAO;IACT;IAEA7B,YAAYjC,GAAW,EAAU;QAC/B,IAAI;YACF,MAAM+D,SAAA,GAAY,IAAIC,GAAA,CAAIhE,GAAA;YAE1B,IAAI,CAACX,uBAAA,CAAwB4E,GAAG,CAACF,SAAA,CAAUG,QAAQ,GAAG;gBACpD,OAAO;YACT;QACF,EAAE,OAAOC,CAAA,EAAG;YACV,OAAO;QACT;QACA,OAAOnE,GAAA;IACT;IAEAoE,UAAUxE,MAAkB,EAAQ;QAClC,MAAMyE,QAAA,GAAW,IAAI,CAACC,WAAW;QACjCD,QAAA,CAAS7E,QAAQ,GAAGI,MAAA;IACtB;IAEA2E,UAAUC,QAAkB,EAAEvB,MAAyB,EAAErB,MAAoB,EAAW;QACtF,MAAM5B,GAAA,GAAM,IAAI,CAACR,QAAQ,EAAEQ,GAAA;QAC3B,MAAMD,MAAA,GAAS,IAAI,CAACP,QAAQ,EAAEO,MAAA;QAC9B,IAAIC,GAAA,IAAO,QAAQA,GAAA,KAAQwE,QAAA,CAAShF,QAAQ,EAAEQ,GAAA,IAAO,IAAI,CAACR,QAAQ,EAAEM,QAAA,KAAa,UAAU;YACzFmD,MAAA,CAAOjB,IAAI,GAAGhC,GAAA;QAChB;QACA,IAAI,IAAI,CAACR,QAAQ,EAAEM,QAAA,KAAa,cAAc0E,QAAA,CAAShF,QAAQ,EAAEM,QAAA,KAAa,UAAU;YACtFmD,MAAA,CAAOwB,eAAe,CAAC;QACzB;QAEA,4DAAA;QACA,iDAAA;QACA,IAAIxB,MAAA,CAAOd,GAAG,IAAI,MAAM;YACtBc,MAAA,CAAOd,GAAG,GAAG;QACf;QAEA,IAAIpC,MAAA,KAAWyE,QAAA,CAAShF,QAAQ,EAAEO,MAAA,EAAQ;YACxC,IAAIA,MAAA,IAAU,OAAO;gBACnBkD,MAAA,CAAOf,MAAM,GAAG;gBAChB,IAAI,IAAI,CAAC1C,QAAQ,EAAEM,QAAA,KAAa,UAAU;oBACxCmD,MAAA,CAAOd,GAAG,GAAGC,SAAA,CAAUa,MAAA,CAAOd,GAAG,EAAE,OAAO;gBAC5C;YACF,OAAO;gBACLc,MAAA,CAAOwB,eAAe,CAAC;gBACvBxB,MAAA,CAAOd,GAAG,GAAGC,SAAA,CAAUa,MAAA,CAAOd,GAAG,EAAE,UAAU;YAC/C;QACF;QAEA,OAAO;IACT;AACF;AAEA,SAAS1B,sBAAsBiE,OAAa;IAC1C,IAAIvE,IAAA,GAAwB;IAC5B,mJAAIvB,sBAAAA,AAAA,EAAoB8F,OAAA,GAAU;QAChC,MAAMC,OAAA,GAAUD,OAAA,CAAQE,WAAW;QACnC,IAAID,OAAA,KAAY,QAAQA,OAAA,KAAY,IAAI;YACtCxE,IAAA,GAAOc,eAAA,CAAgB;gBACrBtB,EAAA,EAAI,gJAAId,WAAA,CAASkC,OAAO,GAAGC,WAAW;gBACtCpB,MAAA,EAAQ;oBACNC,GAAA,EAAK;oBACLC,QAAA,EAAU;oBACVC,MAAA,EAAQ2E,OAAA,CAAQG,YAAY,CAAC,cAAc;oBAC3C7E,GAAA,EAAK0E,OAAA,CAAQG,YAAY,CAAC,WAAW;gBACvC;YACF;QACF;IACF;IACA,OAAO;QAAE1E;IAAK;AAChB;AAEO,SAASc,gBAAgB,EAAEtB,EAAE,EAAEC,MAAAA,EAA6C;IACjF,sJAAOd,wBAAAA,AAAA,EACL,IAAIS,QAAA,CAAS;QACXI,EAAA,EAAIA,EAAA,IAAM,iJAAId,UAAA,CAASkC,OAAO,GAAGC,WAAW;QAC5CpB;IACF;AAEJ;AAEO,SAASkF,YAAY3E,IAAoC;IAC9D,OAAOA,IAAA,YAAgBZ,QAAA;AACzB;AAEO,MAAMwF,mBAAA,kJACX5F,gBAAAA,AAAA,EAAc;AAET,SAAS6F,YAAYC,OAAoB;IAC9C,MAAMnC,SAAA,kJAAY9D,gBAAAA,AAAA;IAElB,IAAI,gJAACE,oBAAAA,AAAA,EAAkB4D,SAAA,KAAc,CAACmC,OAAA,CAAQC,aAAa,EAAE3B,MAAA,EAAQ;QACnE;IACF;IACA,MAAM4B,KAAA,kJAAQjG,oBAAAA,AAAA,EAAkB4D,SAAA,IAAaA,SAAA,CAAUsC,OAAO,KAAKH,OAAA,CAAQC,aAAa;IAExF,IAAID,OAAA,KAAY,MAAM;QACpB,mBAAA;QACAE,KAAA,EAAOE,OAAA,EAASlF,IAAA;YACd,MAAMmF,MAAA,GAASnF,IAAA,CAAKoF,SAAS;YAE7B,IAAIT,WAAA,CAAYQ,MAAA,GAAS;gBACvB,MAAME,QAAA,GAAWF,MAAA,CAAOG,WAAW;gBAEnC,IAAK,IAAIC,CAAA,GAAI,GAAGA,CAAA,GAAIF,QAAA,CAASjC,MAAM,EAAEmC,CAAA,IAAK,EAAG;oBAC3CJ,MAAA,CAAOK,YAAY,CAACH,QAAQ,CAACE,CAAA,CAAE;gBACjC;gBAEAJ,MAAA,CAAOM,MAAM;YACf;QACF;IACF,OAAO;QACL,yBAAA;QACA,IAAIT,KAAA,EAAO5B,MAAA,KAAW,GAAG;YACvB,MAAMsC,SAAA,GAAYV,KAAK,CAAC,EAAE;YAC1B,4CAAA;YACA,2DAAA;YACA,MAAMvB,QAAA,GAA4BkB,WAAA,CAAYe,SAAA,IAC1CA,SAAA,GACAC,gBAAA,CAAiBD,SAAA;YACrB,IAAIjC,QAAA,KAAa,MAAM;gBACrBA,QAAA,CAASQ,SAAS,CAACa,OAAA,CAAQrF,MAAM;gBAEjC,IAAIqF,OAAA,CAAQc,IAAI,IAAI,QAAQd,OAAA,CAAQc,IAAI,KAAKnC,QAAA,CAASN,cAAc,IAAI;oBACtE,0DAAA;oBACAM,QAAA,CAASC,MAAM,KAAC9E,6JAAAA,AAAA,EAAgBkG,OAAA,CAAQc,IAAI;oBAC5CnC,QAAA,CAAS6B,WAAW,GAAGJ,OAAO,EAAExC,KAAA;wBAC9B,IAAIA,KAAA,KAAUe,QAAA,CAASoC,YAAY,IAAI;4BACrCnD,KAAA,CAAM+C,MAAM;wBACd;oBACF;gBACF;gBACA;YACF;QACF;QAEA,IAAIK,UAAA,GAAgD;QACpD,IAAIrC,QAAA,GAA4B;QAEhCuB,KAAA,EAAOE,OAAA,EAASlF,IAAA;YACd,MAAMmF,MAAA,GAASnF,IAAA,CAAKoF,SAAS;YAE7B,IAAID,MAAA,KAAW1B,QAAA,IAAY0B,MAAA,KAAW,QAASrG,gKAAAA,AAAA,EAAekB,IAAA,KAAS,CAACA,IAAA,CAAK2D,QAAQ,IAAK;gBACxF;YACF;YAEA,IAAIgB,WAAA,CAAYQ,MAAA,GAAS;gBACvB1B,QAAA,GAAW0B,MAAA;gBACXA,MAAA,CAAOlB,SAAS,CAACa,OAAA,CAAQrF,MAAM;gBAC/B,IAAIqF,OAAA,CAAQc,IAAI,IAAI,QAAQd,OAAA,CAAQc,IAAI,KAAKT,MAAA,CAAOhC,cAAc,IAAI;oBACpE,0DAAA;oBACAgC,MAAA,CAAOzB,MAAM,gJAAC9E,kBAAAA,AAAA,EAAgBkG,OAAA,CAAQc,IAAI;oBAC1CT,MAAA,CAAOG,WAAW,GAAGJ,OAAO,EAAExC,KAAA;wBAC5B,IAAIA,KAAA,KAAUyC,MAAA,CAAOU,YAAY,IAAI;4BACnCnD,KAAA,CAAM+C,MAAM;wBACd;oBACF;gBACF;gBACA;YACF;YAEA,IAAI,CAACN,MAAA,CAAOY,EAAE,CAACD,UAAA,GAAa;gBAC1BA,UAAA,GAAaX,MAAA;gBACb1B,QAAA,GAAW3C,eAAA,CAAgB;oBAAErB,MAAA,EAAQqF,OAAA,CAAQrF,MAAAA;gBAAO;gBAEpD,IAAIkF,WAAA,CAAYQ,MAAA,GAAS;oBACvB,IAAInF,IAAA,CAAKgG,kBAAkB,OAAO,MAAM;wBACtCb,MAAA,CAAOK,YAAY,CAAC/B,QAAA;oBACtB,OAAO;wBACL0B,MAAA,CAAOc,WAAW,CAACxC,QAAA;oBACrB;gBACF,OAAO;oBACLzD,IAAA,CAAKwF,YAAY,CAAC/B,QAAA;gBACpB;YACF;YAEA,IAAIkB,WAAA,CAAY3E,IAAA,GAAO;gBACrB,IAAIA,IAAA,CAAK+F,EAAE,CAACtC,QAAA,GAAW;oBACrB;gBACF;gBACA,IAAIA,QAAA,KAAa,MAAM;oBACrB,MAAM4B,QAAA,GAAWrF,IAAA,CAAKsF,WAAW;oBAEjC,IAAK,IAAIC,CAAA,GAAI,GAAGA,CAAA,GAAIF,QAAA,CAASjC,MAAM,EAAEmC,CAAA,IAAK,EAAG;wBAC3C9B,QAAA,CAASC,MAAM,CAAC2B,QAAQ,CAACE,CAAA,CAAE;oBAC7B;gBACF;gBAEAvF,IAAA,CAAKyF,MAAM;gBACX;YACF;YAEA,IAAIhC,QAAA,KAAa,MAAM;gBACrBA,QAAA,CAASC,MAAM,CAAC1D,IAAA;YAClB;QACF;IACF;AACF;AAEA,SAAS2F,iBAAiB3F,IAAiB;IACzC,OAAOkG,YAAA,CAAalG,IAAA,GAAOmG,QAAA,GAAaxB,WAAA,CAAYwB,QAAA;AACtD;AAEA,SAASD,aACPlG,IAAiB,EACjBoG,SAA6C;IAE7C,IAAIjB,MAAA,GAA6BnF,IAAA;IACjC,MAAOmF,MAAA,KAAW,KAAM;QACtBA,MAAA,GAASA,MAAA,CAAOC,SAAS;QACzB,IAAID,MAAA,KAAW,QAAQiB,SAAA,CAAUjB,MAAA,GAAS;YACxC;QACF;IACF;IACA,OAAOA,MAAA;AACT;AAEA,SAASlD,UAAUoE,KAAa,EAAEC,MAAwB,EAAE3F,KAAa;IACvE,IAAI4F,MAAA;IACJ,IAAIC,YAAA,GAAe,GAAGH,KAAA,EAAO;IAC7B,IAAIC,MAAA,KAAW,OAAO;QACpB,2CAAA;QACA,IAAIE,YAAA,CAAaC,QAAQ,CAAC9F,KAAA,GAAQ;YAChC,MAAM+F,EAAA,GAAK,IAAIC,MAAA,CAAOhG,KAAA,EAAO;YAC7B6F,YAAA,GAAeA,YAAA,CAAaI,OAAO,CAACF,EAAA,EAAI,IAAIG,IAAI;QAClD;QACAL,YAAA,GAAeA,YAAA,CAAaK,IAAI;QAChCN,MAAA,GAASC,YAAA,CAAapD,MAAM,KAAK,IAAI,GAAGzC,KAAA,EAAO,GAAG,GAAG6F,YAAA,CAAA,CAAA,EAAgB7F,KAAA,EAAO;IAC9E,OAAO;QACL,MAAM+F,EAAA,GAAK,IAAIC,MAAA,CAAOhG,KAAA,EAAO;QAC7B4F,MAAA,GAASC,YAAA,CAAaI,OAAO,CAACF,EAAA,EAAI,IAAIG,IAAI;IAC5C;IACA,OAAON,MAAA;AACT"}},
    {"offset": {"line": 2531, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2537, "column": 0}, "map": {"version":3,"file":"markdownTransformer.js","sources":["turbopack://[project]/node_modules/@payloadcms/richtext-lexical/src/features/link/markdownTransformer.ts"],"sourcesContent":["/**\n * Code taken from https://github.com/facebook/lexical/blob/main/packages/lexical-markdown/src/MarkdownTransformers.ts#L357\n */\n\n// Order of text transformers matters:\n//\n// - code should go first as it prevents any transformations inside\n\nimport type { TextMatchTransformer } from '@lexical/markdown'\n\nimport { $createTextNode, $isTextNode } from 'lexical'\n\nimport { $createLinkNode, $isLinkNode, LinkNode } from './nodes/LinkNode.js'\n\n// - then longer tags match (e.g. ** or __ should go before * or _)\nexport const LinkMarkdownTransformer: TextMatchTransformer = {\n  type: 'text-match',\n  dependencies: [LinkNode],\n  export: (_node, exportChildren, exportFormat) => {\n    if (!$isLinkNode(_node)) {\n      return null\n    }\n    const node: LinkNode = _node\n    const { url } = node.getFields()\n    const linkContent = `[${node.getTextContent()}](${url})`\n    const firstChild = node.getFirstChild()\n    // Add text styles only if link has single text node inside. If it's more\n    // then one we ignore it as markdown does not support nested styles for links\n    if (node.getChildrenSize() === 1 && $isTextNode(firstChild)) {\n      return exportFormat(firstChild, linkContent)\n    } else {\n      return linkContent\n    }\n  },\n  importRegExp: /\\[([^[]+)\\]\\(([^()\\s]+)(?:\\s\"((?:[^\"]*\\\\\")*[^\"]*)\"\\s*)?\\)/,\n  regExp: /\\[([^[]+)\\]\\(([^()\\s]+)(?:\\s\"((?:[^\"]*\\\\\")*[^\"]*)\"\\s*)?\\)$/,\n  replace: (textNode, match) => {\n    const [, linkText, linkUrl] = match\n    const linkNode = $createLinkNode({\n      fields: {\n        doc: null,\n        linkType: 'custom',\n        newTab: false,\n        url: linkUrl,\n      },\n    })\n    const linkTextNode = $createTextNode(linkText)\n    linkTextNode.setFormat(textNode.getFormat())\n    linkNode.append(linkTextNode)\n    textNode.replace(linkNode)\n  },\n  trigger: ')',\n}\n"],"names":["$createTextNode","$isTextNode","$createLinkNode","$isLinkNode","LinkNode","LinkMarkdownTransformer","type","dependencies","export","_node","exportChildren","exportFormat","node","url","getFields","linkContent","getTextContent","firstChild","getFirstChild","getChildrenSize","importRegExp","regExp","replace","textNode","match","linkText","linkUrl","linkNode","fields","doc","linkType","newTab","linkTextNode","setFormat","getFormat","append","trigger"],"mappings":"AAAA;;GAAA,CAIA,sCAAA;AACA,EAAA;AACA,mEAAA;;;;AAMA,SAASE,eAAe,EAAEC,WAAW,EAAEC,QAAQ,QAAQ;AAFvD,SAASJ,eAAe,EAAEC,WAAW,QAAQ;;;AAKtC,MAAMI,uBAAA,GAAgD;IAC3DC,IAAA,EAAM;IACNC,YAAA,EAAc;6MAACH,WAAA;KAAS;IACxBI,MAAA,EAAQA,CAACC,KAAA,EAAOC,cAAA,EAAgBC,YAAA;QAC9B,IAAI,0MAACR,cAAAA,AAAA,EAAYM,KAAA,GAAQ;YACvB,OAAO;QACT;QACA,MAAMG,IAAA,GAAiBH,KAAA;QACvB,MAAM,EAAEI,GAAAA,EAAK,GAAGD,IAAA,CAAKE,SAAS;QAC9B,MAAMC,WAAA,GAAc,CAAA,CAAA,EAAIH,IAAA,CAAKI,cAAc,GAAA,EAAA,EAAOH,GAAA,CAAA,CAAA,CAAM;QACxD,MAAMI,UAAA,GAAaL,IAAA,CAAKM,aAAa;QACrC,yEAAA;QACA,6EAAA;QACA,IAAIN,IAAA,CAAKO,eAAe,OAAO,oJAAKlB,cAAAA,AAAA,EAAYgB,UAAA,GAAa;YAC3D,OAAON,YAAA,CAAaM,UAAA,EAAYF,WAAA;QAClC,OAAO;YACL,OAAOA,WAAA;QACT;IACF;IACAK,YAAA,EAAc;IACdC,MAAA,EAAQ;IACRC,OAAA,EAASA,CAACC,QAAA,EAAUC,KAAA;QAClB,MAAM,GAAGC,QAAA,EAAUC,OAAA,CAAQ,GAAGF,KAAA;QAC9B,MAAMG,QAAA,4MAAWzB,kBAAAA,AAAA,EAAgB;YAC/B0B,MAAA,EAAQ;gBACNC,GAAA,EAAK;gBACLC,QAAA,EAAU;gBACVC,MAAA,EAAQ;gBACRlB,GAAA,EAAKa;YACP;QACF;QACA,MAAMM,YAAA,kJAAehC,kBAAAA,AAAA,EAAgByB,QAAA;QACrCO,YAAA,CAAaC,SAAS,CAACV,QAAA,CAASW,SAAS;QACzCP,QAAA,CAASQ,MAAM,CAACH,YAAA;QAChBT,QAAA,CAASD,OAAO,CAACK,QAAA;IACnB;IACAS,OAAA,EAAS;AACX"}},
    {"offset": {"line": 2589, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2595, "column": 0}, "map": {"version":3,"file":"AutoLinkNode.js","sources":["turbopack://[project]/node_modules/@payloadcms/richtext-lexical/src/features/link/nodes/AutoLinkNode.ts"],"sourcesContent":["import type { ElementNode, LexicalNode, RangeSelection } from 'lexical'\n\nimport { $applyNodeReplacement, $isElementNode } from 'lexical'\n\nimport type { LinkFields, SerializedAutoLinkNode } from './types.js'\n\nimport { LinkNode } from './LinkNode.js'\n\n// Custom node type to override `canInsertTextAfter` that will\n// allow typing within the link\n\nexport class AutoLinkNode extends LinkNode {\n  static clone(node: AutoLinkNode): AutoLinkNode {\n    return new AutoLinkNode({ id: '', fields: node.__fields, key: node.__key })\n  }\n\n  static getType(): string {\n    return 'autolink'\n  }\n\n  static importDOM(): null {\n    // TODO: Should link node should handle the import over autolink?\n    return null\n  }\n\n  static importJSON(serializedNode: SerializedAutoLinkNode): AutoLinkNode {\n    if (\n      serializedNode.version === 1 &&\n      typeof serializedNode.fields?.doc?.value === 'object' &&\n      serializedNode.fields?.doc?.value?.id\n    ) {\n      serializedNode.fields.doc.value = serializedNode.fields.doc.value.id\n      serializedNode.version = 2\n    }\n\n    const node = $createAutoLinkNode({ fields: serializedNode.fields })\n\n    node.setFormat(serializedNode.format)\n    node.setIndent(serializedNode.indent)\n    node.setDirection(serializedNode.direction)\n    return node\n  }\n\n  // @ts-expect-error\n  exportJSON(): SerializedAutoLinkNode {\n    const serialized = super.exportJSON()\n    return {\n      type: 'autolink',\n      children: serialized.children,\n      direction: serialized.direction,\n      fields: serialized.fields,\n      format: serialized.format,\n      indent: serialized.indent,\n      version: 2,\n    }\n  }\n\n  insertNewAfter(selection: RangeSelection, restoreSelection = true): ElementNode | null {\n    const element = this.getParentOrThrow().insertNewAfter(selection, restoreSelection)\n    if ($isElementNode(element)) {\n      const linkNode = $createAutoLinkNode({ fields: this.__fields })\n      element.append(linkNode)\n      return linkNode\n    }\n    return null\n  }\n}\n\nexport function $createAutoLinkNode({ fields }: { fields: LinkFields }): AutoLinkNode {\n  return $applyNodeReplacement(new AutoLinkNode({ id: '', fields }))\n}\nexport function $isAutoLinkNode(node: LexicalNode | null | undefined): node is AutoLinkNode {\n  return node instanceof AutoLinkNode\n}\n"],"names":["$applyNodeReplacement","$isElementNode","LinkNode","AutoLinkNode","clone","node","id","fields","__fields","key","__key","getType","importDOM","importJSON","serializedNode","version","doc","value","$createAutoLinkNode","setFormat","format","setIndent","indent","setDirection","direction","exportJSON","serialized","type","children","insertNewAfter","selection","restoreSelection","element","getParentOrThrow","linkNode","append","$isAutoLinkNode"],"mappings":";;;;;AAEA,SAASA,qBAAqB,EAAEC,cAAc,QAAQ;AAItD,SAASC,QAAQ,QAAQ;;;AAKlB,MAAMC,YAAA,8MAAqBD,WAAA;IAChC,OAAOE,MAAMC,IAAkB,EAAgB;QAC7C,OAAO,IAAIF,YAAA,CAAa;YAAEG,EAAA,EAAI;YAAIC,MAAA,EAAQF,IAAA,CAAKG,QAAQ;YAAEC,GAAA,EAAKJ,IAAA,CAAKK,KAAAA;QAAM;IAC3E;IAEA,OAAOC,QAAA,EAAkB;QACvB,OAAO;IACT;IAEA,OAAOC,UAAA,EAAkB;QACvB,iEAAA;QACA,OAAO;IACT;IAEA,OAAOC,WAAWC,cAAsC,EAAgB;QACtE,IACEA,cAAA,CAAeC,OAAO,KAAK,KAC3B,OAAOD,cAAA,CAAeP,MAAM,EAAES,GAAA,EAAKC,KAAA,KAAU,YAC7CH,cAAA,CAAeP,MAAM,EAAES,GAAA,EAAKC,KAAA,EAAOX,EAAA,EACnC;YACAQ,cAAA,CAAeP,MAAM,CAACS,GAAG,CAACC,KAAK,GAAGH,cAAA,CAAeP,MAAM,CAACS,GAAG,CAACC,KAAK,CAACX,EAAE;YACpEQ,cAAA,CAAeC,OAAO,GAAG;QAC3B;QAEA,MAAMV,IAAA,GAAOa,mBAAA,CAAoB;YAAEX,MAAA,EAAQO,cAAA,CAAeP,MAAAA;QAAO;QAEjEF,IAAA,CAAKc,SAAS,CAACL,cAAA,CAAeM,MAAM;QACpCf,IAAA,CAAKgB,SAAS,CAACP,cAAA,CAAeQ,MAAM;QACpCjB,IAAA,CAAKkB,YAAY,CAACT,cAAA,CAAeU,SAAS;QAC1C,OAAOnB,IAAA;IACT;IAEA,mBAAA;IACAoB,WAAA,EAAqC;QACnC,MAAMC,UAAA,GAAa,KAAK,CAACD,UAAA;QACzB,OAAO;YACLE,IAAA,EAAM;YACNC,QAAA,EAAUF,UAAA,CAAWE,QAAQ;YAC7BJ,SAAA,EAAWE,UAAA,CAAWF,SAAS;YAC/BjB,MAAA,EAAQmB,UAAA,CAAWnB,MAAM;YACzBa,MAAA,EAAQM,UAAA,CAAWN,MAAM;YACzBE,MAAA,EAAQI,UAAA,CAAWJ,MAAM;YACzBP,OAAA,EAAS;QACX;IACF;IAEAc,eAAeC,SAAyB,EAAEC,gBAAA,GAAmB,IAAI,EAAsB;QACrF,MAAMC,OAAA,GAAU,IAAI,CAACC,gBAAgB,GAAGJ,cAAc,CAACC,SAAA,EAAWC,gBAAA;QAClE,mJAAI9B,iBAAAA,AAAA,EAAe+B,OAAA,GAAU;YAC3B,MAAME,QAAA,GAAWhB,mBAAA,CAAoB;gBAAEX,MAAA,EAAQ,IAAI,CAACC,QAAAA;YAAS;YAC7DwB,OAAA,CAAQG,MAAM,CAACD,QAAA;YACf,OAAOA,QAAA;QACT;QACA,OAAO;IACT;AACF;AAEO,SAAShB,oBAAoB,EAAEX,MAAAA,EAAgC;IACpE,sJAAOP,wBAAAA,AAAA,EAAsB,IAAIG,YAAA,CAAa;QAAEG,EAAA,EAAI;QAAIC;IAAO;AACjE;AACO,SAAS6B,gBAAgB/B,IAAoC;IAClE,OAAOA,IAAA,YAAgBF,YAAA;AACzB"}},
    {"offset": {"line": 2666, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2672, "column": 0}, "map": {"version":3,"file":"validate.js","sources":["turbopack://[project]/node_modules/@payloadcms/richtext-lexical/src/features/link/server/validate.ts"],"sourcesContent":["import type { Field } from 'payload'\n\nimport { buildStateFromSchema } from '@payloadcms/ui/forms/buildStateFromSchema'\n\nimport type { NodeValidation } from '../../typesServer.js'\nimport type { SerializedAutoLinkNode, SerializedLinkNode } from '../nodes/types.js'\nimport type { LinkFeatureServerProps } from './index.js'\n\nexport const linkValidation = (\n  props: LinkFeatureServerProps,\n  sanitizedFieldsWithoutText: Field[],\n): NodeValidation<SerializedAutoLinkNode | SerializedLinkNode> => {\n  return async ({\n    node,\n    validation: {\n      options: { id, collectionSlug, operation, preferences, req },\n    },\n  }) => {\n    /**\n     * Run buildStateFromSchema as that properly validates link fields and link sub-fields\n     */\n\n    const result = await buildStateFromSchema({\n      id,\n      collectionSlug,\n      data: node.fields,\n      fieldSchema: sanitizedFieldsWithoutText, // Sanitized in feature.server.ts\n      operation: operation === 'create' || operation === 'update' ? operation : 'update',\n      preferences,\n      req,\n      siblingData: node.fields,\n    })\n\n    let errorPaths: string[] = []\n    for (const fieldKey in result) {\n      if (result[fieldKey].errorPaths) {\n        errorPaths = errorPaths.concat(result[fieldKey].errorPaths)\n      }\n    }\n\n    if (errorPaths.length) {\n      return 'The following fields are invalid: ' + errorPaths.join(', ')\n    }\n\n    return true\n  }\n}\n"],"names":["buildStateFromSchema","linkValidation","props","sanitizedFieldsWithoutText","node","validation","options","id","collectionSlug","operation","preferences","req","result","data","fields","fieldSchema","siblingData","errorPaths","fieldKey","concat","length","join"],"mappings":";;;AAEA,SAASA,oBAAoB,QAAQ;;AAM9B,MAAMC,cAAA,GAAiBA,CAC5BC,KAAA,EACAC,0BAAA;IAEA,OAAO,OAAO,EACZC,IAAI,EACJC,UAAA,EAAY,EACVC,OAAA,EAAS,EAAEC,EAAE,EAAEC,cAAc,EAAEC,SAAS,EAAEC,WAAW,EAAEC,GAAAA,EAAG,EAAE,EAE/D;QACC;;OAIA,MAAMC,MAAA,GAAS,+MAAMZ,uBAAAA,AAAA,EAAqB;YACxCO,EAAA;YACAC,cAAA;YACAK,IAAA,EAAMT,IAAA,CAAKU,MAAM;YACjBC,WAAA,EAAaZ,0BAAA;YACbM,SAAA,EAAWA,SAAA,KAAc,YAAYA,SAAA,KAAc,WAAWA,SAAA,GAAY;YAC1EC,WAAA;YACAC,GAAA;YACAK,WAAA,EAAaZ,IAAA,CAAKU,MAAAA;QACpB;QAEA,IAAIG,UAAA,GAAuB,EAAE;QAC7B,IAAK,MAAMC,QAAA,IAAYN,MAAA,CAAQ;YAC7B,IAAIA,MAAM,CAACM,QAAA,CAAS,CAACD,UAAU,EAAE;gBAC/BA,UAAA,GAAaA,UAAA,CAAWE,MAAM,CAACP,MAAM,CAACM,QAAA,CAAS,CAACD,UAAU;YAC5D;QACF;QAEA,IAAIA,UAAA,CAAWG,MAAM,EAAE;YACrB,OAAO,uCAAuCH,UAAA,CAAWI,IAAI,CAAC;QAChE;QAEA,OAAO;IACT;AACF"}},
    {"offset": {"line": 2703, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2709, "column": 0}, "map": {"version":3,"file":"recursivelyPopulateFieldsForGraphQL.js","sources":["turbopack://[project]/node_modules/@payloadcms/richtext-lexical/src/populateGraphQL/recursivelyPopulateFieldsForGraphQL.ts"],"sourcesContent":["import type { Field, JsonObject, PayloadRequest, RequestContext } from 'payload'\n\nimport { afterReadTraverseFields } from 'payload'\n\nimport type { PopulationPromise } from '../features/typesServer.js'\n\ntype NestedRichTextFieldsArgs = {\n  context: RequestContext\n  currentDepth?: number\n  data: unknown\n  depth: number\n  draft: boolean\n  /**\n   * This maps all the population promises to the node types\n   */\n  editorPopulationPromises: Map<string, Array<PopulationPromise>>\n  /**\n   * fieldPromises are used for things like field hooks. They should be awaited before awaiting populationPromises\n   */\n  fieldPromises: Promise<void>[]\n  fields: Field[]\n  findMany: boolean\n  flattenLocales: boolean\n  overrideAccess: boolean\n  populationPromises: Promise<void>[]\n  req: PayloadRequest\n  showHiddenFields: boolean\n  siblingDoc: JsonObject\n}\n\nexport const recursivelyPopulateFieldsForGraphQL = ({\n  context,\n  currentDepth = 0,\n  data,\n  depth,\n  draft,\n  fieldPromises,\n  fields,\n  findMany,\n  flattenLocales,\n  overrideAccess = false,\n  populationPromises,\n  req,\n  showHiddenFields,\n  siblingDoc,\n}: NestedRichTextFieldsArgs): void => {\n  afterReadTraverseFields({\n    collection: null, // Pass from core? This is only needed for hooks, so we can leave this null for now\n    context,\n    currentDepth,\n    depth,\n    doc: data as any, // Looks like it's only needed for hooks and access control, so doesn't matter what we pass here right now\n    draft,\n    fallbackLocale: req.fallbackLocale!,\n    fieldPromises,\n    fields,\n    findMany,\n    flattenLocales,\n    global: null, // Pass from core? This is only needed for hooks, so we can leave this null for now\n    locale: req.locale!,\n    overrideAccess,\n    path: [],\n    populationPromises, // This is not the same as populationPromises passed into this recurseNestedFields. These are just promises resolved at the very end.\n    req,\n    schemaPath: [],\n    showHiddenFields,\n    siblingDoc,\n    triggerHooks: false,\n  })\n}\n"],"names":["afterReadTraverseFields","recursivelyPopulateFieldsForGraphQL","context","currentDepth","data","depth","draft","fieldPromises","fields","findMany","flattenLocales","overrideAccess","populationPromises","req","showHiddenFields","siblingDoc","collection","doc","fallbackLocale","global","locale","path","schemaPath","triggerHooks"],"mappings":";;;AAEA,SAASA,uBAAuB,QAAQ;;AA4BjC,MAAMC,mCAAA,GAAsCA,CAAC,EAClDC,OAAO,EACPC,YAAA,GAAe,CAAC,EAChBC,IAAI,EACJC,KAAK,EACLC,KAAK,EACLC,aAAa,EACbC,MAAM,EACNC,QAAQ,EACRC,cAAc,EACdC,cAAA,GAAiB,KAAK,EACtBC,kBAAkB,EAClBC,GAAG,EACHC,gBAAgB,EAChBC,UAAAA,EACyB;uPACzBf,0BAAAA,AAAA,EAAwB;QACtBgB,UAAA,EAAY;QACZd,OAAA;QACAC,YAAA;QACAE,KAAA;QACAY,GAAA,EAAKb,IAAA;QACLE,KAAA;QACAY,cAAA,EAAgBL,GAAA,CAAIK,cAAc;QAClCX,aAAA;QACAC,MAAA;QACAC,QAAA;QACAC,cAAA;QACAS,MAAA,EAAQ;QACRC,MAAA,EAAQP,GAAA,CAAIO,MAAM;QAClBT,cAAA;QACAU,IAAA,EAAM,EAAE;QACRT,kBAAA;QACAC,GAAA;QACAS,UAAA,EAAY,EAAE;QACdR,gBAAA;QACAC,UAAA;QACAQ,YAAA,EAAc;IAChB;AACF"}},
    {"offset": {"line": 2739, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2745, "column": 0}, "map": {"version":3,"file":"graphQLPopulationPromise.js","sources":["turbopack://[project]/node_modules/@payloadcms/richtext-lexical/src/features/link/server/graphQLPopulationPromise.ts"],"sourcesContent":["import type { PopulationPromise } from '../../typesServer.js'\nimport type { SerializedLinkNode } from '../nodes/types.js'\nimport type { LinkFeatureServerProps } from './index.js'\n\nimport { recursivelyPopulateFieldsForGraphQL } from '../../../populateGraphQL/recursivelyPopulateFieldsForGraphQL.js'\n\nexport const linkPopulationPromiseHOC = (\n  props: LinkFeatureServerProps,\n): PopulationPromise<SerializedLinkNode> => {\n  return ({\n    context,\n    currentDepth,\n    depth,\n    draft,\n    editorPopulationPromises,\n    fieldPromises,\n    findMany,\n    flattenLocales,\n    node,\n    overrideAccess,\n    populationPromises,\n    req,\n    showHiddenFields,\n  }) => {\n    if (!props.fields?.length) {\n      return\n    }\n\n    /**\n     * Should populate all fields, including the doc field (for internal links), as it's treated like a normal field\n     */\n    if (Array.isArray(props.fields)) {\n      recursivelyPopulateFieldsForGraphQL({\n        context,\n        currentDepth,\n        data: node.fields,\n        depth,\n        draft,\n        editorPopulationPromises,\n        fieldPromises,\n        fields: props.fields,\n        findMany,\n        flattenLocales,\n        overrideAccess,\n        populationPromises,\n        req,\n        showHiddenFields,\n        siblingDoc: node.fields,\n      })\n    }\n  }\n}\n"],"names":["recursivelyPopulateFieldsForGraphQL","linkPopulationPromiseHOC","props","context","currentDepth","depth","draft","editorPopulationPromises","fieldPromises","findMany","flattenLocales","node","overrideAccess","populationPromises","req","showHiddenFields","fields","length","Array","isArray","data","siblingDoc"],"mappings":";;;AAIA,SAASA,mCAAmC,QAAQ;;AAE7C,MAAMC,wBAAA,IACXC,KAAA;IAEA,OAAO,CAAC,EACNC,OAAO,EACPC,YAAY,EACZC,KAAK,EACLC,KAAK,EACLC,wBAAwB,EACxBC,aAAa,EACbC,QAAQ,EACRC,cAAc,EACdC,IAAI,EACJC,cAAc,EACdC,kBAAkB,EAClBC,GAAG,EACHC,gBAAAA,EACD;QACC,IAAI,CAACb,KAAA,CAAMc,MAAM,EAAEC,MAAA,EAAQ;YACzB;QACF;QAEA;;OAGA,IAAIC,KAAA,CAAMC,OAAO,CAACjB,KAAA,CAAMc,MAAM,GAAG;sOAC/BhB,sCAAAA,AAAA,EAAoC;gBAClCG,OAAA;gBACAC,YAAA;gBACAgB,IAAA,EAAMT,IAAA,CAAKK,MAAM;gBACjBX,KAAA;gBACAC,KAAA;gBACAC,wBAAA;gBACAC,aAAA;gBACAQ,MAAA,EAAQd,KAAA,CAAMc,MAAM;gBACpBP,QAAA;gBACAC,cAAA;gBACAE,cAAA;gBACAC,kBAAA;gBACAC,GAAA;gBACAC,gBAAA;gBACAM,UAAA,EAAYV,IAAA,CAAKK,MAAAA;YACnB;QACF;IACF;AACF"}},
    {"offset": {"line": 2778, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2784, "column": 0}, "map": {"version":3,"file":"index.js","sources":["turbopack://[project]/node_modules/@payloadcms/richtext-lexical/src/features/link/server/index.ts"],"sourcesContent":["import type {\n  CollectionSlug,\n  Config,\n  DefaultDocumentIDType,\n  Field,\n  FieldAffectingData,\n  SanitizedConfig,\n} from 'payload'\n\nimport escapeHTML from 'escape-html'\nimport { sanitizeFields } from 'payload'\nimport { deepCopyObject } from 'payload/shared'\n\nimport type { ClientProps } from '../client/index.js'\n\nimport { createServerFeature } from '../../../utilities/createServerFeature.js'\nimport { convertLexicalNodesToHTML } from '../../converters/html/converter/index.js'\nimport { createNode } from '../../typeUtilities.js'\nimport { LinkMarkdownTransformer } from '../markdownTransformer.js'\nimport { AutoLinkNode } from '../nodes/AutoLinkNode.js'\nimport { LinkNode } from '../nodes/LinkNode.js'\nimport { linkPopulationPromiseHOC } from './graphQLPopulationPromise.js'\nimport { i18n } from './i18n.js'\nimport { transformExtraFields } from './transformExtraFields.js'\nimport { linkValidation } from './validate.js'\n\nexport type ExclusiveLinkCollectionsProps =\n  | {\n      /**\n       * The collections that should be disabled for internal linking. Overrides the `enableRichTextLink` property in the collection config.\n       * When this property is set, `enabledCollections` will not be available.\n       **/\n      disabledCollections?: CollectionSlug[]\n\n      // Ensures that enabledCollections is not available when disabledCollections is set\n      enabledCollections?: never\n    }\n  | {\n      // Ensures that disabledCollections is not available when enabledCollections is set\n      disabledCollections?: never\n\n      /**\n       * The collections that should be enabled for internal linking. Overrides the `enableRichTextLink` property in the collection config\n       * When this property is set, `disabledCollections` will not be available.\n       **/\n      enabledCollections?: CollectionSlug[]\n    }\n\nexport type LinkFeatureServerProps = {\n  /**\n   * A function or array defining additional fields for the link feature. These will be\n   * displayed in the link editor drawer.\n   */\n  fields?:\n    | ((args: {\n        config: SanitizedConfig\n        defaultFields: FieldAffectingData[]\n      }) => (Field | FieldAffectingData)[])\n    | Field[]\n  /**\n   * Sets a maximum population depth for the internal doc default field of link, regardless of the remaining depth when the field is reached.\n   * This behaves exactly like the maxDepth properties of relationship and upload fields.\n   *\n   * {@link https://payloadcms.com/docs/getting-started/concepts#field-level-max-depth}\n   */\n  maxDepth?: number\n} & ExclusiveLinkCollectionsProps\n\nexport const LinkFeature = createServerFeature<\n  LinkFeatureServerProps,\n  LinkFeatureServerProps,\n  ClientProps\n>({\n  feature: async ({ config: _config, isRoot, parentIsLocalized, props }) => {\n    if (!props) {\n      props = {}\n    }\n    const validRelationships = _config.collections.map((c) => c.slug) || []\n\n    const _transformedFields = transformExtraFields(\n      props.fields ? deepCopyObject(props.fields) : null,\n      _config,\n      props.enabledCollections,\n      props.disabledCollections,\n      props.maxDepth,\n    )\n\n    const sanitizedFields = await sanitizeFields({\n      config: _config as unknown as Config,\n      fields: _transformedFields,\n      parentIsLocalized,\n      requireFieldLevelRichTextEditor: isRoot,\n      validRelationships,\n    })\n    props.fields = sanitizedFields\n\n    // the text field is not included in the node data.\n    // Thus, for tasks like validation, we do not want to pass it a text field in the schema which will never have data.\n    // Otherwise, it will cause a validation error (field is required).\n    const sanitizedFieldsWithoutText = deepCopyObject(sanitizedFields).filter(\n      (field) => !('name' in field) || field.name !== 'text',\n    )\n\n    return {\n      ClientFeature: '@payloadcms/richtext-lexical/client#LinkFeatureClient',\n      clientFeatureProps: {\n        disabledCollections: props.disabledCollections,\n        enabledCollections: props.enabledCollections,\n      } as ExclusiveLinkCollectionsProps,\n      generateSchemaMap: () => {\n        if (!sanitizedFields || !Array.isArray(sanitizedFields) || sanitizedFields.length === 0) {\n          return null\n        }\n\n        const schemaMap = new Map<string, Field[]>()\n        schemaMap.set('fields', sanitizedFields)\n\n        return schemaMap\n      },\n      i18n,\n      markdownTransformers: [LinkMarkdownTransformer],\n      nodes: [\n        createNode({\n          converters: {\n            html: {\n              converter: async ({\n                converters,\n                currentDepth,\n                depth,\n                draft,\n                node,\n                overrideAccess,\n                parent,\n                req,\n                showHiddenFields,\n              }) => {\n                const childrenText = await convertLexicalNodesToHTML({\n                  converters,\n                  currentDepth,\n                  depth,\n                  draft,\n                  lexicalNodes: node.children,\n                  overrideAccess,\n                  parent: {\n                    ...node,\n                    parent,\n                  },\n                  req,\n                  showHiddenFields,\n                })\n\n                const rel: string = node.fields.newTab ? ' rel=\"noopener noreferrer\"' : ''\n                const target: string = node.fields.newTab ? ' target=\"_blank\"' : ''\n\n                let href: string = node.fields.url\n                if (node.fields.linkType === 'internal') {\n                  href =\n                    typeof node.fields.doc?.value !== 'object'\n                      ? String(node.fields.doc?.value)\n                      : String(node.fields.doc?.value?.id)\n                }\n\n                return `<a href=\"${href}\"${target}${rel}>${childrenText}</a>`\n              },\n              nodeTypes: [AutoLinkNode.getType()],\n            },\n          },\n          node: AutoLinkNode,\n          // Since AutoLinkNodes are just internal links, they need no hooks or graphQL population promises\n          validations: [linkValidation(props, sanitizedFieldsWithoutText)],\n        }),\n        createNode({\n          converters: {\n            html: {\n              converter: async ({\n                converters,\n                currentDepth,\n                depth,\n                draft,\n                node,\n                overrideAccess,\n                parent,\n                req,\n                showHiddenFields,\n              }) => {\n                const childrenText = await convertLexicalNodesToHTML({\n                  converters,\n                  currentDepth,\n                  depth,\n                  draft,\n                  lexicalNodes: node.children,\n                  overrideAccess,\n                  parent: {\n                    ...node,\n                    parent,\n                  },\n                  req,\n                  showHiddenFields,\n                })\n\n                const rel: string = node.fields.newTab ? ' rel=\"noopener noreferrer\"' : ''\n                const target: string = node.fields.newTab ? ' target=\"_blank\"' : ''\n\n                const href: string =\n                  node.fields.linkType === 'custom'\n                    ? escapeHTML(node.fields.url)\n                    : (node.fields.doc?.value as string)\n\n                return `<a href=\"${href}\"${target}${rel}>${childrenText}</a>`\n              },\n              nodeTypes: [LinkNode.getType()],\n            },\n          },\n          getSubFields: () => {\n            return sanitizedFieldsWithoutText\n          },\n          getSubFieldsData: ({ node }) => {\n            return node?.fields\n          },\n          graphQLPopulationPromises: [linkPopulationPromiseHOC(props)],\n          node: LinkNode,\n          validations: [linkValidation(props, sanitizedFieldsWithoutText)],\n        }),\n      ],\n      sanitizedServerFeatureProps: props,\n    }\n  },\n  key: 'link',\n})\n"],"names":["escapeHTML","sanitizeFields","deepCopyObject","createServerFeature","convertLexicalNodesToHTML","createNode","LinkMarkdownTransformer","AutoLinkNode","LinkNode","linkPopulationPromiseHOC","i18n","transformExtraFields","linkValidation","LinkFeature","feature","config","_config","isRoot","parentIsLocalized","props","validRelationships","collections","map","c","slug","_transformedFields","fields","enabledCollections","disabledCollections","maxDepth","sanitizedFields","requireFieldLevelRichTextEditor","sanitizedFieldsWithoutText","filter","field","name","ClientFeature","clientFeatureProps","generateSchemaMap","Array","isArray","length","schemaMap","Map","set","markdownTransformers","nodes","converters","html","converter","currentDepth","depth","draft","node","overrideAccess","parent","req","showHiddenFields","childrenText","lexicalNodes","children","rel","newTab","target","href","url","linkType","doc","value","String","id","nodeTypes","getType","validations","getSubFields","getSubFieldsData","graphQLPopulationPromises","sanitizedServerFeatureProps","key"],"mappings":"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"}},
    {"offset": {"line": 2936, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2942, "column": 0}, "map": {"version":3,"file":"i18n.js","sources":["turbopack://[project]/node_modules/@payloadcms/richtext-lexical/src/features/relationship/server/i18n.ts"],"sourcesContent":["import type { GenericLanguages } from '@payloadcms/translations'\n\nexport const i18n: Partial<GenericLanguages> = {\n  ar: {\n    label: 'العلاقة',\n  },\n  az: {\n    label: 'Münasibət',\n  },\n  bg: {\n    label: 'Връзка',\n  },\n  cs: {\n    label: 'Vztah',\n  },\n  de: {\n    label: 'Beziehung',\n  },\n  en: {\n    label: 'Relationship',\n  },\n  es: {\n    label: 'Relación',\n  },\n  fa: {\n    label: 'روابط',\n  },\n  fr: {\n    label: 'Relation',\n  },\n  he: {\n    label: 'יחסים',\n  },\n  hr: {\n    label: 'Odnos',\n  },\n  hu: {\n    label: 'Kapcsolat',\n  },\n  it: {\n    label: 'Relazione',\n  },\n  ja: {\n    label: '関係性',\n  },\n  ko: {\n    label: '관계',\n  },\n  my: {\n    label: 'Hubungan',\n  },\n  nb: {\n    label: 'Forhold',\n  },\n  nl: {\n    label: 'Relatie',\n  },\n  pl: {\n    label: 'Relacja',\n  },\n  pt: {\n    label: 'Relacionamento',\n  },\n  ro: {\n    label: 'Relație',\n  },\n  rs: {\n    label: 'Veza',\n  },\n  'rs-latin': {\n    label: 'Odnos',\n  },\n  ru: {\n    label: 'Отношения',\n  },\n  sk: {\n    label: 'Vzťah',\n  },\n  sv: {\n    label: 'Relation',\n  },\n  th: {\n    label: 'ความสัมพันธ์',\n  },\n  tr: {\n    label: 'İlişki',\n  },\n  uk: {\n    label: 'Стосунки',\n  },\n  vi: {\n    label: 'Mối quan hệ',\n  },\n  zh: {\n    label: '关系',\n  },\n  'zh-TW': {\n    label: '關係',\n  },\n}\n"],"names":["i18n","ar","label","az","bg","cs","de","en","es","fa","fr","he","hr","hu","it","ja","ko","my","nb","nl","pl","pt","ro","rs","ru","sk","sv","th","tr","uk","vi","zh"],"mappings":";;;AAEO,MAAMA,IAAA,GAAkC;IAC7CC,EAAA,EAAI;QACFC,KAAA,EAAO;IACT;IACAC,EAAA,EAAI;QACFD,KAAA,EAAO;IACT;IACAE,EAAA,EAAI;QACFF,KAAA,EAAO;IACT;IACAG,EAAA,EAAI;QACFH,KAAA,EAAO;IACT;IACAI,EAAA,EAAI;QACFJ,KAAA,EAAO;IACT;IACAK,EAAA,EAAI;QACFL,KAAA,EAAO;IACT;IACAM,EAAA,EAAI;QACFN,KAAA,EAAO;IACT;IACAO,EAAA,EAAI;QACFP,KAAA,EAAO;IACT;IACAQ,EAAA,EAAI;QACFR,KAAA,EAAO;IACT;IACAS,EAAA,EAAI;QACFT,KAAA,EAAO;IACT;IACAU,EAAA,EAAI;QACFV,KAAA,EAAO;IACT;IACAW,EAAA,EAAI;QACFX,KAAA,EAAO;IACT;IACAY,EAAA,EAAI;QACFZ,KAAA,EAAO;IACT;IACAa,EAAA,EAAI;QACFb,KAAA,EAAO;IACT;IACAc,EAAA,EAAI;QACFd,KAAA,EAAO;IACT;IACAe,EAAA,EAAI;QACFf,KAAA,EAAO;IACT;IACAgB,EAAA,EAAI;QACFhB,KAAA,EAAO;IACT;IACAiB,EAAA,EAAI;QACFjB,KAAA,EAAO;IACT;IACAkB,EAAA,EAAI;QACFlB,KAAA,EAAO;IACT;IACAmB,EAAA,EAAI;QACFnB,KAAA,EAAO;IACT;IACAoB,EAAA,EAAI;QACFpB,KAAA,EAAO;IACT;IACAqB,EAAA,EAAI;QACFrB,KAAA,EAAO;IACT;IACA,YAAY;QACVA,KAAA,EAAO;IACT;IACAsB,EAAA,EAAI;QACFtB,KAAA,EAAO;IACT;IACAuB,EAAA,EAAI;QACFvB,KAAA,EAAO;IACT;IACAwB,EAAA,EAAI;QACFxB,KAAA,EAAO;IACT;IACAyB,EAAA,EAAI;QACFzB,KAAA,EAAO;IACT;IACA0B,EAAA,EAAI;QACF1B,KAAA,EAAO;IACT;IACA2B,EAAA,EAAI;QACF3B,KAAA,EAAO;IACT;IACA4B,EAAA,EAAI;QACF5B,KAAA,EAAO;IACT;IACA6B,EAAA,EAAI;QACF7B,KAAA,EAAO;IACT;IACA,SAAS;QACPA,KAAA,EAAO;IACT;AACF"}},
    {"offset": {"line": 3043, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 3049, "column": 0}, "map": {"version":3,"file":"populate.js","sources":["turbopack://[project]/node_modules/@payloadcms/richtext-lexical/src/populateGraphQL/populate.ts"],"sourcesContent":["import type { PayloadRequest } from 'payload'\n\nimport { createDataloaderCacheKey } from 'payload'\n\ntype Arguments = {\n  currentDepth?: number\n  data: unknown\n  depth: number\n  draft: boolean\n  key: number | string\n  overrideAccess: boolean\n  req: PayloadRequest\n  showHiddenFields: boolean\n}\n\nexport const populate = async ({\n  id,\n  collectionSlug,\n  currentDepth,\n  data,\n  depth,\n  draft,\n  key,\n  overrideAccess,\n  req,\n  showHiddenFields,\n}: {\n  collectionSlug: string\n  id: number | string\n} & Arguments): Promise<void> => {\n  const shouldPopulate = depth && currentDepth! <= depth\n  // usually depth is checked within recursivelyPopulateFieldsForGraphQL. But since this populate function can be called outside of that (in rest afterRead node hooks) we need to check here too\n  if (!shouldPopulate) {\n    return\n  }\n\n  const dataRef = data as Record<string, unknown>\n\n  const doc = await req.payloadDataLoader?.load(\n    createDataloaderCacheKey({\n      collectionSlug,\n      currentDepth: currentDepth! + 1,\n      depth,\n      docID: id as string,\n      draft,\n      fallbackLocale: req.fallbackLocale!,\n      locale: req.locale!,\n      overrideAccess,\n      showHiddenFields,\n      transactionID: req.transactionID!,\n    }),\n  )\n\n  if (doc) {\n    dataRef[key] = doc\n  } else {\n    dataRef[key] = null\n  }\n}\n"],"names":["createDataloaderCacheKey","populate","id","collectionSlug","currentDepth","data","depth","draft","key","overrideAccess","req","showHiddenFields","shouldPopulate","dataRef","doc","payloadDataLoader","load","docID","fallbackLocale","locale","transactionID"],"mappings":";;;AAEA,SAASA,wBAAwB,QAAQ;;AAalC,MAAMC,QAAA,GAAW,MAAAA,CAAO,EAC7BC,EAAE,EACFC,cAAc,EACdC,YAAY,EACZC,IAAI,EACJC,KAAK,EACLC,KAAK,EACLC,GAAG,EACHC,cAAc,EACdC,GAAG,EACHC,gBAAAA,EAIW;IACX,MAAMC,cAAA,GAAiBN,KAAA,IAASF,YAAA,IAAiBE,KAAA;IACjD,+LAAA;IACA,IAAI,CAACM,cAAA,EAAgB;QACnB;IACF;IAEA,MAAMC,OAAA,GAAUR,IAAA;IAEhB,MAAMS,GAAA,GAAM,MAAMJ,GAAA,CAAIK,iBAAiB,EAAEC,IAAA,EACvChB,2LAAAA,AAAA,EAAyB;QACvBG,cAAA;QACAC,YAAA,EAAcA,YAAA,GAAgB;QAC9BE,KAAA;QACAW,KAAA,EAAOf,EAAA;QACPK,KAAA;QACAW,cAAA,EAAgBR,GAAA,CAAIQ,cAAc;QAClCC,MAAA,EAAQT,GAAA,CAAIS,MAAM;QAClBV,cAAA;QACAE,gBAAA;QACAS,aAAA,EAAeV,GAAA,CAAIU,aAAAA;IACrB;IAGF,IAAIN,GAAA,EAAK;QACPD,OAAO,CAACL,GAAA,CAAI,GAAGM,GAAA;IACjB,OAAO;QACLD,OAAO,CAACL,GAAA,CAAI,GAAG;IACjB;AACF"}},
    {"offset": {"line": 3079, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 3085, "column": 0}, "map": {"version":3,"file":"graphQLPopulationPromise.js","sources":["turbopack://[project]/node_modules/@payloadcms/richtext-lexical/src/features/relationship/server/graphQLPopulationPromise.ts"],"sourcesContent":["import type { PopulationPromise } from '../../typesServer.js'\nimport type { RelationshipFeatureProps } from './index.js'\nimport type { SerializedRelationshipNode } from './nodes/RelationshipNode.js'\n\nimport { populate } from '../../../populateGraphQL/populate.js'\n\nexport const relationshipPopulationPromiseHOC = (\n  props: RelationshipFeatureProps,\n): PopulationPromise<SerializedRelationshipNode> => {\n  const relationshipPopulationPromise: PopulationPromise<SerializedRelationshipNode> = ({\n    currentDepth,\n    depth,\n    draft,\n    node,\n    overrideAccess,\n    populationPromises,\n    req,\n    showHiddenFields,\n  }) => {\n    if (node?.value) {\n      // @ts-expect-error\n      const id = node?.value?.id || node?.value // for backwards-compatibility\n\n      const collection = req.payload.collections[node?.relationTo]\n\n      if (collection) {\n        const populateDepth =\n          props?.maxDepth !== undefined && props?.maxDepth < depth ? props?.maxDepth : depth\n\n        populationPromises.push(\n          populate({\n            id,\n            collectionSlug: collection.config.slug,\n            currentDepth,\n            data: node,\n            depth: populateDepth,\n            draft,\n            key: 'value',\n            overrideAccess,\n            req,\n            showHiddenFields,\n          }),\n        )\n      }\n    }\n  }\n\n  return relationshipPopulationPromise\n}\n"],"names":["populate","relationshipPopulationPromiseHOC","props","relationshipPopulationPromise","currentDepth","depth","draft","node","overrideAccess","populationPromises","req","showHiddenFields","value","id","collection","payload","collections","relationTo","populateDepth","maxDepth","undefined","push","collectionSlug","config","slug","data","key"],"mappings":";;;AAIA,SAASA,QAAQ,QAAQ;;AAElB,MAAMC,gCAAA,IACXC,KAAA;IAEA,MAAMC,6BAAA,GAA+EA,CAAC,EACpFC,YAAY,EACZC,KAAK,EACLC,KAAK,EACLC,IAAI,EACJC,cAAc,EACdC,kBAAkB,EAClBC,GAAG,EACHC,gBAAAA,EACD;QACC,IAAIJ,IAAA,EAAMK,KAAA,EAAO;YACf,mBAAA;YACA,MAAMC,EAAA,GAAKN,IAAA,EAAMK,KAAA,EAAOC,EAAA,IAAMN,IAAA,EAAMK,KAAA,CAAM,8BAAA;;YAE1C,MAAME,UAAA,GAAaJ,GAAA,CAAIK,OAAO,CAACC,WAAW,CAACT,IAAA,EAAMU,UAAA,CAAW;YAE5D,IAAIH,UAAA,EAAY;gBACd,MAAMI,aAAA,GACJhB,KAAA,EAAOiB,QAAA,KAAaC,SAAA,IAAalB,KAAA,EAAOiB,QAAA,GAAWd,KAAA,GAAQH,KAAA,EAAOiB,QAAA,GAAWd,KAAA;gBAE/EI,kBAAA,CAAmBY,IAAI,gMACrBrB,WAAAA,AAAA,EAAS;oBACPa,EAAA;oBACAS,cAAA,EAAgBR,UAAA,CAAWS,MAAM,CAACC,IAAI;oBACtCpB,YAAA;oBACAqB,IAAA,EAAMlB,IAAA;oBACNF,KAAA,EAAOa,aAAA;oBACPZ,KAAA;oBACAoB,GAAA,EAAK;oBACLlB,cAAA;oBACAE,GAAA;oBACAC;gBACF;YAEJ;QACF;IACF;IAEA,OAAOR,6BAAA;AACT"}},
    {"offset": {"line": 3116, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 3122, "column": 0}, "map": {"version":3,"file":"RelationshipNode.js","sources":["turbopack://[project]/node_modules/@payloadcms/richtext-lexical/src/features/relationship/server/nodes/RelationshipNode.tsx"],"sourcesContent":["import type { SerializedDecoratorBlockNode } from '@lexical/react/LexicalDecoratorBlockNode.js'\nimport type {\n  DOMConversionMap,\n  DOMConversionOutput,\n  DOMExportOutput,\n  EditorConfig,\n  ElementFormatType,\n  LexicalEditor,\n  LexicalNode,\n  NodeKey,\n  Spread,\n} from 'lexical'\nimport type { CollectionSlug, DataFromCollectionSlug } from 'payload'\nimport type { JSX } from 'react'\n\nimport { DecoratorBlockNode } from '@lexical/react/LexicalDecoratorBlockNode.js'\n\nexport type RelationshipData = {\n  [TCollectionSlug in CollectionSlug]: {\n    relationTo: TCollectionSlug\n    value: DataFromCollectionSlug<TCollectionSlug> | number | string\n  }\n}[CollectionSlug]\n\nexport type SerializedRelationshipNode = {\n  children?: never // required so that our typed editor state doesn't automatically add children\n  type: 'relationship'\n} & Spread<RelationshipData, SerializedDecoratorBlockNode>\n\nfunction $relationshipElementToServerNode(domNode: HTMLDivElement): DOMConversionOutput | null {\n  const id = domNode.getAttribute('data-lexical-relationship-id')\n  const relationTo = domNode.getAttribute('data-lexical-relationship-relationTo')\n\n  if (id != null && relationTo != null) {\n    const node = $createServerRelationshipNode({\n      relationTo,\n      value: id,\n    })\n    return { node }\n  }\n  return null\n}\n\nexport class RelationshipServerNode extends DecoratorBlockNode {\n  __data: RelationshipData\n\n  constructor({\n    data,\n    format,\n    key,\n  }: {\n    data: RelationshipData\n    format?: ElementFormatType\n    key?: NodeKey\n  }) {\n    super(format, key)\n    this.__data = data\n  }\n\n  static clone(node: RelationshipServerNode): RelationshipServerNode {\n    return new this({\n      data: node.__data,\n      format: node.__format,\n      key: node.__key,\n    })\n  }\n\n  static getType(): string {\n    return 'relationship'\n  }\n\n  static importDOM(): DOMConversionMap<HTMLDivElement> | null {\n    return {\n      div: (domNode: HTMLDivElement) => {\n        if (\n          !domNode.hasAttribute('data-lexical-relationship-relationTo') ||\n          !domNode.hasAttribute('data-lexical-relationship-id')\n        ) {\n          return null\n        }\n        return {\n          conversion: $relationshipElementToServerNode,\n          priority: 2,\n        }\n      },\n    }\n  }\n\n  static importJSON(serializedNode: SerializedRelationshipNode): RelationshipServerNode {\n    if (serializedNode.version === 1 && (serializedNode?.value as unknown as { id: string })?.id) {\n      serializedNode.value = (serializedNode.value as unknown as { id: string }).id\n    }\n\n    const importedData: RelationshipData = {\n      relationTo: serializedNode.relationTo,\n      value: serializedNode.value,\n    }\n    const node = $createServerRelationshipNode(importedData)\n    node.setFormat(serializedNode.format)\n    return node\n  }\n\n  static isInline(): false {\n    return false\n  }\n\n  decorate(editor: LexicalEditor, config: EditorConfig): JSX.Element | null {\n    return null\n  }\n\n  exportDOM(): DOMExportOutput {\n    const element = document.createElement('div')\n    element.setAttribute('data-lexical-relationship-id', String(this.__data?.value))\n    element.setAttribute('data-lexical-relationship-relationTo', this.__data?.relationTo)\n\n    const text = document.createTextNode(this.getTextContent())\n    element.append(text)\n    return { element }\n  }\n\n  exportJSON(): SerializedRelationshipNode {\n    return {\n      ...super.exportJSON(),\n      ...this.getData(),\n      type: 'relationship',\n      version: 2,\n    }\n  }\n\n  getData(): RelationshipData {\n    return this.getLatest().__data\n  }\n\n  getTextContent(): string {\n    return `${this.__data?.relationTo} relation to ${this.__data?.value}`\n  }\n\n  setData(data: RelationshipData): void {\n    const writable = this.getWritable()\n    writable.__data = data\n  }\n}\n\nexport function $createServerRelationshipNode(data: RelationshipData): RelationshipServerNode {\n  return new RelationshipServerNode({\n    data,\n  })\n}\n\nexport function $isServerRelationshipNode(\n  node: LexicalNode | null | RelationshipServerNode | undefined,\n): node is RelationshipServerNode {\n  return node instanceof RelationshipServerNode\n}\n"],"names":["DecoratorBlockNode","$relationshipElementToServerNode","domNode","id","getAttribute","relationTo","node","$createServerRelationshipNode","value","RelationshipServerNode","__data","constructor","data","format","key","clone","__format","__key","getType","importDOM","div","hasAttribute","conversion","priority","importJSON","serializedNode","version","importedData","setFormat","isInline","decorate","editor","config","exportDOM","element","document","createElement","setAttribute","String","text","createTextNode","getTextContent","append","exportJSON","getData","type","getLatest","setData","writable","getWritable","$isServerRelationshipNode"],"mappings":"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"}},
    {"offset": {"line": 3227, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 3233, "column": 0}, "map": {"version":3,"file":"index.js","sources":["turbopack://[project]/node_modules/@payloadcms/richtext-lexical/src/features/relationship/server/index.ts"],"sourcesContent":["import type { CollectionSlug } from 'payload'\n\nimport { populate } from '../../../populateGraphQL/populate.js'\nimport { createServerFeature } from '../../../utilities/createServerFeature.js'\nimport { createNode } from '../../typeUtilities.js'\nimport { relationshipPopulationPromiseHOC } from './graphQLPopulationPromise.js'\nimport { i18n } from './i18n.js'\nimport { RelationshipServerNode } from './nodes/RelationshipNode.js'\n\nexport type ExclusiveRelationshipFeatureProps =\n  | {\n      /**\n       * The collections that should be disabled. Overrides the `enableRichTextRelationship` property in the collection config.\n       * When this property is set, `enabledCollections` will not be available.\n       **/\n      disabledCollections?: CollectionSlug[]\n\n      // Ensures that enabledCollections is not available when disabledCollections is set\n      enabledCollections?: never\n    }\n  | {\n      // Ensures that disabledCollections is not available when enabledCollections is set\n      disabledCollections?: never\n\n      /**\n       * The collections that should be enabled. Overrides the `enableRichTextRelationship` property in the collection config\n       * When this property is set, `disabledCollections` will not be available.\n       **/\n      enabledCollections?: CollectionSlug[]\n    }\n\nexport type RelationshipFeatureProps = {\n  /**\n   * Sets a maximum population depth for this relationship, regardless of the remaining depth when the respective field is reached.\n   * This behaves exactly like the maxDepth properties of relationship and upload fields.\n   *\n   * {@link https://payloadcms.com/docs/getting-started/concepts#field-level-max-depth}\n   */\n  maxDepth?: number\n} & ExclusiveRelationshipFeatureProps\n\nexport const RelationshipFeature = createServerFeature<\n  RelationshipFeatureProps,\n  RelationshipFeatureProps,\n  ExclusiveRelationshipFeatureProps\n>({\n  feature: ({ props }) => {\n    // we don't need to pass maxDepth to the client, it's only used on the server\n    const { maxDepth, ...clientFeatureProps } = props ?? {}\n    return {\n      ClientFeature: '@payloadcms/richtext-lexical/client#RelationshipFeatureClient',\n      clientFeatureProps,\n      i18n,\n      nodes: [\n        createNode({\n          graphQLPopulationPromises: [relationshipPopulationPromiseHOC(props)],\n          hooks: {\n            afterRead: [\n              ({\n                currentDepth,\n                depth,\n                draft,\n                node,\n                overrideAccess,\n                populationPromises,\n                req,\n                showHiddenFields,\n              }) => {\n                if (!node?.value) {\n                  return node\n                }\n                const collection = req.payload.collections[node?.relationTo]\n\n                if (!collection) {\n                  return node\n                }\n                // @ts-expect-error\n                const id = node?.value?.id || node?.value // for backwards-compatibility\n\n                const populateDepth = maxDepth !== undefined && maxDepth < depth ? maxDepth : depth\n\n                populationPromises.push(\n                  populate({\n                    id,\n                    collectionSlug: collection.config.slug,\n                    currentDepth,\n                    data: node,\n                    depth: populateDepth,\n                    draft,\n                    key: 'value',\n                    overrideAccess,\n                    req,\n                    showHiddenFields,\n                  }),\n                )\n\n                return node\n              },\n            ],\n          },\n          node: RelationshipServerNode,\n        }),\n      ],\n    }\n  },\n  key: 'relationship',\n})\n"],"names":["populate","createServerFeature","createNode","relationshipPopulationPromiseHOC","i18n","RelationshipServerNode","RelationshipFeature","feature","props","maxDepth","clientFeatureProps","ClientFeature","nodes","graphQLPopulationPromises","hooks","afterRead","currentDepth","depth","draft","node","overrideAccess","populationPromises","req","showHiddenFields","value","collection","payload","collections","relationTo","id","populateDepth","undefined","push","collectionSlug","config","slug","data","key"],"mappings":";;;AAGA,SAASC,mBAAmB,QAAQ;AAGpC,SAASG,IAAI,QAAQ;AAFrB,SAASF,UAAU,QAAQ;AAC3B,SAASC,gCAAgC,QAAQ;AAHjD,SAASH,QAAQ,QAAQ;AAKzB,SAASK,sBAAsB,QAAQ;;;;;;;AAkChC,MAAMC,mBAAA,uMAAsBL,sBAAAA,AAAA,EAIjC;IACAM,OAAA,EAASA,CAAC,EAAEC,KAAAA,EAAO;QACjB,6EAAA;QACA,MAAM,EAAEC,QAAQ,EAAE,GAAGC,oBAAoB,GAAGF,KAAA,IAAS,CAAC;QACtD,OAAO;YACLG,aAAA,EAAe;YACfD,kBAAA;4NACAN,OAAA;YACAQ,KAAA,EAAO;6MACLV,aAAA,AAAAA,EAAW;oBACTW,yBAAA,EAA2B;0PAACV,mCAAAA,AAAA,EAAiCK,KAAA;qBAAO;oBACpEM,KAAA,EAAO;wBACLC,SAAA,EAAW;4BACT,CAAC,EACCC,YAAY,EACZC,KAAK,EACLC,KAAK,EACLC,IAAI,EACJC,cAAc,EACdC,kBAAkB,EAClBC,GAAG,EACHC,gBAAAA,EACD;gCACC,IAAI,CAACJ,IAAA,EAAMK,KAAA,EAAO;oCAChB,OAAOL,IAAA;gCACT;gCACA,MAAMM,UAAA,GAAaH,GAAA,CAAII,OAAO,CAACC,WAAW,CAACR,IAAA,EAAMS,UAAA,CAAW;gCAE5D,IAAI,CAACH,UAAA,EAAY;oCACf,OAAON,IAAA;gCACT;gCACA,mBAAA;gCACA,MAAMU,EAAA,GAAKV,IAAA,EAAMK,KAAA,EAAOK,EAAA,IAAMV,IAAA,EAAMK,KAAA,CAAM,8BAAA;;gCAE1C,MAAMM,aAAA,GAAgBrB,QAAA,KAAasB,SAAA,IAAatB,QAAA,GAAWQ,KAAA,GAAQR,QAAA,GAAWQ,KAAA;gCAE9EI,kBAAA,CAAmBW,IAAI,gMACrBhC,WAAAA,AAAA,EAAS;oCACP6B,EAAA;oCACAI,cAAA,EAAgBR,UAAA,CAAWS,MAAM,CAACC,IAAI;oCACtCnB,YAAA;oCACAoB,IAAA,EAAMjB,IAAA;oCACNF,KAAA,EAAOa,aAAA;oCACPZ,KAAA;oCACAmB,GAAA,EAAK;oCACLjB,cAAA;oCACAE,GAAA;oCACAC;gCACF;gCAGF,OAAOJ,IAAA;4BACT;yBAAA;oBAEJ;oBACAA,IAAA,iOAAMd,yBAAAA;gBACR;aAAA;QAEJ;IACF;IACAgC,GAAA,EAAK;AACP"}},
    {"offset": {"line": 3298, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 3304, "column": 0}, "map": {"version":3,"file":"i18n.js","sources":["turbopack://[project]/node_modules/@payloadcms/richtext-lexical/src/features/blockquote/server/i18n.ts"],"sourcesContent":["import type { GenericLanguages } from '@payloadcms/translations'\n\nexport const i18n: Partial<GenericLanguages> = {\n  ar: {\n    label: 'اقتباس',\n  },\n  az: {\n    label: 'Blokkvota',\n  },\n  bg: {\n    label: 'Цитат',\n  },\n  cs: {\n    label: 'Citace',\n  },\n  de: {\n    label: 'Blockzitat',\n  },\n  en: {\n    label: 'Blockquote',\n  },\n  es: {\n    label: 'Cita en bloque',\n  },\n  fa: {\n    label: 'نقل قول بلوکی',\n  },\n  fr: {\n    label: 'Citation',\n  },\n  he: {\n    label: 'בלוק ציטוט',\n  },\n  hr: {\n    label: 'Blok citat',\n  },\n  hu: {\n    label: 'Idézetblokk',\n  },\n  it: {\n    label: 'Citazione',\n  },\n  ja: {\n    label: 'ブロッククォート',\n  },\n  ko: {\n    label: '인용구',\n  },\n  my: {\n    label: 'ဒေါင်းချီးခြင်း',\n  },\n  nb: {\n    label: 'Blokksitat',\n  },\n  nl: {\n    label: 'Citaat',\n  },\n  pl: {\n    label: 'Cytat blokowy',\n  },\n  pt: {\n    label: 'Citação em bloco',\n  },\n  ro: {\n    label: 'Citat',\n  },\n  rs: {\n    label: 'Blok citat',\n  },\n  'rs-latin': {\n    label: 'Blok citata',\n  },\n  ru: {\n    label: 'Цитата',\n  },\n  sk: {\n    label: 'Citát',\n  },\n  sv: {\n    label: 'Blockcitat',\n  },\n  th: {\n    label: '[SKIPPED]',\n  },\n  tr: {\n    label: 'Alıntı',\n  },\n  uk: {\n    label: 'Блокцитата',\n  },\n  vi: {\n    label: 'Trích dẫn',\n  },\n  zh: {\n    label: '块引用',\n  },\n  'zh-TW': {\n    label: '引用塊',\n  },\n}\n"],"names":["i18n","ar","label","az","bg","cs","de","en","es","fa","fr","he","hr","hu","it","ja","ko","my","nb","nl","pl","pt","ro","rs","ru","sk","sv","th","tr","uk","vi","zh"],"mappings":";;;AAEO,MAAMA,IAAA,GAAkC;IAC7CC,EAAA,EAAI;QACFC,KAAA,EAAO;IACT;IACAC,EAAA,EAAI;QACFD,KAAA,EAAO;IACT;IACAE,EAAA,EAAI;QACFF,KAAA,EAAO;IACT;IACAG,EAAA,EAAI;QACFH,KAAA,EAAO;IACT;IACAI,EAAA,EAAI;QACFJ,KAAA,EAAO;IACT;IACAK,EAAA,EAAI;QACFL,KAAA,EAAO;IACT;IACAM,EAAA,EAAI;QACFN,KAAA,EAAO;IACT;IACAO,EAAA,EAAI;QACFP,KAAA,EAAO;IACT;IACAQ,EAAA,EAAI;QACFR,KAAA,EAAO;IACT;IACAS,EAAA,EAAI;QACFT,KAAA,EAAO;IACT;IACAU,EAAA,EAAI;QACFV,KAAA,EAAO;IACT;IACAW,EAAA,EAAI;QACFX,KAAA,EAAO;IACT;IACAY,EAAA,EAAI;QACFZ,KAAA,EAAO;IACT;IACAa,EAAA,EAAI;QACFb,KAAA,EAAO;IACT;IACAc,EAAA,EAAI;QACFd,KAAA,EAAO;IACT;IACAe,EAAA,EAAI;QACFf,KAAA,EAAO;IACT;IACAgB,EAAA,EAAI;QACFhB,KAAA,EAAO;IACT;IACAiB,EAAA,EAAI;QACFjB,KAAA,EAAO;IACT;IACAkB,EAAA,EAAI;QACFlB,KAAA,EAAO;IACT;IACAmB,EAAA,EAAI;QACFnB,KAAA,EAAO;IACT;IACAoB,EAAA,EAAI;QACFpB,KAAA,EAAO;IACT;IACAqB,EAAA,EAAI;QACFrB,KAAA,EAAO;IACT;IACA,YAAY;QACVA,KAAA,EAAO;IACT;IACAsB,EAAA,EAAI;QACFtB,KAAA,EAAO;IACT;IACAuB,EAAA,EAAI;QACFvB,KAAA,EAAO;IACT;IACAwB,EAAA,EAAI;QACFxB,KAAA,EAAO;IACT;IACAyB,EAAA,EAAI;QACFzB,KAAA,EAAO;IACT;IACA0B,EAAA,EAAI;QACF1B,KAAA,EAAO;IACT;IACA2B,EAAA,EAAI;QACF3B,KAAA,EAAO;IACT;IACA4B,EAAA,EAAI;QACF5B,KAAA,EAAO;IACT;IACA6B,EAAA,EAAI;QACF7B,KAAA,EAAO;IACT;IACA,SAAS;QACPA,KAAA,EAAO;IACT;AACF"}},
    {"offset": {"line": 3405, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 3411, "column": 0}, "map": {"version":3,"file":"markdownTransformer.js","sources":["turbopack://[project]/node_modules/@payloadcms/richtext-lexical/src/features/blockquote/markdownTransformer.ts"],"sourcesContent":["import type { ElementTransformer } from '@lexical/markdown'\n\nimport { $createQuoteNode, $isQuoteNode, QuoteNode } from '@lexical/rich-text'\nimport { $createLineBreakNode } from 'lexical'\n\nexport const MarkdownTransformer: ElementTransformer = {\n  type: 'element',\n  dependencies: [QuoteNode],\n  export: (node, exportChildren) => {\n    if (!$isQuoteNode(node)) {\n      return null\n    }\n\n    const lines = exportChildren(node).split('\\n')\n    const output: string[] = []\n    for (const line of lines) {\n      output.push('> ' + line)\n    }\n    return output.join('\\n')\n  },\n  regExp: /^>\\s/,\n  replace: (parentNode, children, _match, isImport) => {\n    if (isImport) {\n      const previousNode = parentNode.getPreviousSibling()\n      if ($isQuoteNode(previousNode)) {\n        previousNode.splice(previousNode.getChildrenSize(), 0, [\n          $createLineBreakNode(),\n          ...children,\n        ])\n        previousNode.select(0, 0)\n        parentNode.remove()\n        return\n      }\n    }\n\n    const node = $createQuoteNode()\n    node.append(...children)\n    parentNode.replace(node)\n    node.select(0, 0)\n  },\n}\n"],"names":["$createQuoteNode","$isQuoteNode","QuoteNode","$createLineBreakNode","MarkdownTransformer","type","dependencies","export","node","exportChildren","lines","split","output","line","push","join","regExp","replace","parentNode","children","_match","isImport","previousNode","getPreviousSibling","splice","getChildrenSize","select","remove","append"],"mappings":";;;AAEA,SAASA,gBAAgB,EAAEC,YAAY,EAAEC,SAAS,QAAQ;AAC1D,SAASC,oBAAoB,QAAQ;;;AAE9B,MAAMC,mBAAA,GAA0C;IACrDC,IAAA,EAAM;IACNC,YAAA,EAAc;6KAACJ,YAAA;KAAU;IACzBK,MAAA,EAAQA,CAACC,IAAA,EAAMC,cAAA;QACb,IAAI,CAACR,wLAAAA,AAAA,EAAaO,IAAA,GAAO;YACvB,OAAO;QACT;QAEA,MAAME,KAAA,GAAQD,cAAA,CAAeD,IAAA,EAAMG,KAAK,CAAC;QACzC,MAAMC,MAAA,GAAmB,EAAE;QAC3B,KAAK,MAAMC,IAAA,IAAQH,KAAA,CAAO;YACxBE,MAAA,CAAOE,IAAI,CAAC,OAAOD,IAAA;QACrB;QACA,OAAOD,MAAA,CAAOG,IAAI,CAAC;IACrB;IACAC,MAAA,EAAQ;IACRC,OAAA,EAASA,CAACC,UAAA,EAAYC,QAAA,EAAUC,MAAA,EAAQC,QAAA;QACtC,IAAIA,QAAA,EAAU;YACZ,MAAMC,YAAA,GAAeJ,UAAA,CAAWK,kBAAkB;YAClD,IAAItB,wLAAAA,AAAA,EAAaqB,YAAA,GAAe;gBAC9BA,YAAA,CAAaE,MAAM,CAACF,YAAA,CAAaG,eAAe,IAAI,GAAG;mKACrDtB,uBAAAA,AAAA,I;uBACGgB,QAAA;iBACJ;gBACDG,YAAA,CAAaI,MAAM,CAAC,GAAG;gBACvBR,UAAA,CAAWS,MAAM;gBACjB;YACF;QACF;QAEA,MAAMnB,IAAA,4KAAOR,mBAAAA,AAAA;QACbQ,IAAA,CAAKoB,MAAM,IAAIT,QAAA;QACfD,UAAA,CAAWD,OAAO,CAACT,IAAA;QACnBA,IAAA,CAAKkB,MAAM,CAAC,GAAG;IACjB;AACF"}},
    {"offset": {"line": 3454, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 3460, "column": 0}, "map": {"version":3,"file":"index.js","sources":["turbopack://[project]/node_modules/@payloadcms/richtext-lexical/src/features/blockquote/server/index.ts"],"sourcesContent":["import type { SerializedQuoteNode as _SerializedQuoteNode } from '@lexical/rich-text'\nimport type { Spread } from 'lexical'\n\nimport { QuoteNode } from '@lexical/rich-text'\n\nimport { createServerFeature } from '../../../utilities/createServerFeature.js'\nimport { convertLexicalNodesToHTML } from '../../converters/html/converter/index.js'\nimport { createNode } from '../../typeUtilities.js'\nimport { MarkdownTransformer } from '../markdownTransformer.js'\nimport { i18n } from './i18n.js'\n\nexport type SerializedQuoteNode = Spread<\n  {\n    type: 'quote'\n  },\n  _SerializedQuoteNode\n>\n\nexport const BlockquoteFeature = createServerFeature({\n  feature: {\n    ClientFeature: '@payloadcms/richtext-lexical/client#BlockquoteFeatureClient',\n    clientFeatureProps: null,\n    i18n,\n    markdownTransformers: [MarkdownTransformer],\n    nodes: [\n      createNode({\n        converters: {\n          html: {\n            converter: async ({\n              converters,\n              currentDepth,\n              depth,\n              draft,\n              node,\n              overrideAccess,\n              parent,\n              req,\n              showHiddenFields,\n            }) => {\n              const childrenText = await convertLexicalNodesToHTML({\n                converters,\n                currentDepth,\n                depth,\n                draft,\n                lexicalNodes: node.children,\n                overrideAccess,\n                parent: {\n                  ...node,\n                  parent,\n                },\n                req,\n                showHiddenFields,\n              })\n\n              return `<blockquote>${childrenText}</blockquote>`\n            },\n            nodeTypes: [QuoteNode.getType()],\n          },\n        },\n        node: QuoteNode,\n      }),\n    ],\n  },\n  key: 'blockquote',\n})\n"],"names":["QuoteNode","createServerFeature","convertLexicalNodesToHTML","createNode","MarkdownTransformer","i18n","BlockquoteFeature","feature","ClientFeature","clientFeatureProps","markdownTransformers","nodes","converters","html","converter","currentDepth","depth","draft","node","overrideAccess","parent","req","showHiddenFields","childrenText","lexicalNodes","children","nodeTypes","getType","key"],"mappings":";;;AAKA,SAASC,mBAAmB,QAAQ;AAIpC,SAASI,IAAI,QAAQ;AADrB,SAASD,mBAAmB,QAAQ;AADpC,SAASD,UAAU,QAAQ;AAD3B,SAASD,yBAAyB,QAAQ;AAH1C,SAASF,SAAS,QAAQ;;;;;;;AAenB,MAAMM,iBAAA,uMAAoBL,sBAAAA,AAAA,EAAoB;IACnDM,OAAA,EAAS;QACPC,aAAA,EAAe;QACfC,kBAAA,EAAoB;qNACpBJ,QAAA;QACAK,oBAAA,EAAsB;yNAACN,sBAAA;SAAoB;QAC3CO,KAAA,EAAO;yMACLR,aAAAA,AAAA,EAAW;gBACTS,UAAA,EAAY;oBACVC,IAAA,EAAM;wBACJC,SAAA,EAAW,MAAAA,CAAO,EAChBF,UAAU,EACVG,YAAY,EACZC,KAAK,EACLC,KAAK,EACLC,IAAI,EACJC,cAAc,EACdC,MAAM,EACNC,GAAG,EACHC,gBAAAA,EACD;4BACC,MAAMC,YAAA,GAAe,MAAMrB,oPAAAA,AAAA,EAA0B;gCACnDU,UAAA;gCACAG,YAAA;gCACAC,KAAA;gCACAC,KAAA;gCACAO,YAAA,EAAcN,IAAA,CAAKO,QAAQ;gCAC3BN,cAAA;gCACAC,MAAA,EAAQ;oCACN,GAAGF,IAAI;oCACPE;gCACF;gCACAC,GAAA;gCACAC;4BACF;4BAEA,OAAO,CAAA,YAAA,EAAeC,YAAA,CAAA,aAAA,CAA2B;wBACnD;wBACAG,SAAA,EAAW;iMAAC1B,YAAA,CAAU2B,OAAO;yBAAA;oBAC/B;gBACF;gBACAT,IAAA,uKAAMlB,YAAAA;YACR;SAAA;IAEJ;IACA4B,GAAA,EAAK;AACP"}},
    {"offset": {"line": 3515, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 3521, "column": 0}, "map": {"version":3,"file":"i18n.js","sources":["turbopack://[project]/node_modules/@payloadcms/richtext-lexical/src/features/upload/server/i18n.ts"],"sourcesContent":["import type { GenericLanguages } from '@payloadcms/translations'\n\nexport const i18n: Partial<GenericLanguages> = {\n  ar: {\n    label: 'تحميل',\n  },\n  az: {\n    label: 'Yükləyin',\n  },\n  bg: {\n    label: 'Качване',\n  },\n  cs: {\n    label: 'Nahrát',\n  },\n  de: {\n    label: 'Datei',\n  },\n  en: {\n    label: 'Upload',\n  },\n  es: {\n    label: 'Subir',\n  },\n  fa: {\n    label: 'بارگذاری',\n  },\n  fr: {\n    label: 'Télécharger',\n  },\n  he: {\n    label: 'העלה',\n  },\n  hr: {\n    label: 'Prenesi',\n  },\n  hu: {\n    label: 'Feltöltés',\n  },\n  it: {\n    label: 'Carica',\n  },\n  ja: {\n    label: 'アップロード',\n  },\n  ko: {\n    label: '업로드',\n  },\n  my: {\n    label: 'တင်ပြီး',\n  },\n  nb: {\n    label: 'Last opp',\n  },\n  nl: {\n    label: 'Uploaden',\n  },\n  pl: {\n    label: 'Prześlij',\n  },\n  pt: {\n    label: 'Carregar',\n  },\n  ro: {\n    label: 'Încarcă',\n  },\n  rs: {\n    label: 'Otpremi',\n  },\n  'rs-latin': {\n    label: 'Otpremi',\n  },\n  ru: {\n    label: 'Загрузить',\n  },\n  sk: {\n    label: 'Nahrať',\n  },\n  sv: {\n    label: 'Ladda upp',\n  },\n  th: {\n    label: 'อัปโหลด',\n  },\n  tr: {\n    label: 'Yükle',\n  },\n  uk: {\n    label: 'Завантажити',\n  },\n  vi: {\n    label: 'Tải lên',\n  },\n  zh: {\n    label: '上传',\n  },\n  'zh-TW': {\n    label: '上傳',\n  },\n}\n"],"names":["i18n","ar","label","az","bg","cs","de","en","es","fa","fr","he","hr","hu","it","ja","ko","my","nb","nl","pl","pt","ro","rs","ru","sk","sv","th","tr","uk","vi","zh"],"mappings":";;;AAEO,MAAMA,IAAA,GAAkC;IAC7CC,EAAA,EAAI;QACFC,KAAA,EAAO;IACT;IACAC,EAAA,EAAI;QACFD,KAAA,EAAO;IACT;IACAE,EAAA,EAAI;QACFF,KAAA,EAAO;IACT;IACAG,EAAA,EAAI;QACFH,KAAA,EAAO;IACT;IACAI,EAAA,EAAI;QACFJ,KAAA,EAAO;IACT;IACAK,EAAA,EAAI;QACFL,KAAA,EAAO;IACT;IACAM,EAAA,EAAI;QACFN,KAAA,EAAO;IACT;IACAO,EAAA,EAAI;QACFP,KAAA,EAAO;IACT;IACAQ,EAAA,EAAI;QACFR,KAAA,EAAO;IACT;IACAS,EAAA,EAAI;QACFT,KAAA,EAAO;IACT;IACAU,EAAA,EAAI;QACFV,KAAA,EAAO;IACT;IACAW,EAAA,EAAI;QACFX,KAAA,EAAO;IACT;IACAY,EAAA,EAAI;QACFZ,KAAA,EAAO;IACT;IACAa,EAAA,EAAI;QACFb,KAAA,EAAO;IACT;IACAc,EAAA,EAAI;QACFd,KAAA,EAAO;IACT;IACAe,EAAA,EAAI;QACFf,KAAA,EAAO;IACT;IACAgB,EAAA,EAAI;QACFhB,KAAA,EAAO;IACT;IACAiB,EAAA,EAAI;QACFjB,KAAA,EAAO;IACT;IACAkB,EAAA,EAAI;QACFlB,KAAA,EAAO;IACT;IACAmB,EAAA,EAAI;QACFnB,KAAA,EAAO;IACT;IACAoB,EAAA,EAAI;QACFpB,KAAA,EAAO;IACT;IACAqB,EAAA,EAAI;QACFrB,KAAA,EAAO;IACT;IACA,YAAY;QACVA,KAAA,EAAO;IACT;IACAsB,EAAA,EAAI;QACFtB,KAAA,EAAO;IACT;IACAuB,EAAA,EAAI;QACFvB,KAAA,EAAO;IACT;IACAwB,EAAA,EAAI;QACFxB,KAAA,EAAO;IACT;IACAyB,EAAA,EAAI;QACFzB,KAAA,EAAO;IACT;IACA0B,EAAA,EAAI;QACF1B,KAAA,EAAO;IACT;IACA2B,EAAA,EAAI;QACF3B,KAAA,EAAO;IACT;IACA4B,EAAA,EAAI;QACF5B,KAAA,EAAO;IACT;IACA6B,EAAA,EAAI;QACF7B,KAAA,EAAO;IACT;IACA,SAAS;QACPA,KAAA,EAAO;IACT;AACF"}},
    {"offset": {"line": 3622, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 3628, "column": 0}, "map": {"version":3,"file":"UploadNode.js","sources":["turbopack://[project]/node_modules/@payloadcms/richtext-lexical/src/features/upload/server/nodes/UploadNode.tsx"],"sourcesContent":["import type { SerializedDecoratorBlockNode } from '@lexical/react/LexicalDecoratorBlockNode.js'\nimport type {\n  DOMConversionMap,\n  DOMConversionOutput,\n  DOMExportOutput,\n  ElementFormatType,\n  LexicalNode,\n  NodeKey,\n  Spread,\n} from 'lexical'\nimport type { CollectionSlug, DataFromCollectionSlug, JsonObject } from 'payload'\nimport type { JSX } from 'react'\n\nimport { DecoratorBlockNode } from '@lexical/react/LexicalDecoratorBlockNode.js'\nimport ObjectID from 'bson-objectid'\nimport { $applyNodeReplacement } from 'lexical'\nimport * as React from 'react'\n\nexport type UploadData<TUploadExtraFieldsData extends JsonObject = JsonObject> = {\n  [TCollectionSlug in CollectionSlug]: {\n    fields: TUploadExtraFieldsData\n    // Every lexical node that has sub-fields needs to have a unique ID. This is the ID of this upload node, not the ID of the linked upload document\n    id: string\n    relationTo: TCollectionSlug\n    // Value can be just the document ID, or the full, populated document\n    value: DataFromCollectionSlug<TCollectionSlug> | number | string\n  }\n}[CollectionSlug]\n\nexport function isGoogleDocCheckboxImg(img: HTMLImageElement): boolean {\n  return (\n    img.parentElement != null &&\n    img.parentElement.tagName === 'LI' &&\n    img.previousSibling === null &&\n    img.getAttribute('aria-roledescription') === 'checkbox'\n  )\n}\n\nfunction $convertUploadServerElement(domNode: HTMLImageElement): DOMConversionOutput | null {\n  if (\n    domNode.hasAttribute('data-lexical-upload-relation-to') &&\n    domNode.hasAttribute('data-lexical-upload-id')\n  ) {\n    const id = domNode.getAttribute('data-lexical-upload-id')\n    const relationTo = domNode.getAttribute('data-lexical-upload-relation-to')\n\n    if (id != null && relationTo != null) {\n      const node = $createUploadServerNode({\n        data: {\n          fields: {},\n          relationTo,\n          value: id,\n        },\n      })\n      return { node }\n    }\n  }\n  const img = domNode\n  if (img.src.startsWith('file:///') || isGoogleDocCheckboxImg(img)) {\n    return null\n  }\n  // TODO: Auto-upload functionality here!\n  //}\n  return null\n}\n\nexport type SerializedUploadNode = {\n  children?: never // required so that our typed editor state doesn't automatically add children\n  type: 'upload'\n} & Spread<UploadData, SerializedDecoratorBlockNode>\n\nexport class UploadServerNode extends DecoratorBlockNode {\n  __data: UploadData\n\n  constructor({\n    data,\n    format,\n    key,\n  }: {\n    data: UploadData\n    format?: ElementFormatType\n    key?: NodeKey\n  }) {\n    super(format, key)\n    this.__data = data\n  }\n\n  static clone(node: UploadServerNode): UploadServerNode {\n    return new this({\n      data: node.__data,\n      format: node.__format,\n      key: node.__key,\n    })\n  }\n\n  static getType(): string {\n    return 'upload'\n  }\n\n  static importDOM(): DOMConversionMap | null {\n    return {\n      img: (node: HTMLImageElement) => ({\n        conversion: $convertUploadServerElement,\n        priority: 0,\n      }),\n    }\n  }\n\n  static importJSON(serializedNode: SerializedUploadNode): UploadServerNode {\n    if (serializedNode.version === 1 && (serializedNode?.value as unknown as { id: string })?.id) {\n      serializedNode.value = (serializedNode.value as unknown as { id: string }).id\n    }\n    if (serializedNode.version === 2 && !serializedNode?.id) {\n      serializedNode.id = new ObjectID.default().toHexString()\n      serializedNode.version = 3\n    }\n\n    const importedData: UploadData = {\n      id: serializedNode.id,\n      fields: serializedNode.fields,\n      relationTo: serializedNode.relationTo,\n      value: serializedNode.value,\n    }\n\n    const node = $createUploadServerNode({ data: importedData })\n    node.setFormat(serializedNode.format)\n\n    return node\n  }\n\n  static isInline(): false {\n    return false\n  }\n\n  decorate(): JSX.Element {\n    // @ts-expect-error\n    return <RawUploadComponent data={this.__data} format={this.__format} nodeKey={this.getKey()} />\n  }\n\n  exportDOM(): DOMExportOutput {\n    const element = document.createElement('img')\n    element.setAttribute('data-lexical-upload-id', String(this.__data?.value))\n    element.setAttribute('data-lexical-upload-relation-to', this.__data?.relationTo)\n\n    return { element }\n  }\n\n  exportJSON(): SerializedUploadNode {\n    return {\n      ...super.exportJSON(),\n      ...this.getData(),\n      type: 'upload',\n      version: 3,\n    }\n  }\n\n  getData(): UploadData {\n    return this.getLatest().__data\n  }\n\n  setData(data: UploadData): void {\n    const writable = this.getWritable()\n    writable.__data = data\n  }\n\n  updateDOM(): false {\n    return false\n  }\n}\n\nexport function $createUploadServerNode({\n  data,\n}: {\n  data: Omit<UploadData, 'id'> & Partial<Pick<UploadData, 'id'>>\n}): UploadServerNode {\n  if (!data?.id) {\n    data.id = new ObjectID.default().toHexString()\n  }\n  return $applyNodeReplacement(new UploadServerNode({ data: data as UploadData }))\n}\n\nexport function $isUploadServerNode(\n  node: LexicalNode | null | undefined,\n): node is UploadServerNode {\n  return node instanceof UploadServerNode\n}\n"],"names":["DecoratorBlockNode","ObjectID","$applyNodeReplacement","React","isGoogleDocCheckboxImg","img","parentElement","tagName","previousSibling","getAttribute","$convertUploadServerElement","domNode","hasAttribute","id","relationTo","node","$createUploadServerNode","data","fields","value","src","startsWith","UploadServerNode","__data","constructor","format","key","clone","__format","__key","getType","importDOM","conversion","priority","importJSON","serializedNode","version","default","toHexString","importedData","setFormat","isInline","decorate","_jsx","RawUploadComponent","nodeKey","getKey","exportDOM","element","document","createElement","setAttribute","String","exportJSON","getData","type","getLatest","setData","writable","getWritable","updateDOM","$isUploadServerNode"],"mappings":"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"}},
    {"offset": {"line": 3765, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 3771, "column": 0}, "map": {"version":3,"file":"graphQLPopulationPromise.js","sources":["turbopack://[project]/node_modules/@payloadcms/richtext-lexical/src/features/upload/server/graphQLPopulationPromise.ts"],"sourcesContent":["import type { PopulationPromise } from '../../typesServer.js'\nimport type { UploadFeatureProps } from './feature.server.js'\nimport type { SerializedUploadNode } from './nodes/UploadNode.js'\n\nimport { populate } from '../../../populateGraphQL/populate.js'\nimport { recursivelyPopulateFieldsForGraphQL } from '../../../populateGraphQL/recursivelyPopulateFieldsForGraphQL.js'\n\nexport const uploadPopulationPromiseHOC = (\n  props?: UploadFeatureProps,\n): PopulationPromise<SerializedUploadNode> => {\n  return ({\n    context,\n    currentDepth,\n    depth,\n    draft,\n    editorPopulationPromises,\n    fieldPromises,\n    findMany,\n    flattenLocales,\n    node,\n    overrideAccess,\n    populationPromises,\n    req,\n    showHiddenFields,\n  }) => {\n    if (node?.value) {\n      const collection = req.payload.collections[node?.relationTo]\n\n      if (collection) {\n        // @ts-expect-error\n        const id = node?.value?.id || node?.value // for backwards-compatibility\n\n        const populateDepth =\n          props?.maxDepth !== undefined && props?.maxDepth < depth ? props?.maxDepth : depth\n\n        populationPromises.push(\n          populate({\n            id,\n            collectionSlug: collection.config.slug,\n            currentDepth,\n            data: node,\n            depth: populateDepth,\n            draft,\n            key: 'value',\n            overrideAccess,\n            req,\n            showHiddenFields,\n          }),\n        )\n\n        const collectionFieldSchema = props?.collections?.[node?.relationTo]?.fields\n\n        if (Array.isArray(collectionFieldSchema)) {\n          if (!collectionFieldSchema?.length) {\n            return\n          }\n          recursivelyPopulateFieldsForGraphQL({\n            context,\n            currentDepth,\n            data: node.fields || {},\n            depth,\n            draft,\n            editorPopulationPromises,\n            fieldPromises,\n            fields: collectionFieldSchema,\n            findMany,\n            flattenLocales,\n            overrideAccess,\n            populationPromises,\n            req,\n            showHiddenFields,\n            siblingDoc: node.fields || {},\n          })\n        }\n      }\n    }\n  }\n}\n"],"names":["populate","recursivelyPopulateFieldsForGraphQL","uploadPopulationPromiseHOC","props","context","currentDepth","depth","draft","editorPopulationPromises","fieldPromises","findMany","flattenLocales","node","overrideAccess","populationPromises","req","showHiddenFields","value","collection","payload","collections","relationTo","id","populateDepth","maxDepth","undefined","push","collectionSlug","config","slug","data","key","collectionFieldSchema","fields","Array","isArray","length","siblingDoc"],"mappings":";;;AAIA,SAASA,QAAQ,QAAQ;AACzB,SAASC,mCAAmC,QAAQ;;;AAE7C,MAAMC,0BAAA,IACXC,KAAA;IAEA,OAAO,CAAC,EACNC,OAAO,EACPC,YAAY,EACZC,KAAK,EACLC,KAAK,EACLC,wBAAwB,EACxBC,aAAa,EACbC,QAAQ,EACRC,cAAc,EACdC,IAAI,EACJC,cAAc,EACdC,kBAAkB,EAClBC,GAAG,EACHC,gBAAAA,EACD;QACC,IAAIJ,IAAA,EAAMK,KAAA,EAAO;YACf,MAAMC,UAAA,GAAaH,GAAA,CAAII,OAAO,CAACC,WAAW,CAACR,IAAA,EAAMS,UAAA,CAAW;YAE5D,IAAIH,UAAA,EAAY;gBACd,mBAAA;gBACA,MAAMI,EAAA,GAAKV,IAAA,EAAMK,KAAA,EAAOK,EAAA,IAAMV,IAAA,EAAMK,KAAA,CAAM,8BAAA;;gBAE1C,MAAMM,aAAA,GACJpB,KAAA,EAAOqB,QAAA,KAAaC,SAAA,IAAatB,KAAA,EAAOqB,QAAA,GAAWlB,KAAA,GAAQH,KAAA,EAAOqB,QAAA,GAAWlB,KAAA;gBAE/EQ,kBAAA,CAAmBY,IAAI,gMACrB1B,WAAAA,AAAA,EAAS;oBACPsB,EAAA;oBACAK,cAAA,EAAgBT,UAAA,CAAWU,MAAM,CAACC,IAAI;oBACtCxB,YAAA;oBACAyB,IAAA,EAAMlB,IAAA;oBACNN,KAAA,EAAOiB,aAAA;oBACPhB,KAAA;oBACAwB,GAAA,EAAK;oBACLlB,cAAA;oBACAE,GAAA;oBACAC;gBACF;gBAGF,MAAMgB,qBAAA,GAAwB7B,KAAA,EAAOiB,WAAA,EAAA,CAAcR,IAAA,EAAMS,UAAA,CAAW,EAAEY,MAAA;gBAEtE,IAAIC,KAAA,CAAMC,OAAO,CAACH,qBAAA,GAAwB;oBACxC,IAAI,CAACA,qBAAA,EAAuBI,MAAA,EAAQ;wBAClC;oBACF;8OACAnC,sCAAAA,AAAA,EAAoC;wBAClCG,OAAA;wBACAC,YAAA;wBACAyB,IAAA,EAAMlB,IAAA,CAAKqB,MAAM,IAAI,CAAC;wBACtB3B,KAAA;wBACAC,KAAA;wBACAC,wBAAA;wBACAC,aAAA;wBACAwB,MAAA,EAAQD,qBAAA;wBACRtB,QAAA;wBACAC,cAAA;wBACAE,cAAA;wBACAC,kBAAA;wBACAC,GAAA;wBACAC,gBAAA;wBACAqB,UAAA,EAAYzB,IAAA,CAAKqB,MAAM,IAAI,CAAC;oBAC9B;gBACF;YACF;QACF;IACF;AACF"}},
    {"offset": {"line": 3826, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 3832, "column": 0}, "map": {"version":3,"file":"validate.js","sources":["turbopack://[project]/node_modules/@payloadcms/richtext-lexical/src/features/upload/server/validate.ts"],"sourcesContent":["import { buildStateFromSchema } from '@payloadcms/ui/forms/buildStateFromSchema'\nimport { isValidID } from 'payload'\n\nimport type { NodeValidation } from '../../typesServer.js'\nimport type { UploadFeatureProps } from './feature.server.js'\nimport type { SerializedUploadNode } from './nodes/UploadNode.js'\n\nexport const uploadValidation = (\n  props: UploadFeatureProps,\n): NodeValidation<SerializedUploadNode> => {\n  return async ({\n    node,\n    validation: {\n      options: {\n        id,\n        operation,\n        preferences,\n        req,\n        req: { payload, t },\n      },\n    },\n  }) => {\n    const idType = payload.collections[node.relationTo].customIDType || payload.db.defaultIDType\n    // @ts-expect-error\n    const nodeID = node?.value?.id || node?.value // for backwards-compatibility\n\n    if (!isValidID(nodeID, idType)) {\n      return t('validation:validUploadID')\n    }\n\n    if (!props?.collections) {\n      return true\n    }\n\n    if (Object.keys(props?.collections).length === 0) {\n      return true\n    }\n\n    const collection = props?.collections[node.relationTo]\n\n    if (!collection?.fields?.length) {\n      return true\n    }\n\n    const result = await buildStateFromSchema({\n      id,\n      collectionSlug: node.relationTo,\n      data: node?.fields ?? {},\n      fieldSchema: collection.fields,\n      operation: operation === 'create' || operation === 'update' ? operation : 'update',\n      preferences,\n      req,\n      siblingData: node?.fields ?? {},\n    })\n\n    let errorPaths: string[] = []\n    for (const fieldKey in result) {\n      if (result[fieldKey].errorPaths) {\n        errorPaths = errorPaths.concat(result[fieldKey].errorPaths)\n      }\n    }\n\n    if (errorPaths.length) {\n      return 'The following fields are invalid: ' + errorPaths.join(', ')\n    }\n\n    return true\n  }\n}\n"],"names":["buildStateFromSchema","isValidID","uploadValidation","props","node","validation","options","id","operation","preferences","req","payload","t","idType","collections","relationTo","customIDType","db","defaultIDType","nodeID","value","Object","keys","length","collection","fields","result","collectionSlug","data","fieldSchema","siblingData","errorPaths","fieldKey","concat","join"],"mappings":";;;AACA,SAASC,SAAS,QAAQ;AAD1B,SAASD,oBAAoB,QAAQ;;;AAO9B,MAAME,gBAAA,IACXC,KAAA;IAEA,OAAO,OAAO,EACZC,IAAI,EACJC,UAAA,EAAY,EACVC,OAAA,EAAS,EACPC,EAAE,EACFC,SAAS,EACTC,WAAW,EACXC,GAAG,EACHA,GAAA,EAAK,EAAEC,OAAO,EAAEC,CAAAA,EAAC,EAAE,EACpB,EAEJ;QACC,MAAMC,MAAA,GAASF,OAAA,CAAQG,WAAW,CAACV,IAAA,CAAKW,UAAU,CAAC,CAACC,YAAY,IAAIL,OAAA,CAAQM,EAAE,CAACC,aAAa;QAC5F,mBAAA;QACA,MAAMC,MAAA,GAASf,IAAA,EAAMgB,KAAA,EAAOb,EAAA,IAAMH,IAAA,EAAMgB,KAAA,CAAM,8BAAA;;QAE9C,IAAI,CAACnB,0KAAAA,AAAA,EAAUkB,MAAA,EAAQN,MAAA,GAAS;YAC9B,OAAOD,CAAA,CAAE;QACX;QAEA,IAAI,CAACT,KAAA,EAAOW,WAAA,EAAa;YACvB,OAAO;QACT;QAEA,IAAIO,MAAA,CAAOC,IAAI,CAACnB,KAAA,EAAOW,WAAA,EAAaS,MAAM,KAAK,GAAG;YAChD,OAAO;QACT;QAEA,MAAMC,UAAA,GAAarB,KAAA,EAAOW,WAAW,CAACV,IAAA,CAAKW,UAAU,CAAC;QAEtD,IAAI,CAACS,UAAA,EAAYC,MAAA,EAAQF,MAAA,EAAQ;YAC/B,OAAO;QACT;QAEA,MAAMG,MAAA,GAAS,+MAAM1B,uBAAAA,AAAA,EAAqB;YACxCO,EAAA;YACAoB,cAAA,EAAgBvB,IAAA,CAAKW,UAAU;YAC/Ba,IAAA,EAAMxB,IAAA,EAAMqB,MAAA,IAAU,CAAC;YACvBI,WAAA,EAAaL,UAAA,CAAWC,MAAM;YAC9BjB,SAAA,EAAWA,SAAA,KAAc,YAAYA,SAAA,KAAc,WAAWA,SAAA,GAAY;YAC1EC,WAAA;YACAC,GAAA;YACAoB,WAAA,EAAa1B,IAAA,EAAMqB,MAAA,IAAU,CAAC;QAChC;QAEA,IAAIM,UAAA,GAAuB,EAAE;QAC7B,IAAK,MAAMC,QAAA,IAAYN,MAAA,CAAQ;YAC7B,IAAIA,MAAM,CAACM,QAAA,CAAS,CAACD,UAAU,EAAE;gBAC/BA,UAAA,GAAaA,UAAA,CAAWE,MAAM,CAACP,MAAM,CAACM,QAAA,CAAS,CAACD,UAAU;YAC5D;QACF;QAEA,IAAIA,UAAA,CAAWR,MAAM,EAAE;YACrB,OAAO,uCAAuCQ,UAAA,CAAWG,IAAI,CAAC;QAChE;QAEA,OAAO;IACT;AACF"}},
    {"offset": {"line": 3880, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 3886, "column": 0}, "map": {"version":3,"file":"feature.server.js","sources":["turbopack://[project]/node_modules/@payloadcms/richtext-lexical/src/features/upload/server/feature.server.ts"],"sourcesContent":["import type {\n  CollectionSlug,\n  Config,\n  Field,\n  FileData,\n  FileSize,\n  Payload,\n  TypeWithID,\n} from 'payload'\n\nimport { sanitizeFields } from 'payload'\n\nimport type { UploadFeaturePropsClient } from '../client/feature.client.js'\n\nimport { populate } from '../../../populateGraphQL/populate.js'\nimport { createServerFeature } from '../../../utilities/createServerFeature.js'\nimport { createNode } from '../../typeUtilities.js'\nimport { uploadPopulationPromiseHOC } from './graphQLPopulationPromise.js'\nimport { i18n } from './i18n.js'\nimport { UploadServerNode } from './nodes/UploadNode.js'\nimport { uploadValidation } from './validate.js'\n\nexport type UploadFeatureProps = {\n  collections?: {\n    [collection: CollectionSlug]: {\n      fields: Field[]\n    }\n  }\n  /**\n   * Sets a maximum population depth for this upload (not the fields for this upload), regardless of the remaining depth when the respective field is reached.\n   * This behaves exactly like the maxDepth properties of relationship and upload fields.\n   *\n   * {@link https://payloadcms.com/docs/getting-started/concepts#field-level-max-depth}\n   */\n  maxDepth?: number\n}\n\n/**\n * Get the absolute URL for an upload URL by potentially prepending the serverURL\n */\nfunction getAbsoluteURL(url: string, payload: Payload): string {\n  return url?.startsWith('http') ? url : (payload?.config?.serverURL || '') + url\n}\n\nexport const UploadFeature = createServerFeature<\n  UploadFeatureProps,\n  UploadFeatureProps,\n  UploadFeaturePropsClient\n>({\n  feature: async ({ config: _config, isRoot, parentIsLocalized, props }) => {\n    if (!props) {\n      props = { collections: {} }\n    }\n\n    const clientProps: UploadFeaturePropsClient = {\n      collections: {},\n    }\n    if (props.collections) {\n      for (const collection in props.collections) {\n        clientProps.collections[collection] = {\n          hasExtraFields: props.collections[collection].fields.length >= 1,\n        }\n      }\n    }\n\n    const validRelationships = _config.collections.map((c) => c.slug) || []\n\n    for (const collection in props.collections) {\n      if (props.collections[collection].fields?.length) {\n        props.collections[collection].fields = await sanitizeFields({\n          config: _config as unknown as Config,\n          fields: props.collections[collection].fields,\n          parentIsLocalized,\n          requireFieldLevelRichTextEditor: isRoot,\n          validRelationships,\n        })\n      }\n    }\n\n    return {\n      ClientFeature: '@payloadcms/richtext-lexical/client#UploadFeatureClient',\n      clientFeatureProps: clientProps,\n      generateSchemaMap: ({ props }) => {\n        if (!props?.collections) {\n          return null\n        }\n\n        const schemaMap = new Map<string, Field[]>()\n\n        for (const collection in props.collections) {\n          if (props.collections[collection].fields?.length) {\n            schemaMap.set(collection, props.collections[collection].fields)\n          }\n        }\n\n        return schemaMap\n      },\n      i18n,\n      nodes: [\n        createNode({\n          converters: {\n            html: {\n              converter: async ({\n                currentDepth,\n                depth,\n                draft,\n                node,\n                overrideAccess,\n                req,\n                showHiddenFields,\n              }) => {\n                // @ts-expect-error - for backwards-compatibility\n                const id = node?.value?.id || node?.value\n\n                if (req?.payload) {\n                  const uploadDocument: {\n                    value?: FileData & TypeWithID\n                  } = {}\n\n                  try {\n                    await populate({\n                      id,\n                      collectionSlug: node.relationTo,\n                      currentDepth,\n                      data: uploadDocument,\n                      depth,\n                      draft,\n                      key: 'value',\n                      overrideAccess,\n                      req,\n                      showHiddenFields,\n                    })\n                  } catch (ignored) {\n                    // eslint-disable-next-line no-console\n                    console.error(\n                      'Lexical upload node HTML converter: error fetching upload file',\n                      ignored,\n                      'Node:',\n                      node,\n                    )\n                    return `<img />`\n                  }\n\n                  const url = getAbsoluteURL(uploadDocument?.value?.url ?? '', req?.payload)\n\n                  /**\n                   * If the upload is not an image, return a link to the upload\n                   */\n                  if (!uploadDocument?.value?.mimeType?.startsWith('image')) {\n                    return `<a href=\"${url}\" rel=\"noopener noreferrer\">${uploadDocument.value?.filename}</a>`\n                  }\n\n                  /**\n                   * If the upload is a simple image with no different sizes, return a simple img tag\n                   */\n                  if (\n                    !uploadDocument?.value?.sizes ||\n                    !Object.keys(uploadDocument?.value?.sizes).length\n                  ) {\n                    return `<img src=\"${url}\" alt=\"${uploadDocument?.value?.filename}\" width=\"${uploadDocument?.value?.width}\"  height=\"${uploadDocument?.value?.height}\"/>`\n                  }\n\n                  /**\n                   * If the upload is an image with different sizes, return a picture element\n                   */\n                  let pictureHTML = '<picture>'\n\n                  // Iterate through each size in the data.sizes object\n                  for (const size in uploadDocument.value?.sizes) {\n                    const imageSize: {\n                      url?: string\n                    } & FileSize = uploadDocument.value?.sizes[size]\n\n                    // Skip if any property of the size object is null\n                    if (\n                      !imageSize.width ||\n                      !imageSize.height ||\n                      !imageSize.mimeType ||\n                      !imageSize.filesize ||\n                      !imageSize.filename ||\n                      !imageSize.url\n                    ) {\n                      continue\n                    }\n                    const imageSizeURL = getAbsoluteURL(imageSize?.url, req?.payload)\n\n                    pictureHTML += `<source srcset=\"${imageSizeURL}\" media=\"(max-width: ${imageSize.width}px)\" type=\"${imageSize.mimeType}\">`\n                  }\n\n                  // Add the default img tag\n                  pictureHTML += `<img src=\"${url}\" alt=\"Image\" width=\"${uploadDocument.value?.width}\" height=\"${uploadDocument.value?.height}\">`\n                  pictureHTML += '</picture>'\n                  return pictureHTML\n                } else {\n                  return `<img src=\"${id}\" />`\n                }\n              },\n              nodeTypes: [UploadServerNode.getType()],\n            },\n          },\n          getSubFields: ({ node, req }) => {\n            if (!node) {\n              let allSubFields: Field[] = []\n              for (const collection in props?.collections) {\n                allSubFields = allSubFields.concat(props?.collections?.[collection]?.fields)\n              }\n              return allSubFields\n            }\n            const collection = req ? req.payload.collections[node?.relationTo] : null\n\n            if (collection) {\n              const collectionFieldSchema = props?.collections?.[node?.relationTo]?.fields\n\n              if (Array.isArray(collectionFieldSchema)) {\n                if (!collectionFieldSchema?.length) {\n                  return null\n                }\n                return collectionFieldSchema\n              }\n            }\n            return null\n          },\n          getSubFieldsData: ({ node }) => {\n            return node?.fields\n          },\n          graphQLPopulationPromises: [uploadPopulationPromiseHOC(props)],\n          hooks: {\n            afterRead: [\n              ({\n                currentDepth,\n                depth,\n                draft,\n                node,\n                overrideAccess,\n                populationPromises,\n                req,\n                showHiddenFields,\n              }) => {\n                if (!node?.value) {\n                  return node\n                }\n                const collection = req.payload.collections[node?.relationTo]\n\n                if (!collection) {\n                  return node\n                }\n                // @ts-expect-error\n                const id = node?.value?.id || node?.value // for backwards-compatibility\n\n                const populateDepth =\n                  props?.maxDepth !== undefined && props?.maxDepth < depth ? props?.maxDepth : depth\n\n                populationPromises.push(\n                  populate({\n                    id,\n                    collectionSlug: collection.config.slug,\n                    currentDepth,\n                    data: node,\n                    depth: populateDepth,\n                    draft,\n                    key: 'value',\n                    overrideAccess,\n                    req,\n                    showHiddenFields,\n                  }),\n                )\n\n                return node\n              },\n            ],\n          },\n          node: UploadServerNode,\n          validations: [uploadValidation(props)],\n        }),\n      ],\n      sanitizedServerFeatureProps: props,\n    }\n  },\n  key: 'upload',\n})\n"],"names":["sanitizeFields","populate","createServerFeature","createNode","uploadPopulationPromiseHOC","i18n","UploadServerNode","uploadValidation","getAbsoluteURL","url","payload","startsWith","config","serverURL","UploadFeature","feature","_config","isRoot","parentIsLocalized","props","collections","clientProps","collection","hasExtraFields","fields","length","validRelationships","map","c","slug","requireFieldLevelRichTextEditor","ClientFeature","clientFeatureProps","generateSchemaMap","schemaMap","Map","set","nodes","converters","html","converter","currentDepth","depth","draft","node","overrideAccess","req","showHiddenFields","id","value","uploadDocument","collectionSlug","relationTo","data","key","ignored","console","error","mimeType","filename","sizes","Object","keys","width","height","pictureHTML","size","imageSize","filesize","imageSizeURL","nodeTypes","getType","getSubFields","allSubFields","concat","collectionFieldSchema","Array","isArray","getSubFieldsData","graphQLPopulationPromises","hooks","afterRead","populationPromises","populateDepth","maxDepth","undefined","push","validations","sanitizedServerFeatureProps"],"mappings":"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"}},
    {"offset": {"line": 4086, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 4092, "column": 0}, "map": {"version":3,"file":"i18n.js","sources":["turbopack://[project]/node_modules/@payloadcms/richtext-lexical/src/features/horizontalRule/server/i18n.ts"],"sourcesContent":["import type { GenericLanguages } from '@payloadcms/translations'\n\nexport const i18n: Partial<GenericLanguages> = {\n  ar: {\n    label: 'القاعدة الأفقية',\n  },\n  az: {\n    label: 'Üfüqi Xətt',\n  },\n  bg: {\n    label: 'Хоризонтална линия',\n  },\n  cs: {\n    label: 'Vodorovný pravítko',\n  },\n  de: {\n    label: 'Trennlinie',\n  },\n  en: {\n    label: 'Horizontal Rule',\n  },\n  es: {\n    label: 'Regla Horizontal',\n  },\n  fa: {\n    label: 'قاعده افقی',\n  },\n  fr: {\n    label: 'Règle horizontale',\n  },\n  he: {\n    label: 'קו אופקי',\n  },\n  hr: {\n    label: 'Vodoravna linija',\n  },\n  hu: {\n    label: 'Vízszintes vonal',\n  },\n  it: {\n    label: 'Regola Orizzontale',\n  },\n  ja: {\n    label: '水平線',\n  },\n  ko: {\n    label: '수평 규칙',\n  },\n  my: {\n    label: 'Peraturan Mendatar',\n  },\n  nb: {\n    label: 'Horisontal Regel',\n  },\n  nl: {\n    label: 'Horizontale Regel',\n  },\n  pl: {\n    label: 'Pozioma Linia',\n  },\n  pt: {\n    label: 'Regra Horizontal',\n  },\n  ro: {\n    label: 'Linie orizontală',\n  },\n  rs: {\n    label: 'Horizontalna linija',\n  },\n  'rs-latin': {\n    label: 'Horizontalna linija',\n  },\n  ru: {\n    label: 'Горизонтальная линия',\n  },\n  sk: {\n    label: 'Vodorovná čiara',\n  },\n  sv: {\n    label: 'Horisontell linje',\n  },\n  th: {\n    label: 'กฎขีดตรง',\n  },\n  tr: {\n    label: 'Yatay Çizgi',\n  },\n  uk: {\n    label: 'Горизонтальна лінія',\n  },\n  vi: {\n    label: 'Quy tắc ngang',\n  },\n  zh: {\n    label: '水平线',\n  },\n  'zh-TW': {\n    label: '水平線',\n  },\n}\n"],"names":["i18n","ar","label","az","bg","cs","de","en","es","fa","fr","he","hr","hu","it","ja","ko","my","nb","nl","pl","pt","ro","rs","ru","sk","sv","th","tr","uk","vi","zh"],"mappings":";;;AAEO,MAAMA,IAAA,GAAkC;IAC7CC,EAAA,EAAI;QACFC,KAAA,EAAO;IACT;IACAC,EAAA,EAAI;QACFD,KAAA,EAAO;IACT;IACAE,EAAA,EAAI;QACFF,KAAA,EAAO;IACT;IACAG,EAAA,EAAI;QACFH,KAAA,EAAO;IACT;IACAI,EAAA,EAAI;QACFJ,KAAA,EAAO;IACT;IACAK,EAAA,EAAI;QACFL,KAAA,EAAO;IACT;IACAM,EAAA,EAAI;QACFN,KAAA,EAAO;IACT;IACAO,EAAA,EAAI;QACFP,KAAA,EAAO;IACT;IACAQ,EAAA,EAAI;QACFR,KAAA,EAAO;IACT;IACAS,EAAA,EAAI;QACFT,KAAA,EAAO;IACT;IACAU,EAAA,EAAI;QACFV,KAAA,EAAO;IACT;IACAW,EAAA,EAAI;QACFX,KAAA,EAAO;IACT;IACAY,EAAA,EAAI;QACFZ,KAAA,EAAO;IACT;IACAa,EAAA,EAAI;QACFb,KAAA,EAAO;IACT;IACAc,EAAA,EAAI;QACFd,KAAA,EAAO;IACT;IACAe,EAAA,EAAI;QACFf,KAAA,EAAO;IACT;IACAgB,EAAA,EAAI;QACFhB,KAAA,EAAO;IACT;IACAiB,EAAA,EAAI;QACFjB,KAAA,EAAO;IACT;IACAkB,EAAA,EAAI;QACFlB,KAAA,EAAO;IACT;IACAmB,EAAA,EAAI;QACFnB,KAAA,EAAO;IACT;IACAoB,EAAA,EAAI;QACFpB,KAAA,EAAO;IACT;IACAqB,EAAA,EAAI;QACFrB,KAAA,EAAO;IACT;IACA,YAAY;QACVA,KAAA,EAAO;IACT;IACAsB,EAAA,EAAI;QACFtB,KAAA,EAAO;IACT;IACAuB,EAAA,EAAI;QACFvB,KAAA,EAAO;IACT;IACAwB,EAAA,EAAI;QACFxB,KAAA,EAAO;IACT;IACAyB,EAAA,EAAI;QACFzB,KAAA,EAAO;IACT;IACA0B,EAAA,EAAI;QACF1B,KAAA,EAAO;IACT;IACA2B,EAAA,EAAI;QACF3B,KAAA,EAAO;IACT;IACA4B,EAAA,EAAI;QACF5B,KAAA,EAAO;IACT;IACA6B,EAAA,EAAI;QACF7B,KAAA,EAAO;IACT;IACA,SAAS;QACPA,KAAA,EAAO;IACT;AACF"}},
    {"offset": {"line": 4193, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 4199, "column": 0}, "map": {"version":3,"file":"HorizontalRuleNode.js","sources":["turbopack://[project]/node_modules/@payloadcms/richtext-lexical/src/features/horizontalRule/server/nodes/HorizontalRuleNode.tsx"],"sourcesContent":["import type {\n  DOMConversionMap,\n  DOMConversionOutput,\n  DOMExportOutput,\n  EditorConfig,\n  LexicalCommand,\n  LexicalNode,\n  SerializedLexicalNode,\n  Spread,\n} from 'lexical'\nimport type * as React from 'react'\n\nimport { addClassNamesToElement } from '@lexical/utils'\nimport { $applyNodeReplacement, createCommand, DecoratorNode } from 'lexical'\n\n/**\n * Serialized representation of a horizontal rule node. Serialized = converted to JSON. This is what is stored in the database / in the lexical editor state.\n */\nexport type SerializedHorizontalRuleNode = Spread<\n  {\n    children?: never // required so that our typed editor state doesn't automatically add children\n    type: 'horizontalrule'\n  },\n  SerializedLexicalNode\n>\n\nexport const INSERT_HORIZONTAL_RULE_COMMAND: LexicalCommand<void> = createCommand(\n  'INSERT_HORIZONTAL_RULE_COMMAND',\n)\n\n/**\n * This node is a DecoratorNode. DecoratorNodes allow you to render React components in the editor.\n *\n * They need both createDom and decorate functions. createDom => outside of the html. decorate => React Component inside of the html.\n *\n * If we used DecoratorBlockNode instead, we would only need a decorate method\n */\nexport class HorizontalRuleServerNode extends DecoratorNode<null | React.ReactElement> {\n  static clone(node: HorizontalRuleServerNode): HorizontalRuleServerNode {\n    return new this(node.__key)\n  }\n\n  static getType(): string {\n    return 'horizontalrule'\n  }\n\n  /**\n   * Defines what happens if you copy an hr element from another page and paste it into the lexical editor\n   *\n   * This also determines the behavior of lexical's internal HTML -> Lexical converter\n   */\n  static importDOM(): DOMConversionMap | null {\n    return {\n      hr: () => ({\n        conversion: $convertHorizontalRuleElement,\n        priority: 0,\n      }),\n    }\n  }\n\n  /**\n   * The data for this node is stored serialized as JSON. This is the \"load function\" of that node: it takes the saved data and converts it into a node.\n   */\n  static importJSON(serializedNode: SerializedHorizontalRuleNode): HorizontalRuleServerNode {\n    return $createHorizontalRuleServerNode()\n  }\n\n  /**\n   * Determines how the hr element is rendered in the lexical editor. This is only the \"initial\" / \"outer\" HTML element.\n   */\n  createDOM(config: EditorConfig): HTMLElement {\n    const element = document.createElement('hr')\n    addClassNamesToElement(element, config.theme.hr)\n    return element\n  }\n\n  decorate(): null | React.ReactElement {\n    return null\n  }\n\n  /**\n   * Opposite of importDOM, this function defines what happens when you copy an hr element from the lexical editor and paste it into another page.\n   *\n   * This also determines the behavior of lexical's internal Lexical -> HTML converter\n   */\n  exportDOM(): DOMExportOutput {\n    return { element: document.createElement('hr') }\n  }\n  /**\n   * Opposite of importJSON. This determines what data is saved in the database / in the lexical editor state.\n   */\n  exportJSON(): SerializedLexicalNode {\n    return {\n      type: 'horizontalrule',\n      version: 1,\n    }\n  }\n\n  getTextContent(): string {\n    return '\\n'\n  }\n\n  isInline(): false {\n    return false\n  }\n\n  updateDOM(): boolean {\n    return false\n  }\n}\n\nfunction $convertHorizontalRuleElement(): DOMConversionOutput {\n  return { node: $createHorizontalRuleServerNode() }\n}\n\nexport function $createHorizontalRuleServerNode(): HorizontalRuleServerNode {\n  return $applyNodeReplacement(new HorizontalRuleServerNode())\n}\n\nexport function $isHorizontalRuleServerNode(\n  node: LexicalNode | null | undefined,\n): node is HorizontalRuleServerNode {\n  return node instanceof HorizontalRuleServerNode\n}\n"],"names":["addClassNamesToElement","$applyNodeReplacement","createCommand","DecoratorNode","INSERT_HORIZONTAL_RULE_COMMAND","HorizontalRuleServerNode","clone","node","__key","getType","importDOM","hr","conversion","$convertHorizontalRuleElement","priority","importJSON","serializedNode","$createHorizontalRuleServerNode","createDOM","config","element","document","createElement","theme","decorate","exportDOM","exportJSON","type","version","getTextContent","isInline","updateDOM","$isHorizontalRuleServerNode"],"mappings":";;;;;;AAaA,SAASC,qBAAqB,EAAEC,aAAa,EAAEC,aAAa,QAAQ;AADpE,SAASH,sBAAsB,QAAQ;;;AAchC,MAAMI,8BAAA,kJAAuDF,gBAAAA,AAAA,EAClE;AAUK,MAAMG,wBAAA,oJAAiCF,gBAAA;IAC5C,OAAOG,MAAMC,IAA8B,EAA4B;QACrE,OAAO,IAAI,IAAI,CAACA,IAAA,CAAKC,KAAK;IAC5B;IAEA,OAAOC,QAAA,EAAkB;QACvB,OAAO;IACT;IAEA;;;;KAKA,OAAOC,UAAA,EAAqC;QAC1C,OAAO;YACLC,EAAA,EAAIA,CAAA,GAAA,CAAO;oBACTC,UAAA,EAAYC,6BAAA;oBACZC,QAAA,EAAU;gBACZ,CAAA;QACF;IACF;IAEA;;KAGA,OAAOC,WAAWC,cAA4C,EAA4B;QACxF,OAAOC,+BAAA;IACT;IAEA;;KAGAC,UAAUC,MAAoB,EAAe;QAC3C,MAAMC,OAAA,GAAUC,QAAA,CAASC,aAAa,CAAC;uLACvCtB,yBAAAA,AAAA,EAAuBoB,OAAA,EAASD,MAAA,CAAOI,KAAK,CAACZ,EAAE;QAC/C,OAAOS,OAAA;IACT;IAEAI,SAAA,EAAsC;QACpC,OAAO;IACT;IAEA;;;;KAKAC,UAAA,EAA6B;QAC3B,OAAO;YAAEL,OAAA,EAASC,QAAA,CAASC,aAAa,CAAC;QAAM;IACjD;IACA;;KAGAI,WAAA,EAAoC;QAClC,OAAO;YACLC,IAAA,EAAM;YACNC,OAAA,EAAS;QACX;IACF;IAEAC,eAAA,EAAyB;QACvB,OAAO;IACT;IAEAC,SAAA,EAAkB;QAChB,OAAO;IACT;IAEAC,UAAA,EAAqB;QACnB,OAAO;IACT;AACF;AAEA,SAASlB,8BAAA;IACP,OAAO;QAAEN,IAAA,EAAMU,+BAAA;IAAkC;AACnD;AAEO,SAASA,gCAAA;IACd,sJAAOhB,wBAAAA,AAAA,EAAsB,IAAII,wBAAA;AACnC;AAEO,SAAS2B,4BACdzB,IAAoC;IAEpC,OAAOA,IAAA,YAAgBF,wBAAA;AACzB"}},
    {"offset": {"line": 4282, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 4288, "column": 0}, "map": {"version":3,"file":"markdownTransformer.js","sources":["turbopack://[project]/node_modules/@payloadcms/richtext-lexical/src/features/horizontalRule/server/markdownTransformer.ts"],"sourcesContent":["import type { ElementTransformer } from '@lexical/markdown'\n\nimport {\n  $createHorizontalRuleServerNode,\n  $isHorizontalRuleServerNode,\n  HorizontalRuleServerNode,\n} from './nodes/HorizontalRuleNode.js'\n\nexport const MarkdownTransformer: ElementTransformer = {\n  type: 'element',\n  dependencies: [HorizontalRuleServerNode],\n  export: (node, exportChildren) => {\n    if (!$isHorizontalRuleServerNode(node)) {\n      return null\n    }\n    return '---'\n  },\n  // match ---\n  regExp: /^---\\s*$/,\n  replace: (parentNode) => {\n    const node = $createHorizontalRuleServerNode()\n    if (node) {\n      parentNode.replace(node)\n    }\n  },\n}\n"],"names":["$createHorizontalRuleServerNode","$isHorizontalRuleServerNode","HorizontalRuleServerNode","MarkdownTransformer","type","dependencies","export","node","exportChildren","regExp","replace","parentNode"],"mappings":";;;AAEA,SACEA,+BAA+B,EAC/BC,2BAA2B,EAC3BC,wBAAwB,QACnB;;AAEA,MAAMC,mBAAA,GAA0C;IACrDC,IAAA,EAAM;IACNC,YAAA,EAAc;2OAACH,2BAAA;KAAyB;IACxCI,MAAA,EAAQA,CAACC,IAAA,EAAMC,cAAA;QACb,IAAI,wOAACP,8BAAAA,AAAA,EAA4BM,IAAA,GAAO;YACtC,OAAO;QACT;QACA,OAAO;IACT;IACA,YAAA;IACAE,MAAA,EAAQ;IACRC,OAAA,GAAUC,UAAA;QACR,MAAMJ,IAAA,0OAAOP,kCAAAA,AAAA;QACb,IAAIO,IAAA,EAAM;YACRI,UAAA,CAAWD,OAAO,CAACH,IAAA;QACrB;IACF;AACF"}},
    {"offset": {"line": 4313, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 4319, "column": 0}, "map": {"version":3,"file":"index.js","sources":["turbopack://[project]/node_modules/@payloadcms/richtext-lexical/src/features/horizontalRule/server/index.ts"],"sourcesContent":["import { createServerFeature } from '../../../utilities/createServerFeature.js'\nimport { createNode } from '../../typeUtilities.js'\nimport { i18n } from './i18n.js'\nimport { MarkdownTransformer } from './markdownTransformer.js'\nimport { HorizontalRuleServerNode } from './nodes/HorizontalRuleNode.js'\n\nexport const HorizontalRuleFeature = createServerFeature({\n  feature: {\n    ClientFeature: '@payloadcms/richtext-lexical/client#HorizontalRuleFeatureClient',\n    i18n,\n    markdownTransformers: [MarkdownTransformer],\n    nodes: [\n      createNode({\n        converters: {\n          html: {\n            converter: () => {\n              return `<hr/>`\n            },\n            nodeTypes: [HorizontalRuleServerNode.getType()],\n          },\n        },\n        node: HorizontalRuleServerNode,\n      }),\n    ],\n  },\n  key: 'horizontalRule',\n})\n"],"names":["createServerFeature","createNode","i18n","MarkdownTransformer","HorizontalRuleServerNode","HorizontalRuleFeature","feature","ClientFeature","markdownTransformers","nodes","converters","html","converter","nodeTypes","getType","node","key"],"mappings":";;;AAAA,SAASA,mBAAmB,QAAQ;AAEpC,SAASE,IAAI,QAAQ;AACrB,SAASC,mBAAmB,QAAQ;AAFpC,SAASF,UAAU,QAAQ;AAG3B,SAASG,wBAAwB,QAAQ;;;;;;AAElC,MAAMC,qBAAA,uMAAwBL,sBAAAA,AAAA,EAAoB;IACvDM,OAAA,EAAS;QACPC,aAAA,EAAe;cACfL,mNAAA;QACAM,oBAAA,EAAsB;uOAACL,sBAAA;SAAoB;QAC3CM,KAAA,EAAO;yMACLR,aAAA,AAAAA,EAAW;gBACTS,UAAA,EAAY;oBACVC,IAAA,EAAM;wBACJC,SAAA,EAAWA,CAAA;4BACT,OAAO,CAAA,KAAA,CAAO;wBAChB;wBACAC,SAAA,EAAW;4BAACT,8PAAA,CAAyBU,OAAO;yBAAA;oBAC9C;gBACF;gBACAC,IAAA,qOAAMX,2BAAAA;YACR;SAAA;IAEJ;IACAY,GAAA,EAAK;AACP"}},
    {"offset": {"line": 4357, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 4363, "column": 0}, "map": {"version":3,"file":"index.js","sources":["turbopack://[project]/node_modules/@payloadcms/richtext-lexical/src/features/toolbars/inline/server/index.ts"],"sourcesContent":["import { createServerFeature } from '../../../../utilities/createServerFeature.js'\n\nexport const InlineToolbarFeature = createServerFeature({\n  feature: {\n    ClientFeature: '@payloadcms/richtext-lexical/client#InlineToolbarFeatureClient',\n  },\n  key: 'toolbarInline',\n})\n"],"names":["createServerFeature","InlineToolbarFeature","feature","ClientFeature","key"],"mappings":";;;AAAA,SAASA,mBAAmB,QAAQ;;AAE7B,MAAMC,oBAAA,uMAAuBD,sBAAAA,AAAA,EAAoB;IACtDE,OAAA,EAAS;QACPC,aAAA,EAAe;IACjB;IACAC,GAAA,EAAK;AACP"}},
    {"offset": {"line": 4374, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 4380, "column": 0}, "map": {"version":3,"file":"default.js","sources":["turbopack://[project]/node_modules/@payloadcms/richtext-lexical/src/lexical/config/server/default.ts"],"sourcesContent":["import type { EditorConfig as LexicalEditorConfig } from 'lexical'\n\nimport type { FeatureProviderServer } from '../../../features/typesServer.js'\nimport type { ServerEditorConfig } from '../types.js'\n\nimport { AlignFeature } from '../../../features/align/server/index.js'\nimport { BlockquoteFeature } from '../../../features/blockquote/server/index.js'\nimport { BoldFeature } from '../../../features/format/bold/feature.server.js'\nimport { InlineCodeFeature } from '../../../features/format/inlineCode/feature.server.js'\nimport { ItalicFeature } from '../../../features/format/italic/feature.server.js'\nimport { StrikethroughFeature } from '../../../features/format/strikethrough/feature.server.js'\nimport { SubscriptFeature } from '../../../features/format/subscript/feature.server.js'\nimport { SuperscriptFeature } from '../../../features/format/superscript/feature.server.js'\nimport { UnderlineFeature } from '../../../features/format/underline/feature.server.js'\nimport { HeadingFeature } from '../../../features/heading/server/index.js'\nimport { HorizontalRuleFeature } from '../../../features/horizontalRule/server/index.js'\nimport { IndentFeature } from '../../../features/indent/server/index.js'\nimport { LinkFeature } from '../../../features/link/server/index.js'\nimport { ChecklistFeature } from '../../../features/lists/checklist/server/index.js'\nimport { OrderedListFeature } from '../../../features/lists/orderedList/server/index.js'\nimport { UnorderedListFeature } from '../../../features/lists/unorderedList/server/index.js'\nimport { ParagraphFeature } from '../../../features/paragraph/server/index.js'\nimport { RelationshipFeature } from '../../../features/relationship/server/index.js'\nimport { InlineToolbarFeature } from '../../../features/toolbars/inline/server/index.js'\nimport { UploadFeature } from '../../../features/upload/server/feature.server.js'\nimport { LexicalEditorTheme } from '../../theme/EditorTheme.js'\n\nexport const defaultEditorLexicalConfig: LexicalEditorConfig = {\n  namespace: 'lexical',\n  theme: LexicalEditorTheme,\n}\n\nexport const defaultEditorFeatures: FeatureProviderServer<any, any, any>[] = [\n  BoldFeature(),\n  ItalicFeature(),\n  UnderlineFeature(),\n  StrikethroughFeature(),\n  SubscriptFeature(),\n  SuperscriptFeature(),\n  InlineCodeFeature(),\n  ParagraphFeature(),\n  HeadingFeature(),\n  AlignFeature(),\n  IndentFeature(),\n  UnorderedListFeature(),\n  OrderedListFeature(),\n  ChecklistFeature(),\n  LinkFeature(),\n  RelationshipFeature(),\n  BlockquoteFeature(),\n  UploadFeature(),\n  HorizontalRuleFeature(),\n  InlineToolbarFeature(),\n]\n\nexport const defaultEditorConfig: ServerEditorConfig = {\n  features: defaultEditorFeatures,\n  lexical: defaultEditorLexicalConfig,\n}\n"],"names":["AlignFeature","BlockquoteFeature","BoldFeature","InlineCodeFeature","ItalicFeature","StrikethroughFeature","SubscriptFeature","SuperscriptFeature","UnderlineFeature","HeadingFeature","HorizontalRuleFeature","IndentFeature","LinkFeature","ChecklistFeature","OrderedListFeature","UnorderedListFeature","ParagraphFeature","RelationshipFeature","InlineToolbarFeature","UploadFeature","LexicalEditorTheme","defaultEditorLexicalConfig","namespace","theme","defaultEditorFeatures","defaultEditorConfig","features","lexical"],"mappings":";;;;;AAyBA,SAASoB,kBAAkB,QAAQ;AAlBnC,SAASlB,WAAW,QAAQ;AAE5B,SAASE,aAAa,QAAQ;AAI9B,SAASI,gBAAgB,QAAQ;AAHjC,SAASH,oBAAoB,QAAQ;AACrC,SAASC,gBAAgB,QAAQ;AACjC,SAASC,kBAAkB,QAAQ;AAJnC,SAASJ,iBAAiB,QAAQ;AAalC,SAASa,gBAAgB,QAAQ;AAPjC,SAASP,cAAc,QAAQ;AAT/B,SAAST,YAAY,QAAQ;AAW7B,SAASW,aAAa,QAAQ;AAI9B,SAASI,oBAAoB,QAAQ;AADrC,SAASD,kBAAkB,QAAQ;AADnC,SAASD,gBAAgB,QAAQ;AADjC,SAASD,WAAW,QAAQ;AAK5B,SAASK,mBAAmB,QAAQ;AAhBpC,SAAShB,iBAAiB,QAAQ;AAkBlC,SAASkB,aAAa,QAAQ;AAT9B,SAAST,qBAAqB,QAAQ;AAQtC,SAASQ,oBAAoB,QAAQ;;;;;;;;;;;;;;;;;;;;;;AAI9B,MAAMG,0BAAA,GAAkD;IAC7DC,SAAA,EAAW;IACXC,KAAA,gMAAOH,sBAAAA;AACT;AAEO,MAAMI,qBAAA,GAAgE;uNAC3EtB,cAAAA,AAAA;yNACAE,gBAAAA,AAAA;KACAI,0OAAAA,AAAA;gOACAH,uBAAAA,AAAA;4NACAC,mBAAA,AAAAA;8NACAC,qBAAAA,AAAA;IACAJ,6OAAAA,AAAA;gNACAa,mBAAAA,AAAA;8MACAP,iBAAAA,AAAA;KACAT,sNAAAA,AAAA;6MACAW,gBAAAA,AAAA;6NACAI,uBAAAA,AAAA;IACAD,4OAAAA,AAAA;yNACAD,mBAAAA,AAAA;2MACAD,cAAAA,AAAA;KACAK,oOAAAA,AAAA;iNACAhB,oBAAAA,AAAA;yNACAkB,gBAAAA,AAAA;qNACAT,wBAAAA,AAAA;yNACAQ,uBAAAA,AAAA;CACD;AAEM,MAAMO,mBAAA,GAA0C;IACrDC,QAAA,EAAUF,qBAAA;IACVG,OAAA,EAASN;AACX"}},
    {"offset": {"line": 4457, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 4463, "column": 0}, "map": {"version":3,"file":"loader.js","sources":["turbopack://[project]/node_modules/@payloadcms/richtext-lexical/src/lexical/config/server/loader.ts"],"sourcesContent":["import type { SanitizedConfig } from 'payload'\n\nimport type {\n  FeatureProviderServer,\n  ResolvedServerFeatureMap,\n  ServerFeatureProviderMap,\n} from '../../../features/typesServer.js'\nimport type { ServerEditorConfig } from '../types.js'\n\ntype DependencyGraph = {\n  [key: string]: {\n    dependencies: string[]\n    dependenciesPriority: string[]\n    dependenciesSoft: string[]\n    featureProvider: FeatureProviderServer<unknown, unknown, unknown>\n  }\n}\n\nfunction createDependencyGraph(\n  featureProviders: FeatureProviderServer<unknown, unknown, unknown>[],\n): DependencyGraph {\n  const graph: DependencyGraph = {}\n  for (const fp of featureProviders) {\n    graph[fp.key] = {\n      dependencies: fp.dependencies || [],\n      dependenciesPriority: fp.dependenciesPriority || [],\n      dependenciesSoft: fp.dependenciesSoft || [],\n      featureProvider: fp,\n    }\n  }\n  return graph\n}\n\nfunction topologicallySortFeatures(\n  featureProviders: FeatureProviderServer<unknown, unknown, unknown>[],\n): FeatureProviderServer<unknown, unknown, unknown>[] {\n  const graph = createDependencyGraph(featureProviders)\n  const visited: { [key: string]: boolean } = {}\n  const stack: FeatureProviderServer<unknown, unknown, unknown>[] = []\n\n  for (const key in graph) {\n    if (!visited[key]) {\n      visit(graph, key, visited, stack)\n    }\n  }\n\n  return stack.reverse()\n}\n\nfunction visit(\n  graph: DependencyGraph,\n  key: string,\n  visited: { [key: string]: boolean },\n  stack: FeatureProviderServer<unknown, unknown, unknown>[],\n  currentPath: string[] = [],\n) {\n  if (!graph[key]) {\n    throw new Error(`Feature key ${key} is not present in the dependency graph.`)\n  }\n\n  if (currentPath.includes(key)) {\n    throw new Error(`Circular dependency detected: ${currentPath.join(' -> ')} -> ${key}`)\n  }\n\n  if (visited[key]) {\n    return\n  }\n\n  visited[key] = true\n  currentPath.push(key)\n\n  // First process the hard priority dependencies\n  for (const dep of graph[key].dependenciesPriority) {\n    if (!visited[dep]) {\n      visit(graph, dep, visited, stack, currentPath)\n    }\n  }\n\n  // Then process the normal dependencies, but make sure to not violate hard dependencies\n  for (const dep of graph[key].dependencies) {\n    if (!visited[dep] && !graph[key].dependenciesPriority.includes(dep)) {\n      visit(graph, dep, visited, stack, currentPath)\n    }\n  }\n\n  // Then process the soft dependencies. Make sure to not violate hard and normal dependencies.\n  for (const dep of graph[key].dependenciesSoft) {\n    if (\n      graph[dep] &&\n      !visited[dep] &&\n      !graph[key].dependenciesPriority.includes(dep) &&\n      !graph[key].dependencies.includes(dep)\n    ) {\n      visit(graph, dep, visited, stack, currentPath)\n    }\n  }\n\n  stack.push(graph[key].featureProvider)\n  currentPath.pop()\n}\n\nexport function sortFeaturesForOptimalLoading(\n  featureProviders: FeatureProviderServer<unknown, unknown, unknown>[],\n): FeatureProviderServer<unknown, unknown, unknown>[] {\n  return topologicallySortFeatures(featureProviders)\n}\n\nexport async function loadFeatures({\n  config,\n  isRoot,\n  parentIsLocalized,\n  unSanitizedEditorConfig,\n}: {\n  config: SanitizedConfig\n  isRoot?: boolean\n  parentIsLocalized: boolean\n  unSanitizedEditorConfig: ServerEditorConfig\n}): Promise<ResolvedServerFeatureMap> {\n  // First remove all duplicate features. The LAST feature with a given key wins.\n  unSanitizedEditorConfig.features = unSanitizedEditorConfig.features\n    .reverse()\n    .filter((f, i, arr) => {\n      const firstIndex = arr.findIndex((f2) => f2.key === f.key)\n      return firstIndex === i\n    })\n    .reverse()\n\n  unSanitizedEditorConfig.features = sortFeaturesForOptimalLoading(unSanitizedEditorConfig.features)\n\n  const featureProviderMap: ServerFeatureProviderMap = new Map(\n    unSanitizedEditorConfig.features.map(\n      (f) => [f.key, f] as [string, FeatureProviderServer<unknown, unknown, unknown>],\n    ),\n  )\n\n  const resolvedFeatures: ResolvedServerFeatureMap = new Map()\n\n  // Make sure all dependencies declared in the respective features exist\n  let loaded = 0\n  for (const featureProvider of unSanitizedEditorConfig.features) {\n    if (!featureProvider.key) {\n      throw new Error(\n        `A Feature you've added does not have a key. Please add a key to the feature. This is used to uniquely identify the feature.`,\n      )\n    }\n    if (featureProvider.dependencies?.length) {\n      for (const dependencyKey of featureProvider.dependencies) {\n        const found = unSanitizedEditorConfig.features.find((f) => f.key === dependencyKey)\n        if (!found) {\n          throw new Error(\n            `Feature ${featureProvider.key} has a dependency ${dependencyKey} which does not exist.`,\n          )\n        }\n      }\n    }\n\n    if (featureProvider.dependenciesPriority?.length) {\n      for (const priorityDependencyKey of featureProvider.dependenciesPriority) {\n        // look in the resolved features instead of the editorConfig.features, as a dependency requires the feature to be loaded before it, contrary to a soft-dependency\n        const found = resolvedFeatures.get(priorityDependencyKey)\n        if (!found) {\n          const existsInEditorConfig = unSanitizedEditorConfig.features.find(\n            (f) => f.key === priorityDependencyKey,\n          )\n          if (!existsInEditorConfig) {\n            throw new Error(\n              `Feature ${featureProvider.key} has a priority dependency ${priorityDependencyKey} which does not exist.`,\n            )\n          } else {\n            throw new Error(\n              `Feature ${featureProvider.key} has a priority dependency ${priorityDependencyKey} which is not loaded before it.`,\n            )\n          }\n        }\n      }\n    }\n\n    const feature =\n      typeof featureProvider.feature === 'function'\n        ? await featureProvider.feature({\n            config,\n            featureProviderMap,\n            isRoot,\n            parentIsLocalized,\n            resolvedFeatures,\n            unSanitizedEditorConfig,\n          })\n        : featureProvider.feature\n    resolvedFeatures.set(featureProvider.key, {\n      ...feature,\n      dependencies: featureProvider.dependencies!,\n      dependenciesPriority: featureProvider.dependenciesPriority!,\n      dependenciesSoft: featureProvider.dependenciesSoft!,\n      key: featureProvider.key,\n      order: loaded,\n    })\n\n    loaded++\n  }\n\n  return resolvedFeatures\n}\n"],"names":["createDependencyGraph","featureProviders","graph","fp","key","dependencies","dependenciesPriority","dependenciesSoft","featureProvider","topologicallySortFeatures","visited","stack","visit","reverse","currentPath","Error","includes","join","push","dep","pop","sortFeaturesForOptimalLoading","loadFeatures","config","isRoot","parentIsLocalized","unSanitizedEditorConfig","features","filter","f","i","arr","firstIndex","findIndex","f2","featureProviderMap","Map","map","resolvedFeatures","loaded","length","dependencyKey","found","find","priorityDependencyKey","get","existsInEditorConfig","feature","set","order"],"mappings":"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"}},
    {"offset": {"line": 4586, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 4592, "column": 0}, "map": {"version":3,"file":"sanitize.js","sources":["turbopack://[project]/node_modules/@payloadcms/richtext-lexical/src/lexical/config/server/sanitize.ts"],"sourcesContent":["import type { SanitizedConfig } from 'payload'\n\nimport type {\n  ResolvedServerFeatureMap,\n  SanitizedServerFeatures,\n} from '../../../features/typesServer.js'\nimport type { SanitizedServerEditorConfig, ServerEditorConfig } from '../types.js'\n\nimport { loadFeatures } from './loader.js'\n\nexport const sanitizeServerFeatures = (\n  features: ResolvedServerFeatureMap,\n): SanitizedServerFeatures => {\n  const sanitized: SanitizedServerFeatures = {\n    converters: {\n      html: [],\n    },\n    enabledFeatures: [],\n    generatedTypes: {\n      modifyOutputSchemas: [],\n    },\n    getSubFields: new Map(),\n    getSubFieldsData: new Map(),\n    graphQLPopulationPromises: new Map(),\n    hooks: {\n      afterChange: [],\n      afterRead: [],\n      beforeChange: [],\n      beforeValidate: [],\n    },\n    i18n: {},\n    markdownTransformers: [],\n    nodeHooks: {\n      afterChange: new Map(),\n      afterRead: new Map(),\n      beforeChange: new Map(),\n      beforeValidate: new Map(),\n    },\n    nodes: [],\n\n    validations: new Map(),\n  }\n\n  if (!features?.size) {\n    return sanitized\n  }\n\n  features.forEach((feature) => {\n    if (feature?.generatedTypes?.modifyOutputSchema) {\n      sanitized.generatedTypes.modifyOutputSchemas.push(feature.generatedTypes.modifyOutputSchema)\n    }\n\n    if (feature?.hooks?.beforeValidate?.length) {\n      sanitized.hooks.beforeValidate = sanitized.hooks.beforeValidate?.concat(\n        feature.hooks.beforeValidate,\n      )\n    }\n    if (feature?.hooks?.beforeChange?.length) {\n      sanitized.hooks.beforeChange = sanitized.hooks.beforeChange?.concat(\n        feature.hooks.beforeChange,\n      )\n    }\n    if (feature?.hooks?.afterRead?.length) {\n      sanitized.hooks.afterRead = sanitized.hooks.afterRead?.concat(feature.hooks.afterRead)\n    }\n    if (feature?.hooks?.afterChange?.length) {\n      sanitized.hooks.afterChange = sanitized.hooks.afterChange?.concat(feature.hooks.afterChange)\n    }\n\n    if (feature?.i18n) {\n      for (const lang in feature.i18n) {\n        if (!sanitized.i18n[lang]) {\n          sanitized.i18n[lang] = {\n            lexical: {},\n          }\n        }\n        sanitized.i18n[lang].lexical[feature.key] = feature.i18n[lang]\n      }\n    }\n\n    if (feature.nodes?.length) {\n      sanitized.nodes = sanitized.nodes.concat(feature.nodes)\n      feature.nodes.forEach((node) => {\n        const nodeType = 'with' in node.node ? node.node.replace.getType() : node.node.getType() // TODO: Idk if this works for node replacements\n        if (node?.graphQLPopulationPromises?.length) {\n          sanitized.graphQLPopulationPromises.set(nodeType, node.graphQLPopulationPromises)\n        }\n        if (node?.validations?.length) {\n          sanitized.validations.set(nodeType, node.validations)\n        }\n        if (node?.converters?.html) {\n          sanitized.converters.html.push(node.converters.html)\n        }\n        if (node?.hooks?.afterChange) {\n          sanitized.nodeHooks?.afterChange?.set(nodeType, node.hooks.afterChange)\n        }\n        if (node?.hooks?.afterRead) {\n          sanitized.nodeHooks?.afterRead?.set(nodeType, node.hooks.afterRead)\n        }\n        if (node?.hooks?.beforeChange) {\n          sanitized.nodeHooks?.beforeChange?.set(nodeType, node.hooks.beforeChange)\n        }\n        if (node?.hooks?.beforeValidate) {\n          sanitized.nodeHooks?.beforeValidate?.set(nodeType, node.hooks.beforeValidate)\n        }\n        if (node?.getSubFields) {\n          sanitized.getSubFields?.set(nodeType, node.getSubFields)\n        }\n        if (node?.getSubFieldsData) {\n          sanitized.getSubFieldsData?.set(nodeType, node.getSubFieldsData)\n        }\n      })\n    }\n\n    if (feature.markdownTransformers?.length) {\n      sanitized.markdownTransformers = sanitized.markdownTransformers.concat(\n        feature.markdownTransformers,\n      )\n    }\n\n    sanitized.enabledFeatures.push(feature.key)\n  })\n\n  return sanitized\n}\n\nexport async function sanitizeServerEditorConfig(\n  editorConfig: ServerEditorConfig,\n  config: SanitizedConfig,\n  parentIsLocalized?: boolean,\n): Promise<SanitizedServerEditorConfig> {\n  const resolvedFeatureMap = await loadFeatures({\n    config,\n    parentIsLocalized: parentIsLocalized!,\n    unSanitizedEditorConfig: editorConfig,\n  })\n\n  return {\n    features: sanitizeServerFeatures(resolvedFeatureMap),\n    lexical: editorConfig.lexical!,\n    resolvedFeatureMap,\n  }\n}\n"],"names":["loadFeatures","sanitizeServerFeatures","features","sanitized","converters","html","enabledFeatures","generatedTypes","modifyOutputSchemas","getSubFields","Map","getSubFieldsData","graphQLPopulationPromises","hooks","afterChange","afterRead","beforeChange","beforeValidate","i18n","markdownTransformers","nodeHooks","nodes","validations","size","forEach","feature","modifyOutputSchema","push","length","concat","lang","lexical","key","node","nodeType","replace","getType","set","sanitizeServerEditorConfig","editorConfig","config","parentIsLocalized","resolvedFeatureMap","unSanitizedEditorConfig"],"mappings":"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"}},
    {"offset": {"line": 4709, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 4715, "column": 0}, "map": {"version":3,"file":"i18n.js","sources":["turbopack://[project]/node_modules/@payloadcms/richtext-lexical/src/i18n.ts"],"sourcesContent":["import type { GenericLanguages } from '@payloadcms/translations'\n\nexport const i18n: Partial<GenericLanguages> = {\n  ar: {\n    placeholder: \"ابدأ بالكتابة، أو اضغط على '/' للأوامر ...\",\n    slashMenuBasicGroupLabel: 'أساسي',\n    slashMenuListGroupLabel: 'قوائم',\n  },\n  az: {\n    placeholder: \"Yazmağa başlayın və ya əmrlər üçün '/' düyməsini basın...\",\n    slashMenuBasicGroupLabel: 'Əsas',\n    slashMenuListGroupLabel: 'Siyahılar',\n  },\n  bg: {\n    placeholder: \"Започнете да пишете или натиснете '/' за команди...\",\n    slashMenuBasicGroupLabel: 'Основен',\n    slashMenuListGroupLabel: 'Списъци',\n  },\n  cs: {\n    placeholder: \"Začněte psát nebo stiskněte '/' pro příkazy...\",\n    slashMenuBasicGroupLabel: 'Základní',\n    slashMenuListGroupLabel: 'Seznamy',\n  },\n  de: {\n    placeholder: \"Beginne zu tippen oder drücke '/' für Befehle...\",\n    slashMenuBasicGroupLabel: 'Basis',\n    slashMenuListGroupLabel: 'Listen',\n  },\n  en: {\n    placeholder: \"Start typing, or press '/' for commands...\",\n    slashMenuBasicGroupLabel: 'Basic',\n    slashMenuListGroupLabel: 'Lists',\n  },\n  es: {\n    placeholder: \"Comience a escribir, o presione '/' para comandos...\",\n    slashMenuBasicGroupLabel: 'Básico',\n    slashMenuListGroupLabel: 'Listas',\n  },\n  fa: {\n    placeholder: \"شروع به تایپ کنید، یا برای دستورات '/' را فشار دهید ...\",\n    slashMenuBasicGroupLabel: 'پایه',\n    slashMenuListGroupLabel: 'لیست ها',\n  },\n  fr: {\n    placeholder: \"Commencez à taper, ou appuyez sur '/' pour les commandes...\",\n    slashMenuBasicGroupLabel: 'De base',\n    slashMenuListGroupLabel: 'Listes',\n  },\n  he: {\n    placeholder: \"התחיל להקליד, או לחץ על '/' עבור פקודות ...\",\n    slashMenuBasicGroupLabel: 'בסיסי',\n    slashMenuListGroupLabel: 'רשימות',\n  },\n  hr: {\n    placeholder: \"Počnite tipkati, ili pritisnite '/' za naredbe...\",\n    slashMenuBasicGroupLabel: 'Osnovno',\n    slashMenuListGroupLabel: 'Popisi',\n  },\n  hu: {\n    placeholder: \"Kezdje el gépelni, vagy nyomja meg a '/' billentyűt a parancsokhoz...\",\n    slashMenuBasicGroupLabel: 'Alapvető',\n    slashMenuListGroupLabel: 'Listák',\n  },\n  it: {\n    placeholder: \"Inizia a digitare, oppure premi '/' per i comandi...\",\n    slashMenuBasicGroupLabel: 'Base',\n    slashMenuListGroupLabel: 'Elenchi',\n  },\n  ja: {\n    placeholder: \"入力を開始するか、コマンドのために'/'を押してください…\",\n    slashMenuBasicGroupLabel: '基本的な',\n    slashMenuListGroupLabel: 'リスト',\n  },\n  ko: {\n    placeholder: \"타이핑을 시작하거나, 명령어를 입력하려면 '/'를 누르세요...\",\n    slashMenuBasicGroupLabel: '기본적인',\n    slashMenuListGroupLabel: '목록',\n  },\n  my: {\n    placeholder: \"Mula menaip, atau tekan '/' untuk arahan...\",\n    slashMenuBasicGroupLabel: 'အခြေခံ',\n    slashMenuListGroupLabel: 'Senarai',\n  },\n  nb: {\n    placeholder: \"Begynn å skrive, eller trykk '/' for kommandoer...\",\n    slashMenuBasicGroupLabel: 'Grunnleggende',\n    slashMenuListGroupLabel: 'Lister',\n  },\n  nl: {\n    placeholder: \"Begin met typen, of druk op '/' voor opdrachten...\",\n    slashMenuBasicGroupLabel: 'Basis',\n    slashMenuListGroupLabel: 'Lijsten',\n  },\n  pl: {\n    placeholder: \"Rozpocznij pisanie lub naciśnij '/' dla poleceń...\",\n    slashMenuBasicGroupLabel: 'Podstawowy',\n    slashMenuListGroupLabel: 'Listy',\n  },\n  pt: {\n    placeholder: \"Comece a digitar, ou pressione '/' para comandos...\",\n    slashMenuBasicGroupLabel: 'Básico',\n    slashMenuListGroupLabel: 'Listas',\n  },\n  ro: {\n    placeholder: \"Începeți să tastați sau apăsați '/' pentru comenzi...\",\n    slashMenuBasicGroupLabel: 'De bază',\n    slashMenuListGroupLabel: 'Liste',\n  },\n  rs: {\n    placeholder: \"Počnite da kucate, ili pritisnite '/' za komande...\",\n    slashMenuBasicGroupLabel: 'Osnovno',\n    slashMenuListGroupLabel: 'Liste',\n  },\n  'rs-latin': {\n    placeholder: \"Počnite da kucate, ili pritisnite '/' za komande...\",\n    slashMenuBasicGroupLabel: 'Osnovno',\n    slashMenuListGroupLabel: 'Liste',\n  },\n  ru: {\n    placeholder: \"Начните печатать или нажмите '/' для команд...\",\n    slashMenuBasicGroupLabel: 'Базовый',\n    slashMenuListGroupLabel: 'Списки',\n  },\n  sk: {\n    placeholder: \"Začnite písať alebo stlačte '/' pre príkazy...\",\n    slashMenuBasicGroupLabel: 'Základný',\n    slashMenuListGroupLabel: 'Zoznamy',\n  },\n  sv: {\n    placeholder: \"Börja skriva, eller tryck på '/' för kommandon...\",\n    slashMenuBasicGroupLabel: 'Grundläggande',\n    slashMenuListGroupLabel: 'Listor',\n  },\n  th: {\n    placeholder: \"เริ่มพิมพ์หรือกด '/' สำหรับคำสั่ง...\",\n    slashMenuBasicGroupLabel: 'พื้นฐาน',\n    slashMenuListGroupLabel: 'รายการ',\n  },\n  tr: {\n    placeholder: \"Yazmaya başlayın veya komutlar için '/' tuşuna basın...\",\n    slashMenuBasicGroupLabel: 'Temel',\n    slashMenuListGroupLabel: 'Listeler',\n  },\n  uk: {\n    placeholder: \"Почніть друкувати, або натисніть '/' для команд...\",\n    slashMenuBasicGroupLabel: 'Базовий',\n    slashMenuListGroupLabel: 'Списки',\n  },\n  vi: {\n    placeholder: \"Bắt đầu gõ, hoặc nhấn '/' để gọi lệnh...\",\n    slashMenuBasicGroupLabel: 'Cơ bản',\n    slashMenuListGroupLabel: 'Danh sách',\n  },\n  zh: {\n    placeholder: \"开始输入，或按'/'进行命令...\",\n    slashMenuBasicGroupLabel: '基础',\n    slashMenuListGroupLabel: '列表',\n  },\n  'zh-TW': {\n    placeholder: \"開始輸入，或按'/'以使用命令...\",\n    slashMenuBasicGroupLabel: '基本的',\n    slashMenuListGroupLabel: '清單',\n  },\n}\n"],"names":["i18n","ar","placeholder","slashMenuBasicGroupLabel","slashMenuListGroupLabel","az","bg","cs","de","en","es","fa","fr","he","hr","hu","it","ja","ko","my","nb","nl","pl","pt","ro","rs","ru","sk","sv","th","tr","uk","vi","zh"],"mappings":"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"}},
    {"offset": {"line": 4880, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 4886, "column": 0}, "map": {"version":3,"file":"generateImportMap.js","sources":["turbopack://[project]/node_modules/@payloadcms/richtext-lexical/src/utilities/generateImportMap.tsx"],"sourcesContent":["import type { RichTextAdapter } from 'payload'\n\nimport { genImportMapIterateFields } from 'payload'\n\nimport type { ResolvedServerFeatureMap } from '../features/typesServer.js'\n\nexport const getGenerateImportMap =\n  (args: { resolvedFeatureMap: ResolvedServerFeatureMap }): RichTextAdapter['generateImportMap'] =>\n  ({ addToImportMap, baseDir, config, importMap, imports }) => {\n    addToImportMap('@payloadcms/richtext-lexical/client#RichTextCell')\n    addToImportMap('@payloadcms/richtext-lexical/client#RichTextField')\n    addToImportMap('@payloadcms/richtext-lexical/generateComponentMap#getGenerateComponentMap')\n\n    // iterate just through args.resolvedFeatureMap.values()\n    for (const resolvedFeature of args.resolvedFeatureMap.values()) {\n      if ('componentImports' in resolvedFeature) {\n        if (typeof resolvedFeature.componentImports === 'function') {\n          resolvedFeature.componentImports({\n            addToImportMap,\n            baseDir,\n            config,\n            importMap,\n            imports,\n          })\n        } else if (resolvedFeature.componentImports?.length) {\n          resolvedFeature.componentImports.forEach((component) => {\n            addToImportMap(component)\n          })\n        }\n      }\n\n      const ClientComponent = resolvedFeature.ClientFeature\n      if (ClientComponent) {\n        addToImportMap(ClientComponent)\n      }\n\n      /*\n        Now run for all possible sub-fields\n       */\n      if (resolvedFeature.nodes?.length) {\n        for (const node of resolvedFeature.nodes) {\n          if (typeof node?.getSubFields !== 'function') {\n            continue\n          }\n          const subFields = node.getSubFields({})\n          if (subFields?.length) {\n            genImportMapIterateFields({\n              addToImportMap,\n              baseDir,\n              config,\n              fields: subFields,\n              importMap,\n              imports,\n            })\n          }\n        }\n      }\n    }\n  }\n"],"names":["genImportMapIterateFields","getGenerateImportMap","args","addToImportMap","baseDir","config","importMap","imports","resolvedFeature","resolvedFeatureMap","values","componentImports","length","forEach","component","ClientComponent","ClientFeature","nodes","node","getSubFields","subFields","fields"],"mappings":";;;AAEA,SAASA,yBAAyB,QAAQ;;AAInC,MAAMC,oBAAA,IACVC,IAAA,GACD,CAAC,EAAEC,cAAc,EAAEC,OAAO,EAAEC,MAAM,EAAEC,SAAS,EAAEC,OAAAA,EAAS;QACtDJ,cAAA,CAAe;QACfA,cAAA,CAAe;QACfA,cAAA,CAAe;QAEf,wDAAA;QACA,KAAK,MAAMK,eAAA,IAAmBN,IAAA,CAAKO,kBAAkB,CAACC,MAAM,GAAI;YAC9D,IAAI,sBAAsBF,eAAA,EAAiB;gBACzC,IAAI,OAAOA,eAAA,CAAgBG,gBAAgB,KAAK,YAAY;oBAC1DH,eAAA,CAAgBG,gBAAgB,CAAC;wBAC/BR,cAAA;wBACAC,OAAA;wBACAC,MAAA;wBACAC,SAAA;wBACAC;oBACF;gBACF,OAAO,IAAIC,eAAA,CAAgBG,gBAAgB,EAAEC,MAAA,EAAQ;oBACnDJ,eAAA,CAAgBG,gBAAgB,CAACE,OAAO,EAAEC,SAAA;wBACxCX,cAAA,CAAeW,SAAA;oBACjB;gBACF;YACF;YAEA,MAAMC,eAAA,GAAkBP,eAAA,CAAgBQ,aAAa;YACrD,IAAID,eAAA,EAAiB;gBACnBZ,cAAA,CAAeY,eAAA;YACjB;YAEA;;OAGA,IAAIP,eAAA,CAAgBS,KAAK,EAAEL,MAAA,EAAQ;gBACjC,KAAK,MAAMM,IAAA,IAAQV,eAAA,CAAgBS,KAAK,CAAE;oBACxC,IAAI,OAAOC,IAAA,EAAMC,YAAA,KAAiB,YAAY;wBAC5C;oBACF;oBACA,MAAMC,SAAA,GAAYF,IAAA,CAAKC,YAAY,CAAC,CAAC;oBACrC,IAAIC,SAAA,EAAWR,MAAA,EAAQ;yMACrBZ,4BAAAA,AAAA,EAA0B;4BACxBG,cAAA;4BACAC,OAAA;4BACAC,MAAA;4BACAgB,MAAA,EAAQD,SAAA;4BACRd,SAAA;4BACAC;wBACF;oBACF;gBACF;YACF;QACF;IACF"}},
    {"offset": {"line": 4938, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 4944, "column": 0}, "map": {"version":3,"file":"generateSchemaMap.js","sources":["turbopack://[project]/node_modules/@payloadcms/richtext-lexical/src/utilities/generateSchemaMap.ts"],"sourcesContent":["import type { RichTextAdapter } from 'payload'\n\nimport { traverseFields } from '@payloadcms/ui/utilities/buildFieldSchemaMap/traverseFields'\n\nimport type { ResolvedServerFeatureMap } from '../features/typesServer.js'\n\nexport const getGenerateSchemaMap =\n  (args: { resolvedFeatureMap: ResolvedServerFeatureMap }): RichTextAdapter['generateSchemaMap'] =>\n  ({ config, field, i18n, schemaMap, schemaPath }) => {\n    for (const [featureKey, resolvedFeature] of args.resolvedFeatureMap.entries()) {\n      if (\n        !('generateSchemaMap' in resolvedFeature) ||\n        typeof resolvedFeature.generateSchemaMap !== 'function'\n      ) {\n        continue\n      }\n      const schemas = resolvedFeature.generateSchemaMap({\n        config,\n        field,\n        i18n,\n        props: resolvedFeature.sanitizedServerFeatureProps,\n        schemaMap,\n        schemaPath,\n      })\n\n      if (schemas) {\n        for (const [schemaKey, fields] of schemas.entries()) {\n          // generate schema map entries for sub-fields using traverseFields\n          traverseFields({\n            config,\n            fields,\n            i18n,\n            schemaMap: schemas,\n            schemaPath: schemaKey,\n          })\n\n          schemaMap.set(`${schemaPath}.lexical_internal_feature.${featureKey}.${schemaKey}`, fields)\n        }\n      }\n    }\n\n    return schemaMap\n  }\n"],"names":["traverseFields","getGenerateSchemaMap","args","config","field","i18n","schemaMap","schemaPath","featureKey","resolvedFeature","resolvedFeatureMap","entries","generateSchemaMap","schemas","props","sanitizedServerFeatureProps","schemaKey","fields","set"],"mappings":";;;AAEA,SAASA,cAAc,QAAQ;;AAIxB,MAAMC,oBAAA,IACVC,IAAA,GACD,CAAC,EAAEC,MAAM,EAAEC,KAAK,EAAEC,IAAI,EAAEC,SAAS,EAAEC,UAAAA,EAAY;QAC7C,KAAK,MAAM,CAACC,UAAA,EAAYC,eAAA,CAAgB,IAAIP,IAAA,CAAKQ,kBAAkB,CAACC,OAAO,GAAI;YAC7E,IACE,CAAA,CAAE,uBAAuBF,eAAc,KACvC,OAAOA,eAAA,CAAgBG,iBAAiB,KAAK,YAC7C;gBACA;YACF;YACA,MAAMC,OAAA,GAAUJ,eAAA,CAAgBG,iBAAiB,CAAC;gBAChDT,MAAA;gBACAC,KAAA;gBACAC,IAAA;gBACAS,KAAA,EAAOL,eAAA,CAAgBM,2BAA2B;gBAClDT,SAAA;gBACAC;YACF;YAEA,IAAIM,OAAA,EAAS;gBACX,KAAK,MAAM,CAACG,SAAA,EAAWC,MAAA,CAAO,IAAIJ,OAAA,CAAQF,OAAO,GAAI;oBACnD,kEAAA;yNACAX,iBAAAA,AAAA,EAAe;wBACbG,MAAA;wBACAc,MAAA;wBACAZ,IAAA;wBACAC,SAAA,EAAWO,OAAA;wBACXN,UAAA,EAAYS;oBACd;oBAEAV,SAAA,CAAUY,GAAG,CAAC,GAAGX,UAAA,CAAA,0BAAA,EAAuCC,UAAA,CAAA,CAAA,EAAcQ,SAAA,EAAW,EAAEC,MAAA;gBACrF;YACF;QACF;QAEA,OAAOX,SAAA;IACT"}},
    {"offset": {"line": 4978, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 4984, "column": 0}, "map": {"version":3,"file":"forEachNodeRecursively.js","sources":["turbopack://[project]/node_modules/@payloadcms/richtext-lexical/src/utilities/forEachNodeRecursively.ts"],"sourcesContent":["import type { SerializedLexicalNode } from 'lexical'\n\nexport function recurseNodes({\n  callback,\n  nodes,\n}: {\n  callback: (node: SerializedLexicalNode) => void\n  nodes: SerializedLexicalNode[]\n}) {\n  for (const node of nodes) {\n    callback(node)\n\n    if ('children' in node && Array.isArray(node?.children) && node?.children?.length) {\n      recurseNodes({ callback, nodes: node.children as SerializedLexicalNode[] })\n    }\n  }\n}\n\nexport async function recurseNodesAsync({\n  callback,\n  nodes,\n}: {\n  callback: (node: SerializedLexicalNode) => Promise<void>\n  nodes: SerializedLexicalNode[]\n}) {\n  for (const node of nodes) {\n    await callback(node)\n\n    if ('children' in node && Array.isArray(node?.children) && node?.children?.length) {\n      await recurseNodesAsync({ callback, nodes: node.children as SerializedLexicalNode[] })\n    }\n  }\n}\n"],"names":["recurseNodes","callback","nodes","node","Array","isArray","children","length","recurseNodesAsync"],"mappings":";;;;AAEO,SAASA,aAAa,EAC3BC,QAAQ,EACRC,KAAAA,EAID;IACC,KAAK,MAAMC,IAAA,IAAQD,KAAA,CAAO;QACxBD,QAAA,CAASE,IAAA;QAET,IAAI,cAAcA,IAAA,IAAQC,KAAA,CAAMC,OAAO,CAACF,IAAA,EAAMG,QAAA,KAAaH,IAAA,EAAMG,QAAA,EAAUC,MAAA,EAAQ;YACjFP,YAAA,CAAa;gBAAEC,QAAA;gBAAUC,KAAA,EAAOC,IAAA,CAAKG,QAAAA;YAAoC;QAC3E;IACF;AACF;AAEO,eAAeE,kBAAkB,EACtCP,QAAQ,EACRC,KAAAA,EAID;IACC,KAAK,MAAMC,IAAA,IAAQD,KAAA,CAAO;QACxB,MAAMD,QAAA,CAASE,IAAA;QAEf,IAAI,cAAcA,IAAA,IAAQC,KAAA,CAAMC,OAAO,CAACF,IAAA,EAAMG,QAAA,KAAaH,IAAA,EAAMG,QAAA,EAAUC,MAAA,EAAQ;YACjF,MAAMC,iBAAA,CAAkB;gBAAEP,QAAA;gBAAUC,KAAA,EAAOC,IAAA,CAAKG,QAAAA;YAAoC;QACtF;IACF;AACF"}},
    {"offset": {"line": 5010, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 5016, "column": 0}, "map": {"version":3,"file":"populateLexicalPopulationPromises.js","sources":["turbopack://[project]/node_modules/@payloadcms/richtext-lexical/src/populateGraphQL/populateLexicalPopulationPromises.ts"],"sourcesContent":["import type { SerializedEditorState } from 'lexical'\nimport type { RichTextAdapter } from 'payload'\n\nimport type { PopulationPromise } from '../features/typesServer.js'\nimport type { AdapterProps } from '../types.js'\n\nimport { recurseNodes } from '../utilities/forEachNodeRecursively.js'\n\nexport type Args = {\n  editorPopulationPromises: Map<string, Array<PopulationPromise>>\n} & Parameters<\n  NonNullable<RichTextAdapter<SerializedEditorState, AdapterProps>['graphQLPopulationPromises']>\n>[0]\n\n/**\n * Appends all new populationPromises to the populationPromises prop\n */\nexport const populateLexicalPopulationPromises = ({\n  context,\n  currentDepth,\n  depth,\n  draft,\n  editorPopulationPromises,\n  field,\n  fieldPromises,\n  findMany,\n  flattenLocales,\n  overrideAccess,\n  populationPromises,\n  req,\n  showHiddenFields,\n  siblingDoc,\n}: Args) => {\n  const shouldPopulate = depth && currentDepth! <= depth\n\n  if (!shouldPopulate) {\n    return\n  }\n\n  recurseNodes({\n    callback: (node) => {\n      const editorPopulationPromisesOfNodeType = editorPopulationPromises?.get(node.type)\n      if (editorPopulationPromisesOfNodeType) {\n        for (const promise of editorPopulationPromisesOfNodeType) {\n          promise({\n            context,\n            currentDepth: currentDepth!,\n            depth,\n            draft,\n            editorPopulationPromises,\n            field,\n            fieldPromises,\n            findMany,\n            flattenLocales,\n            node,\n            overrideAccess: overrideAccess!,\n            populationPromises,\n            req,\n            showHiddenFields,\n            siblingDoc,\n          })\n        }\n      }\n    },\n\n    nodes: (siblingDoc[field?.name] as SerializedEditorState)?.root?.children ?? [],\n  })\n}\n"],"names":["recurseNodes","populateLexicalPopulationPromises","context","currentDepth","depth","draft","editorPopulationPromises","field","fieldPromises","findMany","flattenLocales","overrideAccess","populationPromises","req","showHiddenFields","siblingDoc","shouldPopulate","callback","node","editorPopulationPromisesOfNodeType","get","type","promise","nodes","name","root","children"],"mappings":";;;AAMA,SAASA,YAAY,QAAQ;;AAWtB,MAAMC,iCAAA,GAAoCA,CAAC,EAChDC,OAAO,EACPC,YAAY,EACZC,KAAK,EACLC,KAAK,EACLC,wBAAwB,EACxBC,KAAK,EACLC,aAAa,EACbC,QAAQ,EACRC,cAAc,EACdC,cAAc,EACdC,kBAAkB,EAClBC,GAAG,EACHC,gBAAgB,EAChBC,UAAAA,EACK;IACL,MAAMC,cAAA,GAAiBZ,KAAA,IAASD,YAAA,IAAiBC,KAAA;IAEjD,IAAI,CAACY,cAAA,EAAgB;QACnB;IACF;2MAEAhB,eAAAA,AAAA,EAAa;QACXiB,QAAA,GAAWC,IAAA;YACT,MAAMC,kCAAA,GAAqCb,wBAAA,EAA0Bc,GAAA,CAAIF,IAAA,CAAKG,IAAI;YAClF,IAAIF,kCAAA,EAAoC;gBACtC,KAAK,MAAMG,OAAA,IAAWH,kCAAA,CAAoC;oBACxDG,OAAA,CAAQ;wBACNpB,OAAA;wBACAC,YAAA,EAAcA,YAAA;wBACdC,KAAA;wBACAC,KAAA;wBACAC,wBAAA;wBACAC,KAAA;wBACAC,aAAA;wBACAC,QAAA;wBACAC,cAAA;wBACAQ,IAAA;wBACAP,cAAA,EAAgBA,cAAA;wBAChBC,kBAAA;wBACAC,GAAA;wBACAC,gBAAA;wBACAC;oBACF;gBACF;YACF;QACF;QAEAQ,KAAA,EAAOR,UAAW,CAACR,KAAA,EAAOiB,IAAA,CAAK,EAA4BC,IAAA,EAAMC,QAAA,IAAY,EAAA;IAC/E;AACF"}},
    {"offset": {"line": 5054, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 5060, "column": 0}, "map": {"version":3,"file":"recurseNodeTree.js","sources":["turbopack://[project]/node_modules/@payloadcms/richtext-lexical/src/utilities/recurseNodeTree.ts"],"sourcesContent":["import type { SerializedLexicalNode } from 'lexical'\n\n// Initialize both flattenedNodes and nodeIDMap\nexport const recurseNodeTree = ({\n  flattenedNodes,\n  nodeIDMap,\n  nodes,\n}: {\n  flattenedNodes?: SerializedLexicalNode[]\n  nodeIDMap?: {\n    [key: string]: SerializedLexicalNode\n  }\n  nodes: SerializedLexicalNode[]\n}): void => {\n  if (!nodes?.length) {\n    return\n  }\n\n  for (const node of nodes) {\n    if (flattenedNodes) {\n      flattenedNodes.push(node)\n    }\n    if (nodeIDMap) {\n      if (node && 'id' in node && node.id) {\n        nodeIDMap[node.id as string] = node\n      } else if (\n        'fields' in node &&\n        typeof node.fields === 'object' &&\n        node.fields &&\n        'id' in node.fields &&\n        node?.fields?.id\n      ) {\n        nodeIDMap[node.fields.id as string] = node\n      }\n    }\n\n    if ('children' in node && Array.isArray(node?.children) && node?.children?.length) {\n      recurseNodeTree({\n        flattenedNodes,\n        nodeIDMap,\n        nodes: node.children as SerializedLexicalNode[],\n      })\n    }\n  }\n}\n"],"names":["recurseNodeTree","flattenedNodes","nodeIDMap","nodes","length","node","push","id","fields","Array","isArray","children"],"mappings":"AAEA,+CAAA;;;;AACO,MAAMA,eAAA,GAAkBA,CAAC,EAC9BC,cAAc,EACdC,SAAS,EACTC,KAAAA,EAOD;IACC,IAAI,CAACA,KAAA,EAAOC,MAAA,EAAQ;QAClB;IACF;IAEA,KAAK,MAAMC,IAAA,IAAQF,KAAA,CAAO;QACxB,IAAIF,cAAA,EAAgB;YAClBA,cAAA,CAAeK,IAAI,CAACD,IAAA;QACtB;QACA,IAAIH,SAAA,EAAW;YACb,IAAIG,IAAA,IAAQ,QAAQA,IAAA,IAAQA,IAAA,CAAKE,EAAE,EAAE;gBACnCL,SAAS,CAACG,IAAA,CAAKE,EAAE,CAAW,GAAGF,IAAA;YACjC,OAAO,IACL,YAAYA,IAAA,IACZ,OAAOA,IAAA,CAAKG,MAAM,KAAK,YACvBH,IAAA,CAAKG,MAAM,IACX,QAAQH,IAAA,CAAKG,MAAM,IACnBH,IAAA,EAAMG,MAAA,EAAQD,EAAA,EACd;gBACAL,SAAS,CAACG,IAAA,CAAKG,MAAM,CAACD,EAAE,CAAW,GAAGF,IAAA;YACxC;QACF;QAEA,IAAI,cAAcA,IAAA,IAAQI,KAAA,CAAMC,OAAO,CAACL,IAAA,EAAMM,QAAA,KAAaN,IAAA,EAAMM,QAAA,EAAUP,MAAA,EAAQ;YACjFJ,eAAA,CAAgB;gBACdC,cAAA;gBACAC,SAAA;gBACAC,KAAA,EAAOE,IAAA,CAAKM,QAAAA;YACd;QACF;IACF;AACF"}},
    {"offset": {"line": 5088, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 5094, "column": 0}, "map": {"version":3,"file":"validateNodes.js","sources":["turbopack://[project]/node_modules/@payloadcms/richtext-lexical/src/validate/validateNodes.ts"],"sourcesContent":["import type { SerializedEditorState, SerializedLexicalNode } from 'lexical'\nimport type { RichTextField, ValidateOptions } from 'payload'\n\nimport type { NodeValidation } from '../features/typesServer.js'\n\nexport async function validateNodes({\n  nodes,\n  nodeValidations,\n  validation: validationFromProps,\n}: {\n  nodes: SerializedLexicalNode[]\n  nodeValidations: Map<string, Array<NodeValidation>>\n  validation: {\n    options: ValidateOptions<unknown, unknown, RichTextField, SerializedEditorState>\n    value: SerializedEditorState\n  }\n}): Promise<string | true> {\n  for (const node of nodes) {\n    // Validate node\n    const validations = nodeValidations.get(node.type)\n    if (validations) {\n      for (const validation of validations) {\n        const validationResult = await validation({\n          node,\n          nodeValidations,\n          validation: validationFromProps,\n        })\n        if (validationResult !== true) {\n          return `${node.type} node failed to validate: ${validationResult}`\n        }\n      }\n    }\n\n    // Validate node's children\n    if ('children' in node && node?.children) {\n      const childrenValidationResult = await validateNodes({\n        nodes: node.children as SerializedLexicalNode[],\n        nodeValidations,\n        validation: validationFromProps,\n      })\n      if (childrenValidationResult !== true) {\n        return childrenValidationResult\n      }\n    }\n  }\n\n  return true\n}\n"],"names":["validateNodes","nodes","nodeValidations","validation","validationFromProps","node","validations","get","type","validationResult","children","childrenValidationResult"],"mappings":";;;AAKO,eAAeA,cAAc,EAClCC,KAAK,EACLC,eAAe,EACfC,UAAA,EAAYC,mBAAAA,EAQb;IACC,KAAK,MAAMC,IAAA,IAAQJ,KAAA,CAAO;QACxB,gBAAA;QACA,MAAMK,WAAA,GAAcJ,eAAA,CAAgBK,GAAG,CAACF,IAAA,CAAKG,IAAI;QACjD,IAAIF,WAAA,EAAa;YACf,KAAK,MAAMH,UAAA,IAAcG,WAAA,CAAa;gBACpC,MAAMG,gBAAA,GAAmB,MAAMN,UAAA,CAAW;oBACxCE,IAAA;oBACAH,eAAA;oBACAC,UAAA,EAAYC;gBACd;gBACA,IAAIK,gBAAA,KAAqB,MAAM;oBAC7B,OAAO,GAAGJ,IAAA,CAAKG,IAAI,CAAA,0BAAA,EAA6BC,gBAAA,EAAkB;gBACpE;YACF;QACF;QAEA,2BAAA;QACA,IAAI,cAAcJ,IAAA,IAAQA,IAAA,EAAMK,QAAA,EAAU;YACxC,MAAMC,wBAAA,GAA2B,MAAMX,aAAA,CAAc;gBACnDC,KAAA,EAAOI,IAAA,CAAKK,QAAQ;gBACpBR,eAAA;gBACAC,UAAA,EAAYC;YACd;YACA,IAAIO,wBAAA,KAA6B,MAAM;gBACrC,OAAOA,wBAAA;YACT;QACF;IACF;IAEA,OAAO;AACT"}},
    {"offset": {"line": 5127, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 5133, "column": 0}, "map": {"version":3,"file":"index.js","sources":["turbopack://[project]/node_modules/@payloadcms/richtext-lexical/src/validate/index.ts"],"sourcesContent":["import type { SerializedEditorState, SerializedParagraphNode } from 'lexical'\nimport type { RichTextField, Validate } from 'payload'\n\nimport type { SanitizedServerEditorConfig } from '../lexical/config/types.js'\n\nimport { validateNodes } from './validateNodes.js'\n\nexport const richTextValidateHOC = ({\n  editorConfig,\n}: {\n  editorConfig: SanitizedServerEditorConfig\n}) => {\n  const richTextValidate: Validate<SerializedEditorState, unknown, unknown, RichTextField> = async (\n    value,\n    options,\n  ) => {\n    const {\n      req: { t },\n      required,\n    } = options\n\n    if (required) {\n      const hasChildren = !!value?.root?.children?.length\n\n      let hasOnlyEmptyParagraph = false\n      if (value?.root?.children?.length === 1) {\n        if (value?.root?.children[0]?.type === 'paragraph') {\n          const paragraphNode = value?.root?.children[0] as SerializedParagraphNode\n          if (paragraphNode?.children?.length === 0) {\n            hasOnlyEmptyParagraph = true\n          } else if (paragraphNode?.children?.length === 1) {\n            const paragraphNodeChild = paragraphNode?.children[0]\n            if (paragraphNodeChild.type === 'text') {\n              if (!paragraphNodeChild?.['text']?.length) {\n                hasOnlyEmptyParagraph = true\n              }\n            }\n          }\n        }\n      }\n\n      if (!hasChildren || hasOnlyEmptyParagraph) {\n        return t('validation:required')\n      }\n    }\n\n    // Traverse through nodes and validate them. Just like a node can hook into the population process (e.g. link or relationship nodes),\n    // they can also hook into the validation process. E.g. a block node probably has fields with validation rules.\n\n    const rootNodes = value?.root?.children\n    if (rootNodes && Array.isArray(rootNodes) && rootNodes?.length) {\n      return await validateNodes({\n        nodes: rootNodes,\n        nodeValidations: editorConfig.features.validations,\n        validation: {\n          options,\n          value,\n        },\n      })\n    }\n\n    return true\n  }\n\n  return richTextValidate\n}\n"],"names":["validateNodes","richTextValidateHOC","editorConfig","richTextValidate","value","options","req","t","required","hasChildren","root","children","length","hasOnlyEmptyParagraph","type","paragraphNode","paragraphNodeChild","rootNodes","Array","isArray","nodes","nodeValidations","features","validations","validation"],"mappings":";;;AAKA,SAASA,aAAa,QAAQ;;AAEvB,MAAMC,mBAAA,GAAsBA,CAAC,EAClCC,YAAAA,EAGD;IACC,MAAMC,gBAAA,GAAqF,MAAAA,CACzFC,KAAA,EACAC,OAAA;QAEA,MAAM,EACJC,GAAA,EAAK,EAAEC,CAAAA,EAAG,EACVC,QAAAA,EACD,GAAGH,OAAA;QAEJ,IAAIG,QAAA,EAAU;YACZ,MAAMC,WAAA,GAAc,CAAC,CAACL,KAAA,EAAOM,IAAA,EAAMC,QAAA,EAAUC,MAAA;YAE7C,IAAIC,qBAAA,GAAwB;YAC5B,IAAIT,KAAA,EAAOM,IAAA,EAAMC,QAAA,EAAUC,MAAA,KAAW,GAAG;gBACvC,IAAIR,KAAA,EAAOM,IAAA,EAAMC,QAAQ,CAAC,EAAE,EAAEG,IAAA,KAAS,aAAa;oBAClD,MAAMC,aAAA,GAAgBX,KAAA,EAAOM,IAAA,EAAMC,QAAQ,CAAC,EAAE;oBAC9C,IAAII,aAAA,EAAeJ,QAAA,EAAUC,MAAA,KAAW,GAAG;wBACzCC,qBAAA,GAAwB;oBAC1B,OAAO,IAAIE,aAAA,EAAeJ,QAAA,EAAUC,MAAA,KAAW,GAAG;wBAChD,MAAMI,kBAAA,GAAqBD,aAAA,EAAeJ,QAAQ,CAAC,EAAE;wBACrD,IAAIK,kBAAA,CAAmBF,IAAI,KAAK,QAAQ;4BACtC,IAAI,CAACE,kBAAA,EAAA,CAAqB,OAAO,EAAEJ,MAAA,EAAQ;gCACzCC,qBAAA,GAAwB;4BAC1B;wBACF;oBACF;gBACF;YACF;YAEA,IAAI,CAACJ,WAAA,IAAeI,qBAAA,EAAuB;gBACzC,OAAON,CAAA,CAAE;YACX;QACF;QAEA,qIAAA;QACA,+GAAA;QAEA,MAAMU,SAAA,GAAYb,KAAA,EAAOM,IAAA,EAAMC,QAAA;QAC/B,IAAIM,SAAA,IAAaC,KAAA,CAAMC,OAAO,CAACF,SAAA,KAAcA,SAAA,EAAWL,MAAA,EAAQ;YAC9D,OAAO,mMAAMZ,gBAAAA,AAAA,EAAc;gBACzBoB,KAAA,EAAOH,SAAA;gBACPI,eAAA,EAAiBnB,YAAA,CAAaoB,QAAQ,CAACC,WAAW;gBAClDC,UAAA,EAAY;oBACVnB,OAAA;oBACAD;gBACF;YACF;QACF;QAEA,OAAO;IACT;IAEA,OAAOD,gBAAA;AACT"}},
    {"offset": {"line": 5180, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 5186, "column": 0}, "map": {"version":3,"file":"index.js","sources":["turbopack://[project]/node_modules/@payloadcms/richtext-lexical/src/index.ts"],"sourcesContent":["import type { JSONSchema4 } from 'json-schema'\nimport type { SerializedEditorState, SerializedLexicalNode } from 'lexical'\n\nimport {\n  afterChangeTraverseFields,\n  afterReadTraverseFields,\n  beforeChangeTraverseFields,\n  beforeValidateTraverseFields,\n  checkDependencies,\n  deepCopyObject,\n  deepCopyObjectSimple,\n  withNullableJSONSchemaType,\n} from 'payload'\n\nimport type { FeatureProviderServer, ResolvedServerFeatureMap } from './features/typesServer.js'\nimport type { SanitizedServerEditorConfig } from './lexical/config/types.js'\nimport type {\n  AdapterProps,\n  LexicalEditorProps,\n  LexicalRichTextAdapter,\n  LexicalRichTextAdapterProvider,\n} from './types.js'\n\nimport { i18n } from './i18n.js'\nimport { defaultEditorConfig, defaultEditorFeatures } from './lexical/config/server/default.js'\nimport { loadFeatures } from './lexical/config/server/loader.js'\nimport {\n  sanitizeServerEditorConfig,\n  sanitizeServerFeatures,\n} from './lexical/config/server/sanitize.js'\nimport { populateLexicalPopulationPromises } from './populateGraphQL/populateLexicalPopulationPromises.js'\nimport { getGenerateImportMap } from './utilities/generateImportMap.js'\nimport { getGenerateSchemaMap } from './utilities/generateSchemaMap.js'\nimport { recurseNodeTree } from './utilities/recurseNodeTree.js'\nimport { richTextValidateHOC } from './validate/index.js'\n\nlet defaultSanitizedServerEditorConfig: null | SanitizedServerEditorConfig = null\nlet checkedDependencies = false\n\nexport function lexicalEditor(props?: LexicalEditorProps): LexicalRichTextAdapterProvider {\n  return async ({ config, isRoot, parentIsLocalized }) => {\n    if (\n      process.env.NODE_ENV !== 'production' &&\n      process.env.PAYLOAD_DISABLE_DEPENDENCY_CHECKER !== 'true' &&\n      !checkedDependencies\n    ) {\n      checkedDependencies = true\n      await checkDependencies({\n        dependencyGroups: [\n          {\n            name: 'lexical',\n            dependencies: [\n              'lexical',\n              '@lexical/headless',\n              '@lexical/link',\n              '@lexical/list',\n              '@lexical/mark',\n              '@lexical/markdown',\n              '@lexical/react',\n              '@lexical/rich-text',\n              '@lexical/selection',\n              '@lexical/utils',\n            ],\n            targetVersion: '0.18.0',\n          },\n        ],\n      })\n    }\n\n    let features: FeatureProviderServer<any, any, any>[] = []\n    let resolvedFeatureMap: ResolvedServerFeatureMap\n\n    let finalSanitizedEditorConfig: SanitizedServerEditorConfig // For server only\n    if (!props || (!props.features && !props.lexical)) {\n      if (!defaultSanitizedServerEditorConfig) {\n        defaultSanitizedServerEditorConfig = await sanitizeServerEditorConfig(\n          defaultEditorConfig,\n          config,\n          parentIsLocalized,\n        )\n        features = deepCopyObject(defaultEditorFeatures)\n      }\n\n      finalSanitizedEditorConfig = deepCopyObject(defaultSanitizedServerEditorConfig)\n\n      resolvedFeatureMap = finalSanitizedEditorConfig.resolvedFeatureMap\n    } else {\n      const rootEditor = config.editor\n      let rootEditorFeatures: FeatureProviderServer<unknown, unknown, unknown>[] = []\n      if (typeof rootEditor === 'object' && 'features' in rootEditor) {\n        rootEditorFeatures = (rootEditor as LexicalRichTextAdapter).features\n      }\n\n      features =\n        props.features && typeof props.features === 'function'\n          ? props.features({\n              defaultFeatures: deepCopyObject(defaultEditorFeatures),\n              rootFeatures: rootEditorFeatures,\n            })\n          : (props.features as FeatureProviderServer<unknown, unknown, unknown>[])\n      if (!features) {\n        features = deepCopyObject(defaultEditorFeatures)\n      }\n\n      const lexical = props.lexical ?? deepCopyObjectSimple(defaultEditorConfig.lexical)!\n\n      resolvedFeatureMap = await loadFeatures({\n        config,\n        isRoot,\n        parentIsLocalized,\n        unSanitizedEditorConfig: {\n          features,\n          lexical,\n        },\n      })\n\n      finalSanitizedEditorConfig = {\n        features: sanitizeServerFeatures(resolvedFeatureMap),\n        lexical,\n        resolvedFeatureMap,\n      }\n    }\n\n    const featureI18n = finalSanitizedEditorConfig.features.i18n\n    for (const lang in i18n) {\n      if (!featureI18n[lang]) {\n        featureI18n[lang] = {\n          lexical: {},\n        }\n      }\n\n      featureI18n[lang].lexical.general = i18n[lang]\n    }\n\n    return {\n      CellComponent: {\n        clientProps: {\n          admin: props?.admin,\n          lexicalEditorConfig: finalSanitizedEditorConfig.lexical,\n        },\n        path: '@payloadcms/richtext-lexical/client#RichTextCell',\n      },\n      editorConfig: finalSanitizedEditorConfig,\n      features,\n      FieldComponent: {\n        clientProps: {\n          admin: props?.admin,\n          lexicalEditorConfig: finalSanitizedEditorConfig.lexical,\n        },\n        path: '@payloadcms/richtext-lexical/client#RichTextField',\n      },\n      generateComponentMap: {\n        path: '@payloadcms/richtext-lexical/generateComponentMap#getGenerateComponentMap',\n        serverProps: {\n          resolvedFeatureMap,\n        },\n      },\n      generateImportMap: getGenerateImportMap({\n        resolvedFeatureMap,\n      }),\n      generateSchemaMap: getGenerateSchemaMap({\n        resolvedFeatureMap,\n      }),\n      graphQLPopulationPromises({\n        context,\n        currentDepth,\n        depth,\n        draft,\n        field,\n        fieldPromises,\n        findMany,\n        flattenLocales,\n        overrideAccess,\n        populationPromises,\n        req,\n        showHiddenFields,\n        siblingDoc,\n      }) {\n        // check if there are any features with nodes which have populationPromises for this field\n        if (finalSanitizedEditorConfig?.features?.graphQLPopulationPromises?.size) {\n          populateLexicalPopulationPromises({\n            context,\n            currentDepth: currentDepth ?? 0,\n            depth,\n            draft,\n            editorPopulationPromises: finalSanitizedEditorConfig.features.graphQLPopulationPromises,\n            field,\n            fieldPromises,\n            findMany,\n            flattenLocales,\n            overrideAccess,\n            populationPromises,\n            req,\n            showHiddenFields,\n            siblingDoc,\n          })\n        }\n      },\n      hooks: {\n        afterChange: [\n          async (args) => {\n            const { collection, context: _context, global, operation, path, req, schemaPath } = args\n            let { value } = args\n            if (finalSanitizedEditorConfig?.features?.hooks?.afterChange?.length) {\n              for (const hook of finalSanitizedEditorConfig.features.hooks.afterChange) {\n                value = await hook(args)\n              }\n            }\n            if (\n              !finalSanitizedEditorConfig.features.nodeHooks?.afterChange?.size &&\n              !finalSanitizedEditorConfig.features.getSubFields?.size\n            ) {\n              return value\n            }\n            const context: any = _context\n            const nodeIDMap: {\n              [key: string]: SerializedLexicalNode\n            } = {}\n\n            /**\n             * Get the originalNodeIDMap from the beforeValidate hook, which is always run before this hook.\n             */\n            const originalNodeIDMap: {\n              [key: string]: SerializedLexicalNode\n            } = context?.internal?.richText?.[path.join('.')]?.originalNodeIDMap\n\n            if (!originalNodeIDMap || !Object.keys(originalNodeIDMap).length || !value) {\n              return value\n            }\n\n            recurseNodeTree({\n              nodeIDMap,\n              nodes: (value as SerializedEditorState)?.root?.children ?? [],\n            })\n\n            // eslint-disable-next-line prefer-const\n            for (let [id, node] of Object.entries(nodeIDMap)) {\n              const afterChangeHooks = finalSanitizedEditorConfig.features.nodeHooks?.afterChange\n              const afterChangeHooksForNode = afterChangeHooks?.get(node.type)\n              if (afterChangeHooksForNode) {\n                for (const hook of afterChangeHooksForNode) {\n                  if (!originalNodeIDMap[id]) {\n                    console.warn(\n                      '(afterChange) No original node found for node with id',\n                      id,\n                      'node:',\n                      node,\n                      'path',\n                      path.join('.'),\n                    )\n                    continue\n                  }\n                  node = await hook({\n                    context,\n                    node,\n                    operation,\n                    originalNode: originalNodeIDMap[id],\n                    parentRichTextFieldPath: path,\n                    parentRichTextFieldSchemaPath: schemaPath,\n                    req,\n                  })\n                }\n              }\n              const subFieldFn = finalSanitizedEditorConfig.features.getSubFields?.get(node.type)\n              const subFieldDataFn = finalSanitizedEditorConfig.features.getSubFieldsData?.get(\n                node.type,\n              )\n\n              if (subFieldFn && subFieldDataFn) {\n                const subFields = subFieldFn({ node, req })\n                const data = subFieldDataFn({ node, req }) ?? {}\n                const originalData = subFieldDataFn({ node: originalNodeIDMap[id], req }) ?? {}\n\n                if (subFields?.length) {\n                  await afterChangeTraverseFields({\n                    collection,\n                    context,\n                    data: originalData,\n                    doc: data,\n                    fields: subFields,\n                    global,\n                    operation,\n                    path,\n                    previousDoc: data,\n                    previousSiblingDoc: { ...data },\n                    req,\n                    schemaPath,\n                    siblingData: originalData || {},\n                    siblingDoc: { ...data },\n                  })\n                }\n              }\n            }\n            return value\n          },\n        ],\n        afterRead: [\n          /**\n           * afterRead hooks do not receive the originalNode. Thus, they can run on all nodes, not just nodes with an ID.\n           */\n          async (args) => {\n            const {\n              collection,\n              context: context,\n              currentDepth,\n              depth,\n              draft,\n              fallbackLocale,\n              fieldPromises,\n              findMany,\n              flattenLocales,\n              global,\n              locale,\n              overrideAccess,\n              path,\n              populationPromises,\n              req,\n              schemaPath,\n              showHiddenFields,\n              triggerAccessControl,\n              triggerHooks,\n            } = args\n            let { value } = args\n\n            if (finalSanitizedEditorConfig?.features?.hooks?.afterRead?.length) {\n              for (const hook of finalSanitizedEditorConfig.features.hooks.afterRead) {\n                value = await hook(args)\n              }\n            }\n\n            if (\n              !finalSanitizedEditorConfig.features.nodeHooks?.afterRead?.size &&\n              !finalSanitizedEditorConfig.features.getSubFields?.size\n            ) {\n              return value\n            }\n            const flattenedNodes: SerializedLexicalNode[] = []\n\n            recurseNodeTree({\n              flattenedNodes,\n              nodes: (value as SerializedEditorState)?.root?.children ?? [],\n            })\n\n            for (let node of flattenedNodes) {\n              const afterReadHooks = finalSanitizedEditorConfig.features.nodeHooks?.afterRead\n              const afterReadHooksForNode = afterReadHooks?.get(node.type)\n              if (afterReadHooksForNode) {\n                for (const hook of afterReadHooksForNode) {\n                  node = await hook({\n                    context,\n                    currentDepth: currentDepth!,\n                    depth: depth!,\n                    draft: draft!,\n                    fallbackLocale: fallbackLocale!,\n                    fieldPromises: fieldPromises!,\n                    findMany: findMany!,\n                    flattenLocales: flattenLocales!,\n                    locale: locale!,\n                    node,\n                    overrideAccess: overrideAccess!,\n                    parentRichTextFieldPath: path,\n                    parentRichTextFieldSchemaPath: schemaPath,\n                    populationPromises: populationPromises!,\n                    req,\n                    showHiddenFields: showHiddenFields!,\n                    triggerAccessControl: triggerAccessControl!,\n                    triggerHooks: triggerHooks!,\n                  })\n                }\n              }\n              const subFieldFn = finalSanitizedEditorConfig.features.getSubFields?.get(node.type)\n              const subFieldDataFn = finalSanitizedEditorConfig.features.getSubFieldsData?.get(\n                node.type,\n              )\n\n              if (subFieldFn && subFieldDataFn) {\n                const subFields = subFieldFn({ node, req })\n                const data = subFieldDataFn({ node, req }) ?? {}\n\n                if (subFields?.length) {\n                  afterReadTraverseFields({\n                    collection,\n                    context,\n                    currentDepth: currentDepth!,\n                    depth: depth!,\n                    doc: data,\n                    draft: draft!,\n                    fallbackLocale: fallbackLocale!,\n                    fieldPromises: fieldPromises!,\n                    fields: subFields,\n                    findMany: findMany!,\n                    flattenLocales: flattenLocales!,\n                    global,\n                    locale: locale!,\n                    overrideAccess: overrideAccess!,\n                    path,\n                    populationPromises: populationPromises!,\n                    req,\n                    schemaPath,\n                    showHiddenFields: showHiddenFields!,\n                    siblingDoc: data,\n                    triggerAccessControl,\n                    triggerHooks,\n                  })\n                }\n              }\n            }\n\n            return value\n          },\n        ],\n        beforeChange: [\n          async (args) => {\n            const {\n              collection,\n              context: _context,\n              errors,\n              field,\n              global,\n              mergeLocaleActions,\n              operation,\n              path,\n              req,\n              schemaPath,\n              siblingData,\n              siblingDocWithLocales,\n              skipValidation,\n            } = args\n            let { value } = args\n\n            if (finalSanitizedEditorConfig?.features?.hooks?.beforeChange?.length) {\n              for (const hook of finalSanitizedEditorConfig.features.hooks.beforeChange) {\n                value = await hook(args)\n              }\n            }\n\n            if (\n              !finalSanitizedEditorConfig.features.nodeHooks?.beforeChange?.size &&\n              !finalSanitizedEditorConfig.features.getSubFields?.size\n            ) {\n              return value\n            }\n\n            const context: any = _context\n            const nodeIDMap: {\n              [key: string]: SerializedLexicalNode\n            } = {}\n\n            /**\n             * Get the originalNodeIDMap from the beforeValidate hook, which is always run before this hook.\n             */\n            const originalNodeIDMap: {\n              [key: string]: SerializedLexicalNode\n            } = context?.internal?.richText?.[path.join('.')]?.originalNodeIDMap\n\n            if (!originalNodeIDMap || !Object.keys(originalNodeIDMap).length || !value) {\n              return value\n            }\n\n            const originalNodeWithLocalesIDMap: {\n              [key: string]: SerializedLexicalNode\n            } = {}\n\n            recurseNodeTree({\n              nodeIDMap,\n              nodes: (value as SerializedEditorState)?.root?.children ?? [],\n            })\n\n            if (field.name && siblingDocWithLocales?.[field.name]) {\n              recurseNodeTree({\n                nodeIDMap: originalNodeWithLocalesIDMap,\n                nodes:\n                  (siblingDocWithLocales[field.name] as SerializedEditorState)?.root?.children ??\n                  [],\n              })\n            }\n\n            // eslint-disable-next-line prefer-const\n            for (let [id, node] of Object.entries(nodeIDMap)) {\n              const beforeChangeHooks = finalSanitizedEditorConfig.features.nodeHooks?.beforeChange\n              const beforeChangeHooksForNode = beforeChangeHooks?.get(node.type)\n              if (beforeChangeHooksForNode) {\n                for (const hook of beforeChangeHooksForNode) {\n                  if (!originalNodeIDMap[id]) {\n                    console.warn(\n                      '(beforeChange) No original node found for node with id',\n                      id,\n                      'node:',\n                      node,\n                      'path',\n                      path.join('.'),\n                    )\n                    continue\n                  }\n                  node = await hook({\n                    context,\n                    errors: errors!,\n                    mergeLocaleActions: mergeLocaleActions!,\n                    node,\n                    operation: operation!,\n                    originalNode: originalNodeIDMap[id],\n                    originalNodeWithLocales: originalNodeWithLocalesIDMap[id],\n                    parentRichTextFieldPath: path,\n                    parentRichTextFieldSchemaPath: schemaPath,\n                    req,\n                    skipValidation: skipValidation!,\n                  })\n                }\n              }\n\n              const subFieldFn = finalSanitizedEditorConfig.features.getSubFields?.get(node.type)\n              const subFieldDataFn = finalSanitizedEditorConfig.features.getSubFieldsData?.get(\n                node.type,\n              )\n\n              if (subFieldFn && subFieldDataFn) {\n                const subFields = subFieldFn({ node, req })\n                const data = subFieldDataFn({ node, req }) ?? {}\n                const originalData = subFieldDataFn({ node: originalNodeIDMap[id], req }) ?? {}\n                const originalDataWithLocales =\n                  subFieldDataFn({\n                    node: originalNodeWithLocalesIDMap[id],\n                    req,\n                  }) ?? {}\n\n                if (subFields?.length) {\n                  await beforeChangeTraverseFields({\n                    id,\n                    collection,\n                    context,\n                    data,\n                    doc: originalData,\n                    docWithLocales: originalDataWithLocales ?? {},\n                    errors: errors!,\n                    fields: subFields,\n                    global,\n                    mergeLocaleActions: mergeLocaleActions!,\n                    operation: operation!,\n                    path,\n                    req,\n                    schemaPath,\n                    siblingData: data,\n                    siblingDoc: originalData,\n                    siblingDocWithLocales: originalDataWithLocales ?? {},\n                    skipValidation,\n                  })\n                }\n              }\n            }\n\n            /**\n             * within the beforeChange hook, id's may be re-generated.\n             * Example:\n             * 1. Seed data contains IDs for block feature blocks.\n             * 2. Those are used in beforeValidate\n             * 3. in beforeChange, those IDs are regenerated, because you cannot provide IDs during document creation. See baseIDField beforeChange hook for reasoning\n             * 4. Thus, in order for all post-beforeChange hooks to receive the correct ID, we need to update the originalNodeIDMap with the new ID's, by regenerating the nodeIDMap.\n             * The reason this is not generated for every hook, is to save on performance. We know we only really have to generate it in beforeValidate, which is the first hook,\n             * and in beforeChange, which is where modifications to the provided IDs can occur.\n             */\n            const newOriginalNodeIDMap: {\n              [key: string]: SerializedLexicalNode\n            } = {}\n\n            const previousValue = siblingData[field.name!]\n\n            recurseNodeTree({\n              nodeIDMap: newOriginalNodeIDMap,\n              nodes: (previousValue as SerializedEditorState)?.root?.children ?? [],\n            })\n\n            if (!context.internal) {\n              // Add to context, for other hooks to use\n              context.internal = {}\n            }\n            if (!context.internal.richText) {\n              context.internal.richText = {}\n            }\n            context.internal.richText[path.join('.')] = {\n              originalNodeIDMap: newOriginalNodeIDMap,\n            }\n\n            return value\n          },\n        ],\n        beforeValidate: [\n          async (args) => {\n            const {\n              collection,\n              context,\n              global,\n              operation,\n              overrideAccess,\n              path,\n              previousValue,\n              req,\n              schemaPath,\n            } = args\n            let { value } = args\n            if (finalSanitizedEditorConfig?.features?.hooks?.beforeValidate?.length) {\n              for (const hook of finalSanitizedEditorConfig.features.hooks.beforeValidate) {\n                value = await hook(args)\n              }\n            }\n\n            // return value if there are NO hooks\n            if (\n              !finalSanitizedEditorConfig.features.nodeHooks?.beforeValidate?.size &&\n              !finalSanitizedEditorConfig.features.nodeHooks?.afterChange?.size &&\n              !finalSanitizedEditorConfig.features.nodeHooks?.beforeChange?.size &&\n              !finalSanitizedEditorConfig.features.getSubFields?.size\n            ) {\n              return value\n            }\n\n            /**\n             * beforeValidate is the first field hook which runs. This is where we can create the node map, which can then be used in the other hooks.\n             *\n             */\n\n            /**\n             * flattenedNodes contains all nodes in the editor, in the order they appear in the editor. They will be used for the following hooks:\n             * - afterRead\n             *\n             * The other hooks require nodes to have IDs, which is why those are ran only from the nodeIDMap. They require IDs because they have both doc/siblingDoc and data/siblingData, and\n             * thus require a reliable way to match new node data to old node data. Given that node positions can change in between hooks, this is only reliably possible for nodes which are saved with\n             * an ID.\n             */\n            //const flattenedNodes: SerializedLexicalNode[] = []\n\n            /**\n             * Only nodes with id's (so, nodes with hooks added to them) will be added to the nodeIDMap. They will be used for the following hooks:\n             * - afterChange\n             * - beforeChange\n             * - beforeValidate\n             *\n             * Other hooks are handled by the flattenedNodes. All nodes in the nodeIDMap are part of flattenedNodes.\n             */\n\n            const originalNodeIDMap: {\n              [key: string]: SerializedLexicalNode\n            } = {}\n\n            recurseNodeTree({\n              nodeIDMap: originalNodeIDMap,\n              nodes: (previousValue as SerializedEditorState)?.root?.children ?? [],\n            })\n\n            if (!context.internal) {\n              // Add to context, for other hooks to use\n              context.internal = {}\n            }\n            if (!(context as any).internal.richText) {\n              ;(context as any).internal.richText = {}\n            }\n            ;(context as any).internal.richText[path.join('.')] = {\n              originalNodeIDMap,\n            }\n\n            /**\n             * Now that the maps for all hooks are set up, we can run the validate hook\n             */\n            if (!finalSanitizedEditorConfig.features.nodeHooks?.beforeValidate?.size) {\n              return value\n            }\n            const nodeIDMap: {\n              [key: string]: SerializedLexicalNode\n            } = {}\n            recurseNodeTree({\n              //flattenedNodes,\n              nodeIDMap,\n              nodes: (value as SerializedEditorState)?.root?.children ?? [],\n            })\n\n            // eslint-disable-next-line prefer-const\n            for (let [id, node] of Object.entries(nodeIDMap)) {\n              const beforeValidateHooks =\n                finalSanitizedEditorConfig.features.nodeHooks.beforeValidate\n              const beforeValidateHooksForNode = beforeValidateHooks?.get(node.type)\n              if (beforeValidateHooksForNode) {\n                for (const hook of beforeValidateHooksForNode) {\n                  if (!originalNodeIDMap[id]) {\n                    console.warn(\n                      '(beforeValidate) No original node found for node with id',\n                      id,\n                      'node:',\n                      node,\n                      'path',\n                      path.join('.'),\n                    )\n                    continue\n                  }\n                  node = await hook({\n                    context,\n                    node,\n                    operation,\n                    originalNode: originalNodeIDMap[id],\n                    overrideAccess: overrideAccess!,\n                    parentRichTextFieldPath: path,\n                    parentRichTextFieldSchemaPath: schemaPath,\n                    req,\n                  })\n                }\n              }\n              const subFieldFn = finalSanitizedEditorConfig.features.getSubFields?.get(node.type)\n              const subFieldDataFn = finalSanitizedEditorConfig.features.getSubFieldsData?.get(\n                node.type,\n              )\n\n              if (subFieldFn && subFieldDataFn) {\n                const subFields = subFieldFn({ node, req })\n                const data = subFieldDataFn({ node, req }) ?? {}\n                const originalData = subFieldDataFn({ node: originalNodeIDMap[id], req }) ?? {}\n\n                if (subFields?.length) {\n                  await beforeValidateTraverseFields({\n                    id,\n                    collection,\n                    context,\n                    data,\n                    doc: originalData,\n                    fields: subFields,\n                    global,\n                    operation,\n                    overrideAccess: overrideAccess!,\n                    path,\n                    req,\n                    schemaPath,\n                    siblingData: data,\n                    siblingDoc: originalData,\n                  })\n                }\n              }\n            }\n\n            return value\n          },\n        ],\n      },\n      i18n: featureI18n,\n      outputSchema: ({\n        collectionIDFieldTypes,\n        config,\n        field,\n        interfaceNameDefinitions,\n        isRequired,\n      }) => {\n        let outputSchema: JSONSchema4 = {\n          // This schema matches the SerializedEditorState type so far, that it's possible to cast SerializedEditorState to this schema without any errors.\n          // In the future, we should\n          // 1) allow recursive children\n          // 2) Pass in all the different types for every node added to the editorconfig. This can be done with refs in the schema.\n          type: withNullableJSONSchemaType('object', isRequired),\n          properties: {\n            root: {\n              type: 'object',\n              additionalProperties: false,\n              properties: {\n                type: {\n                  type: 'string',\n                },\n                children: {\n                  type: 'array',\n                  items: {\n                    type: 'object',\n                    additionalProperties: true,\n                    properties: {\n                      type: {\n                        type: 'string',\n                      },\n                      version: {\n                        type: 'integer',\n                      },\n                    },\n                    required: ['type', 'version'],\n                  },\n                },\n                direction: {\n                  oneOf: [\n                    {\n                      enum: ['ltr', 'rtl'],\n                    },\n                    {\n                      type: 'null',\n                    },\n                  ],\n                },\n                format: {\n                  type: 'string',\n                  enum: ['left', 'start', 'center', 'right', 'end', 'justify', ''], // ElementFormatType, since the root node is an element\n                },\n                indent: {\n                  type: 'integer',\n                },\n                version: {\n                  type: 'integer',\n                },\n              },\n              required: ['children', 'direction', 'format', 'indent', 'type', 'version'],\n            },\n          },\n          required: ['root'],\n        }\n        for (const modifyOutputSchema of finalSanitizedEditorConfig.features.generatedTypes\n          .modifyOutputSchemas) {\n          outputSchema = modifyOutputSchema({\n            collectionIDFieldTypes,\n            config,\n            currentSchema: outputSchema,\n            field,\n            interfaceNameDefinitions,\n            isRequired,\n          })\n        }\n\n        return outputSchema\n      },\n      validate: richTextValidateHOC({\n        editorConfig: finalSanitizedEditorConfig,\n      }),\n    }\n  }\n}\n\nexport { AlignFeature } from './features/align/server/index.js'\nexport { BlockquoteFeature } from './features/blockquote/server/index.js'\nexport { BlocksFeature, type BlocksFeatureProps } from './features/blocks/server/index.js'\nexport { type BlockFields } from './features/blocks/server/nodes/BlocksNode.js'\n\nexport { LinebreakHTMLConverter } from './features/converters/html/converter/converters/linebreak.js'\nexport { ParagraphHTMLConverter } from './features/converters/html/converter/converters/paragraph.js'\n\nexport { TextHTMLConverter } from './features/converters/html/converter/converters/text.js'\nexport { defaultHTMLConverters } from './features/converters/html/converter/defaultConverters.js'\nexport {\n  convertLexicalNodesToHTML,\n  convertLexicalToHTML,\n} from './features/converters/html/converter/index.js'\n\nexport type { HTMLConverter } from './features/converters/html/converter/types.js'\nexport { consolidateHTMLConverters, lexicalHTML } from './features/converters/html/field/index.js'\nexport {\n  HTMLConverterFeature,\n  type HTMLConverterFeatureProps,\n} from './features/converters/html/index.js'\nexport { TestRecorderFeature } from './features/debug/testRecorder/server/index.js'\nexport { TreeViewFeature } from './features/debug/treeView/server/index.js'\nexport { EXPERIMENTAL_TableFeature } from './features/experimental_table/server/index.js'\nexport { BoldFeature } from './features/format/bold/feature.server.js'\nexport { InlineCodeFeature } from './features/format/inlineCode/feature.server.js'\nexport { ItalicFeature } from './features/format/italic/feature.server.js'\n\nexport { StrikethroughFeature } from './features/format/strikethrough/feature.server.js'\nexport { SubscriptFeature } from './features/format/subscript/feature.server.js'\nexport { SuperscriptFeature } from './features/format/superscript/feature.server.js'\nexport { UnderlineFeature } from './features/format/underline/feature.server.js'\nexport { HeadingFeature, type HeadingFeatureProps } from './features/heading/server/index.js'\nexport { HorizontalRuleFeature } from './features/horizontalRule/server/index.js'\nexport { IndentFeature } from './features/indent/server/index.js'\n\nexport { AutoLinkNode } from './features/link/nodes/AutoLinkNode.js'\n\nexport { LinkNode } from './features/link/nodes/LinkNode.js'\nexport type { LinkFields } from './features/link/nodes/types.js'\nexport { LinkFeature, type LinkFeatureServerProps } from './features/link/server/index.js'\nexport { ChecklistFeature } from './features/lists/checklist/server/index.js'\nexport { OrderedListFeature } from './features/lists/orderedList/server/index.js'\nexport { UnorderedListFeature } from './features/lists/unorderedList/server/index.js'\n\nexport type {\n  SlateNode,\n  SlateNodeConverter,\n} from './features/migrations/slateToLexical/converter/types.js'\n\nexport { ParagraphFeature } from './features/paragraph/server/index.js'\nexport {\n  RelationshipFeature,\n  type RelationshipFeatureProps,\n} from './features/relationship/server/index.js'\nexport {\n  type RelationshipData,\n  RelationshipServerNode,\n} from './features/relationship/server/nodes/RelationshipNode.js'\n\nexport { FixedToolbarFeature } from './features/toolbars/fixed/server/index.js'\nexport { InlineToolbarFeature } from './features/toolbars/inline/server/index.js'\n\nexport type { ToolbarGroup, ToolbarGroupItem } from './features/toolbars/types.js'\nexport type {\n  BaseClientFeatureProps,\n  ClientFeature,\n  ClientFeatureProviderMap,\n  FeatureProviderClient,\n  FeatureProviderProviderClient,\n  PluginComponent,\n  PluginComponentWithAnchor,\n  ResolvedClientFeature,\n  ResolvedClientFeatureMap,\n  SanitizedClientFeatures,\n  SanitizedPlugin,\n} from './features/typesClient.js'\nexport type {\n  AfterChangeNodeHook,\n  AfterChangeNodeHookArgs,\n  AfterReadNodeHook,\n  AfterReadNodeHookArgs,\n  BaseNodeHookArgs,\n  BeforeChangeNodeHook,\n  BeforeChangeNodeHookArgs,\n  BeforeValidateNodeHook,\n  BeforeValidateNodeHookArgs,\n  FeatureProviderProviderServer,\n  FeatureProviderServer,\n  NodeValidation,\n  NodeWithHooks,\n  PopulationPromise,\n  ResolvedServerFeature,\n  ResolvedServerFeatureMap,\n  SanitizedServerFeatures,\n  ServerFeature,\n  ServerFeatureProviderMap,\n} from './features/typesServer.js'\n\nexport { createNode } from './features/typeUtilities.js' // Only useful in feature.server.ts\n\nexport { UploadFeature } from './features/upload/server/feature.server.js'\n\nexport type { UploadFeatureProps } from './features/upload/server/feature.server.js'\nexport { type UploadData, UploadServerNode } from './features/upload/server/nodes/UploadNode.js'\n\nexport type { EditorConfigContextType } from './lexical/config/client/EditorConfigProvider.js'\nexport {\n  defaultEditorConfig,\n  defaultEditorFeatures,\n  defaultEditorLexicalConfig,\n} from './lexical/config/server/default.js'\n\nexport { loadFeatures, sortFeaturesForOptimalLoading } from './lexical/config/server/loader.js'\nexport {\n  sanitizeServerEditorConfig,\n  sanitizeServerFeatures,\n} from './lexical/config/server/sanitize.js'\n\nexport type {\n  ClientEditorConfig,\n  SanitizedClientEditorConfig,\n  SanitizedServerEditorConfig,\n  ServerEditorConfig,\n} from './lexical/config/types.js'\nexport { getEnabledNodes } from './lexical/nodes/index.js'\nexport type { AdapterProps }\n\nexport type {\n  SlashMenuGroup,\n  SlashMenuItem,\n} from './lexical/plugins/SlashMenu/LexicalTypeaheadMenuPlugin/types.js'\n\nexport {\n  DETAIL_TYPE_TO_DETAIL,\n  DOUBLE_LINE_BREAK,\n  ELEMENT_FORMAT_TO_TYPE,\n  ELEMENT_TYPE_TO_FORMAT,\n  IS_ALL_FORMATTING,\n  LTR_REGEX,\n  NodeFormat,\n  NON_BREAKING_SPACE,\n  RTL_REGEX,\n  TEXT_MODE_TO_TYPE,\n  TEXT_TYPE_TO_FORMAT,\n  TEXT_TYPE_TO_MODE,\n} from './lexical/utils/nodeFormat.js'\nexport { sanitizeUrl, validateUrl } from './lexical/utils/url.js'\n\nexport type * from './nodeTypes.js'\n\nexport { defaultRichTextValue } from './populateGraphQL/defaultValue.js'\n\nexport { populate } from './populateGraphQL/populate.js'\nexport type { LexicalEditorProps, LexicalRichTextAdapter } from './types.js'\nexport { createServerFeature } from './utilities/createServerFeature.js'\n\nexport type { FieldsDrawerProps } from './utilities/fieldsDrawer/Drawer.js'\nexport { upgradeLexicalData } from './utilities/upgradeLexicalData/index.js'\n"],"names":["afterChangeTraverseFields","afterReadTraverseFields","beforeChangeTraverseFields","beforeValidateTraverseFields","checkDependencies","deepCopyObject","deepCopyObjectSimple","withNullableJSONSchemaType","i18n","defaultEditorConfig","defaultEditorFeatures","loadFeatures","sanitizeServerEditorConfig","sanitizeServerFeatures","populateLexicalPopulationPromises","getGenerateImportMap","getGenerateSchemaMap","recurseNodeTree","richTextValidateHOC","defaultSanitizedServerEditorConfig","checkedDependencies","lexicalEditor","props","config","isRoot","parentIsLocalized","process","env","NODE_ENV","PAYLOAD_DISABLE_DEPENDENCY_CHECKER","dependencyGroups","name","dependencies","targetVersion","features","resolvedFeatureMap","finalSanitizedEditorConfig","lexical","rootEditor","editor","rootEditorFeatures","defaultFeatures","rootFeatures","unSanitizedEditorConfig","featureI18n","lang","general","CellComponent","clientProps","admin","lexicalEditorConfig","path","editorConfig","FieldComponent","generateComponentMap","serverProps","generateImportMap","generateSchemaMap","graphQLPopulationPromises","context","currentDepth","depth","draft","field","fieldPromises","findMany","flattenLocales","overrideAccess","populationPromises","req","showHiddenFields","siblingDoc","size","editorPopulationPromises","hooks","afterChange","args","collection","_context","global","operation","schemaPath","value","length","hook","nodeHooks","getSubFields","nodeIDMap","originalNodeIDMap","internal","richText","join","Object","keys","nodes","root","children","id","node","entries","afterChangeHooks","afterChangeHooksForNode","get","type","console","warn","originalNode","parentRichTextFieldPath","parentRichTextFieldSchemaPath","subFieldFn","subFieldDataFn","getSubFieldsData","subFields","data","originalData","doc","fields","previousDoc","previousSiblingDoc","siblingData","afterRead","fallbackLocale","locale","triggerAccessControl","triggerHooks","flattenedNodes","afterReadHooks","afterReadHooksForNode","beforeChange","errors","mergeLocaleActions","siblingDocWithLocales","skipValidation","originalNodeWithLocalesIDMap","beforeChangeHooks","beforeChangeHooksForNode","originalNodeWithLocales","originalDataWithLocales","docWithLocales","newOriginalNodeIDMap","previousValue","beforeValidate","beforeValidateHooks","beforeValidateHooksForNode","outputSchema","collectionIDFieldTypes","interfaceNameDefinitions","isRequired","properties","additionalProperties","items","version","required","direction","oneOf","enum","format","indent","modifyOutputSchema","generatedTypes","modifyOutputSchemas","currentSchema","validate","AlignFeature","BlockquoteFeature","BlocksFeature","LinebreakHTMLConverter","ParagraphHTMLConverter","TextHTMLConverter","defaultHTMLConverters","convertLexicalNodesToHTML","convertLexicalToHTML","consolidateHTMLConverters","lexicalHTML","HTMLConverterFeature","TestRecorderFeature","TreeViewFeature","EXPERIMENTAL_TableFeature","BoldFeature","InlineCodeFeature","ItalicFeature","StrikethroughFeature","SubscriptFeature","SuperscriptFeature","UnderlineFeature","HeadingFeature","HorizontalRuleFeature","IndentFeature","AutoLinkNode","LinkNode","LinkFeature","ChecklistFeature","OrderedListFeature","UnorderedListFeature","ParagraphFeature","RelationshipFeature","RelationshipServerNode","FixedToolbarFeature","InlineToolbarFeature","createNode","UploadFeature","UploadServerNode","defaultEditorLexicalConfig","sortFeaturesForOptimalLoading","getEnabledNodes","DETAIL_TYPE_TO_DETAIL","DOUBLE_LINE_BREAK","ELEMENT_FORMAT_TO_TYPE","ELEMENT_TYPE_TO_FORMAT","IS_ALL_FORMATTING","LTR_REGEX","NodeFormat","NON_BREAKING_SPACE","RTL_REGEX","TEXT_MODE_TO_TYPE","TEXT_TYPE_TO_FORMAT","TEXT_TYPE_TO_MODE","sanitizeUrl","validateUrl","defaultRichTextValue","populate","createServerFeature","upgradeLexicalData"],"mappings":"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"}},
    {"offset": {"line": 5909, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}}]
}