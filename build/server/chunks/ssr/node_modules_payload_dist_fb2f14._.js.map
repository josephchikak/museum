{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 7, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/payload/src/errors/APIError.ts"],"sourcesContent":["import httpStatus from 'http-status'\n\n// This gets dynamically reassigned during compilation\nexport let APIErrorName = 'APIError'\n\nclass ExtendableError<TData extends object = { [key: string]: unknown }> extends Error {\n  data: TData\n\n  isOperational: boolean\n\n  isPublic: boolean\n\n  status: number\n\n  constructor(message: string, status: number, data: TData, isPublic: boolean) {\n    super(message, {\n      // show data in cause\n      cause: data,\n    })\n    APIErrorName = this.constructor.name\n    this.name = this.constructor.name\n    this.message = message\n    this.status = status\n    this.data = data\n    this.isPublic = isPublic\n    this.isOperational = true // This is required since bluebird 4 doesn't append it anymore.\n    Error.captureStackTrace(this, this.constructor)\n  }\n}\n\n/**\n * Class representing an API error.\n * @extends ExtendableError\n */\nexport class APIError<\n  TData extends null | object = { [key: string]: unknown } | null,\n> extends ExtendableError<TData> {\n  /**\n   * Creates an API error.\n   * @param {string} message - Error message.\n   * @param {number} status - HTTP status code of error.\n   * @param {object} data - response data to be returned.\n   * @param {boolean} isPublic - Whether the message should be visible to user or not.\n   */\n  constructor(\n    message: string,\n    status: number = httpStatus.INTERNAL_SERVER_ERROR,\n    data: TData = null,\n    isPublic = false,\n  ) {\n    super(message, status, data, isPublic)\n  }\n}\n"],"names":["httpStatus","APIErrorName","ExtendableError","Error","data","isOperational","isPublic","status","constructor","message","cause","name","captureStackTrace","APIError","INTERNAL_SERVER_ERROR"],"mappings":";;;;AAAA,OAAOA,gBAAgB,cAAa;;AAG7B,IAAIC,eAAe,WAAU;AAEpC,MAAMC,wBAA2EC;IAC/EC,KAAW;IAEXC,cAAsB;IAEtBC,SAAiB;IAEjBC,OAAc;IAEdC,YAAYC,OAAe,EAAEF,MAAc,EAAEH,IAAW,EAAEE,QAAiB,CAAE;QAC3E,KAAK,CAACG,SAAS;YACb,qBAAqB;YACrBC,OAAON;QACT;QACAH,eAAe,IAAI,CAACO,WAAW,CAACG,IAAI;QACpC,IAAI,CAACA,IAAI,GAAG,IAAI,CAACH,WAAW,CAACG,IAAI;QACjC,IAAI,CAACF,OAAO,GAAGA;QACf,IAAI,CAACF,MAAM,GAAGA;QACd,IAAI,CAACH,IAAI,GAAGA;QACZ,IAAI,CAACE,QAAQ,GAAGA;QAChB,IAAI,CAACD,aAAa,GAAG,KAAK,+DAA+D;;QACzFF,MAAMS,iBAAiB,CAAC,IAAI,EAAE,IAAI,CAACJ,WAAW;IAChD;AACF;AAMO,MAAMK,iBAEHX;IACR;;;;;;GAMC,GACDM,YACEC,OAAe,EACfF,wJAAiBP,UAAAA,CAAWc,qBAAqB,EACjDV,OAAc,IAAI,EAClBE,WAAW,KAAK,CAChB;QACA,KAAK,CAACG,SAASF,QAAQH,MAAME;IAC/B;AACF"}},
    {"offset": {"line": 46, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 52, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/payload/src/bin/generateImportMap/parsePayloadComponent.ts"],"sourcesContent":["import type { PayloadComponent } from '../../config/types.js'\n\nexport function parsePayloadComponent(payloadComponent: PayloadComponent): {\n  exportName: string\n  path: string\n} {\n  if (!payloadComponent) {\n    return null\n  }\n  const pathAndMaybeExport =\n    typeof payloadComponent === 'string' ? payloadComponent : payloadComponent.path\n\n  let path = ''\n  let exportName = 'default'\n\n  if (pathAndMaybeExport?.includes('#')) {\n    ;[path, exportName] = pathAndMaybeExport.split('#')\n  } else {\n    path = pathAndMaybeExport\n  }\n\n  if (typeof payloadComponent === 'object' && payloadComponent.exportName) {\n    exportName = payloadComponent.exportName\n  }\n\n  return { exportName, path }\n}\n"],"names":["parsePayloadComponent","payloadComponent","pathAndMaybeExport","path","exportName","includes","split"],"mappings":";;;AAEO,SAASA,sBAAsBC,gBAAkC;IAItE,IAAI,CAACA,kBAAkB;QACrB,OAAO;IACT;IACA,MAAMC,qBACJ,OAAOD,qBAAqB,WAAWA,mBAAmBA,iBAAiBE,IAAI;IAEjF,IAAIA,OAAO;IACX,IAAIC,aAAa;IAEjB,IAAIF,oBAAoBG,SAAS,MAAM;QACpC,CAACF,MAAMC,WAAW,GAAGF,mBAAmBI,KAAK,CAAC;IACjD,OAAO;QACLH,OAAOD;IACT;IAEA,IAAI,OAAOD,qBAAqB,YAAYA,iBAAiBG,UAAU,EAAE;QACvEA,aAAaH,iBAAiBG,UAAU;IAC1C;IAEA,OAAO;QAAEA;QAAYD;IAAK;AAC5B"}},
    {"offset": {"line": 75, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 81, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/payload/src/bin/generateImportMap/iterateFields.ts"],"sourcesContent":["import type { PayloadComponent, SanitizedConfig } from '../../config/types.js'\nimport type { Block, Field, Tab } from '../../fields/config/types.js'\nimport type { AddToImportMap, Imports, InternalImportMap } from './index.js'\n\nfunction hasKey<T, K extends string>(\n  obj: null | T | undefined,\n  key: K,\n): obj is { [P in K]: PayloadComponent | PayloadComponent[] } & T {\n  return obj != null && Object.prototype.hasOwnProperty.call(obj, key)\n}\n\nexport function genImportMapIterateFields({\n  addToImportMap,\n  baseDir,\n  config,\n  fields,\n  importMap,\n  imports,\n}: {\n  addToImportMap: AddToImportMap\n  baseDir: string\n  config: SanitizedConfig\n  fields: Block[] | Field[] | Tab[]\n  importMap: InternalImportMap\n  imports: Imports\n}) {\n  for (const field of fields) {\n    if ('fields' in field) {\n      genImportMapIterateFields({\n        addToImportMap,\n        baseDir,\n        config,\n        fields: field.fields,\n        importMap,\n        imports,\n      })\n    } else if (field.type === 'blocks') {\n      genImportMapIterateFields({\n        addToImportMap,\n        baseDir,\n        config,\n        fields: field.blocks,\n        importMap,\n        imports,\n      })\n    } else if (field.type === 'tabs') {\n      genImportMapIterateFields({\n        addToImportMap,\n        baseDir,\n        config,\n        fields: field.tabs,\n        importMap,\n        imports,\n      })\n    } else if (field.type === 'richText') {\n      if (\n        field?.editor &&\n        typeof field.editor === 'object' &&\n        field.editor.generateImportMap &&\n        typeof field.editor.generateImportMap === 'function'\n      ) {\n        field.editor.generateImportMap({\n          addToImportMap,\n          baseDir,\n          config,\n          importMap,\n          imports,\n        })\n      }\n    }\n\n    hasKey(field?.admin?.components, 'Label') && addToImportMap(field.admin.components.Label)\n\n    hasKey(field?.admin?.components, 'Cell') && addToImportMap(field?.admin?.components?.Cell)\n\n    hasKey(field?.admin?.components, 'Description') &&\n      addToImportMap(field?.admin?.components?.Description)\n\n    hasKey(field?.admin?.components, 'Field') && addToImportMap(field?.admin?.components?.Field)\n    hasKey(field?.admin?.components, 'Filter') && addToImportMap(field?.admin?.components?.Filter)\n\n    hasKey(field?.admin?.components, 'Error') && addToImportMap(field?.admin?.components?.Error)\n\n    hasKey(field?.admin?.components, 'afterInput') &&\n      addToImportMap(field?.admin?.components?.afterInput)\n\n    hasKey(field?.admin?.components, 'beforeInput') &&\n      addToImportMap(field?.admin?.components?.beforeInput)\n\n    hasKey(field?.admin?.components, 'RowLabel') &&\n      addToImportMap(field?.admin?.components?.RowLabel)\n  }\n}\n"],"names":["hasKey","obj","key","Object","prototype","hasOwnProperty","call","genImportMapIterateFields","addToImportMap","baseDir","config","fields","importMap","imports","field","type","blocks","tabs","editor","generateImportMap","admin","components","Label","Cell","Description","Field","Filter","Error","afterInput","beforeInput","RowLabel"],"mappings":";;;AAIA,SAASA,OACPC,GAAyB,EACzBC,GAAM;IAEN,OAAOD,OAAO,QAAQE,OAAOC,SAAS,CAACC,cAAc,CAACC,IAAI,CAACL,KAAKC;AAClE;AAEO,SAASK,0BAA0B,EACxCC,cAAc,EACdC,OAAO,EACPC,MAAM,EACNC,MAAM,EACNC,SAAS,EACTC,OAAO,EAQR;IACC,KAAK,MAAMC,SAASH,OAAQ;QAC1B,IAAI,YAAYG,OAAO;YACrBP,0BAA0B;gBACxBC;gBACAC;gBACAC;gBACAC,QAAQG,MAAMH,MAAM;gBACpBC;gBACAC;YACF;QACF,OAAO,IAAIC,MAAMC,IAAI,KAAK,UAAU;YAClCR,0BAA0B;gBACxBC;gBACAC;gBACAC;gBACAC,QAAQG,MAAME,MAAM;gBACpBJ;gBACAC;YACF;QACF,OAAO,IAAIC,MAAMC,IAAI,KAAK,QAAQ;YAChCR,0BAA0B;gBACxBC;gBACAC;gBACAC;gBACAC,QAAQG,MAAMG,IAAI;gBAClBL;gBACAC;YACF;QACF,OAAO,IAAIC,MAAMC,IAAI,KAAK,YAAY;YACpC,IACED,OAAOI,UACP,OAAOJ,MAAMI,MAAM,KAAK,YACxBJ,MAAMI,MAAM,CAACC,iBAAiB,IAC9B,OAAOL,MAAMI,MAAM,CAACC,iBAAiB,KAAK,YAC1C;gBACAL,MAAMI,MAAM,CAACC,iBAAiB,CAAC;oBAC7BX;oBACAC;oBACAC;oBACAE;oBACAC;gBACF;YACF;QACF;QAEAb,OAAOc,OAAOM,OAAOC,YAAY,YAAYb,eAAeM,MAAMM,KAAK,CAACC,UAAU,CAACC,KAAK;QAExFtB,OAAOc,OAAOM,OAAOC,YAAY,WAAWb,eAAeM,OAAOM,OAAOC,YAAYE;QAErFvB,OAAOc,OAAOM,OAAOC,YAAY,kBAC/Bb,eAAeM,OAAOM,OAAOC,YAAYG;QAE3CxB,OAAOc,OAAOM,OAAOC,YAAY,YAAYb,eAAeM,OAAOM,OAAOC,YAAYI;QACtFzB,OAAOc,OAAOM,OAAOC,YAAY,aAAab,eAAeM,OAAOM,OAAOC,YAAYK;QAEvF1B,OAAOc,OAAOM,OAAOC,YAAY,YAAYb,eAAeM,OAAOM,OAAOC,YAAYM;QAEtF3B,OAAOc,OAAOM,OAAOC,YAAY,iBAC/Bb,eAAeM,OAAOM,OAAOC,YAAYO;QAE3C5B,OAAOc,OAAOM,OAAOC,YAAY,kBAC/Bb,eAAeM,OAAOM,OAAOC,YAAYQ;QAE3C7B,OAAOc,OAAOM,OAAOC,YAAY,eAC/Bb,eAAeM,OAAOM,OAAOC,YAAYS;IAC7C;AACF"}},
    {"offset": {"line": 138, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 144, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/payload/src/bin/generateImportMap/iterateCollections.ts"],"sourcesContent":["import type { SanitizedCollectionConfig } from '../../collections/config/types.js'\nimport type { SanitizedConfig } from '../../config/types.js'\nimport type { AddToImportMap, Imports, InternalImportMap } from './index.js'\n\nimport { genImportMapIterateFields } from './iterateFields.js'\n\nexport function iterateCollections({\n  addToImportMap,\n  baseDir,\n  collections,\n  config,\n  importMap,\n  imports,\n}: {\n  addToImportMap: AddToImportMap\n  baseDir: string\n  collections: SanitizedCollectionConfig[]\n  config: SanitizedConfig\n  importMap: InternalImportMap\n  imports: Imports\n}) {\n  for (const collection of collections) {\n    genImportMapIterateFields({\n      addToImportMap,\n      baseDir,\n      config,\n      fields: collection.fields,\n      importMap,\n      imports,\n    })\n\n    addToImportMap(collection.admin?.components?.afterList)\n    addToImportMap(collection.admin?.components?.afterListTable)\n    addToImportMap(collection.admin?.components?.beforeList)\n    addToImportMap(collection.admin?.components?.beforeListTable)\n    addToImportMap(collection.admin?.components?.Description)\n\n    addToImportMap(collection.admin?.components?.edit?.PreviewButton)\n    addToImportMap(collection.admin?.components?.edit?.PublishButton)\n    addToImportMap(collection.admin?.components?.edit?.SaveButton)\n    addToImportMap(collection.admin?.components?.edit?.SaveDraftButton)\n    addToImportMap(collection.admin?.components?.edit?.Upload)\n\n    if (collection.admin?.components?.views?.edit) {\n      for (const editViewConfig of Object.values(collection.admin?.components?.views?.edit)) {\n        if ('Component' in editViewConfig) {\n          addToImportMap(editViewConfig?.Component)\n        }\n\n        if ('actions' in editViewConfig) {\n          addToImportMap(editViewConfig?.actions)\n        }\n\n        if ('tab' in editViewConfig) {\n          addToImportMap(editViewConfig?.tab?.Component)\n          addToImportMap(editViewConfig?.tab?.Pill)\n        }\n      }\n    }\n\n    addToImportMap(collection.admin?.components?.views?.list?.Component)\n    addToImportMap(collection.admin?.components?.views?.list?.actions)\n  }\n}\n"],"names":["genImportMapIterateFields","iterateCollections","addToImportMap","baseDir","collections","config","importMap","imports","collection","fields","admin","components","afterList","afterListTable","beforeList","beforeListTable","Description","edit","PreviewButton","PublishButton","SaveButton","SaveDraftButton","Upload","views","editViewConfig","Object","values","Component","actions","tab","Pill","list"],"mappings":";;;AAIA,SAASA,yBAAyB,QAAQ,qBAAoB;;AAEvD,SAASC,mBAAmB,EACjCC,cAAc,EACdC,OAAO,EACPC,WAAW,EACXC,MAAM,EACNC,SAAS,EACTC,OAAO,EAQR;IACC,KAAK,MAAMC,cAAcJ,YAAa;YACpCJ,yMAAAA,EAA0B;YACxBE;YACAC;YACAE;YACAI,QAAQD,WAAWC,MAAM;YACzBH;YACAC;QACF;QAEAL,eAAeM,WAAWE,KAAK,EAAEC,YAAYC;QAC7CV,eAAeM,WAAWE,KAAK,EAAEC,YAAYE;QAC7CX,eAAeM,WAAWE,KAAK,EAAEC,YAAYG;QAC7CZ,eAAeM,WAAWE,KAAK,EAAEC,YAAYI;QAC7Cb,eAAeM,WAAWE,KAAK,EAAEC,YAAYK;QAE7Cd,eAAeM,WAAWE,KAAK,EAAEC,YAAYM,MAAMC;QACnDhB,eAAeM,WAAWE,KAAK,EAAEC,YAAYM,MAAME;QACnDjB,eAAeM,WAAWE,KAAK,EAAEC,YAAYM,MAAMG;QACnDlB,eAAeM,WAAWE,KAAK,EAAEC,YAAYM,MAAMI;QACnDnB,eAAeM,WAAWE,KAAK,EAAEC,YAAYM,MAAMK;QAEnD,IAAId,WAAWE,KAAK,EAAEC,YAAYY,OAAON,MAAM;YAC7C,KAAK,MAAMO,kBAAkBC,OAAOC,MAAM,CAAClB,WAAWE,KAAK,EAAEC,YAAYY,OAAON,MAAO;gBACrF,IAAI,eAAeO,gBAAgB;oBACjCtB,eAAesB,gBAAgBG;gBACjC;gBAEA,IAAI,aAAaH,gBAAgB;oBAC/BtB,eAAesB,gBAAgBI;gBACjC;gBAEA,IAAI,SAASJ,gBAAgB;oBAC3BtB,eAAesB,gBAAgBK,KAAKF;oBACpCzB,eAAesB,gBAAgBK,KAAKC;gBACtC;YACF;QACF;QAEA5B,eAAeM,WAAWE,KAAK,EAAEC,YAAYY,OAAOQ,MAAMJ;QAC1DzB,eAAeM,WAAWE,KAAK,EAAEC,YAAYY,OAAOQ,MAAMH;IAC5D;AACF"}},
    {"offset": {"line": 187, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 193, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/payload/src/bin/generateImportMap/iterateGlobals.ts"],"sourcesContent":["import type { SanitizedConfig } from '../../config/types.js'\nimport type { SanitizedGlobalConfig } from '../../globals/config/types.js'\nimport type { AddToImportMap, Imports, InternalImportMap } from './index.js'\n\nimport { genImportMapIterateFields } from './iterateFields.js'\n\nexport function iterateGlobals({\n  addToImportMap,\n  baseDir,\n  config,\n  globals,\n  importMap,\n  imports,\n}: {\n  addToImportMap: AddToImportMap\n  baseDir: string\n  config: SanitizedConfig\n  globals: SanitizedGlobalConfig[]\n  importMap: InternalImportMap\n  imports: Imports\n}) {\n  for (const global of globals) {\n    genImportMapIterateFields({\n      addToImportMap,\n      baseDir,\n      config,\n      fields: global.fields,\n      importMap,\n      imports,\n    })\n\n    addToImportMap(global.admin?.components?.elements?.Description)\n    addToImportMap(global.admin?.components?.elements?.PreviewButton)\n    addToImportMap(global.admin?.components?.elements?.PublishButton)\n    addToImportMap(global.admin?.components?.elements?.SaveButton)\n    addToImportMap(global.admin?.components?.elements?.SaveDraftButton)\n\n    if (global.admin?.components?.views?.edit) {\n      for (const editViewConfig of Object.values(global.admin?.components?.views?.edit)) {\n        if ('Component' in editViewConfig) {\n          addToImportMap(editViewConfig?.Component)\n        }\n\n        if ('actions' in editViewConfig) {\n          addToImportMap(editViewConfig?.actions)\n        }\n\n        if ('tab' in editViewConfig) {\n          addToImportMap(editViewConfig?.tab?.Component)\n          addToImportMap(editViewConfig?.tab?.Pill)\n        }\n      }\n    }\n  }\n}\n"],"names":["genImportMapIterateFields","iterateGlobals","addToImportMap","baseDir","config","globals","importMap","imports","global","fields","admin","components","elements","Description","PreviewButton","PublishButton","SaveButton","SaveDraftButton","views","edit","editViewConfig","Object","values","Component","actions","tab","Pill"],"mappings":";;;AAIA,SAASA,yBAAyB,QAAQ,qBAAoB;;AAEvD,SAASC,eAAe,EAC7BC,cAAc,EACdC,OAAO,EACPC,MAAM,EACNC,OAAO,EACPC,SAAS,EACTC,OAAO,EAQR;IACC,KAAK,MAAMC,UAAUH,QAAS;YAC5BL,yMAAAA,EAA0B;YACxBE;YACAC;YACAC;YACAK,QAAQD,OAAOC,MAAM;YACrBH;YACAC;QACF;QAEAL,eAAeM,OAAOE,KAAK,EAAEC,YAAYC,UAAUC;QACnDX,eAAeM,OAAOE,KAAK,EAAEC,YAAYC,UAAUE;QACnDZ,eAAeM,OAAOE,KAAK,EAAEC,YAAYC,UAAUG;QACnDb,eAAeM,OAAOE,KAAK,EAAEC,YAAYC,UAAUI;QACnDd,eAAeM,OAAOE,KAAK,EAAEC,YAAYC,UAAUK;QAEnD,IAAIT,OAAOE,KAAK,EAAEC,YAAYO,OAAOC,MAAM;YACzC,KAAK,MAAMC,kBAAkBC,OAAOC,MAAM,CAACd,OAAOE,KAAK,EAAEC,YAAYO,OAAOC,MAAO;gBACjF,IAAI,eAAeC,gBAAgB;oBACjClB,eAAekB,gBAAgBG;gBACjC;gBAEA,IAAI,aAAaH,gBAAgB;oBAC/BlB,eAAekB,gBAAgBI;gBACjC;gBAEA,IAAI,SAASJ,gBAAgB;oBAC3BlB,eAAekB,gBAAgBK,KAAKF;oBACpCrB,eAAekB,gBAAgBK,KAAKC;gBACtC;YACF;QACF;IACF;AACF"}},
    {"offset": {"line": 229, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 235, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/payload/src/bin/generateImportMap/iterateConfig.ts"],"sourcesContent":["import type { AdminViewConfig } from '../../admin/views/types.js'\nimport type { SanitizedConfig } from '../../config/types.js'\nimport type { AddToImportMap, Imports, InternalImportMap } from './index.js'\n\nimport { iterateCollections } from './iterateCollections.js'\nimport { iterateGlobals } from './iterateGlobals.js'\n\nexport function iterateConfig({\n  addToImportMap,\n  baseDir,\n  config,\n  importMap,\n  imports,\n}: {\n  addToImportMap: AddToImportMap\n  baseDir: string\n  config: SanitizedConfig\n  importMap: InternalImportMap\n  imports: Imports\n}) {\n  iterateCollections({\n    addToImportMap,\n    baseDir,\n    collections: config.collections,\n    config,\n    importMap,\n    imports,\n  })\n\n  iterateGlobals({\n    addToImportMap,\n    baseDir,\n    config,\n    globals: config.globals,\n    importMap,\n    imports,\n  })\n\n  if (typeof config.admin?.avatar === 'object') {\n    addToImportMap(config.admin?.avatar?.Component)\n  }\n\n  addToImportMap(config.admin?.components?.Nav)\n  addToImportMap(config.admin?.components?.header)\n  addToImportMap(config.admin?.components?.logout?.Button)\n  addToImportMap(config.admin?.components?.graphics?.Icon)\n  addToImportMap(config.admin?.components?.graphics?.Logo)\n\n  addToImportMap(config.admin?.components?.actions)\n  addToImportMap(config.admin?.components?.afterDashboard)\n  addToImportMap(config.admin?.components?.afterLogin)\n  addToImportMap(config.admin?.components?.afterNavLinks)\n  addToImportMap(config.admin?.components?.beforeDashboard)\n  addToImportMap(config.admin?.components?.beforeLogin)\n  addToImportMap(config.admin?.components?.beforeNavLinks)\n\n  addToImportMap(config.admin?.components?.providers)\n\n  if (config.admin?.components?.views) {\n    if (Object.keys(config.admin?.components?.views)?.length) {\n      for (const key in config.admin?.components?.views) {\n        const adminViewConfig: AdminViewConfig = config.admin?.components?.views[key]\n        addToImportMap(adminViewConfig?.Component)\n      }\n    }\n  }\n\n  if (config?.admin?.importMap?.generators?.length) {\n    for (const generator of config.admin.importMap.generators) {\n      generator({\n        addToImportMap,\n        baseDir,\n        config,\n        importMap,\n        imports,\n      })\n    }\n  }\n\n  if (config?.admin?.dependencies) {\n    for (const key in config.admin.dependencies) {\n      const dependency = config.admin.dependencies[key]\n      addToImportMap(dependency.path)\n    }\n  }\n\n  /*\n  if (\n    config?.editor &&\n    typeof config.editor === 'object' &&\n    config.editor.generateImportMap &&\n    typeof config.editor.generateImportMap === 'function'\n  ) {\n    config.editor.generateImportMap({\n      addToImportMap,\n      baseDir,\n      componentMap,\n      config,\n      importMap,\n    })\n  }*/ // No need to do that here since in the sanitized editor config, this root editor is already added to the field editor - and we already process that in iterateFields\n}\n"],"names":["iterateCollections","iterateGlobals","iterateConfig","addToImportMap","baseDir","config","importMap","imports","collections","globals","admin","avatar","Component","components","Nav","header","logout","Button","graphics","Icon","Logo","actions","afterDashboard","afterLogin","afterNavLinks","beforeDashboard","beforeLogin","beforeNavLinks","providers","views","Object","keys","length","key","adminViewConfig","generators","generator","dependencies","dependency","path"],"mappings":";;;AAIA,SAASA,kBAAkB,QAAQ,0BAAyB;AAC5D,SAASC,cAAc,QAAQ,sBAAqB;;;AAE7C,SAASC,cAAc,EAC5BC,cAAc,EACdC,OAAO,EACPC,MAAM,EACNC,SAAS,EACTC,OAAO,EAOR;0LACCP,qBAAAA,EAAmB;QACjBG;QACAC;QACAI,aAAaH,OAAOG,WAAW;QAC/BH;QACAC;QACAC;IACF;sLAEAN,iBAAAA,EAAe;QACbE;QACAC;QACAC;QACAI,SAASJ,OAAOI,OAAO;QACvBH;QACAC;IACF;IAEA,IAAI,OAAOF,OAAOK,KAAK,EAAEC,WAAW,UAAU;QAC5CR,eAAeE,OAAOK,KAAK,EAAEC,QAAQC;IACvC;IAEAT,eAAeE,OAAOK,KAAK,EAAEG,YAAYC;IACzCX,eAAeE,OAAOK,KAAK,EAAEG,YAAYE;IACzCZ,eAAeE,OAAOK,KAAK,EAAEG,YAAYG,QAAQC;IACjDd,eAAeE,OAAOK,KAAK,EAAEG,YAAYK,UAAUC;IACnDhB,eAAeE,OAAOK,KAAK,EAAEG,YAAYK,UAAUE;IAEnDjB,eAAeE,OAAOK,KAAK,EAAEG,YAAYQ;IACzClB,eAAeE,OAAOK,KAAK,EAAEG,YAAYS;IACzCnB,eAAeE,OAAOK,KAAK,EAAEG,YAAYU;IACzCpB,eAAeE,OAAOK,KAAK,EAAEG,YAAYW;IACzCrB,eAAeE,OAAOK,KAAK,EAAEG,YAAYY;IACzCtB,eAAeE,OAAOK,KAAK,EAAEG,YAAYa;IACzCvB,eAAeE,OAAOK,KAAK,EAAEG,YAAYc;IAEzCxB,eAAeE,OAAOK,KAAK,EAAEG,YAAYe;IAEzC,IAAIvB,OAAOK,KAAK,EAAEG,YAAYgB,OAAO;QACnC,IAAIC,OAAOC,IAAI,CAAC1B,OAAOK,KAAK,EAAEG,YAAYgB,QAAQG,QAAQ;YACxD,IAAK,MAAMC,OAAO5B,OAAOK,KAAK,EAAEG,YAAYgB,MAAO;gBACjD,MAAMK,kBAAmC7B,OAAOK,KAAK,EAAEG,YAAYgB,KAAK,CAACI,IAAI;gBAC7E9B,eAAe+B,iBAAiBtB;YAClC;QACF;IACF;IAEA,IAAIP,QAAQK,OAAOJ,WAAW6B,YAAYH,QAAQ;QAChD,KAAK,MAAMI,aAAa/B,OAAOK,KAAK,CAACJ,SAAS,CAAC6B,UAAU,CAAE;YACzDC,UAAU;gBACRjC;gBACAC;gBACAC;gBACAC;gBACAC;YACF;QACF;IACF;IAEA,IAAIF,QAAQK,OAAO2B,cAAc;QAC/B,IAAK,MAAMJ,OAAO5B,OAAOK,KAAK,CAAC2B,YAAY,CAAE;YAC3C,MAAMC,aAAajC,OAAOK,KAAK,CAAC2B,YAAY,CAACJ,IAAI;YACjD9B,eAAemC,WAAWC,IAAI;QAChC;IACF;AAEA;;;;;;;;;;;;;;GAcC,GAAG,qKAAqK;AAC3K"}},
    {"offset": {"line": 316, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 322, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/payload/src/bin/generateImportMap/index.ts"],"sourcesContent":["import crypto from 'crypto'\nimport fs from 'fs'\nimport process from 'node:process'\nimport path from 'path'\n\nimport type { PayloadComponent, SanitizedConfig } from '../../config/types.js'\n\nimport { iterateConfig } from './iterateConfig.js'\nimport { parsePayloadComponent } from './parsePayloadComponent.js'\n\ntype ImportIdentifier = string\ntype ImportSpecifier = string\ntype ImportPath = string\ntype UserImportPath = string\n\n/**\n * Import Map before being written to the file. Only contains all paths\n */\nexport type InternalImportMap = {\n  [path: UserImportPath]: ImportIdentifier\n}\n\n/**\n * Imports of the import map.\n */\nexport type Imports = {\n  [identifier: ImportIdentifier]: {\n    path: ImportPath\n    specifier: ImportSpecifier\n  }\n}\n\n/**\n * Import Map after being imported from the actual import map. Contains all the actual imported components\n */\nexport type ImportMap = {\n  [path: UserImportPath]: any\n}\n\nexport function addPayloadComponentToImportMap({\n  baseDir,\n  importMap,\n  imports,\n  payloadComponent,\n}: {\n  baseDir: string\n  importMap: InternalImportMap\n  imports: Imports\n  payloadComponent: PayloadComponent\n}) {\n  if (!payloadComponent) {\n    return\n  }\n  const { exportName, path: componentPath } = parsePayloadComponent(payloadComponent)\n\n  if (importMap[componentPath + '#' + exportName]) {\n    return\n  }\n\n  const importIdentifier =\n    exportName + '_' + crypto.createHash('md5').update(componentPath).digest('hex')\n\n  // e.g. if baseDir is /test/fields and componentPath is /components/Field.tsx\n  // then path needs to be /test/fields/components/Field.tsx NOT /users/username/project/test/fields/components/Field.tsx\n  // so we need to append baseDir to componentPath\n\n  imports[importIdentifier] = {\n    path:\n      componentPath.startsWith('.') || componentPath.startsWith('/')\n        ? path.posix.join(baseDir.replace(/\\\\/g, '/'), componentPath.slice(1))\n        : componentPath,\n    specifier: exportName,\n  }\n  importMap[componentPath + '#' + exportName] = importIdentifier\n}\n\nexport type AddToImportMap = (payloadComponent: PayloadComponent | PayloadComponent[]) => void\n\nexport async function generateImportMap(\n  config: SanitizedConfig,\n  options?: { force?: boolean; log: boolean },\n): Promise<void> {\n  const shouldLog = options?.log ?? true\n\n  if (shouldLog) {\n    console.log('Generating import map')\n  }\n\n  const importMap: InternalImportMap = {}\n  const imports: Imports = {}\n\n  const rootDir = process.env.ROOT_DIR ?? process.cwd()\n\n  // get componentsBaseDir.\n  // E.g.:\n  // config.admin.importMap.baseDir = /test/fields/\n  // rootDir: /\n  // componentsBaseDir = /test/fields/\n\n  // or\n\n  // E.g.:\n  // config.admin.importMap.baseDir = /test/fields/\n  // rootDir: /test\n  // componentsBaseDir = /fields/\n\n  // or\n  // config.admin.importMap.baseDir = /\n  // rootDir: /\n  // componentsBaseDir = /\n\n  const componentsBaseDir = path.relative(rootDir, config.admin.importMap.baseDir)\n\n  const addToImportMap: AddToImportMap = (payloadComponent) => {\n    if (!payloadComponent) {\n      return\n    }\n\n    if (typeof payloadComponent !== 'object' && typeof payloadComponent !== 'string') {\n      console.error(payloadComponent)\n      throw new Error('addToImportMap > Payload component must be an object or a string')\n    }\n\n    if (Array.isArray(payloadComponent)) {\n      for (const component of payloadComponent) {\n        addPayloadComponentToImportMap({\n          baseDir: componentsBaseDir,\n          importMap,\n          imports,\n          payloadComponent: component,\n        })\n      }\n    } else {\n      addPayloadComponentToImportMap({\n        baseDir: componentsBaseDir,\n        importMap,\n        imports,\n        payloadComponent,\n      })\n    }\n  }\n\n  iterateConfig({\n    addToImportMap,\n    baseDir: config.admin.importMap.baseDir,\n    config,\n    importMap,\n    imports,\n  })\n\n  await writeImportMap({\n    componentMap: importMap,\n    fileName: 'importMap.js',\n    force: options?.force,\n    importMap: imports,\n    log: shouldLog,\n    rootDir,\n  })\n}\n\nexport async function writeImportMap({\n  componentMap,\n  fileName,\n  force,\n  importMap,\n  log,\n  rootDir,\n}: {\n  componentMap: InternalImportMap\n  fileName: string\n  force?: boolean\n  importMap: Imports\n  log?: boolean\n  rootDir: string\n}) {\n  let importMapFolderPath = ''\n  if (fs.existsSync(path.resolve(rootDir, 'app/(payload)/admin/'))) {\n    importMapFolderPath = path.resolve(rootDir, 'app/(payload)/admin/')\n  } else if (fs.existsSync(path.resolve(rootDir, 'src/app/(payload)/admin/'))) {\n    importMapFolderPath = path.resolve(rootDir, 'src/app/(payload)/admin/')\n  } else {\n    throw new Error(\n      `Could not find the payload admin directory. Looked in ${path.resolve(rootDir, 'app/(payload)/admin/')} and ${path.resolve(rootDir, 'src/app/(payload)/admin/')}`,\n    )\n  }\n\n  const imports: string[] = []\n  for (const [identifier, { path, specifier }] of Object.entries(importMap)) {\n    imports.push(`import { ${specifier} as ${identifier} } from '${path}'`)\n  }\n\n  const mapKeys: string[] = []\n  for (const [userPath, identifier] of Object.entries(componentMap)) {\n    mapKeys.push(`  \"${userPath}\": ${identifier}`)\n  }\n\n  const importMapOutputFile = `${imports.join('\\n')}\n\nexport const importMap = {\n${mapKeys.join(',\\n')}\n}\n`\n\n  const importMapFilePath = path.resolve(importMapFolderPath, fileName)\n\n  if (!force) {\n    // Read current import map and check in the IMPORTS if there are any new imports. If not, don't write the file.\n    const currentImportMap = await fs.promises.readFile(importMapFilePath, 'utf-8')\n\n    if (currentImportMap?.trim() === importMapOutputFile?.trim()) {\n      if (log) {\n        console.log('No new imports found, skipping writing import map')\n      }\n      return\n    }\n  }\n\n  if (log) {\n    console.log('Writing import map to', importMapFilePath)\n  }\n\n  await fs.promises.writeFile(importMapFilePath, importMapOutputFile)\n}\n"],"names":["crypto","fs","process","path","iterateConfig","parsePayloadComponent","addPayloadComponentToImportMap","baseDir","importMap","imports","payloadComponent","exportName","componentPath","importIdentifier","createHash","update","digest","startsWith","posix","join","replace","slice","specifier","generateImportMap","config","options","shouldLog","log","console","rootDir","env","ROOT_DIR","cwd","componentsBaseDir","relative","admin","addToImportMap","error","Error","Array","isArray","component","writeImportMap","componentMap","fileName","force","importMapFolderPath","existsSync","resolve","identifier","Object","entries","push","mapKeys","userPath","importMapOutputFile","importMapFilePath","currentImportMap","promises","readFile","trim","writeFile"],"mappings":"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"}},
    {"offset": {"line": 461, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 467, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/payload/src/auth/executeAuthStrategies.ts"],"sourcesContent":["import type { AuthStrategyFunctionArgs, AuthStrategyResult } from './index.js'\n\nexport const executeAuthStrategies = async (\n  args: AuthStrategyFunctionArgs,\n): Promise<AuthStrategyResult> => {\n  return args.payload.authStrategies.reduce(\n    async (accumulatorPromise, strategy) => {\n      const result: AuthStrategyResult = await accumulatorPromise\n      if (!result.user) {\n        return strategy.authenticate(args)\n      }\n      return result\n    },\n    Promise.resolve({ user: null }),\n  )\n}\n"],"names":["executeAuthStrategies","args","payload","authStrategies","reduce","accumulatorPromise","strategy","result","user","authenticate","Promise","resolve"],"mappings":";;;AAEO,MAAMA,wBAAwB,OACnCC;IAEA,OAAOA,KAAKC,OAAO,CAACC,cAAc,CAACC,MAAM,CACvC,OAAOC,oBAAoBC;QACzB,MAAMC,SAA6B,MAAMF;QACzC,IAAI,CAACE,OAAOC,IAAI,EAAE;YAChB,OAAOF,SAASG,YAAY,CAACR;QAC/B;QACA,OAAOM;IACT,GACAG,QAAQC,OAAO,CAAC;QAAEH,MAAM;IAAK;AAEjC,EAAC"}},
    {"offset": {"line": 481, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 487, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/payload/src/fields/config/types.ts"],"sourcesContent":["/* eslint-disable @typescript-eslint/no-explicit-any */\n\nimport type { EditorProps } from '@monaco-editor/react'\nimport type { JSONSchema4 } from 'json-schema'\nimport type { CSSProperties } from 'react'\nimport type { DeepUndefinable } from 'ts-essentials'\n\nimport type {\n  JoinFieldErrorClientComponent,\n  JoinFieldErrorServerComponent,\n  JoinFieldLabelClientComponent,\n  JoinFieldLabelServerComponent,\n} from '../../admin/fields/Join.js'\nimport type { FieldClientComponent, FieldServerComponent } from '../../admin/forms/Field.js'\nimport type { RichTextAdapter, RichTextAdapterProvider } from '../../admin/RichText.js'\nimport type {\n  ArrayFieldClientProps,\n  ArrayFieldErrorClientComponent,\n  ArrayFieldErrorServerComponent,\n  ArrayFieldLabelClientComponent,\n  ArrayFieldLabelServerComponent,\n  BlocksFieldClientProps,\n  BlocksFieldErrorClientComponent,\n  BlocksFieldErrorServerComponent,\n  CheckboxFieldClientProps,\n  CheckboxFieldErrorClientComponent,\n  CheckboxFieldErrorServerComponent,\n  CheckboxFieldLabelClientComponent,\n  CheckboxFieldLabelServerComponent,\n  ClientTab,\n  CodeFieldClientProps,\n  CodeFieldErrorClientComponent,\n  CodeFieldErrorServerComponent,\n  CodeFieldLabelClientComponent,\n  CodeFieldLabelServerComponent,\n  CollapsibleFieldClientProps,\n  CollapsibleFieldLabelClientComponent,\n  CollapsibleFieldLabelServerComponent,\n  ConditionalDateProps,\n  DateFieldClientProps,\n  DateFieldErrorClientComponent,\n  DateFieldErrorServerComponent,\n  DateFieldLabelClientComponent,\n  DateFieldLabelServerComponent,\n  Description,\n  EmailFieldClientProps,\n  EmailFieldErrorClientComponent,\n  EmailFieldErrorServerComponent,\n  EmailFieldLabelClientComponent,\n  EmailFieldLabelServerComponent,\n  FieldDescriptionClientComponent,\n  FieldDescriptionServerComponent,\n  GroupFieldClientProps,\n  GroupFieldLabelClientComponent,\n  GroupFieldLabelServerComponent,\n  HiddenFieldProps,\n  JSONFieldClientProps,\n  JSONFieldErrorClientComponent,\n  JSONFieldErrorServerComponent,\n  JSONFieldLabelClientComponent,\n  JSONFieldLabelServerComponent,\n  MappedComponent,\n  NumberFieldClientProps,\n  NumberFieldErrorClientComponent,\n  NumberFieldErrorServerComponent,\n  NumberFieldLabelClientComponent,\n  NumberFieldLabelServerComponent,\n  PointFieldClientProps,\n  PointFieldErrorClientComponent,\n  PointFieldErrorServerComponent,\n  PointFieldLabelClientComponent,\n  PointFieldLabelServerComponent,\n  RadioFieldClientProps,\n  RadioFieldErrorClientComponent,\n  RadioFieldErrorServerComponent,\n  RadioFieldLabelClientComponent,\n  RadioFieldLabelServerComponent,\n  RelationshipFieldClientProps,\n  RelationshipFieldErrorClientComponent,\n  RelationshipFieldErrorServerComponent,\n  RelationshipFieldLabelClientComponent,\n  RelationshipFieldLabelServerComponent,\n  RichTextFieldClientProps,\n  RowFieldClientProps,\n  RowLabelComponent,\n  SelectFieldClientProps,\n  SelectFieldErrorClientComponent,\n  SelectFieldErrorServerComponent,\n  SelectFieldLabelClientComponent,\n  SelectFieldLabelServerComponent,\n  StaticDescription,\n  TabsFieldClientProps,\n  TextareaFieldClientProps,\n  TextareaFieldErrorClientComponent,\n  TextareaFieldErrorServerComponent,\n  TextareaFieldLabelClientComponent,\n  TextareaFieldLabelServerComponent,\n  TextFieldErrorClientComponent,\n  TextFieldErrorServerComponent,\n  TextFieldLabelClientComponent,\n  TextFieldLabelServerComponent,\n  UploadFieldClientProps,\n} from '../../admin/types.js'\nimport type { SanitizedCollectionConfig, TypeWithID } from '../../collections/config/types.js'\nimport type {\n  CustomComponent,\n  LabelFunction,\n  PayloadComponent,\n  StaticLabel,\n} from '../../config/types.js'\nimport type { DBIdentifierName } from '../../database/types.js'\nimport type { SanitizedGlobalConfig } from '../../globals/config/types.js'\nimport type {\n  ArrayFieldValidation,\n  BlocksFieldValidation,\n  CheckboxFieldValidation,\n  CodeFieldValidation,\n  CollectionSlug,\n  DateFieldValidation,\n  EmailFieldValidation,\n  JSONFieldValidation,\n  PointFieldValidation,\n  RadioFieldValidation,\n  TextareaFieldValidation,\n} from '../../index.js'\nimport type { DocumentPreferences } from '../../preferences/types.js'\nimport type { Operation, PayloadRequest, RequestContext, Where } from '../../types/index.js'\nimport type {\n  NumberFieldManyValidation,\n  NumberFieldSingleValidation,\n  RelationshipFieldManyValidation,\n  RelationshipFieldSingleValidation,\n  SelectFieldManyValidation,\n  SelectFieldSingleValidation,\n  TextFieldManyValidation,\n  TextFieldSingleValidation,\n  UploadFieldManyValidation,\n  UploadFieldSingleValidation,\n} from '../validations.js'\n\nexport type FieldHookArgs<TData extends TypeWithID = any, TValue = any, TSiblingData = any> = {\n  /** The collection which the field belongs to. If the field belongs to a global, this will be null. */\n  collection: null | SanitizedCollectionConfig\n  context: RequestContext\n  /**\n   * Only available in `afterRead` hooks\n   */\n  currentDepth?: number /**\n   * Only available in `afterRead` hooks\n   */\n  /** The data passed to update the document within create and update operations, and the full document itself in the afterRead hook. */\n  data?: Partial<TData>\n  /**\n   * Only available in the `afterRead` hook.\n   */\n  depth?: number\n  draft?: boolean\n  /** The field which the hook is running against. */\n  field: FieldAffectingData\n  /** Boolean to denote if this hook is running against finding one, or finding many within the afterRead hook. */\n  findMany?: boolean\n  /** The global which the field belongs to. If the field belongs to a collection, this will be null. */\n  global: null | SanitizedGlobalConfig\n  /** A string relating to which operation the field type is currently executing within. Useful within beforeValidate, beforeChange, and afterChange hooks to differentiate between create and update operations. */\n  operation?: 'create' | 'delete' | 'read' | 'update'\n  /** The full original document in `update` operations. In the `afterChange` hook, this is the resulting document of the operation. */\n  originalDoc?: TData\n  overrideAccess?: boolean\n  /**\n   * The path of the field, e.g. [\"group\", \"myArray\", 1, \"textField\"]. The path is the schemaPath but with indexes and would be used in the context of field data, not field schemas.\n   */\n  path: (number | string)[]\n  /** The document before changes were applied, only in `afterChange` hooks. */\n  previousDoc?: TData\n  /** The sibling data of the document before changes being applied, only in `beforeChange`, `beforeValidate`, `beforeDuplicate` and `afterChange` field hooks. */\n  previousSiblingDoc?: TData\n  /** The previous value of the field, before changes, only in `beforeChange`, `afterChange`, `beforeDuplicate` and `beforeValidate` field hooks. */\n  previousValue?: TValue\n  /** The Express request object. It is mocked for Local API operations. */\n  req: PayloadRequest\n  /**\n   * The schemaPath of the field, e.g. [\"group\", \"myArray\", \"textField\"]. The schemaPath is the path but without indexes and would be used in the context of field schemas, not field data.\n   */\n  schemaPath: string[]\n  /**\n   * Only available in the `afterRead` hook.\n   */\n  showHiddenFields?: boolean\n  /** The sibling data passed to a field that the hook is running against. */\n  siblingData: Partial<TSiblingData>\n  /**\n   * The original siblingData with locales (not modified by any hooks). Only available in `beforeChange` and `beforeDuplicate` field hooks.\n   */\n  siblingDocWithLocales?: Record<string, unknown>\n  /** The value of the field. */\n  value?: TValue\n}\n\nexport type FieldHook<TData extends TypeWithID = any, TValue = any, TSiblingData = any> = (\n  args: FieldHookArgs<TData, TValue, TSiblingData>,\n) => Promise<TValue> | TValue\n\nexport type FieldAccess<TData extends TypeWithID = any, TSiblingData = any> = (args: {\n  /**\n   * The incoming data used to `create` or `update` the document with. `data` is undefined during the `read` operation.\n   */\n  data?: Partial<TData>\n  /**\n   * The original data of the document before the `update` is applied. `doc` is undefined during the `create` operation.\n   */\n  doc?: TData\n  /**\n   * The `id` of the current document being read or updated. `id` is undefined during the `create` operation.\n   */\n  id?: number | string\n  /** The `payload` object to interface with the payload API */\n  req: PayloadRequest\n  /**\n   * Immediately adjacent data to this field. For example, if this is a `group` field, then `siblingData` will be the other fields within the group.\n   */\n  siblingData?: Partial<TSiblingData>\n}) => boolean | Promise<boolean>\n\nexport type Condition<TData extends TypeWithID = any, TSiblingData = any> = (\n  data: Partial<TData>,\n  siblingData: Partial<TSiblingData>,\n  { user }: { user: PayloadRequest['user'] },\n) => boolean\n\nexport type FilterOptionsProps<TData = any> = {\n  /**\n   * An object containing the full collection or global document currently being edited.\n   */\n  data: TData\n  /**\n   * The `id` of the current document being edited. `id` is undefined during the `create` operation.\n   */\n  id: number | string\n  /**\n   * The collection `slug` to filter against, limited to this field's `relationTo` property.\n   */\n  relationTo: CollectionSlug\n  /**\n   * An object containing document data that is scoped to only fields within the same parent of this field.\n   */\n  siblingData: unknown\n  /**\n   * An object containing the currently authenticated user.\n   */\n  user: Partial<PayloadRequest['user']>\n}\n\nexport type FilterOptionsFunc<TData = any> = (\n  options: FilterOptionsProps<TData>,\n) => boolean | Promise<boolean | Where> | Where\n\nexport type FilterOptions<TData = any> =\n  | ((options: FilterOptionsProps<TData>) => boolean | Promise<boolean | Where> | Where)\n  | null\n  | Where\n\ntype Admin = {\n  className?: string\n  components?: {\n    Cell?: CustomComponent\n    Description?: CustomComponent<FieldDescriptionClientComponent | FieldDescriptionServerComponent>\n    Field?: CustomComponent<FieldClientComponent | FieldServerComponent>\n    /**\n     * The Filter component has to be a client component\n     */\n    Filter?: PayloadComponent\n  }\n  /**\n   * You can programmatically show / hide fields based on what other fields are doing.\n   * This is also run on the server, to determine if the field should be validated.\n   */\n  condition?: Condition\n  /** Extension point to add your custom data. Available in server and client. */\n  custom?: Record<string, any>\n  description?: Description\n  disableBulkEdit?: boolean\n  disabled?: boolean\n  /**\n   * Shows / hides fields from appearing in the list view column selector.\n   * @type boolean\n   */\n  disableListColumn?: boolean\n  /**\n   * Shows / hides fields from appearing in the list view filter options.\n   * @type boolean\n   */\n  disableListFilter?: boolean\n  hidden?: boolean\n  position?: 'sidebar'\n  readOnly?: boolean\n  style?: CSSProperties\n  width?: CSSProperties['width']\n}\n\nexport type AdminClient = {\n  className?: string\n  components?: {\n    Cell?: MappedComponent\n    Description?: MappedComponent\n    Field?: MappedComponent\n    /**\n     * The Filter component has to be a client component\n     */\n    Filter?: MappedComponent\n  }\n  /** Extension point to add your custom data. Available in server and client. */\n  custom?: Record<string, any>\n  description?: StaticDescription\n  disableBulkEdit?: boolean\n  disabled?: boolean\n  /**\n   * Shows / hides fields from appearing in the list view column selector.\n   * @type boolean\n   */\n  disableListColumn?: boolean\n  /**\n   * Shows / hides fields from appearing in the list view filter options.\n   * @type boolean\n   */\n  disableListFilter?: boolean\n  hidden?: boolean\n  position?: 'sidebar'\n  readOnly?: boolean\n  style?: { '--field-width'?: CSSProperties['width'] } & CSSProperties\n  width?: CSSProperties['width']\n}\n\nexport type Labels = {\n  plural: LabelFunction | StaticLabel\n  singular: LabelFunction | StaticLabel\n}\n\nexport type LabelsClient = {\n  plural: StaticLabel\n  singular: StaticLabel\n}\n\nexport type BaseValidateOptions<TData, TSiblingData, TValue> = {\n  collectionSlug?: string\n  data: Partial<TData>\n  id?: number | string\n  operation?: Operation\n  preferences: DocumentPreferences\n  previousValue?: TValue\n  req: PayloadRequest\n  required?: boolean\n  siblingData: Partial<TSiblingData>\n}\n\nexport type ValidateOptions<\n  TData,\n  TSiblingData,\n  TFieldConfig extends object,\n  TValue,\n> = BaseValidateOptions<TData, TSiblingData, TValue> & TFieldConfig\n\nexport type Validate<\n  TValue = any,\n  TData = any,\n  TSiblingData = any,\n  TFieldConfig extends object = object,\n> = (\n  value: null | TValue | undefined,\n  options: ValidateOptions<TData, TSiblingData, TFieldConfig, TValue>,\n) => Promise<string | true> | string | true\n\nexport type OptionObject = {\n  label: LabelFunction | StaticLabel\n  value: string\n}\n\nexport type Option = OptionObject | string\n\nexport interface FieldBase {\n  /**\n   * Do not set this property manually. This is set to true during sanitization, to avoid\n   * sanitizing the same field multiple times.\n   */\n  _sanitized?: boolean\n  access?: {\n    create?: FieldAccess\n    read?: FieldAccess\n    update?: FieldAccess\n  }\n  admin?: Admin\n  /** Extension point to add your custom data. Server only. */\n  custom?: Record<string, any>\n  defaultValue?: any\n  hidden?: boolean\n  hooks?: {\n    afterChange?: FieldHook[]\n    afterRead?: FieldHook[]\n    beforeChange?: FieldHook[]\n    /**\n     * Runs before a document is duplicated to prevent errors in unique fields or return null to use defaultValue.\n     */\n    beforeDuplicate?: FieldHook[]\n    beforeValidate?: FieldHook[]\n  }\n  index?: boolean\n  label?: false | LabelFunction | StaticLabel\n  localized?: boolean\n  /**\n   * The name of the field. Must be alphanumeric and cannot contain ' . '\n   *\n   * Must not be one of reserved field names: ['__v', 'salt', 'hash', 'file']\n   * @link https://payloadcms.com/docs/fields/overview#field-names\n   */\n  name: string\n  required?: boolean\n  saveToJWT?: boolean | string\n  /**\n   * Allows you to modify the base JSON schema that is generated during generate:types for this field.\n   * This JSON schema will be used to generate the TypeScript interface of this field.\n   */\n  typescriptSchema?: Array<(args: { jsonSchema: JSONSchema4 }) => JSONSchema4>\n  unique?: boolean\n  validate?: Validate\n  /**\n   * Pass `true` to disable field in the DB\n   * for [Virtual Fields](https://payloadcms.com/blog/learn-how-virtual-fields-can-help-solve-common-cms-challenges):\n   * A virtual field cannot be used in `admin.useAsTitle`\n   */\n  virtual?: boolean\n}\n\nexport interface FieldBaseClient {\n  _isPresentational?: undefined\n  _path?: string\n  _schemaPath?: string\n  admin?: AdminClient\n  hidden?: boolean\n  index?: boolean\n  label?: StaticLabel\n  localized?: boolean\n  /**\n   * The name of the field. Must be alphanumeric and cannot contain ' . '\n   *\n   * Must not be one of reserved field names: ['__v', 'salt', 'hash', 'file']\n   * @link https://payloadcms.com/docs/fields/overview#field-names\n   */\n  name: string\n  required?: boolean\n  saveToJWT?: boolean | string\n  /**\n   * Allows you to modify the base JSON schema that is generated during generate:types for this field.\n   * This JSON schema will be used to generate the TypeScript interface of this field.\n   */\n  typescriptSchema?: Array<(args: { jsonSchema: JSONSchema4 }) => JSONSchema4>\n  unique?: boolean\n}\n\nexport type NumberField = {\n  admin?: {\n    /** Set this property to a string that will be used for browser autocomplete. */\n    autoComplete?: string\n    components?: {\n      afterInput?: CustomComponent[]\n      beforeInput?: CustomComponent[]\n      Error?: CustomComponent<NumberFieldErrorClientComponent | NumberFieldErrorServerComponent>\n      Label?: CustomComponent<NumberFieldLabelClientComponent | NumberFieldLabelServerComponent>\n    } & Admin['components']\n    /** Set this property to define a placeholder string for the field. */\n    placeholder?: Record<string, string> | string\n    /** Set a value for the number field to increment / decrement using browser controls. */\n    step?: number\n  } & Admin\n  /** Maximum value accepted. Used in the default `validate` function. */\n  max?: number\n  /** Minimum value accepted. Used in the default `validate` function. */\n  min?: number\n  type: 'number'\n} & (\n  | {\n      /** Makes this field an ordered array of numbers instead of just a single number. */\n      hasMany: true\n      /** Maximum number of numbers in the numbers array, if `hasMany` is set to true. */\n      maxRows?: number\n      /** Minimum number of numbers in the numbers array, if `hasMany` is set to true. */\n      minRows?: number\n      validate?: NumberFieldManyValidation\n    }\n  | {\n      /** Makes this field an ordered array of numbers instead of just a single number. */\n      hasMany?: false | undefined\n      /** Maximum number of numbers in the numbers array, if `hasMany` is set to true. */\n      maxRows?: undefined\n      /** Minimum number of numbers in the numbers array, if `hasMany` is set to true. */\n      minRows?: undefined\n      validate?: NumberFieldSingleValidation\n    }\n) &\n  Omit<FieldBase, 'validate'>\n\nexport type NumberFieldClient = {\n  admin?: {\n    components?: {\n      afterInput?: MappedComponent[]\n      beforeInput?: MappedComponent[]\n      Error?: MappedComponent\n      Label?: MappedComponent\n    } & AdminClient['components']\n  } & AdminClient &\n    Pick<NumberField['admin'], 'autoComplete' | 'placeholder' | 'step'>\n} & FieldBaseClient &\n  Pick<NumberField, 'hasMany' | 'max' | 'maxRows' | 'min' | 'minRows' | 'type'>\n\nexport type TextField = {\n  admin?: {\n    autoComplete?: string\n    components?: {\n      afterInput?: CustomComponent[]\n      beforeInput?: CustomComponent[]\n      Error?: CustomComponent<TextFieldErrorClientComponent | TextFieldErrorServerComponent>\n      Label?: CustomComponent<TextFieldLabelClientComponent | TextFieldLabelServerComponent>\n    } & Admin['components']\n    placeholder?: Record<string, string> | string\n    rtl?: boolean\n  } & Admin\n  maxLength?: number\n  minLength?: number\n  type: 'text'\n} & (\n  | {\n      /** Makes this field an ordered array of strings instead of just a single string. */\n      hasMany: true\n      /** Maximum number of strings in the strings array, if `hasMany` is set to true. */\n      maxRows?: number\n      /** Minimum number of strings in the strings array, if `hasMany` is set to true. */\n      minRows?: number\n      validate?: TextFieldManyValidation\n    }\n  | {\n      /** Makes this field an ordered array of strings instead of just a single string. */\n      hasMany?: false | undefined\n      /** Maximum number of strings in the strings array, if `hasMany` is set to true. */\n      maxRows?: undefined\n      /** Minimum number of strings in the strings array, if `hasMany` is set to true. */\n      minRows?: undefined\n      validate?: TextFieldSingleValidation\n    }\n) &\n  Omit<FieldBase, 'validate'>\n\nexport type TextFieldClient = {\n  admin?: {\n    components?: {\n      afterInput?: MappedComponent[]\n      beforeInput?: MappedComponent[]\n      Error?: MappedComponent\n      Label?: MappedComponent\n    } & AdminClient['components']\n  } & AdminClient &\n    Pick<TextField['admin'], 'autoComplete' | 'placeholder' | 'rtl'>\n} & FieldBaseClient &\n  Pick<TextField, 'hasMany' | 'maxLength' | 'maxRows' | 'minLength' | 'minRows' | 'type'>\n\nexport type EmailField = {\n  admin?: {\n    autoComplete?: string\n    components?: {\n      afterInput?: CustomComponent[]\n      beforeInput?: CustomComponent[]\n      Error?: CustomComponent<EmailFieldErrorClientComponent | EmailFieldErrorServerComponent>\n      Label?: CustomComponent<EmailFieldLabelClientComponent | EmailFieldLabelServerComponent>\n    } & Admin['components']\n    placeholder?: Record<string, string> | string\n  } & Admin\n  type: 'email'\n  validate?: EmailFieldValidation\n} & Omit<FieldBase, 'validate'>\n\nexport type EmailFieldClient = {\n  admin?: {\n    components?: {\n      afterInput?: MappedComponent[]\n      beforeInput?: MappedComponent[]\n      Error?: MappedComponent\n      Label?: MappedComponent\n    } & AdminClient['components']\n  } & AdminClient &\n    Pick<EmailField['admin'], 'placeholder'>\n} & FieldBaseClient &\n  Pick<EmailField, 'type'>\n\nexport type TextareaField = {\n  admin?: {\n    components?: {\n      afterInput?: CustomComponent[]\n      beforeInput?: CustomComponent[]\n      Error?: CustomComponent<TextareaFieldErrorClientComponent | TextareaFieldErrorServerComponent>\n      Label?: CustomComponent<TextareaFieldLabelClientComponent | TextareaFieldLabelServerComponent>\n    } & Admin['components']\n    placeholder?: Record<string, string> | string\n    rows?: number\n    rtl?: boolean\n  } & Admin\n  maxLength?: number\n  minLength?: number\n  type: 'textarea'\n  validate?: TextareaFieldValidation\n} & Omit<FieldBase, 'validate'>\n\nexport type TextareaFieldClient = {\n  admin?: {\n    components?: {\n      afterInput?: MappedComponent[]\n      beforeInput?: MappedComponent[]\n      Error?: MappedComponent\n      Label?: MappedComponent\n    } & AdminClient['components']\n  } & AdminClient &\n    Pick<TextareaField['admin'], 'placeholder' | 'rows' | 'rtl'>\n} & FieldBaseClient &\n  Pick<TextareaField, 'maxLength' | 'minLength' | 'type'>\n\nexport type CheckboxField = {\n  admin?: {\n    components?: {\n      afterInput?: CustomComponent[]\n      beforeInput?: CustomComponent[]\n      Error?: CustomComponent<CheckboxFieldErrorClientComponent | CheckboxFieldErrorServerComponent>\n      Label?: CustomComponent<CheckboxFieldLabelClientComponent | CheckboxFieldLabelServerComponent>\n    } & Admin['components']\n  } & Admin\n  type: 'checkbox'\n  validate?: CheckboxFieldValidation\n} & Omit<FieldBase, 'validate'>\n\nexport type CheckboxFieldClient = {\n  admin?: {\n    components?: {\n      afterInput?: MappedComponent[]\n      beforeInput?: MappedComponent[]\n      Error?: MappedComponent\n      Label?: MappedComponent\n    } & AdminClient['components']\n  } & AdminClient\n} & FieldBaseClient &\n  Pick<CheckboxField, 'type'>\n\nexport type DateField = {\n  admin?: {\n    components?: {\n      afterInput?: CustomComponent[]\n      beforeInput?: CustomComponent[]\n      Error?: CustomComponent<DateFieldErrorClientComponent | DateFieldErrorServerComponent>\n      Label?: CustomComponent<DateFieldLabelClientComponent | DateFieldLabelServerComponent>\n    } & Admin['components']\n    date?: ConditionalDateProps\n    placeholder?: Record<string, string> | string\n  } & Admin\n  type: 'date'\n  validate?: DateFieldValidation\n} & Omit<FieldBase, 'validate'>\n\nexport type DateFieldClient = {\n  admin?: {\n    components?: {\n      afterInput?: MappedComponent[]\n      beforeInput?: MappedComponent[]\n      Error?: MappedComponent\n      Label?: MappedComponent\n    } & AdminClient['components']\n  } & AdminClient &\n    Pick<DateField['admin'], 'date' | 'placeholder'>\n} & FieldBaseClient &\n  Pick<DateField, 'type'>\n\nexport type GroupField = {\n  admin?: {\n    components?: {\n      Label?: CustomComponent<GroupFieldLabelClientComponent | GroupFieldLabelServerComponent>\n    } & Admin['components']\n    hideGutter?: boolean\n  } & Admin\n  fields: Field[]\n  /** Customize generated GraphQL and Typescript schema names.\n   * By default, it is bound to the collection.\n   *\n   * This is useful if you would like to generate a top level type to share amongst collections/fields.\n   * **Note**: Top level types can collide, ensure they are unique amongst collections, arrays, groups, blocks, tabs.\n   */\n  interfaceName?: string\n  type: 'group'\n  validate?: Validate<unknown, unknown, unknown, GroupField>\n} & Omit<FieldBase, 'required' | 'validate'>\n\nexport type GroupFieldClient = {\n  admin?: {\n    components?: {\n      Label?: MappedComponent\n    } & AdminClient['components']\n  } & AdminClient &\n    Pick<GroupField['admin'], 'hideGutter'>\n  fields: ClientField[]\n} & Omit<FieldBaseClient, 'required'> &\n  Pick<GroupField, 'interfaceName' | 'type'>\n\nexport type RowField = {\n  admin?: Omit<Admin, 'description'>\n  fields: Field[]\n  type: 'row'\n} & Omit<FieldBase, 'admin' | 'label' | 'name' | 'validate' | 'virtual'>\n\nexport type RowFieldClient = {\n  admin?: Omit<AdminClient, 'description'>\n  fields: ClientField[]\n} & Omit<FieldBaseClient, 'admin' | 'label' | 'name'> &\n  Pick<RowField, 'type'>\n\nexport type CollapsibleField = {\n  fields: Field[]\n  type: 'collapsible'\n} & (\n  | {\n      admin: {\n        components: {\n          Label?: CustomComponent<\n            CollapsibleFieldLabelClientComponent | CollapsibleFieldLabelServerComponent\n          >\n          RowLabel: RowLabelComponent\n        } & Admin['components']\n        initCollapsed?: boolean\n      } & Admin\n      label?: Required<FieldBase['label']>\n    }\n  | {\n      admin?: {\n        components?: {\n          Label?: CustomComponent<\n            CollapsibleFieldLabelClientComponent | CollapsibleFieldLabelServerComponent\n          >\n        } & Admin['components']\n        initCollapsed?: boolean\n      } & Admin\n      label: Required<FieldBase['label']>\n    }\n) &\n  Omit<FieldBase, 'label' | 'name' | 'validate' | 'virtual'>\n\nexport type CollapsibleFieldClient = {\n  fields: ClientField[]\n} & (\n  | {\n      admin: {\n        components: {\n          RowLabel: MappedComponent\n        } & AdminClient['components']\n        initCollapsed?: boolean\n      } & AdminClient\n      label?: Required<FieldBaseClient['label']>\n    }\n  | {\n      admin?: {\n        initCollapsed?: boolean\n      } & AdminClient\n      label: Required<FieldBaseClient['label']>\n    }\n) &\n  Omit<FieldBaseClient, 'label' | 'name' | 'validate'> &\n  Pick<CollapsibleField, 'type'>\n\ntype TabBase = {\n  description?: Description\n  fields: Field[]\n  interfaceName?: string\n  saveToJWT?: boolean | string\n} & Omit<FieldBase, 'required' | 'validate'>\n\nexport type NamedTab = {\n  /** Customize generated GraphQL and Typescript schema names.\n   * The slug is used by default.\n   *\n   * This is useful if you would like to generate a top level type to share amongst collections/fields.\n   * **Note**: Top level types can collide, ensure they are unique amongst collections, arrays, groups, blocks, tabs.\n   */\n  interfaceName?: string\n} & TabBase\n\nexport type UnnamedTab = {\n  interfaceName?: never\n  /**\n   * Can be either:\n   * - A string, which will be used as the tab's label.\n   * - An object, where the key is the language code and the value is the label.\n   */\n  label:\n    | {\n        [selectedLanguage: string]: string\n      }\n    | LabelFunction\n    | string\n  localized?: never\n} & Omit<TabBase, 'name' | 'virtual'>\n\nexport type Tab = NamedTab | UnnamedTab\n\nexport type TabsField = {\n  admin?: Omit<Admin, 'description'>\n  tabs: Tab[]\n  type: 'tabs'\n} & Omit<FieldBase, 'admin' | 'localized' | 'name' | 'saveToJWT' | 'virtual'>\n\nexport type TabsFieldClient = {\n  admin?: Omit<AdminClient, 'description'>\n  tabs: ClientTab[]\n} & Omit<FieldBaseClient, 'admin' | 'localized' | 'name' | 'saveToJWT'> &\n  Pick<TabsField, 'type'>\n\nexport type TabAsField = {\n  name?: string\n  type: 'tab'\n} & Tab\n\nexport type TabAsFieldClient = ClientTab & Pick<TabAsField, 'name' | 'type'>\n\nexport type UIField = {\n  admin: {\n    components?: {\n      Cell?: CustomComponent\n      Field: CustomComponent\n      /**\n       * The Filter component has to be a client component\n       */\n      Filter?: PayloadComponent\n    } & Admin['components']\n    condition?: Condition\n    /** Extension point to add your custom data. Available in server and client. */\n    custom?: Record<string, any>\n    /**\n     * Set `false` make the UI field appear in the list view column selector. `true` by default for UI fields.\n     * @default true\n     */\n    disableBulkEdit?: boolean\n    /**\n     * Shows / hides fields from appearing in the list view column selector.\n     * @type boolean\n     */\n    disableListColumn?: boolean\n    position?: string\n    width?: CSSProperties['width']\n  }\n  /** Extension point to add your custom data. Server only. */\n  custom?: Record<string, any>\n  label?: Record<string, string> | string\n  name: string\n  type: 'ui'\n}\n\nexport type UIFieldClient = {\n  _isPresentational?: true\n  // still include FieldBaseClient.admin (even if it's undefinable) so that we don't need constant type checks (e.g. if('xy' in field))\n  // eslint-disable-next-line perfectionist/sort-intersection-types\n  admin: DeepUndefinable<FieldBaseClient['admin']> & {\n    components?: {\n      Cell?: MappedComponent\n      Field: MappedComponent\n      Filter?: MappedComponent\n    } & AdminClient['components']\n  } & Pick<\n      UIField['admin'],\n      'custom' | 'disableBulkEdit' | 'disableListColumn' | 'position' | 'width'\n    >\n} & Omit<DeepUndefinable<FieldBaseClient>, '_isPresentational' | 'admin'> & // still include FieldBaseClient (even if it's undefinable) so that we don't need constant type checks (e.g. if('xy' in field))\n  Pick<UIField, 'label' | 'name' | 'type'>\n\ntype SharedUploadProperties = {\n  /**\n   * Toggle the preview in the admin interface.\n   */\n  displayPreview?: boolean\n  filterOptions?: FilterOptions\n  /**\n   * Sets a maximum population depth for this field, regardless of the remaining depth when this field is reached.\n   *\n   * {@link https://payloadcms.com/docs/getting-started/concepts#field-level-max-depth}\n   */\n  maxDepth?: number\n  type: 'upload'\n} & (\n  | {\n      hasMany: true\n      /**\n       * @deprecated Use 'maxRows' instead\n       */\n      max?: number\n      maxRows?: number\n      /**\n       * @deprecated Use 'minRows' instead\n       */\n      min?: number\n      minRows?: number\n      validate?: UploadFieldManyValidation\n    }\n  | {\n      hasMany?: false | undefined\n      /**\n       * @deprecated Use 'maxRows' instead\n       */\n      max?: undefined\n      maxRows?: undefined\n      /**\n       * @deprecated Use 'minRows' instead\n       */\n      min?: undefined\n      minRows?: undefined\n      validate?: UploadFieldSingleValidation\n    }\n) &\n  Omit<FieldBase, 'validate'>\n\ntype SharedUploadPropertiesClient = FieldBaseClient &\n  Pick<\n    SharedUploadProperties,\n    'hasMany' | 'max' | 'maxDepth' | 'maxRows' | 'min' | 'minRows' | 'type'\n  >\n\ntype UploadAdmin = {\n  allowCreate?: boolean\n  components?: {\n    Error?: CustomComponent<\n      RelationshipFieldErrorClientComponent | RelationshipFieldErrorServerComponent\n    >\n    Label?: CustomComponent<\n      RelationshipFieldLabelClientComponent | RelationshipFieldLabelServerComponent\n    >\n  } & Admin['components']\n  isSortable?: boolean\n} & Admin\ntype UploadAdminClient = {\n  components?: {\n    Error?: MappedComponent\n    Label?: MappedComponent\n  } & AdminClient['components']\n} & AdminClient &\n  Pick<UploadAdmin, 'allowCreate' | 'isSortable'>\n\nexport type PolymorphicUploadField = {\n  admin?: {\n    sortOptions?: { [collectionSlug: CollectionSlug]: string }\n  } & UploadAdmin\n  relationTo: CollectionSlug[]\n} & SharedUploadProperties\n\nexport type PolymorphicUploadFieldClient = {\n  admin?: {\n    sortOptions?: Pick<PolymorphicUploadField['admin'], 'sortOptions'>\n  } & UploadAdminClient\n} & Pick<PolymorphicUploadField, 'displayPreview' | 'maxDepth' | 'relationTo' | 'type'> &\n  SharedUploadPropertiesClient\n\nexport type SingleUploadField = {\n  admin?: {\n    sortOptions?: string\n  } & UploadAdmin\n  relationTo: CollectionSlug\n} & SharedUploadProperties\n\nexport type SingleUploadFieldClient = {\n  admin?: Pick<SingleUploadField['admin'], 'sortOptions'> & UploadAdminClient\n} & Pick<SingleUploadField, 'displayPreview' | 'maxDepth' | 'relationTo' | 'type'> &\n  SharedUploadPropertiesClient\n\nexport type UploadField = /* PolymorphicUploadField | */ SingleUploadField\n\nexport type UploadFieldClient = /* PolymorphicUploadFieldClient | */ SingleUploadFieldClient\n\nexport type CodeField = {\n  admin?: {\n    components?: {\n      afterInput?: CustomComponent[]\n      beforeInput?: CustomComponent[]\n      Error?: CustomComponent<CodeFieldErrorClientComponent | CodeFieldErrorServerComponent>\n      Label?: CustomComponent<CodeFieldLabelClientComponent | CodeFieldLabelServerComponent>\n    } & Admin['components']\n    editorOptions?: EditorProps['options']\n    language?: string\n  } & Admin\n  maxLength?: number\n  minLength?: number\n  type: 'code'\n  validate?: CodeFieldValidation\n} & Omit<FieldBase, 'admin' | 'validate'>\n\nexport type CodeFieldClient = {\n  admin?: {\n    components?: {\n      afterInput?: MappedComponent[]\n      beforeInput?: MappedComponent[]\n      Error?: MappedComponent\n      Label?: MappedComponent\n    } & AdminClient['components']\n  } & AdminClient &\n    Pick<CodeField['admin'], 'editorOptions' | 'language'>\n} & Omit<FieldBaseClient, 'admin'> &\n  Pick<CodeField, 'maxLength' | 'minLength' | 'type'>\n\nexport type JSONField = {\n  admin?: {\n    components?: {\n      afterInput?: CustomComponent[]\n      beforeInput?: CustomComponent[]\n      Error?: CustomComponent<JSONFieldErrorClientComponent | JSONFieldErrorServerComponent>\n      Label?: CustomComponent<JSONFieldLabelClientComponent | JSONFieldLabelServerComponent>\n    } & Admin['components']\n    editorOptions?: EditorProps['options']\n  } & Admin\n\n  jsonSchema?: {\n    fileMatch: string[]\n    schema: JSONSchema4\n    uri: string\n  }\n  type: 'json'\n  validate?: JSONFieldValidation\n} & Omit<FieldBase, 'admin' | 'validate'>\n\nexport type JSONFieldClient = {\n  admin?: {\n    components?: {\n      afterInput?: MappedComponent[]\n      beforeInput?: MappedComponent[]\n      Error?: MappedComponent\n      Label?: MappedComponent\n    } & AdminClient['components']\n  } & AdminClient &\n    Pick<JSONField['admin'], 'editorOptions'>\n} & Omit<FieldBaseClient, 'admin'> &\n  Pick<JSONField, 'jsonSchema' | 'type'>\n\nexport type SelectField = {\n  admin?: {\n    components?: {\n      afterInput?: CustomComponent[]\n      beforeInput?: CustomComponent[]\n      Error?: CustomComponent<SelectFieldErrorClientComponent | SelectFieldErrorServerComponent>\n      Label?: CustomComponent<SelectFieldLabelClientComponent | SelectFieldLabelServerComponent>\n    } & Admin['components']\n    isClearable?: boolean\n    isSortable?: boolean\n  } & Admin\n  /**\n   * Customize the SQL table name\n   */\n  dbName?: DBIdentifierName\n  /**\n   * Customize the DB enum name\n   */\n  enumName?: DBIdentifierName\n  hasMany?: boolean\n  options: Option[]\n  type: 'select'\n} & (\n  | {\n      hasMany: true\n      validate?: SelectFieldManyValidation\n    }\n  | {\n      hasMany?: false | undefined\n      validate?: SelectFieldSingleValidation\n    }\n) &\n  Omit<FieldBase, 'validate'>\n\nexport type SelectFieldClient = {\n  admin?: {\n    components?: {\n      afterInput?: MappedComponent[]\n      beforeInput?: MappedComponent[]\n      Error?: MappedComponent\n      Label?: MappedComponent\n    } & AdminClient['components']\n  } & AdminClient &\n    Pick<SelectField['admin'], 'isClearable' | 'isSortable'>\n} & FieldBaseClient &\n  Pick<SelectField, 'hasMany' | 'options' | 'type'>\n\ntype SharedRelationshipProperties = {\n  filterOptions?: FilterOptions\n  /**\n   * Sets a maximum population depth for this field, regardless of the remaining depth when this field is reached.\n   *\n   * {@link https://payloadcms.com/docs/getting-started/concepts#field-level-max-depth}\n   */\n  maxDepth?: number\n  type: 'relationship'\n} & (\n  | {\n      hasMany: true\n      /**\n       * @deprecated Use 'maxRows' instead\n       */\n      max?: number\n      maxRows?: number\n      /**\n       * @deprecated Use 'minRows' instead\n       */\n      min?: number\n      minRows?: number\n      validate?: RelationshipFieldManyValidation\n    }\n  | {\n      hasMany?: false | undefined\n      /**\n       * @deprecated Use 'maxRows' instead\n       */\n      max?: undefined\n      maxRows?: undefined\n      /**\n       * @deprecated Use 'minRows' instead\n       */\n      min?: undefined\n      minRows?: undefined\n      validate?: RelationshipFieldSingleValidation\n    }\n) &\n  Omit<FieldBase, 'validate'>\n\ntype SharedRelationshipPropertiesClient = FieldBaseClient &\n  Pick<\n    SharedRelationshipProperties,\n    'hasMany' | 'max' | 'maxDepth' | 'maxRows' | 'min' | 'minRows' | 'type'\n  >\n\ntype RelationshipAdmin = {\n  allowCreate?: boolean\n  allowEdit?: boolean\n  components?: {\n    Error?: CustomComponent<\n      RelationshipFieldErrorClientComponent | RelationshipFieldErrorServerComponent\n    >\n    Label?: CustomComponent<\n      RelationshipFieldLabelClientComponent | RelationshipFieldLabelServerComponent\n    >\n  } & Admin['components']\n  isSortable?: boolean\n} & Admin\n\ntype RelationshipAdminClient = {\n  components?: {\n    Error?: MappedComponent\n    Label?: MappedComponent\n  } & AdminClient['components']\n} & AdminClient &\n  Pick<RelationshipAdmin, 'allowCreate' | 'allowEdit' | 'isSortable'>\n\nexport type PolymorphicRelationshipField = {\n  admin?: {\n    sortOptions?: { [collectionSlug: CollectionSlug]: string }\n  } & RelationshipAdmin\n  relationTo: CollectionSlug[]\n} & SharedRelationshipProperties\n\nexport type PolymorphicRelationshipFieldClient = {\n  admin?: {\n    sortOptions?: Pick<PolymorphicRelationshipField['admin'], 'sortOptions'>\n  } & RelationshipAdminClient\n} & Pick<PolymorphicRelationshipField, 'relationTo'> &\n  SharedRelationshipPropertiesClient\n\nexport type SingleRelationshipField = {\n  admin?: {\n    sortOptions?: string\n  } & RelationshipAdmin\n  relationTo: CollectionSlug\n} & SharedRelationshipProperties\n\nexport type SingleRelationshipFieldClient = {\n  admin?: Partial<Pick<SingleRelationshipField['admin'], 'sortOptions'>> & RelationshipAdminClient\n} & Pick<SingleRelationshipField, 'relationTo'> &\n  SharedRelationshipPropertiesClient\n\nexport type RelationshipField = PolymorphicRelationshipField | SingleRelationshipField\n\nexport type RelationshipFieldClient =\n  | PolymorphicRelationshipFieldClient\n  | SingleRelationshipFieldClient\n\nexport type ValueWithRelation = {\n  relationTo: CollectionSlug\n  value: number | string\n}\n\nexport function valueIsValueWithRelation(value: unknown): value is ValueWithRelation {\n  return value !== null && typeof value === 'object' && 'relationTo' in value && 'value' in value\n}\n\nexport type RelationshipValue = RelationshipValueMany | RelationshipValueSingle\n\nexport type RelationshipValueMany = (number | string)[] | ValueWithRelation[]\n\nexport type RelationshipValueSingle = number | string | ValueWithRelation\n\nexport type RichTextField<\n  TValue extends object = any,\n  TAdapterProps = any,\n  TExtraProperties = object,\n> = {\n  admin?: {\n    components?: {\n      Error?: CustomComponent\n      Label?: CustomComponent\n    } & Admin['components']\n  } & Admin\n  editor?:\n    | RichTextAdapter<TValue, TAdapterProps, TExtraProperties>\n    | RichTextAdapterProvider<TValue, TAdapterProps, TExtraProperties>\n  /**\n   * Sets a maximum population depth for this field, regardless of the remaining depth when this field is reached.\n   *\n   * {@link https://payloadcms.com/docs/getting-started/concepts#field-level-max-depth}\n   */\n  maxDepth?: number\n  type: 'richText'\n} & FieldBase &\n  TExtraProperties\n\nexport type RichTextFieldClient<\n  TValue extends object = any,\n  TAdapterProps = any,\n  TExtraProperties = object,\n> = {\n  admin?: {\n    components?: {\n      Error?: MappedComponent\n      Label?: MappedComponent\n    } & AdminClient['components']\n    placeholder?: Record<string, string> | string\n  } & AdminClient\n  richTextComponentMap?: Map<string, any>\n} & FieldBaseClient &\n  Pick<RichTextField<TValue, TAdapterProps, TExtraProperties>, 'maxDepth' | 'type'> &\n  TExtraProperties\n\nexport type ArrayField = {\n  admin?: {\n    components?: {\n      Error?: CustomComponent<ArrayFieldErrorClientComponent | ArrayFieldErrorServerComponent>\n      Label?: CustomComponent<ArrayFieldLabelClientComponent | ArrayFieldLabelServerComponent>\n      RowLabel?: RowLabelComponent\n    } & Admin['components']\n    initCollapsed?: boolean\n    /**\n     * Disable drag and drop sorting\n     */\n    isSortable?: boolean\n  } & Admin\n  /**\n   * Customize the SQL table name\n   */\n  dbName?: DBIdentifierName\n  fields: Field[]\n  /** Customize generated GraphQL and Typescript schema names.\n   * By default, it is bound to the collection.\n   *\n   * This is useful if you would like to generate a top level type to share amongst collections/fields.\n   * **Note**: Top level types can collide, ensure they are unique amongst collections, arrays, groups, blocks, tabs.\n   */\n  interfaceName?: string\n  labels?: Labels\n  maxRows?: number\n  minRows?: number\n  type: 'array'\n  validate?: ArrayFieldValidation\n} & Omit<FieldBase, 'validate'>\n\nexport type ArrayFieldClient = {\n  admin?: {\n    components?: {\n      Error?: MappedComponent\n      Label?: MappedComponent\n      RowLabel?: MappedComponent\n    } & AdminClient['components']\n  } & AdminClient &\n    Pick<ArrayField['admin'], 'initCollapsed' | 'isSortable'>\n  fields: ClientField[]\n  labels?: LabelsClient\n} & FieldBaseClient &\n  Pick<ArrayField, 'interfaceName' | 'maxRows' | 'minRows' | 'type'>\n\nexport type RadioField = {\n  admin?: {\n    components?: {\n      Error?: CustomComponent<RadioFieldErrorClientComponent | RadioFieldErrorServerComponent>\n      Label?: CustomComponent<RadioFieldLabelClientComponent | RadioFieldLabelServerComponent>\n    } & Admin['components']\n    layout?: 'horizontal' | 'vertical'\n  } & Admin\n  /**\n   * Customize the SQL table name\n   */\n  dbName?: DBIdentifierName\n  /**\n   * Customize the DB enum name\n   */\n  enumName?: DBIdentifierName\n  options: Option[]\n  type: 'radio'\n  validate?: RadioFieldValidation\n} & Omit<FieldBase, 'validate'>\n\nexport type RadioFieldClient = {\n  admin?: {\n    components?: {\n      Error?: MappedComponent\n      Label?: MappedComponent\n    } & AdminClient['components']\n  } & AdminClient &\n    Pick<RadioField['admin'], 'layout'>\n} & FieldBaseClient &\n  Pick<RadioField, 'options' | 'type'>\n\nexport type Block = {\n  /**\n   * Do not set this property manually. This is set to true during sanitization, to avoid\n   * sanitizing the same block multiple times.\n   */\n  _sanitized?: boolean\n  admin?: {\n    components?: {\n      Label?: PayloadComponent<\n        never,\n        {\n          blockKind: 'block' | 'lexicalBlock' | 'lexicalInlineBlock' | string\n          /**\n           * May contain the formData\n           */\n          formData: Record<string, any>\n        }\n      >\n    }\n    /** Extension point to add your custom data. Available in server and client. */\n    custom?: Record<string, any>\n  }\n  /** Extension point to add your custom data. Server only. */\n  custom?: Record<string, any>\n  /**\n   * Customize the SQL table name\n   */\n  dbName?: DBIdentifierName\n  fields: Field[]\n  /** @deprecated - please migrate to the interfaceName property instead. */\n  graphQL?: {\n    singularName?: string\n  }\n  imageAltText?: string\n  imageURL?: string\n  /** Customize generated GraphQL and Typescript schema names.\n   * The slug is used by default.\n   *\n   * This is useful if you would like to generate a top level type to share amongst collections/fields.\n   * **Note**: Top level types can collide, ensure they are unique amongst collections, arrays, groups, blocks, tabs.\n   */\n  interfaceName?: string\n  labels?: Labels\n  slug: string\n}\nexport type ClientBlock = {\n  admin?: {\n    components?: {\n      Label?: MappedComponent\n    }\n  } & Pick<Block['admin'], 'custom'>\n  fields: ClientField[]\n  labels?: LabelsClient\n} & Pick<Block, 'imageAltText' | 'imageURL' | 'slug'>\n\nexport type BlocksField = {\n  admin?: {\n    components?: {\n      Error?: CustomComponent<BlocksFieldErrorClientComponent | BlocksFieldErrorServerComponent>\n    } & Admin['components']\n    initCollapsed?: boolean\n    /**\n     * Disable drag and drop sorting\n     */\n    isSortable?: boolean\n  } & Admin\n  blocks: Block[]\n  defaultValue?: unknown\n  labels?: Labels\n  maxRows?: number\n  minRows?: number\n  type: 'blocks'\n  validate?: BlocksFieldValidation\n} & Omit<FieldBase, 'validate'>\n\nexport type BlocksFieldClient = {\n  admin?: {\n    components?: {\n      Error?: MappedComponent\n    } & AdminClient['components']\n  } & AdminClient &\n    Pick<BlocksField['admin'], 'initCollapsed' | 'isSortable'>\n  blocks: ClientBlock[]\n  labels?: LabelsClient\n} & FieldBaseClient &\n  Pick<BlocksField, 'maxRows' | 'minRows' | 'type'>\n\nexport type PointField = {\n  admin?: {\n    components?: {\n      afterInput?: CustomComponent[]\n      beforeInput?: CustomComponent[]\n      Error?: CustomComponent<PointFieldErrorClientComponent | PointFieldErrorServerComponent>\n      Label?: CustomComponent<PointFieldLabelClientComponent | PointFieldLabelServerComponent>\n    } & Admin['components']\n    placeholder?: Record<string, string> | string\n    step?: number\n  } & Admin\n  type: 'point'\n  validate?: PointFieldValidation\n} & Omit<FieldBase, 'validate'>\n\nexport type PointFieldClient = {\n  admin?: {\n    components?: {\n      afterInput?: MappedComponent[]\n      beforeInput?: MappedComponent[]\n      Error?: MappedComponent\n      Label?: MappedComponent\n    } & AdminClient['components']\n  } & AdminClient &\n    Pick<PointField['admin'], 'placeholder' | 'step'>\n} & FieldBaseClient &\n  Pick<PointField, 'type'>\n\n/**\n * A virtual field that loads in related collections by querying a relationship or upload field.\n */\nexport type JoinField = {\n  access?: {\n    create?: never\n    read?: FieldAccess\n    update?: never\n  }\n  admin?: {\n    components?: {\n      Error?: CustomComponent<JoinFieldErrorClientComponent | JoinFieldErrorServerComponent>\n      Label?: CustomComponent<JoinFieldLabelClientComponent | JoinFieldLabelServerComponent>\n    } & Admin['components']\n    disableBulkEdit?: never\n    readOnly?: never\n  } & Admin\n  /**\n   * The slug of the collection to relate with.\n   */\n  collection: CollectionSlug\n  defaultValue?: never\n  /**\n   * This does not need to be set and will be overridden by the relationship field's hasMany property.\n   */\n  hasMany?: boolean\n  hidden?: false\n  index?: never\n  /**\n   * This does not need to be set and will be overridden by the relationship field's localized property.\n   */\n  localized?: boolean\n  maxDepth?: number\n  /**\n   * A string for the field in the collection being joined to.\n   */\n  on: string\n  type: 'join'\n  validate?: never\n} & FieldBase\n\nexport type JoinFieldClient = {\n  admin?: {\n    components?: {\n      Label?: MappedComponent\n    } & AdminClient['components']\n  } & AdminClient &\n    Pick<JoinField['admin'], 'disableBulkEdit' | 'readOnly'>\n} & FieldBaseClient &\n  Pick<JoinField, 'collection' | 'index' | 'maxDepth' | 'on' | 'type'>\n\nexport type Field =\n  | ArrayField\n  | BlocksField\n  | CheckboxField\n  | CodeField\n  | CollapsibleField\n  | DateField\n  | EmailField\n  | GroupField\n  | JoinField\n  | JSONField\n  | NumberField\n  | PointField\n  | RadioField\n  | RelationshipField\n  | RichTextField\n  | RowField\n  | SelectField\n  | TabsField\n  | TextareaField\n  | TextField\n  | UIField\n  | UploadField\n\nexport type ClientField =\n  | ArrayFieldClient\n  | BlocksFieldClient\n  | CheckboxFieldClient\n  | CodeFieldClient\n  | CollapsibleFieldClient\n  | DateFieldClient\n  | EmailFieldClient\n  | GroupFieldClient\n  | JoinFieldClient\n  | JSONFieldClient\n  | NumberFieldClient\n  | PointFieldClient\n  | RadioFieldClient\n  | RelationshipFieldClient\n  | RichTextFieldClient\n  | RowFieldClient\n  | SelectFieldClient\n  | TabsFieldClient\n  | TextareaFieldClient\n  | TextFieldClient\n  | UIFieldClient\n  | UploadFieldClient\n\nexport type ClientFieldProps =\n  | ArrayFieldClientProps\n  | BlocksFieldClientProps\n  | CheckboxFieldClientProps\n  | CodeFieldClientProps\n  | CollapsibleFieldClientProps\n  | DateFieldClientProps\n  | EmailFieldClientProps\n  | GroupFieldClientProps\n  | HiddenFieldProps\n  | JSONFieldClientProps\n  | NumberFieldClientProps\n  | PointFieldClientProps\n  | RadioFieldClientProps\n  | RelationshipFieldClientProps\n  | RichTextFieldClientProps\n  | RowFieldClientProps\n  | SelectFieldClientProps\n  | TabsFieldClientProps\n  | TextareaFieldClientProps\n  | UploadFieldClientProps\n\ntype ExtractFieldTypes<T> = T extends { type: infer U } ? U : never\n\nexport type FieldTypes = ExtractFieldTypes<Field>\n\nexport type FieldAffectingData =\n  | ArrayField\n  | BlocksField\n  | CheckboxField\n  | CodeField\n  | DateField\n  | EmailField\n  | GroupField\n  | JoinField\n  | JSONField\n  | NumberField\n  | PointField\n  | RadioField\n  | RelationshipField\n  | RichTextField\n  | SelectField\n  | TabAsField\n  | TextareaField\n  | TextField\n  | UploadField\n\nexport type FieldAffectingDataClient =\n  | ArrayFieldClient\n  | BlocksFieldClient\n  | CheckboxFieldClient\n  | CodeFieldClient\n  | DateFieldClient\n  | EmailFieldClient\n  | GroupFieldClient\n  | JoinFieldClient\n  | JSONFieldClient\n  | NumberFieldClient\n  | PointFieldClient\n  | RadioFieldClient\n  | RelationshipFieldClient\n  | RichTextFieldClient\n  | SelectFieldClient\n  | TabAsFieldClient\n  | TextareaFieldClient\n  | TextFieldClient\n  | UploadFieldClient\n\nexport type NonPresentationalField =\n  | ArrayField\n  | BlocksField\n  | CheckboxField\n  | CodeField\n  | CollapsibleField\n  | DateField\n  | EmailField\n  | GroupField\n  | JSONField\n  | NumberField\n  | PointField\n  | RadioField\n  | RelationshipField\n  | RichTextField\n  | RowField\n  | SelectField\n  | TabsField\n  | TextareaField\n  | TextField\n  | UploadField\n\nexport type NonPresentationalFieldClient =\n  | ArrayFieldClient\n  | BlocksFieldClient\n  | CheckboxFieldClient\n  | CodeFieldClient\n  | CollapsibleFieldClient\n  | DateFieldClient\n  | EmailFieldClient\n  | GroupFieldClient\n  | JSONFieldClient\n  | NumberFieldClient\n  | PointFieldClient\n  | RadioFieldClient\n  | RelationshipFieldClient\n  | RichTextFieldClient\n  | RowFieldClient\n  | SelectFieldClient\n  | TabsFieldClient\n  | TextareaFieldClient\n  | TextFieldClient\n  | UploadFieldClient\n\nexport type FieldWithPath = {\n  path?: string\n} & Field\n\nexport type FieldWithPathClient = {\n  path?: string\n} & ClientField\n\nexport type FieldWithSubFields = ArrayField | CollapsibleField | GroupField | RowField\n\nexport type FieldWithSubFieldsClient =\n  | ArrayFieldClient\n  | CollapsibleFieldClient\n  | GroupFieldClient\n  | RowFieldClient\n\nexport type FieldPresentationalOnly = UIField\nexport type FieldPresentationalOnlyClient = UIFieldClient\n\nexport type FieldWithMany = RelationshipField | SelectField\nexport type FieldWithManyClient = RelationshipFieldClient | SelectFieldClient\n\nexport type FieldWithMaxDepth = RelationshipField | UploadField\nexport type FieldWithMaxDepthClient = JoinFieldClient | RelationshipFieldClient | UploadFieldClient\n\nexport function fieldHasSubFields<TField extends ClientField | Field>(\n  field: TField,\n): field is TField & (TField extends ClientField ? FieldWithSubFieldsClient : FieldWithSubFields) {\n  return (\n    field.type === 'group' ||\n    field.type === 'array' ||\n    field.type === 'row' ||\n    field.type === 'collapsible'\n  )\n}\n\nexport function fieldIsArrayType<TField extends ClientField | Field>(\n  field: TField,\n): field is TField & (TField extends ClientField ? ArrayFieldClient : ArrayField) {\n  return field.type === 'array'\n}\n\nexport function fieldIsBlockType<TField extends ClientField | Field>(\n  field: TField,\n): field is TField & (TField extends ClientField ? BlocksFieldClient : BlocksField) {\n  return field.type === 'blocks'\n}\n\nexport function fieldIsGroupType<TField extends ClientField | Field>(\n  field: TField,\n): field is TField & (TField extends ClientField ? GroupFieldClient : GroupField) {\n  return field.type === 'group'\n}\n\nexport function optionIsObject(option: Option): option is OptionObject {\n  return typeof option === 'object'\n}\n\nexport function optionsAreObjects(options: Option[]): options is OptionObject[] {\n  return Array.isArray(options) && typeof options?.[0] === 'object'\n}\n\nexport function optionIsValue(option: Option): option is string {\n  return typeof option === 'string'\n}\n\nexport function fieldSupportsMany<TField extends ClientField | Field>(\n  field: TField,\n): field is TField & (TField extends ClientField ? FieldWithManyClient : FieldWithMany) {\n  return field.type === 'select' || field.type === 'relationship' || field.type === 'upload'\n}\n\nexport function fieldHasMaxDepth<TField extends ClientField | Field>(\n  field: TField,\n): field is TField & (TField extends ClientField ? FieldWithMaxDepthClient : FieldWithMaxDepth) {\n  return (\n    (field.type === 'upload' || field.type === 'relationship' || field.type === 'join') &&\n    typeof field.maxDepth === 'number'\n  )\n}\n\nexport function fieldIsPresentationalOnly<\n  TField extends ClientField | Field | TabAsField | TabAsFieldClient,\n>(\n  field: TField,\n): field is TField & (TField extends ClientField | TabAsFieldClient ? UIFieldClient : UIField) {\n  return field.type === 'ui'\n}\n\nexport function fieldIsSidebar<TField extends ClientField | Field | TabAsField | TabAsFieldClient>(\n  field: TField,\n): field is { admin: { position: 'sidebar' } } & TField {\n  return 'admin' in field && 'position' in field.admin && field.admin.position === 'sidebar'\n}\n\nexport function fieldAffectsData<\n  TField extends ClientField | Field | TabAsField | TabAsFieldClient,\n>(\n  field: TField,\n): field is TField &\n  (TField extends ClientField | TabAsFieldClient ? FieldAffectingDataClient : FieldAffectingData) {\n  return 'name' in field && !fieldIsPresentationalOnly(field)\n}\n\nexport function tabHasName<TField extends ClientTab | Tab>(tab: TField): tab is NamedTab & TField {\n  return 'name' in tab\n}\n\nexport function fieldIsLocalized(field: Field | Tab): boolean {\n  return 'localized' in field && field.localized\n}\n\nexport function fieldIsVirtual(field: Field | Tab): boolean {\n  return 'virtual' in field && field.virtual\n}\n\nexport type HookName =\n  | 'afterChange'\n  | 'afterRead'\n  | 'beforeChange'\n  | 'beforeRead'\n  | 'beforeValidate'\n"],"names":["valueIsValueWithRelation","value","fieldHasSubFields","field","type","fieldIsArrayType","fieldIsBlockType","fieldIsGroupType","optionIsObject","option","optionsAreObjects","options","Array","isArray","optionIsValue","fieldSupportsMany","fieldHasMaxDepth","maxDepth","fieldIsPresentationalOnly","fieldIsSidebar","admin","position","fieldAffectsData","tabHasName","tab","fieldIsLocalized","localized","fieldIsVirtual","virtual"],"mappings":"AAAA,qDAAqD,GAqqCrD;;;;;;;;;;;;;;;;;;AAAO,SAASA,yBAAyBC,KAAc;IACrD,OAAOA,UAAU,QAAQ,OAAOA,UAAU,YAAY,gBAAgBA,SAAS,WAAWA;AAC5F;AA8dO,SAASC,kBACdC,KAAa;IAEb,OACEA,MAAMC,IAAI,KAAK,WACfD,MAAMC,IAAI,KAAK,WACfD,MAAMC,IAAI,KAAK,SACfD,MAAMC,IAAI,KAAK;AAEnB;AAEO,SAASC,iBACdF,KAAa;IAEb,OAAOA,MAAMC,IAAI,KAAK;AACxB;AAEO,SAASE,iBACdH,KAAa;IAEb,OAAOA,MAAMC,IAAI,KAAK;AACxB;AAEO,SAASG,iBACdJ,KAAa;IAEb,OAAOA,MAAMC,IAAI,KAAK;AACxB;AAEO,SAASI,eAAeC,MAAc;IAC3C,OAAO,OAAOA,WAAW;AAC3B;AAEO,SAASC,kBAAkBC,OAAiB;IACjD,OAAOC,MAAMC,OAAO,CAACF,YAAY,OAAOA,SAAS,CAAC,EAAE,KAAK;AAC3D;AAEO,SAASG,cAAcL,MAAc;IAC1C,OAAO,OAAOA,WAAW;AAC3B;AAEO,SAASM,kBACdZ,KAAa;IAEb,OAAOA,MAAMC,IAAI,KAAK,YAAYD,MAAMC,IAAI,KAAK,kBAAkBD,MAAMC,IAAI,KAAK;AACpF;AAEO,SAASY,iBACdb,KAAa;IAEb,OACGA,CAAAA,MAAMC,IAAI,KAAK,YAAYD,MAAMC,IAAI,KAAK,kBAAkBD,MAAMC,IAAI,KAAK,MAAK,KACjF,OAAOD,MAAMc,QAAQ,KAAK;AAE9B;AAEO,SAASC,0BAGdf,KAAa;IAEb,OAAOA,MAAMC,IAAI,KAAK;AACxB;AAEO,SAASe,eACdhB,KAAa;IAEb,OAAO,WAAWA,SAAS,cAAcA,MAAMiB,KAAK,IAAIjB,MAAMiB,KAAK,CAACC,QAAQ,KAAK;AACnF;AAEO,SAASC,iBAGdnB,KAAa;IAGb,OAAO,UAAUA,SAAS,CAACe,0BAA0Bf;AACvD;AAEO,SAASoB,WAA2CC,GAAW;IACpE,OAAO,UAAUA;AACnB;AAEO,SAASC,iBAAiBtB,KAAkB;IACjD,OAAO,eAAeA,SAASA,MAAMuB,SAAS;AAChD;AAEO,SAASC,eAAexB,KAAkB;IAC/C,OAAO,aAAaA,SAASA,MAAMyB,OAAO;AAC5C"}},
    {"offset": {"line": 553, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 559, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/payload/src/auth/types.ts"],"sourcesContent":["import type { DeepRequired } from 'ts-essentials'\n\nimport type { Payload } from '../index.js'\nimport type { PayloadRequest, Where } from '../types/index.js'\n\nexport type Permission = {\n  permission: boolean\n  where?: Record<string, unknown>\n}\n\nexport type FieldPermissions = {\n  blocks?: {\n    [blockSlug: string]: {\n      fields: {\n        [fieldName: string]: FieldPermissions\n      }\n    }\n  }\n  create: {\n    permission: boolean\n  }\n  fields?: {\n    [fieldName: string]: FieldPermissions\n  }\n  read: {\n    permission: boolean\n  }\n  update: {\n    permission: boolean\n  }\n}\n\nexport type CollectionPermission = {\n  create: Permission\n  delete: Permission\n  fields: {\n    [fieldName: string]: FieldPermissions\n  }\n  read: Permission\n  readVersions?: Permission\n  update: Permission\n}\n\nexport type GlobalPermission = {\n  fields: {\n    [fieldName: string]: FieldPermissions\n  }\n  read: Permission\n  readVersions?: Permission\n  update: Permission\n}\n\nexport type DocumentPermissions = CollectionPermission | GlobalPermission\nexport type Permissions = {\n  canAccessAdmin: boolean\n  collections: {\n    [collectionSlug: string]: CollectionPermission\n  }\n  globals?: {\n    [globalSlug: string]: GlobalPermission\n  }\n}\n\ntype BaseUser = {\n  collection: string\n  email?: string\n  id: number | string\n  username?: string\n}\n\nexport type User = {\n  [key: string]: any\n} & BaseUser\n\n/**\n * `collection` is not available one the client. It's only available on the server (req.user)\n * On the client, you can access the collection via config.admin.user. Config can be accessed using the useConfig() hook\n */\nexport type ClientUser = {\n  [key: string]: any\n} & BaseUser\n\ntype GenerateVerifyEmailHTML<TUser = any> = (args: {\n  req: PayloadRequest\n  token: string\n  user: TUser\n}) => Promise<string> | string\n\ntype GenerateVerifyEmailSubject<TUser = any> = (args: {\n  req: PayloadRequest\n  token: string\n  user: TUser\n}) => Promise<string> | string\n\ntype GenerateForgotPasswordEmailHTML<TUser = any> = (args?: {\n  req?: PayloadRequest\n  token?: string\n  user?: TUser\n}) => Promise<string> | string\n\ntype GenerateForgotPasswordEmailSubject<TUser = any> = (args?: {\n  req?: PayloadRequest\n  token?: string\n  user?: TUser\n}) => Promise<string> | string\n\nexport type AuthStrategyFunctionArgs = {\n  headers: Request['headers']\n  isGraphQL?: boolean\n  payload: Payload\n}\n\nexport type AuthStrategyResult = {\n  responseHeaders?: Headers\n  user: null | User\n}\n\nexport type AuthStrategyFunction = (\n  args: AuthStrategyFunctionArgs,\n) => AuthStrategyResult | Promise<AuthStrategyResult>\nexport type AuthStrategy = {\n  authenticate: AuthStrategyFunction\n  name: string\n}\n\nexport type LoginWithUsernameOptions =\n  | {\n      allowEmailLogin?: false\n      requireEmail?: boolean\n      // If `allowEmailLogin` is false, `requireUsername` must be true (default: true)\n      requireUsername?: true\n    }\n  | {\n      allowEmailLogin?: true\n      requireEmail?: boolean\n      requireUsername?: boolean\n    }\n\nexport interface IncomingAuthType {\n  /**\n   * Set cookie options, including secure, sameSite, and domain. For advanced users.\n   */\n  cookies?: {\n    domain?: string\n    sameSite?: 'Lax' | 'None' | 'Strict' | boolean\n    secure?: boolean\n  }\n  /**\n   * How many levels deep a user document should be populated when creating the JWT and binding the user to the req. Defaults to 0 and should only be modified if absolutely necessary, as this will affect performance.\n   * @default 0\n   */\n  depth?: number\n  /**\n   * Advanced - disable Payload's built-in local auth strategy. Only use this property if you have replaced Payload's auth mechanisms with your own.\n   */\n  disableLocalStrategy?: true\n  /**\n   * Customize the way that the forgotPassword operation functions.\n   * @link https://payloadcms.com/docs/beta/authentication/email#forgot-password\n   */\n  forgotPassword?: {\n    generateEmailHTML?: GenerateForgotPasswordEmailHTML\n    generateEmailSubject?: GenerateForgotPasswordEmailSubject\n  }\n  /**\n   * Set the time (in milliseconds) that a user should be locked out if they fail authentication more times than maxLoginAttempts allows for.\n   */\n  lockTime?: number\n  /**\n   * Ability to allow users to login with username/password.\n   *\n   * @link https://payloadcms.com/docs/beta/authentication/overview#login-with-username\n   */\n  loginWithUsername?: boolean | LoginWithUsernameOptions\n  /**\n   * Only allow a user to attempt logging in X amount of times. Automatically locks out a user from authenticating if this limit is passed. Set to 0 to disable.\n   */\n  maxLoginAttempts?: number\n  /***\n   * Set to true if you want to remove the token from the returned authentication API responses such as login or refresh.\n   */\n  removeTokenFromResponses?: true\n  /**\n   * Advanced - an array of custom authentification strategies to extend this collection's authentication with.\n   * @link https://payloadcms.com/docs/beta/authentication/custom-strategies\n   */\n  strategies?: AuthStrategy[]\n  /**\n   * Controls how many seconds the token will be valid for. Default is 2 hours.\n   * @default 7200\n   * @link https://payloadcms.com/docs/beta/authentication/overview#config-options\n   */\n  tokenExpiration?: number\n  /**\n   * Payload Authentication provides for API keys to be set on each user within an Authentication-enabled Collection.\n   * @default false\n   * @link https://payloadcms.com/docs/beta/authentication/api-keys\n   */\n  useAPIKey?: boolean\n  /**\n   * Set to true or pass an object with verification options to require users to verify by email before they are allowed to log into your app.\n   * @link https://payloadcms.com/docs/beta/authentication/email#email-verification\n   */\n  verify?:\n    | {\n        generateEmailHTML?: GenerateVerifyEmailHTML\n        generateEmailSubject?: GenerateVerifyEmailSubject\n      }\n    | boolean\n}\n\nexport type VerifyConfig = {\n  generateEmailHTML?: GenerateVerifyEmailHTML\n  generateEmailSubject?: GenerateVerifyEmailSubject\n}\n\nexport interface Auth\n  extends Omit<DeepRequired<IncomingAuthType>, 'forgotPassword' | 'loginWithUsername' | 'verify'> {\n  forgotPassword?: {\n    generateEmailHTML?: GenerateForgotPasswordEmailHTML\n    generateEmailSubject?: GenerateForgotPasswordEmailSubject\n  }\n  loginWithUsername: false | LoginWithUsernameOptions\n  verify?: boolean | VerifyConfig\n}\n\nexport function hasWhereAccessResult(result: boolean | Where): result is Where {\n  return result && typeof result === 'object'\n}\n"],"names":["hasWhereAccessResult","result"],"mappings":";;;AAkOO,SAASA,qBAAqBC,MAAuB;IAC1D,OAAOA,UAAU,OAAOA,WAAW;AACrC"}},
    {"offset": {"line": 565, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 571, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/payload/src/database/combineQueries.ts"],"sourcesContent":["import type { Where } from '../types/index.js'\n\nimport { hasWhereAccessResult } from '../auth/index.js'\n\nexport const combineQueries = (where: Where, access: boolean | Where): Where => {\n  if (!where && !access) {\n    return {}\n  }\n\n  const result: Where = {\n    and: [],\n  }\n\n  if (where) {\n    result.and.push(where)\n  }\n  if (hasWhereAccessResult(access)) {\n    result.and.push(access)\n  }\n\n  return result\n}\n"],"names":["hasWhereAccessResult","combineQueries","where","access","result","and","push"],"mappings":";;;AAEA,SAASA,oBAAoB,QAAQ,mBAAkB;;AAEhD,MAAMC,iBAAiB,CAACC,OAAcC;IAC3C,IAAI,CAACD,SAAS,CAACC,QAAQ;QACrB,OAAO,CAAC;IACV;IAEA,MAAMC,SAAgB;QACpBC,KAAK,EAAE;IACT;IAEA,IAAIH,OAAO;QACTE,OAAOC,GAAG,CAACC,IAAI,CAACJ;IAClB;IACA,yJAAIF,uBAAAA,EAAqBG,SAAS;QAChCC,OAAOC,GAAG,CAACC,IAAI,CAACH;IAClB;IAEA,OAAOC;AACT,EAAC"}},
    {"offset": {"line": 591, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 597, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/payload/src/utilities/getEntityPolicies.ts"],"sourcesContent":["import type { CollectionPermission, GlobalPermission } from '../auth/types.js'\nimport type { SanitizedCollectionConfig, TypeWithID } from '../collections/config/types.js'\nimport type { Access } from '../config/types.js'\nimport type { Field, FieldAccess } from '../fields/config/types.js'\nimport type { SanitizedGlobalConfig } from '../globals/config/types.js'\nimport type { AllOperations, Document, PayloadRequest, Where } from '../types/index.js'\n\nimport { combineQueries } from '../database/combineQueries.js'\nimport { tabHasName } from '../fields/config/types.js'\n\ntype Args = {\n  entity: SanitizedCollectionConfig | SanitizedGlobalConfig\n  id?: number | string\n  operations: AllOperations[]\n  req: PayloadRequest\n  type: 'collection' | 'global'\n}\n\ntype ReturnType<T extends Args> = T['type'] extends 'global'\n  ? GlobalPermission\n  : CollectionPermission\n\ntype CreateAccessPromise = (args: {\n  access: Access | FieldAccess\n  accessLevel: 'entity' | 'field'\n  disableWhere?: boolean\n  operation: AllOperations\n  policiesObj: {\n    [key: string]: any\n  }\n}) => Promise<void>\n\nexport async function getEntityPolicies<T extends Args>(args: T): Promise<ReturnType<T>> {\n  const { id, type, entity, operations, req } = args\n  const { data, locale, payload, user } = req\n  const isLoggedIn = !!user\n\n  const policies = {\n    fields: {},\n  } as ReturnType<T>\n\n  let docBeingAccessed\n\n  async function getEntityDoc({ where }: { where?: Where } = {}): Promise<Document & TypeWithID> {\n    if (entity.slug) {\n      if (type === 'global') {\n        return payload.findGlobal({\n          slug: entity.slug,\n          fallbackLocale: null,\n          locale,\n          overrideAccess: true,\n          req,\n        })\n      }\n\n      if (type === 'collection' && id) {\n        if (typeof where === 'object') {\n          const paginatedRes = await payload.find({\n            collection: entity.slug,\n            depth: 0,\n            fallbackLocale: null,\n            limit: 1,\n            locale,\n            overrideAccess: true,\n            pagination: false,\n            req,\n            where: combineQueries(where, { id: { equals: id } }),\n          })\n\n          return paginatedRes?.docs?.[0] || undefined\n        }\n\n        return payload.findByID({\n          id,\n          collection: entity.slug,\n          depth: 0,\n          fallbackLocale: null,\n          locale,\n          overrideAccess: true,\n          req,\n        })\n      }\n    }\n\n    return undefined\n  }\n\n  const createAccessPromise: CreateAccessPromise = async ({\n    access,\n    accessLevel,\n    disableWhere = false,\n    operation,\n    policiesObj,\n  }) => {\n    const mutablePolicies = policiesObj\n\n    if (accessLevel === 'field' && docBeingAccessed === undefined) {\n      // assign docBeingAccessed first as the promise to avoid multiple calls to getEntityDoc\n      docBeingAccessed = getEntityDoc().then((doc) => {\n        docBeingAccessed = doc\n      })\n    }\n    // awaiting the promise to ensure docBeingAccessed is assigned before it is used\n    await docBeingAccessed\n\n    // https://payloadcms.slack.com/archives/C048Z9C2BEX/p1702054928343769\n    const accessResult = await access({ id, data, doc: docBeingAccessed, req })\n\n    if (typeof accessResult === 'object' && !disableWhere) {\n      mutablePolicies[operation] = {\n        permission:\n          id || type === 'global' ? !!(await getEntityDoc({ where: accessResult })) : true,\n        where: accessResult,\n      }\n    } else if (mutablePolicies[operation]?.permission !== false) {\n      mutablePolicies[operation] = {\n        permission: !!accessResult,\n      }\n    }\n  }\n\n  const executeFieldPolicies = async ({\n    entityPermission,\n    fields,\n    operation,\n    policiesObj,\n  }: {\n    entityPermission\n    fields: Field[]\n    operation: AllOperations\n    policiesObj\n  }) => {\n    const mutablePolicies = policiesObj.fields\n\n    await Promise.all(\n      fields.map(async (field) => {\n        if ('name' in field && field.name) {\n          if (!mutablePolicies[field.name]) {\n            mutablePolicies[field.name] = {}\n          }\n\n          if ('access' in field && field.access && typeof field.access[operation] === 'function') {\n            await createAccessPromise({\n              access: field.access[operation],\n              accessLevel: 'field',\n              disableWhere: true,\n              operation,\n              policiesObj: mutablePolicies[field.name],\n            })\n          } else {\n            mutablePolicies[field.name][operation] = {\n              permission: policiesObj[operation]?.permission,\n            }\n          }\n\n          if ('fields' in field && field.fields) {\n            if (!mutablePolicies[field.name].fields) {\n              mutablePolicies[field.name].fields = {}\n            }\n\n            await executeFieldPolicies({\n              entityPermission,\n              fields: field.fields,\n              operation,\n              policiesObj: mutablePolicies[field.name],\n            })\n          }\n\n          if ('blocks' in field && field?.blocks) {\n            if (!mutablePolicies[field.name]?.blocks) {\n              mutablePolicies[field.name].blocks = {}\n            }\n\n            await Promise.all(\n              field.blocks.map(async (block) => {\n                if (!mutablePolicies[field.name].blocks?.[block.slug]) {\n                  mutablePolicies[field.name].blocks[block.slug] = {\n                    fields: {},\n                    [operation]: { permission: entityPermission },\n                  }\n                } else if (!mutablePolicies[field.name].blocks[block.slug][operation]) {\n                  mutablePolicies[field.name].blocks[block.slug][operation] = {\n                    permission: entityPermission,\n                  }\n                }\n\n                await executeFieldPolicies({\n                  entityPermission,\n                  fields: block.fields,\n                  operation,\n                  policiesObj: mutablePolicies[field.name].blocks[block.slug],\n                })\n              }),\n            )\n          }\n        } else if ('fields' in field && field.fields) {\n          await executeFieldPolicies({\n            entityPermission,\n            fields: field.fields,\n            operation,\n            policiesObj,\n          })\n        } else if (field.type === 'tabs') {\n          await Promise.all(\n            field.tabs.map(async (tab) => {\n              if (tabHasName(tab)) {\n                if (!mutablePolicies[tab.name]) {\n                  mutablePolicies[tab.name] = {\n                    fields: {},\n                    [operation]: { permission: entityPermission },\n                  }\n                } else if (!mutablePolicies[tab.name][operation]) {\n                  mutablePolicies[tab.name][operation] = { permission: entityPermission }\n                }\n                await executeFieldPolicies({\n                  entityPermission,\n                  fields: tab.fields,\n                  operation,\n                  policiesObj: mutablePolicies[tab.name],\n                })\n              } else {\n                await executeFieldPolicies({\n                  entityPermission,\n                  fields: tab.fields,\n                  operation,\n                  policiesObj,\n                })\n              }\n            }),\n          )\n        }\n      }),\n    )\n  }\n\n  await operations.reduce(async (priorOperation, operation) => {\n    await priorOperation\n\n    let entityAccessPromise: Promise<void>\n\n    if (typeof entity.access[operation] === 'function') {\n      entityAccessPromise = createAccessPromise({\n        access: entity.access[operation],\n        accessLevel: 'entity',\n        operation,\n        policiesObj: policies,\n      })\n    } else {\n      policies[operation] = {\n        permission: isLoggedIn,\n      }\n    }\n\n    await entityAccessPromise\n\n    await executeFieldPolicies({\n      entityPermission: policies[operation].permission,\n      fields: entity.fields,\n      operation,\n      policiesObj: policies,\n    })\n  }, Promise.resolve())\n\n  return policies\n}\n"],"names":["combineQueries","tabHasName","getEntityPolicies","args","id","type","entity","operations","req","data","locale","payload","user","isLoggedIn","policies","fields","docBeingAccessed","getEntityDoc","where","slug","findGlobal","fallbackLocale","overrideAccess","paginatedRes","find","collection","depth","limit","pagination","equals","docs","undefined","findByID","createAccessPromise","access","accessLevel","disableWhere","operation","policiesObj","mutablePolicies","then","doc","accessResult","permission","executeFieldPolicies","entityPermission","Promise","all","map","field","name","blocks","block","tabs","tab","reduce","priorOperation","entityAccessPromise","resolve"],"mappings":"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"}},
    {"offset": {"line": 806, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 812, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/payload/src/auth/getAccessResults.ts"],"sourcesContent":["import type { AllOperations, PayloadRequest } from '../types/index.js'\nimport type { Permissions } from './types.js'\n\nimport { getEntityPolicies } from '../utilities/getEntityPolicies.js'\n\ntype GetAccessResultsArgs = {\n  req: PayloadRequest\n}\nexport async function getAccessResults({ req }: GetAccessResultsArgs): Promise<Permissions> {\n  const results = {} as Permissions\n  const { payload, user } = req\n\n  const isLoggedIn = !!user\n  const userCollectionConfig =\n    user && user.collection\n      ? payload.config.collections.find((collection) => collection.slug === user.collection)\n      : null\n\n  if (userCollectionConfig && payload.config.admin.user === user.collection) {\n    results.canAccessAdmin = userCollectionConfig.access.admin\n      ? await userCollectionConfig.access.admin({ req })\n      : isLoggedIn\n  } else {\n    results.canAccessAdmin = false\n  }\n\n  await Promise.all(\n    payload.config.collections.map(async (collection) => {\n      const collectionOperations: AllOperations[] = ['create', 'read', 'update', 'delete']\n\n      if (\n        collection.auth &&\n        typeof collection.auth.maxLoginAttempts !== 'undefined' &&\n        collection.auth.maxLoginAttempts !== 0\n      ) {\n        collectionOperations.push('unlock')\n      }\n\n      if (collection.versions) {\n        collectionOperations.push('readVersions')\n      }\n\n      const collectionPolicy = await getEntityPolicies({\n        type: 'collection',\n        entity: collection,\n        operations: collectionOperations,\n        req,\n      })\n      results.collections = {\n        ...results.collections,\n        [collection.slug]: collectionPolicy,\n      }\n    }),\n  )\n\n  await Promise.all(\n    payload.config.globals.map(async (global) => {\n      const globalOperations: AllOperations[] = ['read', 'update']\n\n      if (global.versions) {\n        globalOperations.push('readVersions')\n      }\n\n      const globalPolicy = await getEntityPolicies({\n        type: 'global',\n        entity: global,\n        operations: globalOperations,\n        req,\n      })\n      results.globals = {\n        ...results.globals,\n        [global.slug]: globalPolicy,\n      }\n    }),\n  )\n\n  return results\n}\n"],"names":["getEntityPolicies","getAccessResults","req","results","payload","user","isLoggedIn","userCollectionConfig","collection","config","collections","find","slug","admin","canAccessAdmin","access","Promise","all","map","collectionOperations","auth","maxLoginAttempts","push","versions","collectionPolicy","type","entity","operations","globals","global","globalOperations","globalPolicy"],"mappings":";;;AAGA,SAASA,iBAAiB,QAAQ,oCAAmC;;AAK9D,eAAeC,iBAAiB,EAAEC,GAAG,EAAwB;IAClE,MAAMC,UAAU,CAAC;IACjB,MAAM,EAAEC,OAAO,EAAEC,IAAI,EAAE,GAAGH;IAE1B,MAAMI,aAAa,CAAC,CAACD;IACrB,MAAME,uBACJF,QAAQA,KAAKG,UAAU,GACnBJ,QAAQK,MAAM,CAACC,WAAW,CAACC,IAAI,CAAC,CAACH,aAAeA,WAAWI,IAAI,KAAKP,KAAKG,UAAU,IACnF;IAEN,IAAID,wBAAwBH,QAAQK,MAAM,CAACI,KAAK,CAACR,IAAI,KAAKA,KAAKG,UAAU,EAAE;QACzEL,QAAQW,cAAc,GAAGP,qBAAqBQ,MAAM,CAACF,KAAK,GACtD,MAAMN,qBAAqBQ,MAAM,CAACF,KAAK,CAAC;YAAEX;QAAI,KAC9CI;IACN,OAAO;QACLH,QAAQW,cAAc,GAAG;IAC3B;IAEA,MAAME,QAAQC,GAAG,CACfb,QAAQK,MAAM,CAACC,WAAW,CAACQ,GAAG,CAAC,OAAOV;QACpC,MAAMW,uBAAwC;YAAC;YAAU;YAAQ;YAAU;SAAS;QAEpF,IACEX,WAAWY,IAAI,IACf,OAAOZ,WAAWY,IAAI,CAACC,gBAAgB,KAAK,eAC5Cb,WAAWY,IAAI,CAACC,gBAAgB,KAAK,GACrC;YACAF,qBAAqBG,IAAI,CAAC;QAC5B;QAEA,IAAId,WAAWe,QAAQ,EAAE;YACvBJ,qBAAqBG,IAAI,CAAC;QAC5B;QAEA,MAAME,mBAAmB,4KAAMxB,oBAAAA,EAAkB;YAC/CyB,MAAM;YACNC,QAAQlB;YACRmB,YAAYR;YACZjB;QACF;QACAC,QAAQO,WAAW,GAAG;YACpB,GAAGP,QAAQO,WAAW;YACtB,CAACF,WAAWI,IAAI,CAAC,EAAEY;QACrB;IACF;IAGF,MAAMR,QAAQC,GAAG,CACfb,QAAQK,MAAM,CAACmB,OAAO,CAACV,GAAG,CAAC,OAAOW;QAChC,MAAMC,mBAAoC;YAAC;YAAQ;SAAS;QAE5D,IAAID,OAAON,QAAQ,EAAE;YACnBO,iBAAiBR,IAAI,CAAC;QACxB;QAEA,MAAMS,eAAe,4KAAM/B,oBAAAA,EAAkB;YAC3CyB,MAAM;YACNC,QAAQG;YACRF,YAAYG;YACZ5B;QACF;QACAC,QAAQyB,OAAO,GAAG;YAChB,GAAGzB,QAAQyB,OAAO;YAClB,CAACC,OAAOjB,IAAI,CAAC,EAAEmB;QACjB;IACF;IAGF,OAAO5B;AACT"}},
    {"offset": {"line": 874, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 880, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/payload/src/utilities/killTransaction.ts"],"sourcesContent":["import type { PayloadRequest } from '../types/index.js'\n\n/**\n * Rollback the transaction from the req using the db adapter and removes it from the req\n */\nexport async function killTransaction(req: PayloadRequest): Promise<void> {\n  const { payload, transactionID } = req\n  if (transactionID && !(transactionID instanceof Promise)) {\n    try {\n      await payload.db.rollbackTransaction(req.transactionID)\n    } catch (error) {\n      // swallow any errors while attempting to rollback\n    }\n    delete req.transactionID\n  }\n}\n"],"names":["killTransaction","req","payload","transactionID","Promise","db","rollbackTransaction","error"],"mappings":"AAEA;;CAEC,GACD;;;AAAO,eAAeA,gBAAgBC,GAAmB;IACvD,MAAM,EAAEC,OAAO,EAAEC,aAAa,EAAE,GAAGF;IACnC,IAAIE,iBAAiB,CAAEA,CAAAA,yBAAyBC,OAAM,GAAI;QACxD,IAAI;YACF,MAAMF,QAAQG,EAAE,CAACC,mBAAmB,CAACL,IAAIE,aAAa;QACxD,EAAE,OAAOI,OAAO;QACd,kDAAkD;QACpD;QACA,OAAON,IAAIE,aAAa;IAC1B;AACF"}},
    {"offset": {"line": 896, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 902, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/payload/src/auth/operations/auth.ts"],"sourcesContent":["import type { TypedUser } from '../../index.js'\nimport type { PayloadRequest } from '../../types/index.js'\nimport type { Permissions } from '../types.js'\n\nimport { killTransaction } from '../../utilities/killTransaction.js'\nimport { executeAuthStrategies } from '../executeAuthStrategies.js'\nimport { getAccessResults } from '../getAccessResults.js'\n\nexport type AuthArgs = {\n  headers: Request['headers']\n  req?: Omit<PayloadRequest, 'user'>\n}\n\nexport type AuthResult = {\n  permissions: Permissions\n  responseHeaders?: Headers\n  user: null | TypedUser\n}\n\nexport const auth = async (args: Required<AuthArgs>): Promise<AuthResult> => {\n  const { headers } = args\n  const req = args.req as PayloadRequest\n  const { payload } = req\n\n  try {\n    const { responseHeaders, user } = await executeAuthStrategies({\n      headers,\n      payload,\n    })\n\n    req.user = user\n    req.responseHeaders = responseHeaders\n\n    const permissions = await getAccessResults({\n      req,\n    })\n\n    return {\n      permissions,\n      responseHeaders,\n      user,\n    }\n  } catch (error: unknown) {\n    await killTransaction(req)\n    throw error\n  }\n}\n"],"names":["killTransaction","executeAuthStrategies","getAccessResults","auth","args","headers","req","payload","responseHeaders","user","permissions","error"],"mappings":";;;AAKA,SAASC,qBAAqB,QAAQ,8BAA6B;AACnE,SAASC,gBAAgB,QAAQ,yBAAwB;AAFzD,SAASF,eAAe,QAAQ,qCAAoC;;;;AAe7D,MAAMG,OAAO,OAAOC;IACzB,MAAM,EAAEC,OAAO,EAAE,GAAGD;IACpB,MAAME,MAAMF,KAAKE,GAAG;IACpB,MAAM,EAAEC,OAAO,EAAE,GAAGD;IAEpB,IAAI;QACF,MAAM,EAAEE,eAAe,EAAEC,IAAI,EAAE,GAAG,2KAAMR,wBAAAA,EAAsB;YAC5DI;YACAE;QACF;QAEAD,IAAIG,IAAI,GAAGA;QACXH,IAAIE,eAAe,GAAGA;QAEtB,MAAME,cAAc,sKAAMR,mBAAAA,EAAiB;YACzCI;QACF;QAEA,OAAO;YACLI;YACAF;YACAC;QACF;IACF,EAAE,OAAOE,OAAgB;QACvB,0KAAMX,kBAAAA,EAAgBM;QACtB,MAAMK;IACR;AACF,EAAC"}},
    {"offset": {"line": 935, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 941, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/payload/src/translations/getLocalI18n.ts"],"sourcesContent":["import type { AcceptedLanguages } from '@payloadcms/translations'\n\nimport { initI18n } from '@payloadcms/translations'\n\nimport type { SanitizedConfig } from '../config/types.js'\n\nexport const getLocalI18n = async ({\n  config,\n  language,\n}: {\n  config: SanitizedConfig\n  language: AcceptedLanguages\n}) =>\n  initI18n({\n    config: config.i18n,\n    context: 'api',\n    language,\n  })\n"],"names":["initI18n","getLocalI18n","config","language","i18n","context"],"mappings":";;;;AAEA,SAASA,QAAQ,QAAQ,2BAA0B;;AAI5C,MAAMC,eAAe,OAAO,EACjCC,MAAM,EACNC,QAAQ,EAIT,iLACCH,WAAAA,EAAS;QACPE,QAAQA,OAAOE,IAAI;QACnBC,SAAS;QACTF;IACF,GAAE"}},
    {"offset": {"line": 952, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 958, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/payload/src/utilities/isValidID.ts"],"sourcesContent":["import ObjectIdImport from 'bson-objectid'\n\nconst ObjectId = (ObjectIdImport.default ||\n  ObjectIdImport) as unknown as typeof ObjectIdImport.default\n\nexport const isValidID = (\n  value: number | string,\n  type: 'number' | 'ObjectID' | 'text',\n): boolean => {\n  if (type === 'text' && value) {\n    if (['object', 'string'].includes(typeof value)) {\n      const isObjectID = ObjectId.isValid(value as string)\n      return typeof value === 'string' || isObjectID\n    }\n    return false\n  }\n\n  if (typeof value === 'number' && !Number.isNaN(value)) {\n    return true\n  }\n\n  if (type === 'ObjectID') {\n    return ObjectId.isValid(String(value))\n  }\n}\n"],"names":["ObjectIdImport","ObjectId","default","isValidID","value","type","includes","isObjectID","isValid","Number","isNaN","String"],"mappings":";;;AAAA,OAAOA,oBAAoB,gBAAe;;AAE1C,MAAMC,wJAAYD,UAAAA,CAAeE,OAAO,iJACtCF,UAAAA;AAEK,MAAMG,YAAY,CACvBC,OACAC;IAEA,IAAIA,SAAS,UAAUD,OAAO;QAC5B,IAAI;YAAC;YAAU;SAAS,CAACE,QAAQ,CAAC,OAAOF,QAAQ;YAC/C,MAAMG,aAAaN,SAASO,OAAO,CAACJ;YACpC,OAAO,OAAOA,UAAU,YAAYG;QACtC;QACA,OAAO;IACT;IAEA,IAAI,OAAOH,UAAU,YAAY,CAACK,OAAOC,KAAK,CAACN,QAAQ;QACrD,OAAO;IACT;IAEA,IAAIC,SAAS,YAAY;QACvB,OAAOJ,SAASO,OAAO,CAACG,OAAOP;IACjC;AACF,EAAC"}},
    {"offset": {"line": 982, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 988, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/payload/src/collections/dataloader.ts"],"sourcesContent":["import type { BatchLoadFn } from 'dataloader'\n\nimport DataLoader from 'dataloader'\n\nimport type { PayloadRequest } from '../types/index.js'\nimport type { TypeWithID } from './config/types.js'\n\nimport { isValidID } from '../utilities/isValidID.js'\n\n// Payload uses `dataloader` to solve the classic GraphQL N+1 problem.\n\n// We keep a list of all documents requested to be populated for any given request\n// and then batch together documents within the same collection,\n// making only 1 find per each collection, rather than `findByID` per each requested doc.\n\n// This dramatically improves performance for REST and Local API `depth` populations,\n// and also ensures complex GraphQL queries perform lightning-fast.\n\nconst batchAndLoadDocs =\n  (req: PayloadRequest): BatchLoadFn<string, TypeWithID> =>\n  async (keys: string[]): Promise<TypeWithID[]> => {\n    const { payload } = req\n\n    // Create docs array of same length as keys, using null as value\n    // We will replace nulls with injected docs as they are retrieved\n    const docs: (null | TypeWithID)[] = keys.map(() => null)\n\n    /**\n    * Batch IDs by their `find` args\n    * so we can make one find query per combination of collection, depth, locale, and fallbackLocale.\n    *\n    * Resulting shape will be as follows:\n      {\n        // key is stringified set of find args\n        '[null,\"pages\",2,0,\"es\",\"en\",false,false]': [\n          // value is array of IDs to find with these args\n          'q34tl23462346234524',\n          '435523540194324280',\n          '2346245j35l3j5234532li',\n        ],\n        // etc\n      };\n    *\n    **/\n\n    const batchByFindArgs = keys.reduce((batches, key) => {\n      const [\n        transactionID,\n        collection,\n        id,\n        depth,\n        currentDepth,\n        locale,\n        fallbackLocale,\n        overrideAccess,\n        showHiddenFields,\n        draft,\n      ] = JSON.parse(key)\n\n      const batchKeyArray = [\n        transactionID,\n        collection,\n        depth,\n        currentDepth,\n        locale,\n        fallbackLocale,\n        overrideAccess,\n        showHiddenFields,\n        draft,\n      ]\n\n      const batchKey = JSON.stringify(batchKeyArray)\n\n      const idType = payload.collections?.[collection].customIDType || payload.db.defaultIDType\n\n      let sanitizedID: number | string = id\n\n      if (idType === 'number') {\n        sanitizedID = parseFloat(id)\n      }\n\n      if (isValidID(sanitizedID, idType)) {\n        return {\n          ...batches,\n          [batchKey]: [...(batches[batchKey] || []), sanitizedID],\n        }\n      }\n      return batches\n    }, {})\n\n    // Run find requests one after another, so as to not hang transactions\n\n    await Object.entries(batchByFindArgs).reduce(async (priorFind, [batchKey, ids]) => {\n      await priorFind\n\n      const [\n        transactionID,\n        collection,\n        depth,\n        currentDepth,\n        locale,\n        fallbackLocale,\n        overrideAccess,\n        showHiddenFields,\n        draft,\n      ] = JSON.parse(batchKey)\n\n      req.transactionID = transactionID\n\n      const result = await payload.find({\n        collection,\n        currentDepth,\n        depth,\n        disableErrors: true,\n        draft,\n        fallbackLocale,\n        locale,\n        overrideAccess: Boolean(overrideAccess),\n        pagination: false,\n        req,\n        showHiddenFields: Boolean(showHiddenFields),\n        where: {\n          id: {\n            in: ids,\n          },\n        },\n      })\n\n      // For each returned doc, find index in original keys\n      // Inject doc within docs array if index exists\n\n      result.docs.forEach((doc) => {\n        const docKey = createDataloaderCacheKey({\n          collectionSlug: collection,\n          currentDepth,\n          depth,\n          docID: doc.id,\n          draft,\n          fallbackLocale,\n          locale,\n          overrideAccess,\n          showHiddenFields,\n          transactionID: req.transactionID,\n        })\n        const docsIndex = keys.findIndex((key) => key === docKey)\n\n        if (docsIndex > -1) {\n          docs[docsIndex] = doc\n        }\n      })\n    }, Promise.resolve())\n\n    // Return docs array,\n    // which has now been injected with all fetched docs\n    // and should match the length of the incoming keys arg\n    return docs\n  }\n\nexport const getDataLoader = (req: PayloadRequest) => new DataLoader(batchAndLoadDocs(req))\n\ntype CreateCacheKeyArgs = {\n  collectionSlug: string\n  currentDepth: number\n  depth: number\n  docID: number | string\n  draft: boolean\n  fallbackLocale: string\n  locale: string\n  overrideAccess: boolean\n  showHiddenFields: boolean\n  transactionID: number | Promise<number | string> | string\n}\nexport const createDataloaderCacheKey = ({\n  collectionSlug,\n  currentDepth,\n  depth,\n  docID,\n  draft,\n  fallbackLocale,\n  locale,\n  overrideAccess,\n  showHiddenFields,\n  transactionID,\n}: CreateCacheKeyArgs): string =>\n  JSON.stringify([\n    transactionID,\n    collectionSlug,\n    docID,\n    depth,\n    currentDepth,\n    locale,\n    fallbackLocale,\n    overrideAccess,\n    showHiddenFields,\n    draft,\n  ])\n"],"names":["DataLoader","isValidID","batchAndLoadDocs","req","keys","payload","docs","map","batchByFindArgs","reduce","batches","key","transactionID","collection","id","depth","currentDepth","locale","fallbackLocale","overrideAccess","showHiddenFields","draft","JSON","parse","batchKeyArray","batchKey","stringify","idType","collections","customIDType","db","defaultIDType","sanitizedID","parseFloat","Object","entries","priorFind","ids","result","find","disableErrors","Boolean","pagination","where","in","forEach","doc","docKey","createDataloaderCacheKey","collectionSlug","docID","docsIndex","findIndex","Promise","resolve","getDataLoader"],"mappings":";;;;AAEA,OAAOA,gBAAgB,aAAY;AAKnC,SAASC,SAAS,QAAQ,4BAA2B;;;AAErD,sEAAsE;AAEtE,kFAAkF;AAClF,gEAAgE;AAChE,yFAAyF;AAEzF,qFAAqF;AACrF,mEAAmE;AAEnE,MAAMC,mBACJ,CAACC,MACD,OAAOC;QACL,MAAM,EAAEC,OAAO,EAAE,GAAGF;QAEpB,gEAAgE;QAChE,iEAAiE;QACjE,MAAMG,OAA8BF,KAAKG,GAAG,CAAC,IAAM;QAEnD;;;;;;;;;;;;;;;;KAgBC,GAED,MAAMC,kBAAkBJ,KAAKK,MAAM,CAAC,CAACC,SAASC;YAC5C,MAAM,CACJC,eACAC,YACAC,IACAC,OACAC,cACAC,QACAC,gBACAC,gBACAC,kBACAC,MACD,GAAGC,KAAKC,KAAK,CAACZ;YAEf,MAAMa,gBAAgB;gBACpBZ;gBACAC;gBACAE;gBACAC;gBACAC;gBACAC;gBACAC;gBACAC;gBACAC;aACD;YAED,MAAMI,WAAWH,KAAKI,SAAS,CAACF;YAEhC,MAAMG,SAAStB,QAAQuB,WAAW,EAAE,CAACf,WAAW,CAACgB,gBAAgBxB,QAAQyB,EAAE,CAACC,aAAa;YAEzF,IAAIC,cAA+BlB;YAEnC,IAAIa,WAAW,UAAU;gBACvBK,cAAcC,WAAWnB;YAC3B;YAEA,kKAAIb,YAAAA,EAAU+B,aAAaL,SAAS;gBAClC,OAAO;oBACL,GAAGjB,OAAO;oBACV,CAACe,SAAS,EAAE;2BAAKf,OAAO,CAACe,SAAS,IAAI,EAAE;wBAAGO;qBAAY;gBACzD;YACF;YACA,OAAOtB;QACT,GAAG,CAAC;QAEJ,sEAAsE;QAEtE,MAAMwB,OAAOC,OAAO,CAAC3B,iBAAiBC,MAAM,CAAC,OAAO2B,WAAW,CAACX,UAAUY,IAAI;YAC5E,MAAMD;YAEN,MAAM,CACJxB,eACAC,YACAE,OACAC,cACAC,QACAC,gBACAC,gBACAC,kBACAC,MACD,GAAGC,KAAKC,KAAK,CAACE;YAEftB,IAAIS,aAAa,GAAGA;YAEpB,MAAM0B,SAAS,MAAMjC,QAAQkC,IAAI,CAAC;gBAChC1B;gBACAG;gBACAD;gBACAyB,eAAe;gBACfnB;gBACAH;gBACAD;gBACAE,gBAAgBsB,QAAQtB;gBACxBuB,YAAY;gBACZvC;gBACAiB,kBAAkBqB,QAAQrB;gBAC1BuB,OAAO;oBACL7B,IAAI;wBACF8B,IAAIP;oBACN;gBACF;YACF;YAEA,qDAAqD;YACrD,+CAA+C;YAE/CC,OAAOhC,IAAI,CAACuC,OAAO,CAAC,CAACC;gBACnB,MAAMC,SAASC,yBAAyB;oBACtCC,gBAAgBpC;oBAChBG;oBACAD;oBACAmC,OAAOJ,IAAIhC,EAAE;oBACbO;oBACAH;oBACAD;oBACAE;oBACAC;oBACAR,eAAeT,IAAIS,aAAa;gBAClC;gBACA,MAAMuC,YAAY/C,KAAKgD,SAAS,CAAC,CAACzC,MAAQA,QAAQoC;gBAElD,IAAII,YAAY,CAAC,GAAG;oBAClB7C,IAAI,CAAC6C,UAAU,GAAGL;gBACpB;YACF;QACF,GAAGO,QAAQC,OAAO;QAElB,qBAAqB;QACrB,oDAAoD;QACpD,uDAAuD;QACvD,OAAOhD;IACT;AAEK,MAAMiD,gBAAgB,CAACpD,MAAwB,wIAAIH,UAAAA,CAAWE,iBAAiBC,MAAK;AAcpF,MAAM6C,2BAA2B,CAAC,EACvCC,cAAc,EACdjC,YAAY,EACZD,KAAK,EACLmC,KAAK,EACL7B,KAAK,EACLH,cAAc,EACdD,MAAM,EACNE,cAAc,EACdC,gBAAgB,EAChBR,aAAa,EACM,GACnBU,KAAKI,SAAS,CAAC;QACbd;QACAqC;QACAC;QACAnC;QACAC;QACAC;QACAC;QACAC;QACAC;QACAC;KACD,EAAC"}},
    {"offset": {"line": 1115, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1121, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/payload/src/utilities/createLocalReq.ts"],"sourcesContent":["import type { User } from '../auth/types.js'\nimport type { Payload, RequestContext } from '../index.js'\nimport type { PayloadRequest } from '../types/index.js'\n\nimport { getDataLoader } from '../collections/dataloader.js'\nimport { getLocalI18n } from '../translations/getLocalI18n.js'\n\nfunction getRequestContext(\n  req: PayloadRequest = { context: null } as PayloadRequest,\n  context: RequestContext = {},\n): RequestContext {\n  if (req.context) {\n    if (Object.keys(req.context).length === 0 && req.context.constructor === Object) {\n      // if req.context is `{}` avoid unnecessary spread\n      return context\n    } else {\n      return { ...req.context, ...context }\n    }\n  } else {\n    return context\n  }\n}\n\nconst attachFakeURLProperties = (req: PayloadRequest) => {\n  /**\n   * *NOTE*\n   * If no URL is provided, the local API was called directly outside\n   * the context of a request. Therefore we create a fake URL object.\n   * `ts-expect-error` is used below for properties that are 'read-only'\n   * since they do not exist yet we can safely ignore the error.\n   */\n  let urlObject\n\n  function getURLObject() {\n    if (urlObject) {\n      return urlObject\n    }\n    const urlToUse = req?.url || req.payload.config?.serverURL || 'http://localhost'\n    try {\n      urlObject = new URL(urlToUse)\n    } catch (error) {\n      urlObject = new URL('http://localhost')\n    }\n\n    return urlObject\n  }\n\n  if (!req.host) {\n    req.host = getURLObject().host\n  }\n  if (!req.protocol) {\n    req.protocol = getURLObject().protocol\n  }\n  if (!req.pathname) {\n    req.pathname = getURLObject().pathname\n  }\n  if (!req.searchParams) {\n    // @ts-expect-error\n    req.searchParams = getURLObject().searchParams\n  }\n  if (!req.origin) {\n    // @ts-expect-error\n    req.origin = getURLObject().origin\n  }\n  if (!req?.url) {\n    // @ts-expect-error\n    req.url = getURLObject().href\n  }\n}\n\ntype CreateLocalReq = (\n  options: {\n    context?: RequestContext\n    fallbackLocale?: string\n    locale?: string\n    req?: PayloadRequest\n    user?: User\n  },\n  payload: Payload,\n) => Promise<PayloadRequest>\nexport const createLocalReq: CreateLocalReq = async (\n  { context, fallbackLocale, locale: localeArg, req = {} as PayloadRequest, user },\n  payload,\n) => {\n  if (payload.config?.localization) {\n    const locale = localeArg === '*' ? 'all' : localeArg\n    const defaultLocale = payload.config.localization.defaultLocale\n    const localeCandidate = locale || req?.locale || req?.query?.locale\n    req.locale =\n      localeCandidate && typeof localeCandidate === 'string' ? localeCandidate : defaultLocale\n    const fallbackLocaleFromConfig = payload.config.localization.locales.find(\n      ({ code }) => req.locale === code,\n    )?.fallbackLocale\n    if (typeof fallbackLocale !== 'undefined') {\n      req.fallbackLocale = fallbackLocale\n    } else if (typeof req?.fallbackLocale === 'undefined') {\n      req.fallbackLocale = fallbackLocaleFromConfig || defaultLocale\n    }\n  }\n\n  const i18n =\n    req?.i18n ||\n    (await getLocalI18n({ config: payload.config, language: payload.config.i18n.fallbackLanguage }))\n\n  if (!req.headers) {\n    // @ts-expect-error\n    req.headers = new Headers()\n  }\n  req.context = getRequestContext(req, context)\n  req.payloadAPI = req?.payloadAPI || 'local'\n  req.payload = payload\n  req.i18n = i18n\n  req.t = i18n.t\n  req.user = user || req?.user || null\n  req.payloadDataLoader = req?.payloadDataLoader || getDataLoader(req)\n  req.routeParams = req?.routeParams || {}\n  req.query = req?.query || {}\n\n  attachFakeURLProperties(req)\n\n  return req\n}\n"],"names":["getDataLoader","getLocalI18n","getRequestContext","req","context","Object","keys","length","constructor","attachFakeURLProperties","urlObject","getURLObject","urlToUse","url","payload","config","serverURL","URL","error","host","protocol","pathname","searchParams","origin","href","createLocalReq","fallbackLocale","locale","localeArg","user","localization","defaultLocale","localeCandidate","query","fallbackLocaleFromConfig","locales","find","code","i18n","language","fallbackLanguage","headers","Headers","payloadAPI","t","payloadDataLoader","routeParams"],"mappings":"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"}},
    {"offset": {"line": 1220, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1226, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/payload/src/auth/operations/local/auth.ts"],"sourcesContent":["import type { Payload } from '../../../index.js'\nimport type { PayloadRequest } from '../../../types/index.js'\nimport type { AuthArgs, AuthResult } from '../auth.js'\n\nimport { createLocalReq } from '../../../utilities/createLocalReq.js'\nimport { auth as authOperation } from '../auth.js'\n\nexport const auth = async (payload: Payload, options: AuthArgs): Promise<AuthResult> => {\n  const { headers } = options\n\n  return await authOperation({\n    headers,\n    req: await createLocalReq({ req: options.req as PayloadRequest }, payload),\n  })\n}\n"],"names":["createLocalReq","auth","authOperation","payload","options","headers","req"],"mappings":";;;AAKA,SAASC,QAAQC,aAAa,QAAQ,aAAY;AADlD,SAASF,cAAc,QAAQ,uCAAsC;;;AAG9D,MAAMC,OAAO,OAAOE,SAAkBC;IAC3C,MAAM,EAAEC,OAAO,EAAE,GAAGD;IAEpB,OAAO,wKAAMF,OAAAA,EAAc;QACzBG;QACAC,KAAK,yKAAMN,iBAAAA,EAAe;YAAEM,KAAKF,QAAQE,GAAG;QAAmB,GAAGH;IACpE;AACF,EAAC"}},
    {"offset": {"line": 1242, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1248, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/payload/src/utilities/initTransaction.ts"],"sourcesContent":["import type { PayloadRequest } from '../types/index.js'\n\n/**\n * Starts a new transaction using the db adapter with a random id and then assigns it to the req.transaction\n * @returns true if beginning a transaction and false when req already has a transaction to use\n */\nexport async function initTransaction(req: PayloadRequest): Promise<boolean> {\n  const { payload, transactionID } = req\n  if (transactionID instanceof Promise) {\n    // wait for whoever else is already creating the transaction\n    await transactionID\n    return false\n  }\n\n  if (transactionID) {\n    // we already have a transaction, we're not in charge of committing it\n    return false\n  }\n  if (typeof payload.db.beginTransaction === 'function') {\n    // create a new transaction\n    req.transactionID = payload.db.beginTransaction().then((transactionID) => {\n      if (transactionID) {\n        req.transactionID = transactionID\n      }\n\n      return transactionID\n    })\n    return !!(await req.transactionID)\n  }\n  return false\n}\n"],"names":["initTransaction","req","payload","transactionID","Promise","db","beginTransaction","then"],"mappings":"AAEA;;;CAGC,GACD;;;AAAO,eAAeA,gBAAgBC,GAAmB;IACvD,MAAM,EAAEC,OAAO,EAAEC,aAAa,EAAE,GAAGF;IACnC,IAAIE,yBAAyBC,SAAS;QACpC,4DAA4D;QAC5D,MAAMD;QACN,OAAO;IACT;IAEA,IAAIA,eAAe;QACjB,sEAAsE;QACtE,OAAO;IACT;IACA,IAAI,OAAOD,QAAQG,EAAE,CAACC,gBAAgB,KAAK,YAAY;QACrD,2BAA2B;QAC3BL,IAAIE,aAAa,GAAGD,QAAQG,EAAE,CAACC,gBAAgB,GAAGC,IAAI,CAAC,CAACJ;YACtD,IAAIA,eAAe;gBACjBF,IAAIE,aAAa,GAAGA;YACtB;YAEA,OAAOA;QACT;QACA,OAAO,CAAC,CAAE,MAAMF,IAAIE,aAAa;IACnC;IACA,OAAO;AACT"}},
    {"offset": {"line": 1277, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1283, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/payload/src/collections/operations/utils.ts"],"sourcesContent":["import type { forgotPasswordOperation } from '../../auth/operations/forgotPassword.js'\nimport type { loginOperation } from '../../auth/operations/login.js'\nimport type { refreshOperation } from '../../auth/operations/refresh.js'\nimport type { CollectionSlug } from '../../index.js'\nimport type { PayloadRequest } from '../../types/index.js'\nimport type { AfterOperationHook, SanitizedCollectionConfig } from '../config/types.js'\nimport type { countOperation } from './count.js'\nimport type { createOperation } from './create.js'\nimport type { deleteOperation } from './delete.js'\nimport type { deleteByIDOperation } from './deleteByID.js'\nimport type { findOperation } from './find.js'\nimport type { findByIDOperation } from './findByID.js'\nimport type { updateOperation } from './update.js'\nimport type { updateByIDOperation } from './updateByID.js'\n\nexport type AfterOperationMap<TOperationGeneric extends CollectionSlug> = {\n  count: typeof countOperation<TOperationGeneric>\n  create: typeof createOperation<TOperationGeneric>\n  delete: typeof deleteOperation<TOperationGeneric>\n  deleteByID: typeof deleteByIDOperation<TOperationGeneric>\n  find: typeof findOperation<TOperationGeneric>\n  findByID: typeof findByIDOperation<TOperationGeneric>\n  forgotPassword: typeof forgotPasswordOperation\n  login: typeof loginOperation<TOperationGeneric>\n  refresh: typeof refreshOperation\n  update: typeof updateOperation<TOperationGeneric>\n  updateByID: typeof updateByIDOperation<TOperationGeneric>\n}\n\nexport type AfterOperationArg<TOperationGeneric extends CollectionSlug> = {\n  /** The collection which this hook is being run on */\n  collection: SanitizedCollectionConfig\n  req: PayloadRequest\n} & (\n  | {\n      args: Parameters<AfterOperationMap<TOperationGeneric>['count']>[0]\n      operation: 'count'\n      result: Awaited<ReturnType<AfterOperationMap<TOperationGeneric>['count']>>\n    }\n  | {\n      args: Parameters<AfterOperationMap<TOperationGeneric>['create']>[0]\n      operation: 'create'\n      result: Awaited<ReturnType<AfterOperationMap<TOperationGeneric>['create']>>\n    }\n  | {\n      args: Parameters<AfterOperationMap<TOperationGeneric>['delete']>[0]\n      operation: 'delete'\n      result: Awaited<ReturnType<AfterOperationMap<TOperationGeneric>['delete']>>\n    }\n  | {\n      args: Parameters<AfterOperationMap<TOperationGeneric>['deleteByID']>[0]\n      operation: 'deleteByID'\n      result: Awaited<ReturnType<AfterOperationMap<TOperationGeneric>['deleteByID']>>\n    }\n  | {\n      args: Parameters<AfterOperationMap<TOperationGeneric>['find']>[0]\n      operation: 'find'\n      result: Awaited<ReturnType<AfterOperationMap<TOperationGeneric>['find']>>\n    }\n  | {\n      args: Parameters<AfterOperationMap<TOperationGeneric>['findByID']>[0]\n      operation: 'findByID'\n      result: Awaited<ReturnType<AfterOperationMap<TOperationGeneric>['findByID']>>\n    }\n  | {\n      args: Parameters<AfterOperationMap<TOperationGeneric>['forgotPassword']>[0]\n      operation: 'forgotPassword'\n      result: Awaited<ReturnType<AfterOperationMap<TOperationGeneric>['forgotPassword']>>\n    }\n  | {\n      args: Parameters<AfterOperationMap<TOperationGeneric>['login']>[0]\n      operation: 'login'\n      result: Awaited<ReturnType<AfterOperationMap<TOperationGeneric>['login']>>\n    }\n  | {\n      args: Parameters<AfterOperationMap<TOperationGeneric>['refresh']>[0]\n      operation: 'refresh'\n      result: Awaited<ReturnType<AfterOperationMap<TOperationGeneric>['refresh']>>\n    }\n  | {\n      args: Parameters<AfterOperationMap<TOperationGeneric>['update']>[0]\n      operation: 'update'\n      result: Awaited<ReturnType<AfterOperationMap<TOperationGeneric>['update']>>\n    }\n  | {\n      args: Parameters<AfterOperationMap<TOperationGeneric>['updateByID']>[0]\n      operation: 'updateByID'\n      result: Awaited<ReturnType<AfterOperationMap<TOperationGeneric>['updateByID']>>\n    }\n)\n\ntype OperationResult<\n  TOperationGeneric extends CollectionSlug,\n  O extends keyof AfterOperationMap<TOperationGeneric>,\n> = Awaited<ReturnType<AfterOperationMap<TOperationGeneric>[O]>>\n\nexport const buildAfterOperation = async <\n  TOperationGeneric extends CollectionSlug,\n  O extends keyof AfterOperationMap<TOperationGeneric> = keyof AfterOperationMap<TOperationGeneric>,\n>(\n  operationArgs: { operation: O } & Omit<AfterOperationArg<TOperationGeneric>, 'req'>,\n): Promise<any | OperationResult<TOperationGeneric, O>> => {\n  const { args, collection, operation, result } = operationArgs\n\n  let newResult = result as OperationResult<TOperationGeneric, O>\n\n  await args.collection.config.hooks.afterOperation.reduce(\n    async (priorHook, hook: AfterOperationHook<TOperationGeneric>) => {\n      await priorHook\n\n      const hookResult = await hook({\n        args,\n        collection,\n        operation,\n        req: args.req,\n        result: newResult,\n      } as AfterOperationArg<TOperationGeneric>)\n\n      if (hookResult !== undefined) {\n        newResult = hookResult as OperationResult<TOperationGeneric, O>\n      }\n    },\n    Promise.resolve(),\n  )\n\n  return newResult\n}\n"],"names":["buildAfterOperation","operationArgs","args","collection","operation","result","newResult","config","hooks","afterOperation","reduce","priorHook","hook","hookResult","req","undefined","Promise","resolve"],"mappings":";;;AAgGO,MAAMA,sBAAsB,OAIjCC;IAEA,MAAM,EAAEC,IAAI,EAAEC,UAAU,EAAEC,SAAS,EAAEC,MAAM,EAAE,GAAGJ;IAEhD,IAAIK,YAAYD;IAEhB,MAAMH,KAAKC,UAAU,CAACI,MAAM,CAACC,KAAK,CAACC,cAAc,CAACC,MAAM,CACtD,OAAOC,WAAWC;QAChB,MAAMD;QAEN,MAAME,aAAa,MAAMD,KAAK;YAC5BV;YACAC;YACAC;YACAU,KAAKZ,KAAKY,GAAG;YACbT,QAAQC;QACV;QAEA,IAAIO,eAAeE,WAAW;YAC5BT,YAAYO;QACd;IACF,GACAG,QAAQC,OAAO;IAGjB,OAAOX;AACT,EAAC"}},
    {"offset": {"line": 1304, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1310, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/payload/src/utilities/commitTransaction.ts"],"sourcesContent":["import type { PayloadRequest } from '../types/index.js'\n\n/**\n * complete a transaction calling adapter db.commitTransaction and delete the transactionID from req\n */\nexport async function commitTransaction(req: PayloadRequest): Promise<void> {\n  const { payload, transactionID } = req\n\n  await payload.db.commitTransaction(transactionID)\n  delete req.transactionID\n}\n"],"names":["commitTransaction","req","payload","transactionID","db"],"mappings":"AAEA;;CAEC,GACD;;;AAAO,eAAeA,kBAAkBC,GAAmB;IACzD,MAAM,EAAEC,OAAO,EAAEC,aAAa,EAAE,GAAGF;IAEnC,MAAMC,QAAQE,EAAE,CAACJ,iBAAiB,CAACG;IACnC,OAAOF,IAAIE,aAAa;AAC1B"}},
    {"offset": {"line": 1320, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1326, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/payload/src/auth/operations/forgotPassword.ts"],"sourcesContent":["import crypto from 'crypto'\nimport httpStatus from 'http-status'\nimport { URL } from 'url'\n\nimport type {\n  AuthOperationsFromCollectionSlug,\n  Collection,\n} from '../../collections/config/types.js'\nimport type { CollectionSlug } from '../../index.js'\nimport type { PayloadRequest, Where } from '../../types/index.js'\n\nimport { buildAfterOperation } from '../../collections/operations/utils.js'\nimport { APIError } from '../../errors/index.js'\nimport { commitTransaction } from '../../utilities/commitTransaction.js'\nimport { initTransaction } from '../../utilities/initTransaction.js'\nimport { killTransaction } from '../../utilities/killTransaction.js'\n\nexport type Arguments<TSlug extends CollectionSlug> = {\n  collection: Collection\n  data: {\n    [key: string]: unknown\n  } & AuthOperationsFromCollectionSlug<TSlug>['forgotPassword']\n  disableEmail?: boolean\n  expiration?: number\n  req: PayloadRequest\n}\n\nexport type Result = string\n\nexport const forgotPasswordOperation = async <TSlug extends CollectionSlug>(\n  incomingArgs: Arguments<TSlug>,\n): Promise<null | string> => {\n  const loginWithUsername = incomingArgs.collection.config.auth.loginWithUsername\n  const { data } = incomingArgs\n\n  const canLoginWithUsername = Boolean(loginWithUsername)\n  const canLoginWithEmail = !loginWithUsername || loginWithUsername.allowEmailLogin\n\n  const sanitizedEmail =\n    (canLoginWithEmail && (incomingArgs.data.email || '').toLowerCase().trim()) || null\n  const sanitizedUsername =\n    'username' in data && typeof data?.username === 'string'\n      ? data.username.toLowerCase().trim()\n      : null\n\n  if (!sanitizedEmail && !sanitizedUsername) {\n    throw new APIError(\n      `Missing ${loginWithUsername ? 'username' : 'email'}.`,\n      httpStatus.BAD_REQUEST,\n    )\n  }\n\n  let args = incomingArgs\n\n  try {\n    const shouldCommit = await initTransaction(args.req)\n\n    // /////////////////////////////////////\n    // beforeOperation - Collection\n    // /////////////////////////////////////\n\n    await args.collection.config.hooks.beforeOperation.reduce(async (priorHook, hook) => {\n      await priorHook\n\n      args =\n        (await hook({\n          args,\n          collection: args.collection?.config,\n          context: args.req.context,\n          operation: 'forgotPassword',\n          req: args.req,\n        })) || args\n    }, Promise.resolve())\n\n    const {\n      collection: { config: collectionConfig },\n      data,\n      disableEmail,\n      expiration,\n      req: {\n        payload: { config, email },\n        payload,\n      },\n      req,\n    } = args\n\n    // /////////////////////////////////////\n    // Forget password\n    // /////////////////////////////////////\n\n    let token: string = crypto.randomBytes(20).toString('hex')\n    type UserDoc = {\n      email?: string\n      id: number | string\n      resetPasswordExpiration?: string\n      resetPasswordToken?: string\n    }\n\n    if (!sanitizedEmail && !sanitizedUsername) {\n      throw new APIError(\n        `Missing ${loginWithUsername ? 'username' : 'email'}.`,\n        httpStatus.BAD_REQUEST,\n      )\n    }\n\n    let whereConstraint: Where = {}\n\n    if (canLoginWithEmail && sanitizedEmail) {\n      whereConstraint = {\n        email: {\n          equals: sanitizedEmail,\n        },\n      }\n    } else if (canLoginWithUsername && sanitizedUsername) {\n      whereConstraint = {\n        username: {\n          equals: sanitizedUsername,\n        },\n      }\n    }\n\n    let user = await payload.db.findOne<UserDoc>({\n      collection: collectionConfig.slug,\n      req,\n      where: whereConstraint,\n    })\n\n    // We don't want to indicate specifically that an email was not found,\n    // as doing so could lead to the exposure of registered emails.\n    // Therefore, we prefer to fail silently.\n    if (!user) {\n      return null\n    }\n\n    user.resetPasswordToken = token\n    user.resetPasswordExpiration = new Date(expiration || Date.now() + 3600000).toISOString() // 1 hour\n\n    user = await payload.update({\n      id: user.id,\n      collection: collectionConfig.slug,\n      data: user,\n      req,\n    })\n\n    if (!disableEmail && user.email) {\n      const protocol = new URL(req.url).protocol // includes the final :\n      const serverURL =\n        config.serverURL !== null && config.serverURL !== ''\n          ? config.serverURL\n          : `${protocol}//${req.headers.get('host')}`\n\n      let html = `${req.t('authentication:youAreReceivingResetPassword')}\n    <a href=\"${serverURL}${config.routes.admin}${config.admin.routes.reset}/${token}\">${serverURL}${config.routes.admin}${config.admin.routes.reset}/${token}</a>\n    ${req.t('authentication:youDidNotRequestPassword')}`\n\n      if (typeof collectionConfig.auth.forgotPassword.generateEmailHTML === 'function') {\n        html = await collectionConfig.auth.forgotPassword.generateEmailHTML({\n          req,\n          token,\n          user,\n        })\n      }\n\n      let subject = req.t('authentication:resetYourPassword')\n\n      if (typeof collectionConfig.auth.forgotPassword.generateEmailSubject === 'function') {\n        subject = await collectionConfig.auth.forgotPassword.generateEmailSubject({\n          req,\n          token,\n          user,\n        })\n      }\n\n      await email.sendEmail({\n        from: `\"${email.defaultFromName}\" <${email.defaultFromAddress}>`,\n        html,\n        subject,\n        to: user.email,\n      })\n    }\n\n    // /////////////////////////////////////\n    // afterForgotPassword - Collection\n    // /////////////////////////////////////\n\n    await collectionConfig.hooks.afterForgotPassword.reduce(async (priorHook, hook) => {\n      await priorHook\n      await hook({ args, collection: args.collection?.config, context: req.context })\n    }, Promise.resolve())\n\n    // /////////////////////////////////////\n    // afterOperation - Collection\n    // /////////////////////////////////////\n\n    token = await buildAfterOperation({\n      args,\n      collection: args.collection?.config,\n      operation: 'forgotPassword',\n      result: token,\n    })\n\n    if (shouldCommit) {\n      await commitTransaction(req)\n    }\n\n    return token\n  } catch (error: unknown) {\n    await killTransaction(args.req)\n    throw error\n  }\n}\n"],"names":["crypto","httpStatus","URL","buildAfterOperation","APIError","commitTransaction","initTransaction","killTransaction","forgotPasswordOperation","incomingArgs","loginWithUsername","collection","config","auth","data","canLoginWithUsername","Boolean","canLoginWithEmail","allowEmailLogin","sanitizedEmail","email","toLowerCase","trim","sanitizedUsername","username","BAD_REQUEST","args","shouldCommit","req","hooks","beforeOperation","reduce","priorHook","hook","context","operation","Promise","resolve","collectionConfig","disableEmail","expiration","payload","token","randomBytes","toString","whereConstraint","equals","user","db","findOne","slug","where","resetPasswordToken","resetPasswordExpiration","Date","now","toISOString","update","id","protocol","url","serverURL","headers","get","html","t","routes","admin","reset","forgotPassword","generateEmailHTML","subject","generateEmailSubject","sendEmail","from","defaultFromName","defaultFromAddress","to","afterForgotPassword","result","error"],"mappings":"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"}},
    {"offset": {"line": 1471, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1477, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/payload/src/auth/operations/local/forgotPassword.ts"],"sourcesContent":["import type { CollectionSlug, Payload, RequestContext } from '../../../index.js'\nimport type { PayloadRequest } from '../../../types/index.js'\nimport type { Result } from '../forgotPassword.js'\n\nimport { APIError } from '../../../errors/index.js'\nimport { createLocalReq } from '../../../utilities/createLocalReq.js'\nimport { forgotPasswordOperation } from '../forgotPassword.js'\n\nexport type Options<T extends CollectionSlug> = {\n  collection: T\n  context?: RequestContext\n  data: {\n    email: string\n  }\n  disableEmail?: boolean\n  expiration?: number\n  req?: PayloadRequest\n}\n\nasync function localForgotPassword<T extends CollectionSlug>(\n  payload: Payload,\n  options: Options<T>,\n): Promise<Result> {\n  const { collection: collectionSlug, data, disableEmail, expiration } = options\n\n  const collection = payload.collections[collectionSlug]\n\n  if (!collection) {\n    throw new APIError(\n      `The collection with slug ${String(\n        collectionSlug,\n      )} can't be found. Forgot Password Operation.`,\n    )\n  }\n\n  return forgotPasswordOperation({\n    collection,\n    data,\n    disableEmail,\n    expiration,\n    req: await createLocalReq(options, payload),\n  })\n}\n\nexport default localForgotPassword\n"],"names":["APIError","createLocalReq","forgotPasswordOperation","localForgotPassword","payload","options","collection","collectionSlug","data","disableEmail","expiration","collections","String","req"],"mappings":";;;AAIA,SAASA,QAAQ,QAAQ,2BAA0B;AAEnD,SAASE,uBAAuB,QAAQ,uBAAsB;AAD9D,SAASD,cAAc,QAAQ,uCAAsC;;;;AAcrE,eAAeE,oBACbC,OAAgB,EAChBC,OAAmB;IAEnB,MAAM,EAAEC,YAAYC,cAAc,EAAEC,IAAI,EAAEC,YAAY,EAAEC,UAAU,EAAE,GAAGL;IAEvE,MAAMC,aAAaF,QAAQO,WAAW,CAACJ,eAAe;IAEtD,IAAI,CAACD,YAAY;QACf,MAAM,0JAAIN,WAAAA,CACR,CAAC,yBAAyB,EAAEY,OAC1BL,gBACA,2CAA2C,CAAC;IAElD;IAEA,mLAAOL,0BAAAA,EAAwB;QAC7BI;QACAE;QACAC;QACAC;QACAG,KAAK,yKAAMZ,iBAAAA,EAAeI,SAASD;IACrC;AACF;uCAEeD,oBAAmB"}},
    {"offset": {"line": 1502, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1508, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/payload/src/errors/ValidationError.ts"],"sourcesContent":["import type { TFunction } from '@payloadcms/translations'\n\nimport { en } from '@payloadcms/translations/languages/en'\nimport httpStatus from 'http-status'\n\nimport { APIError } from './APIError.js'\n\n// This gets dynamically reassigned during compilation\nexport let ValidationErrorName = 'ValidationError'\n\nexport type ValidationFieldError = {\n  // The field path, i.e. \"textField\", \"groupField.subTextField\", etc.\n  field: string\n  // The error message to display for this field\n  message: string\n}\n\nexport class ValidationError extends APIError<{\n  collection?: string\n  errors: ValidationFieldError[]\n  global?: string\n}> {\n  constructor(\n    results: {\n      collection?: string\n      errors: ValidationFieldError[]\n      global?: string\n      id?: number | string\n    },\n    t?: TFunction,\n  ) {\n    const message = t\n      ? t('error:followingFieldsInvalid', { count: results.errors.length })\n      : results.errors.length === 1\n        ? en.translations.error.followingFieldsInvalid_one\n        : en.translations.error.followingFieldsInvalid_other\n\n    super(\n      `${message} ${results.errors.map((f) => f.field).join(', ')}`,\n      httpStatus.BAD_REQUEST,\n      results,\n    )\n\n    ValidationErrorName = this.constructor.name\n  }\n}\n"],"names":["en","httpStatus","APIError","ValidationErrorName","ValidationError","constructor","results","t","message","count","errors","length","translations","error","followingFieldsInvalid_one","followingFieldsInvalid_other","map","f","field","join","BAD_REQUEST","name"],"mappings":";;;;AAEA,SAASA,EAAE,QAAQ,wCAAuC;AAC1D,OAAOC,gBAAgB,cAAa;AAEpC,SAASC,QAAQ,QAAQ,gBAAe;;;;AAGjC,IAAIC,sBAAsB,kBAAiB;AAS3C,MAAMC,8KAAwBF,WAAAA;IAKnCG,YACEC,OAKC,EACDC,CAAa,CACb;QACA,MAAMC,UAAUD,IACZA,EAAE,gCAAgC;YAAEE,OAAOH,QAAQI,MAAM,CAACC,MAAM;QAAC,KACjEL,QAAQI,MAAM,CAACC,MAAM,KAAK,4KACxBX,KAAAA,CAAGY,YAAY,CAACC,KAAK,CAACC,0BAA0B,2KAChDd,KAAAA,CAAGY,YAAY,CAACC,KAAK,CAACE,4BAA4B;QAExD,KAAK,CACH,CAAC,EAAEP,QAAQ,CAAC,EAAEF,QAAQI,MAAM,CAACM,GAAG,CAAC,CAACC,IAAMA,EAAEC,KAAK,EAAEC,IAAI,CAAC,MAAM,CAAC,iJAC7DlB,UAAAA,CAAWmB,WAAW,EACtBd;QAGFH,sBAAsB,IAAI,CAACE,WAAW,CAACgB,IAAI;IAC7C;AACF"}},
    {"offset": {"line": 1528, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1534, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/payload/src/errors/AuthenticationError.ts"],"sourcesContent":["import type { TFunction } from '@payloadcms/translations'\n\nimport { en } from '@payloadcms/translations/languages/en'\nimport httpStatus from 'http-status'\n\nimport { APIError } from './APIError.js'\n\nexport class AuthenticationError extends APIError {\n  constructor(t?: TFunction, loginWithUsername?: boolean) {\n    super(\n      t\n        ? `${loginWithUsername ? t('error:usernameOrPasswordIncorrect') : t('error:emailOrPasswordIncorrect')}`\n        : en.translations.error.emailOrPasswordIncorrect,\n      httpStatus.UNAUTHORIZED,\n    )\n  }\n}\n"],"names":["en","httpStatus","APIError","AuthenticationError","constructor","t","loginWithUsername","translations","error","emailOrPasswordIncorrect","UNAUTHORIZED"],"mappings":";;;AAEA,SAASA,EAAE,QAAQ,wCAAuC;AAC1D,OAAOC,gBAAgB,cAAa;AAEpC,SAASC,QAAQ,QAAQ,gBAAe;;;;AAEjC,MAAMC,kLAA4BD,WAAAA;IACvCE,YAAYC,CAAa,EAAEC,iBAA2B,CAAE;QACtD,KAAK,CACHD,IACI,CAAC,EAAEC,oBAAoBD,EAAE,uCAAuCA,EAAE,kCAAkC,CAAC,2KACrGL,KAAAA,CAAGO,YAAY,CAACC,KAAK,CAACC,wBAAwB,iJAClDR,UAAAA,CAAWS,YAAY;IAE3B;AACF"}},
    {"offset": {"line": 1548, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1554, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/payload/src/auth/isLocked.ts"],"sourcesContent":["const isLocked = (date: number): boolean => {\n  if (!date) {\n    return false\n  }\n  return date > Date.now()\n}\nexport default isLocked\n"],"names":["isLocked","date","Date","now"],"mappings":";;;AAAA,MAAMA,WAAW,CAACC;IAChB,IAAI,CAACA,MAAM;QACT,OAAO;IACT;IACA,OAAOA,OAAOC,KAAKC,GAAG;AACxB;uCACeH,SAAQ"}},
    {"offset": {"line": 1565, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1571, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/payload/src/errors/LockedAuth.ts"],"sourcesContent":["import type { TFunction } from '@payloadcms/translations'\n\nimport { en } from '@payloadcms/translations/languages/en'\nimport httpStatus from 'http-status'\n\nimport { APIError } from './APIError.js'\n\nexport class LockedAuth extends APIError {\n  constructor(t?: TFunction) {\n    super(t ? t('error:userLocked') : en.translations.error.userLocked, httpStatus.UNAUTHORIZED)\n  }\n}\n"],"names":["en","httpStatus","APIError","LockedAuth","constructor","t","translations","error","userLocked","UNAUTHORIZED"],"mappings":";;;AAEA,SAASA,EAAE,QAAQ,wCAAuC;AAC1D,OAAOC,gBAAgB,cAAa;AAEpC,SAASC,QAAQ,QAAQ,gBAAe;;;;AAEjC,MAAMC,yKAAmBD,WAAAA;IAC9BE,YAAYC,CAAa,CAAE;QACzB,KAAK,CAACA,IAAIA,EAAE,8LAAsBL,KAAAA,CAAGM,YAAY,CAACC,KAAK,CAACC,UAAU,iJAAEP,UAAAA,CAAWQ,YAAY;IAC7F;AACF"}},
    {"offset": {"line": 1585, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1591, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/payload/src/auth/strategies/local/authenticate.ts"],"sourcesContent":["import crypto from 'crypto'\nimport scmp from 'scmp'\n\nimport type { TypeWithID } from '../../../collections/config/types.js'\n\ntype Doc = Record<string, unknown> & TypeWithID\n\ntype Args = {\n  doc: Doc\n  password: string\n}\n\nexport const authenticateLocalStrategy = async ({ doc, password }: Args): Promise<Doc | null> => {\n  try {\n    const { hash, salt } = doc\n\n    if (typeof salt === 'string' && typeof hash === 'string') {\n      const res = await new Promise<Doc | null>((resolve, reject) => {\n        crypto.pbkdf2(password, salt, 25000, 512, 'sha256', (e, hashBuffer) => {\n          if (e) {\n            reject(null)\n          }\n\n          if (scmp(hashBuffer, Buffer.from(hash, 'hex'))) {\n            resolve(doc)\n          } else {\n            reject(null)\n          }\n        })\n      })\n\n      return res\n    }\n\n    return null\n  } catch (err) {\n    return null\n  }\n}\n"],"names":["crypto","scmp","authenticateLocalStrategy","doc","password","hash","salt","res","Promise","resolve","reject","pbkdf2","e","hashBuffer","Buffer","from","err"],"mappings":";;;AAAA,OAAOA,YAAY,SAAQ;AAC3B,OAAOC,UAAU,OAAM;;;AAWhB,MAAMC,4BAA4B,OAAO,EAAEC,GAAG,EAAEC,QAAQ,EAAQ;IACrE,IAAI;QACF,MAAM,EAAEC,IAAI,EAAEC,IAAI,EAAE,GAAGH;QAEvB,IAAI,OAAOG,SAAS,YAAY,OAAOD,SAAS,UAAU;YACxD,MAAME,MAAM,MAAM,IAAIC,QAAoB,CAACC,SAASC;gHAClDV,UAAAA,CAAOW,MAAM,CAACP,UAAUE,MAAM,OAAO,KAAK,UAAU,CAACM,GAAGC;oBACtD,IAAID,GAAG;wBACLF,OAAO;oBACT;oBAEA,sIAAIT,UAAAA,EAAKY,YAAYC,OAAOC,IAAI,CAACV,MAAM,SAAS;wBAC9CI,QAAQN;oBACV,OAAO;wBACLO,OAAO;oBACT;gBACF;YACF;YAEA,OAAOH;QACT;QAEA,OAAO;IACT,EAAE,OAAOS,KAAK;QACZ,OAAO;IACT;AACF,EAAC"}},
    {"offset": {"line": 1621, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1627, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/payload/src/utilities/sanitizeInternalFields.ts"],"sourcesContent":["const internalFields = ['__v']\n\nconst sanitizeInternalFields = <T extends Record<string, unknown>>(incomingDoc: T): T =>\n  Object.entries(incomingDoc).reduce((newDoc, [key, val]): T => {\n    if (key === '_id') {\n      return {\n        ...newDoc,\n        id: val,\n      }\n    }\n\n    if (internalFields.indexOf(key) > -1) {\n      return newDoc\n    }\n\n    return {\n      ...newDoc,\n      [key]: val,\n    }\n  }, {} as T)\n\nexport default sanitizeInternalFields\n"],"names":["internalFields","sanitizeInternalFields","incomingDoc","Object","entries","reduce","newDoc","key","val","id","indexOf"],"mappings":";;;AAAA,MAAMA,iBAAiB;IAAC;CAAM;AAE9B,MAAMC,yBAAyB,CAAoCC,cACjEC,OAAOC,OAAO,CAACF,aAAaG,MAAM,CAAC,CAACC,QAAQ,CAACC,KAAKC,IAAI;QACpD,IAAID,QAAQ,OAAO;YACjB,OAAO;gBACL,GAAGD,MAAM;gBACTG,IAAID;YACN;QACF;QAEA,IAAIR,eAAeU,OAAO,CAACH,OAAO,CAAC,GAAG;YACpC,OAAOD;QACT;QAEA,OAAO;YACL,GAAGA,MAAM;YACT,CAACC,IAAI,EAAEC;QACT;IACF,GAAG,CAAC;uCAESP,uBAAsB"}},
    {"offset": {"line": 1650, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1656, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/payload/src/auth/strategies/local/incrementLoginAttempts.ts"],"sourcesContent":["import type { SanitizedCollectionConfig, TypeWithID } from '../../../collections/config/types.js'\nimport type { JsonObject, Payload } from '../../../index.js'\nimport type { PayloadRequest } from '../../../types/index.js'\n\ntype Args = {\n  collection: SanitizedCollectionConfig\n  doc: Record<string, unknown> & TypeWithID\n  payload: Payload\n  req: PayloadRequest\n}\n\nexport const incrementLoginAttempts = async ({\n  collection,\n  doc,\n  payload,\n  req,\n}: Args): Promise<void> => {\n  const {\n    auth: { lockTime, maxLoginAttempts },\n  } = collection\n\n  if ('lockUntil' in doc && typeof doc.lockUntil === 'string') {\n    const lockUntil = new Date(doc.lockUntil).getTime()\n\n    // Expired lock, restart count at 1\n    if (lockUntil < Date.now()) {\n      await payload.update({\n        id: doc.id,\n        collection: collection.slug,\n        data: {\n          lockUntil: null,\n          loginAttempts: 1,\n        },\n        depth: 0,\n        req,\n      })\n    }\n\n    return\n  }\n\n  const data: JsonObject = {\n    loginAttempts: Number(doc.loginAttempts) + 1,\n  }\n\n  // Lock the account if at max attempts and not already locked\n  if (typeof doc.loginAttempts === 'number' && doc.loginAttempts + 1 >= maxLoginAttempts) {\n    const lockUntil = new Date(Date.now() + lockTime).toISOString()\n    data.lockUntil = lockUntil\n  }\n\n  await payload.update({\n    id: doc.id,\n    collection: collection.slug,\n    data,\n    depth: 0,\n    req,\n  })\n}\n"],"names":["incrementLoginAttempts","collection","doc","payload","req","auth","lockTime","maxLoginAttempts","lockUntil","Date","getTime","now","update","id","slug","data","loginAttempts","depth","Number","toISOString"],"mappings":";;;AAWO,MAAMA,yBAAyB,OAAO,EAC3CC,UAAU,EACVC,GAAG,EACHC,OAAO,EACPC,GAAG,EACE;IACL,MAAM,EACJC,MAAM,EAAEC,QAAQ,EAAEC,gBAAgB,EAAE,EACrC,GAAGN;IAEJ,IAAI,eAAeC,OAAO,OAAOA,IAAIM,SAAS,KAAK,UAAU;QAC3D,MAAMA,YAAY,IAAIC,KAAKP,IAAIM,SAAS,EAAEE,OAAO;QAEjD,mCAAmC;QACnC,IAAIF,YAAYC,KAAKE,GAAG,IAAI;YAC1B,MAAMR,QAAQS,MAAM,CAAC;gBACnBC,IAAIX,IAAIW,EAAE;gBACVZ,YAAYA,WAAWa,IAAI;gBAC3BC,MAAM;oBACJP,WAAW;oBACXQ,eAAe;gBACjB;gBACAC,OAAO;gBACPb;YACF;QACF;QAEA;IACF;IAEA,MAAMW,OAAmB;QACvBC,eAAeE,OAAOhB,IAAIc,aAAa,IAAI;IAC7C;IAEA,6DAA6D;IAC7D,IAAI,OAAOd,IAAIc,aAAa,KAAK,YAAYd,IAAIc,aAAa,GAAG,KAAKT,kBAAkB;QACtF,MAAMC,YAAY,IAAIC,KAAKA,KAAKE,GAAG,KAAKL,UAAUa,WAAW;QAC7DJ,KAAKP,SAAS,GAAGA;IACnB;IAEA,MAAML,QAAQS,MAAM,CAAC;QACnBC,IAAIX,IAAIW,EAAE;QACVZ,YAAYA,WAAWa,IAAI;QAC3BC;QACAE,OAAO;QACPb;IACF;AACF,EAAC"}},
    {"offset": {"line": 1694, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1700, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/payload/src/auth/strategies/local/resetLoginAttempts.ts"],"sourcesContent":["import type { SanitizedCollectionConfig, TypeWithID } from '../../../collections/config/types.js'\nimport type { Payload } from '../../../index.js'\nimport type { PayloadRequest } from '../../../types/index.js'\n\ntype Args = {\n  collection: SanitizedCollectionConfig\n  doc: Record<string, unknown> & TypeWithID\n  payload: Payload\n  req: PayloadRequest\n}\n\nexport const resetLoginAttempts = async ({\n  collection,\n  doc,\n  payload,\n  req,\n}: Args): Promise<void> => {\n  if (!('lockUntil' in doc && typeof doc.lockUntil === 'string') || doc.loginAttempts === 0) {\n    return\n  }\n  await payload.update({\n    id: doc.id,\n    collection: collection.slug,\n    data: {\n      lockUntil: null,\n      loginAttempts: 0,\n    },\n    depth: 0,\n    overrideAccess: true,\n    req,\n  })\n}\n"],"names":["resetLoginAttempts","collection","doc","payload","req","lockUntil","loginAttempts","update","id","slug","data","depth","overrideAccess"],"mappings":";;;AAWO,MAAMA,qBAAqB,OAAO,EACvCC,UAAU,EACVC,GAAG,EACHC,OAAO,EACPC,GAAG,EACE;IACL,IAAI,CAAE,CAAA,eAAeF,OAAO,OAAOA,IAAIG,SAAS,KAAK,QAAO,KAAMH,IAAII,aAAa,KAAK,GAAG;QACzF;IACF;IACA,MAAMH,QAAQI,MAAM,CAAC;QACnBC,IAAIN,IAAIM,EAAE;QACVP,YAAYA,WAAWQ,IAAI;QAC3BC,MAAM;YACJL,WAAW;YACXC,eAAe;QACjB;QACAK,OAAO;QACPC,gBAAgB;QAChBR;IACF;AACF,EAAC"}},
    {"offset": {"line": 1719, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1725, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/payload/src/auth/getFieldsToSign.ts"],"sourcesContent":["import type { CollectionConfig } from '../collections/config/types.js'\nimport type { Field, TabAsField } from '../fields/config/types.js'\nimport type { PayloadRequest } from '../types/index.js'\n\nimport { fieldAffectsData, tabHasName } from '../fields/config/types.js'\n\ntype TraverseFieldsArgs = {\n  data: Record<string, unknown>\n  fields: (Field | TabAsField)[]\n  result: Record<string, unknown>\n}\nconst traverseFields = ({\n  data,\n  // parent,\n  fields,\n  result,\n}: TraverseFieldsArgs) => {\n  fields.forEach((field) => {\n    switch (field.type) {\n      case 'row':\n      case 'collapsible': {\n        traverseFields({\n          data,\n          fields: field.fields,\n          result,\n        })\n        break\n      }\n      case 'group': {\n        let targetResult\n        if (typeof field.saveToJWT === 'string') {\n          targetResult = field.saveToJWT\n          result[field.saveToJWT] = data[field.name]\n        } else if (field.saveToJWT) {\n          targetResult = field.name\n          result[field.name] = data[field.name]\n        }\n        const groupData: Record<string, unknown> = data[field.name] as Record<string, unknown>\n        const groupResult = (targetResult ? result[targetResult] : result) as Record<\n          string,\n          unknown\n        >\n        traverseFields({\n          data: groupData,\n          fields: field.fields,\n          result: groupResult,\n        })\n        break\n      }\n      case 'tabs': {\n        traverseFields({\n          data,\n          fields: field.tabs.map((tab) => ({ ...tab, type: 'tab' })),\n          result,\n        })\n        break\n      }\n      case 'tab': {\n        if (tabHasName(field)) {\n          let targetResult\n          if (typeof field.saveToJWT === 'string') {\n            targetResult = field.saveToJWT\n            result[field.saveToJWT] = data[field.name]\n          } else if (field.saveToJWT) {\n            targetResult = field.name\n            result[field.name] = data[field.name]\n          }\n          const tabData: Record<string, unknown> = data[field.name] as Record<string, unknown>\n          const tabResult = (targetResult ? result[targetResult] : result) as Record<\n            string,\n            unknown\n          >\n          traverseFields({\n            data: tabData,\n            fields: field.fields,\n            result: tabResult,\n          })\n        } else {\n          traverseFields({\n            data,\n            fields: field.fields,\n            result,\n          })\n        }\n        break\n      }\n      default:\n        if (fieldAffectsData(field)) {\n          if (field.saveToJWT) {\n            if (typeof field.saveToJWT === 'string') {\n              result[field.saveToJWT] = data[field.name]\n              delete result[field.name]\n            } else {\n              result[field.name] = data[field.name] as Record<string, unknown>\n            }\n          } else if (field.saveToJWT === false) {\n            delete result[field.name]\n          }\n        }\n    }\n  })\n  return result\n}\nexport const getFieldsToSign = (args: {\n  collectionConfig: CollectionConfig\n  email: string\n  user: PayloadRequest['user']\n}): Record<string, unknown> => {\n  const { collectionConfig, email, user } = args\n\n  const result: Record<string, unknown> = {\n    id: user.id,\n    collection: collectionConfig.slug,\n    email,\n  }\n\n  traverseFields({\n    data: user,\n    fields: collectionConfig.fields,\n    result,\n  })\n\n  return result\n}\n"],"names":["fieldAffectsData","tabHasName","traverseFields","data","fields","result","forEach","field","type","targetResult","saveToJWT","name","groupData","groupResult","tabs","map","tab","tabData","tabResult","getFieldsToSign","args","collectionConfig","email","user","id","collection","slug"],"mappings":"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"}},
    {"offset": {"line": 1832, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1838, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/payload/src/auth/jwt.ts"],"sourcesContent":["import { SignJWT } from 'jose'\n\nexport const jwtSign = async ({\n  fieldsToSign,\n  secret,\n  tokenExpiration,\n}: {\n  fieldsToSign: Record<string, unknown>\n  secret: string\n  tokenExpiration: number\n}) => {\n  const secretKey = new TextEncoder().encode(secret)\n  const issuedAt = Math.floor(Date.now() / 1000)\n  const exp = issuedAt + tokenExpiration\n  const token = await new SignJWT(fieldsToSign)\n    .setProtectedHeader({ alg: 'HS256', typ: 'JWT' })\n    .setIssuedAt(issuedAt)\n    .setExpirationTime(exp)\n    .sign(secretKey)\n  return { exp, token }\n}\n"],"names":["SignJWT","jwtSign","fieldsToSign","secret","tokenExpiration","secretKey","TextEncoder","encode","issuedAt","Math","floor","Date","now","exp","token","setProtectedHeader","alg","typ","setIssuedAt","setExpirationTime","sign"],"mappings":";;;AAAA,SAASA,OAAO,QAAQ,OAAM;;AAEvB,MAAMC,UAAU,OAAO,EAC5BC,YAAY,EACZC,MAAM,EACNC,eAAe,EAKhB;IACC,MAAMC,YAAY,IAAIC,cAAcC,MAAM,CAACJ;IAC3C,MAAMK,WAAWC,KAAKC,KAAK,CAACC,KAAKC,GAAG,KAAK;IACzC,MAAMC,MAAML,WAAWJ;IACvB,MAAMU,QAAQ,MAAM,+JAAId,UAAAA,CAAQE,cAC7Ba,kBAAkB,CAAC;QAAEC,KAAK;QAASC,KAAK;IAAM,GAC9CC,WAAW,CAACV,UACZW,iBAAiB,CAACN,KAClBO,IAAI,CAACf;IACR,OAAO;QAAEQ;QAAKC;IAAM;AACtB,EAAC"}},
    {"offset": {"line": 1856, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1862, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/payload/src/utilities/deepCopyObject.ts"],"sourcesContent":["import type { JsonValue } from '../types/index.js'\n\n/*\nMain deepCopyObject handling - from rfdc: https://github.com/davidmarkclements/rfdc/blob/master/index.js\n\nCopyright 2019 \"David Mark Clements <david.mark.clements@gmail.com>\"\n\nPermission is hereby granted, free of charge, to any person obtaining a copy of this software and associated\ndocumentation files (the \"Software\"), to deal in the Software without restriction, including without limitation\nthe rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and\nto permit persons to whom the Software is furnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all copies or substantial portions\nof the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED\nTO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL\nTHE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF\nCONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\nIN THE SOFTWARE.\n*/\n\nfunction copyBuffer(cur) {\n  if (cur instanceof Buffer) {\n    return Buffer.from(cur)\n  }\n\n  return new cur.constructor(cur.buffer.slice(), cur.byteOffset, cur.length)\n}\n\nconst constructorHandlers = new Map()\nconstructorHandlers.set(Date, (o) => new Date(o))\nconstructorHandlers.set(Map, (o, fn) => new Map(cloneArray<any>(Array.from(o), fn)))\nconstructorHandlers.set(Set, (o, fn) => new Set(cloneArray(Array.from(o), fn)))\nlet handler = null\n\nfunction cloneArray<T>(a: T, fn): T {\n  const keys = Object.keys(a)\n  const a2 = new Array(keys.length)\n  for (let i = 0; i < keys.length; i++) {\n    const k = keys[i]\n    const cur = a[k]\n    if (typeof cur !== 'object' || cur === null) {\n      a2[k] = cur\n    } else if (cur.constructor !== Object && (handler = constructorHandlers.get(cur.constructor))) {\n      a2[k] = handler(cur, fn)\n    } else if (ArrayBuffer.isView(cur)) {\n      a2[k] = copyBuffer(cur)\n    } else {\n      a2[k] = fn(cur)\n    }\n  }\n  return a2 as T\n}\n\nexport const deepCopyObject = <T>(o: T): T => {\n  if (typeof o !== 'object' || o === null) {\n    return o\n  }\n  if (Array.isArray(o)) {\n    return cloneArray(o, deepCopyObject)\n  }\n  if (o.constructor !== Object && (handler = constructorHandlers.get(o.constructor))) {\n    return handler(o, deepCopyObject)\n  }\n  const o2 = {}\n  for (const k in o) {\n    if (Object.hasOwnProperty.call(o, k) === false) {\n      continue\n    }\n    const cur = o[k]\n    if (typeof cur !== 'object' || cur === null) {\n      o2[k as string] = cur\n    } else if (cur.constructor !== Object && (handler = constructorHandlers.get(cur.constructor))) {\n      o2[k as string] = handler(cur, deepCopyObject)\n    } else if (ArrayBuffer.isView(cur)) {\n      o2[k as string] = copyBuffer(cur)\n    } else {\n      o2[k as string] = deepCopyObject(cur)\n    }\n  }\n  return o2 as T\n}\n\n/*\nFast deepCopyObjectSimple handling - from fast-json-clone: https://github.com/rhysd/fast-json-clone\n\nBenchmark: https://github.com/AlessioGr/fastest-deep-clone-json/blob/main/test/benchmark.js\n*/\n\n/**\n * A deepCopyObject implementation which only works for JSON objects and arrays, and is faster than\n * JSON.parse(JSON.stringify(obj))\n *\n * @param value The JSON value to be cloned. There are two invariants. 1) It must not contain circles\n *              as JSON does not allow it. This function will cause infinite loop for such values by\n *              design. 2) It must contain JSON values only. Other values like `Date`, `Regexp`, `Map`,\n *              `Set`, `Buffer`, ... are not allowed.\n * @returns The cloned JSON value.\n */\nexport function deepCopyObjectSimple<T extends JsonValue>(value: T): T {\n  if (typeof value !== 'object' || value === null) {\n    return value\n  } else if (Array.isArray(value)) {\n    return value.map((e) =>\n      typeof e !== 'object' || e === null ? e : deepCopyObjectSimple(e),\n    ) as T\n  } else {\n    if (value instanceof Date) {\n      return new Date(value) as unknown as T\n    }\n    const ret: { [key: string]: T } = {}\n    for (const k in value) {\n      const v = value[k]\n      ret[k] = typeof v !== 'object' || v === null ? v : (deepCopyObjectSimple(v as T) as any)\n    }\n    return ret as unknown as T\n  }\n}\n\n/**\n * A deepCopyObject implementation which is slower than deepCopyObject, but more correct.\n * Can be used if correctness is more important than speed. Supports circular dependencies\n */\nexport function deepCopyObjectComplex<T>(object: T, cache: WeakMap<any, any> = new WeakMap()): T {\n  if (object === null) {\n    return null\n  }\n\n  if (cache.has(object)) {\n    return cache.get(object)\n  }\n\n  // Handle Date\n  if (object instanceof Date) {\n    return new Date(object.getTime()) as unknown as T\n  }\n\n  // Handle RegExp\n  if (object instanceof RegExp) {\n    return new RegExp(object.source, object.flags) as unknown as T\n  }\n\n  // Handle Map\n  if (object instanceof Map) {\n    const clonedMap = new Map()\n    cache.set(object, clonedMap)\n    for (const [key, value] of object.entries()) {\n      clonedMap.set(key, deepCopyObjectComplex(value, cache))\n    }\n    return clonedMap as unknown as T\n  }\n\n  // Handle Set\n  if (object instanceof Set) {\n    const clonedSet = new Set()\n    cache.set(object, clonedSet)\n    for (const value of object.values()) {\n      clonedSet.add(deepCopyObjectComplex(value, cache))\n    }\n    return clonedSet as unknown as T\n  }\n\n  // Handle Array and Object\n  if (typeof object === 'object' && object !== null) {\n    if ('$$typeof' in object && typeof object.$$typeof === 'symbol') {\n      return object\n    }\n\n    const clonedObject: any = Array.isArray(object)\n      ? []\n      : Object.create(Object.getPrototypeOf(object))\n    cache.set(object, clonedObject)\n\n    for (const key in object) {\n      if (\n        Object.prototype.hasOwnProperty.call(object, key) ||\n        Object.getOwnPropertySymbols(object).includes(key as any)\n      ) {\n        clonedObject[key] = deepCopyObjectComplex(object[key], cache)\n      }\n    }\n\n    return clonedObject as T\n  }\n\n  // Handle all other cases\n  return object\n}\n"],"names":["copyBuffer","cur","Buffer","from","constructor","buffer","slice","byteOffset","length","constructorHandlers","Map","set","Date","o","fn","cloneArray","Array","Set","handler","a","keys","Object","a2","i","k","get","ArrayBuffer","isView","deepCopyObject","isArray","o2","hasOwnProperty","call","deepCopyObjectSimple","value","map","e","ret","v","deepCopyObjectComplex","object","cache","WeakMap","has","getTime","RegExp","source","flags","clonedMap","key","entries","clonedSet","values","add","$$typeof","clonedObject","create","getPrototypeOf","prototype","getOwnPropertySymbols","includes"],"mappings":"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"}},
    {"offset": {"line": 2009, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2015, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/payload/src/fields/getFieldPaths.ts"],"sourcesContent":["import type { Field, TabAsField } from './config/types.js'\n\nimport { tabHasName } from './config/types.js'\n\nexport function getFieldPaths({\n  field,\n  parentPath,\n  parentSchemaPath,\n}: {\n  field: Field | TabAsField\n  parentPath: (number | string)[]\n  parentSchemaPath: string[]\n}): {\n  path: (number | string)[]\n  schemaPath: string[]\n} {\n  if (field.type === 'tabs' || field.type === 'row' || field.type === 'collapsible') {\n    return {\n      path: parentPath,\n      schemaPath: parentSchemaPath,\n    }\n  } else if (field.type === 'tab') {\n    if (tabHasName(field)) {\n      return {\n        path: [...parentPath, field.name],\n        schemaPath: [...parentSchemaPath, field.name],\n      }\n    } else {\n      return {\n        path: parentPath,\n        schemaPath: parentSchemaPath,\n      }\n    }\n  }\n  const path = parentPath?.length ? [...parentPath, field.name] : [field.name]\n  const schemaPath = parentSchemaPath?.length ? [...parentSchemaPath, field.name] : [field.name]\n\n  return { path, schemaPath }\n}\n"],"names":["tabHasName","getFieldPaths","field","parentPath","parentSchemaPath","type","path","schemaPath","name","length"],"mappings":";;;AAEA,SAASA,UAAU,QAAQ,oBAAmB;;AAEvC,SAASC,cAAc,EAC5BC,KAAK,EACLC,UAAU,EACVC,gBAAgB,EAKjB;IAIC,IAAIF,MAAMG,IAAI,KAAK,UAAUH,MAAMG,IAAI,KAAK,SAASH,MAAMG,IAAI,KAAK,eAAe;QACjF,OAAO;YACLC,MAAMH;YACNI,YAAYH;QACd;IACF,OAAO,IAAIF,MAAMG,IAAI,KAAK,OAAO;QAC/B,qKAAIL,aAAAA,EAAWE,QAAQ;YACrB,OAAO;gBACLI,MAAM;uBAAIH;oBAAYD,MAAMM,IAAI;iBAAC;gBACjCD,YAAY;uBAAIH;oBAAkBF,MAAMM,IAAI;iBAAC;YAC/C;QACF,OAAO;YACL,OAAO;gBACLF,MAAMH;gBACNI,YAAYH;YACd;QACF;IACF;IACA,MAAME,OAAOH,YAAYM,SAAS;WAAIN;QAAYD,MAAMM,IAAI;KAAC,GAAG;QAACN,MAAMM,IAAI;KAAC;IAC5E,MAAMD,aAAaH,kBAAkBK,SAAS;WAAIL;QAAkBF,MAAMM,IAAI;KAAC,GAAG;QAACN,MAAMM,IAAI;KAAC;IAE9F,OAAO;QAAEF;QAAMC;IAAW;AAC5B"}},
    {"offset": {"line": 2062, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2068, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/payload/src/errors/MissingEditorProp.ts"],"sourcesContent":["import type { Field } from '../fields/config/types.js'\n\nimport { fieldAffectsData } from '../fields/config/types.js'\nimport { APIError } from './APIError.js'\n\nexport class MissingEditorProp extends APIError {\n  constructor(field: Field) {\n    super(\n      `RichText field${fieldAffectsData(field) ? ` \"${field.name}\"` : ''} is missing the editor prop. For sub-richText fields, the editor props is required, as it would otherwise create infinite recursion.`,\n    )\n  }\n}\n"],"names":["fieldAffectsData","APIError","MissingEditorProp","constructor","field","name"],"mappings":";;;AAEA,SAASA,gBAAgB,QAAQ,4BAA2B;AAC5D,SAASC,QAAQ,QAAQ,gBAAe;;;AAEjC,MAAMC,gLAA0BD,WAAAA;IACrCE,YAAYC,KAAY,CAAE;QACxB,KAAK,CACH,CAAC,cAAc,mKAAEJ,mBAAAA,EAAiBI,SAAS,CAAC,EAAE,EAAEA,MAAMC,IAAI,CAAC,CAAC,CAAC,GAAG,GAAG,oIAAoI,CAAC;IAE5M;AACF"}},
    {"offset": {"line": 2080, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2086, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/payload/src/fields/getDefaultValue.ts"],"sourcesContent":["import type { JsonValue, PayloadRequest } from '../types/index.js'\n\nimport { deepCopyObjectSimple } from '../utilities/deepCopyObject.js'\n\ntype Args = {\n  defaultValue: ((args: any) => JsonValue) | any\n  locale: string | undefined\n  user: PayloadRequest['user']\n  value?: JsonValue\n}\n\nexport const getDefaultValue = async ({\n  defaultValue,\n  locale,\n  user,\n  value,\n}: Args): Promise<JsonValue> => {\n  if (typeof value !== 'undefined') {\n    return value\n  }\n\n  if (defaultValue && typeof defaultValue === 'function') {\n    return await defaultValue({ locale, user })\n  }\n\n  if (typeof defaultValue === 'object') {\n    return deepCopyObjectSimple(defaultValue)\n  }\n\n  return defaultValue\n}\n"],"names":["deepCopyObjectSimple","getDefaultValue","defaultValue","locale","user","value"],"mappings":";;;AAEA,SAASA,oBAAoB,QAAQ,iCAAgC;;AAS9D,MAAMC,kBAAkB,OAAO,EACpCC,YAAY,EACZC,MAAM,EACNC,IAAI,EACJC,KAAK,EACA;IACL,IAAI,OAAOA,UAAU,aAAa;QAChC,OAAOA;IACT;IAEA,IAAIH,gBAAgB,OAAOA,iBAAiB,YAAY;QACtD,OAAO,MAAMA,aAAa;YAAEC;YAAQC;QAAK;IAC3C;IAEA,IAAI,OAAOF,iBAAiB,UAAU;QACpC,0KAAOF,uBAAAA,EAAqBE;IAC9B;IAEA,OAAOA;AACT,EAAC"}},
    {"offset": {"line": 2106, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2112, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/payload/src/fields/hooks/afterRead/relationshipPopulationPromise.ts"],"sourcesContent":["import type { PayloadRequest } from '../../../types/index.js'\nimport type { JoinField, RelationshipField, UploadField } from '../../config/types.js'\n\nimport { createDataloaderCacheKey } from '../../../collections/dataloader.js'\nimport { fieldHasMaxDepth, fieldSupportsMany } from '../../config/types.js'\n\ntype PopulateArgs = {\n  currentDepth: number\n  data: Record<string, unknown>\n  dataReference: Record<string, any>\n  depth: number\n  draft: boolean\n  fallbackLocale: null | string\n  field: JoinField | RelationshipField | UploadField\n  index?: number\n  key?: string\n  locale: null | string\n  overrideAccess: boolean\n  req: PayloadRequest\n  showHiddenFields: boolean\n}\n\nconst populate = async ({\n  currentDepth,\n  data,\n  dataReference,\n  depth,\n  draft,\n  fallbackLocale,\n  field,\n  index,\n  key,\n  locale,\n  overrideAccess,\n  req,\n  showHiddenFields,\n}: PopulateArgs) => {\n  const dataToUpdate = dataReference\n  let relation\n  if (field.type === 'join') {\n    relation = field.collection\n  } else {\n    relation = Array.isArray(field.relationTo) ? (data.relationTo as string) : field.relationTo\n  }\n  const relatedCollection = req.payload.collections[relation]\n\n  if (relatedCollection) {\n    let id = field.type !== 'join' && Array.isArray(field.relationTo) ? data.value : data\n    let relationshipValue\n    const shouldPopulate = depth && currentDepth <= depth\n\n    if (\n      typeof id !== 'string' &&\n      typeof id !== 'number' &&\n      typeof id?.toString === 'function' &&\n      typeof id !== 'object'\n    ) {\n      id = id.toString()\n    }\n\n    if (shouldPopulate) {\n      relationshipValue = await req.payloadDataLoader.load(\n        createDataloaderCacheKey({\n          collectionSlug: relatedCollection.config.slug,\n          currentDepth: currentDepth + 1,\n          depth,\n          docID: id as string,\n          draft,\n          fallbackLocale,\n          locale,\n          overrideAccess,\n          showHiddenFields,\n          transactionID: req.transactionID,\n        }),\n      )\n    }\n\n    if (!relationshipValue) {\n      // ids are visible regardless of access controls\n      relationshipValue = id\n    }\n    if (typeof index === 'number' && typeof key === 'string') {\n      if (field.type !== 'join' && Array.isArray(field.relationTo)) {\n        dataToUpdate[field.name][key][index].value = relationshipValue\n      } else {\n        dataToUpdate[field.name][key][index] = relationshipValue\n      }\n    } else if (typeof index === 'number' || typeof key === 'string') {\n      if (field.type === 'join') {\n        dataToUpdate[field.name].docs[index ?? key] = relationshipValue\n      } else if (Array.isArray(field.relationTo)) {\n        dataToUpdate[field.name][index ?? key].value = relationshipValue\n      } else {\n        dataToUpdate[field.name][index ?? key] = relationshipValue\n      }\n    } else if (field.type !== 'join' && Array.isArray(field.relationTo)) {\n      dataToUpdate[field.name].value = relationshipValue\n    } else {\n      dataToUpdate[field.name] = relationshipValue\n    }\n  }\n}\n\ntype PromiseArgs = {\n  currentDepth: number\n  depth: number\n  draft: boolean\n  fallbackLocale: null | string\n  field: JoinField | RelationshipField | UploadField\n  locale: null | string\n  overrideAccess: boolean\n  req: PayloadRequest\n  showHiddenFields: boolean\n  siblingDoc: Record<string, any>\n}\n\nexport const relationshipPopulationPromise = async ({\n  currentDepth,\n  depth,\n  draft,\n  fallbackLocale,\n  field,\n  locale,\n  overrideAccess,\n  req,\n  showHiddenFields,\n  siblingDoc,\n}: PromiseArgs): Promise<void> => {\n  const resultingDoc = siblingDoc\n  const populateDepth = fieldHasMaxDepth(field) && field.maxDepth < depth ? field.maxDepth : depth\n  const rowPromises = []\n\n  if (field.type === 'join' || (fieldSupportsMany(field) && field.hasMany)) {\n    if (\n      field.localized &&\n      locale === 'all' &&\n      typeof siblingDoc[field.name] === 'object' &&\n      siblingDoc[field.name] !== null\n    ) {\n      Object.keys(siblingDoc[field.name]).forEach((localeKey) => {\n        if (Array.isArray(siblingDoc[field.name][localeKey])) {\n          siblingDoc[field.name][localeKey].forEach((relatedDoc, index) => {\n            const rowPromise = async () => {\n              await populate({\n                currentDepth,\n                data: siblingDoc[field.name][localeKey][index],\n                dataReference: resultingDoc,\n                depth: populateDepth,\n                draft,\n                fallbackLocale,\n                field,\n                index,\n                key: localeKey,\n                locale,\n                overrideAccess,\n                req,\n                showHiddenFields,\n              })\n            }\n            rowPromises.push(rowPromise())\n          })\n        }\n      })\n    } else if (\n      Array.isArray(siblingDoc[field.name]) ||\n      Array.isArray(siblingDoc[field.name]?.docs)\n    ) {\n      ;(Array.isArray(siblingDoc[field.name])\n        ? siblingDoc[field.name]\n        : siblingDoc[field.name].docs\n      ).forEach((relatedDoc, index) => {\n        const rowPromise = async () => {\n          if (relatedDoc) {\n            await populate({\n              currentDepth,\n              data: relatedDoc?.id ? relatedDoc.id : relatedDoc,\n              dataReference: resultingDoc,\n              depth: populateDepth,\n              draft,\n              fallbackLocale,\n              field,\n              index,\n              locale,\n              overrideAccess,\n              req,\n              showHiddenFields,\n            })\n          }\n        }\n\n        rowPromises.push(rowPromise())\n      })\n    }\n  } else if (\n    field.localized &&\n    locale === 'all' &&\n    typeof siblingDoc[field.name] === 'object' &&\n    siblingDoc[field.name] !== null\n  ) {\n    Object.keys(siblingDoc[field.name]).forEach((localeKey) => {\n      const rowPromise = async () => {\n        await populate({\n          currentDepth,\n          data: siblingDoc[field.name][localeKey],\n          dataReference: resultingDoc,\n          depth: populateDepth,\n          draft,\n          fallbackLocale,\n          field,\n          key: localeKey,\n          locale,\n          overrideAccess,\n          req,\n          showHiddenFields,\n        })\n      }\n      rowPromises.push(rowPromise())\n    })\n\n    await Promise.all(rowPromises)\n  } else if (siblingDoc[field.name]) {\n    await populate({\n      currentDepth,\n      data: siblingDoc[field.name],\n      dataReference: resultingDoc,\n      depth: populateDepth,\n      draft,\n      fallbackLocale,\n      field,\n      locale,\n      overrideAccess,\n      req,\n      showHiddenFields,\n    })\n  }\n  await Promise.all(rowPromises)\n}\n"],"names":["createDataloaderCacheKey","fieldHasMaxDepth","fieldSupportsMany","populate","currentDepth","data","dataReference","depth","draft","fallbackLocale","field","index","key","locale","overrideAccess","req","showHiddenFields","dataToUpdate","relation","type","collection","Array","isArray","relationTo","relatedCollection","payload","collections","id","value","relationshipValue","shouldPopulate","toString","payloadDataLoader","load","collectionSlug","config","slug","docID","transactionID","name","docs","relationshipPopulationPromise","siblingDoc","resultingDoc","populateDepth","maxDepth","rowPromises","hasMany","localized","Object","keys","forEach","localeKey","relatedDoc","rowPromise","push","Promise","all"],"mappings":"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"}},
    {"offset": {"line": 2265, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2271, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/payload/src/fields/hooks/afterRead/promise.ts"],"sourcesContent":["import type { RichTextAdapter } from '../../../admin/RichText.js'\nimport type { SanitizedCollectionConfig } from '../../../collections/config/types.js'\nimport type { SanitizedGlobalConfig } from '../../../globals/config/types.js'\nimport type { JsonObject, PayloadRequest, RequestContext } from '../../../types/index.js'\nimport type { Field, TabAsField } from '../../config/types.js'\n\nimport { MissingEditorProp } from '../../../errors/index.js'\nimport { fieldAffectsData, tabHasName } from '../../config/types.js'\nimport { getDefaultValue } from '../../getDefaultValue.js'\nimport { getFieldPaths } from '../../getFieldPaths.js'\nimport { relationshipPopulationPromise } from './relationshipPopulationPromise.js'\nimport { traverseFields } from './traverseFields.js'\n\ntype Args = {\n  collection: null | SanitizedCollectionConfig\n  context: RequestContext\n  currentDepth: number\n  depth: number\n  doc: JsonObject\n  draft: boolean\n  fallbackLocale: null | string\n  field: Field | TabAsField\n  /**\n   * fieldPromises are used for things like field hooks. They should be awaited before awaiting populationPromises\n   */\n  fieldPromises: Promise<void>[]\n  findMany: boolean\n  flattenLocales: boolean\n  global: null | SanitizedGlobalConfig\n  locale: null | string\n  overrideAccess: boolean\n  /**\n   * The parent's path.\n   */\n  parentPath: (number | string)[]\n  /**\n   * The parent's schemaPath (path without indexes).\n   */\n  parentSchemaPath: string[]\n  populationPromises: Promise<void>[]\n  req: PayloadRequest\n  showHiddenFields: boolean\n  siblingDoc: JsonObject\n  triggerAccessControl?: boolean\n  triggerHooks?: boolean\n}\n\n// This function is responsible for the following actions, in order:\n// - Remove hidden fields from response\n// - Flatten locales into requested locale\n// - Sanitize outgoing data (point field, etc.)\n// - Execute field hooks\n// - Execute read access control\n// - Populate relationships\n\nexport const promise = async ({\n  collection,\n  context,\n  currentDepth,\n  depth,\n  doc,\n  draft,\n  fallbackLocale,\n  field,\n  fieldPromises,\n  findMany,\n  flattenLocales,\n  global,\n  locale,\n  overrideAccess,\n  parentPath,\n  parentSchemaPath,\n  populationPromises,\n  req,\n  showHiddenFields,\n  siblingDoc,\n  triggerAccessControl = true,\n  triggerHooks = true,\n}: Args): Promise<void> => {\n  const { path: fieldPath, schemaPath: fieldSchemaPath } = getFieldPaths({\n    field,\n    parentPath,\n    parentSchemaPath,\n  })\n\n  if (\n    fieldAffectsData(field) &&\n    field.hidden &&\n    typeof siblingDoc[field.name] !== 'undefined' &&\n    !showHiddenFields\n  ) {\n    delete siblingDoc[field.name]\n  }\n\n  const shouldHoistLocalizedValue =\n    flattenLocales &&\n    fieldAffectsData(field) &&\n    typeof siblingDoc[field.name] === 'object' &&\n    siblingDoc[field.name] !== null &&\n    field.localized &&\n    locale !== 'all' &&\n    req.payload.config.localization\n\n  if (shouldHoistLocalizedValue) {\n    // replace actual value with localized value before sanitizing\n    // { [locale]: fields } -> fields\n    const value = siblingDoc[field.name][locale]\n\n    let hoistedValue = value\n\n    if (fallbackLocale && fallbackLocale !== locale) {\n      const fallbackValue = siblingDoc[field.name][fallbackLocale]\n      const isNullOrUndefined = typeof value === 'undefined' || value === null\n\n      if (fallbackValue) {\n        switch (field.type) {\n          case 'text':\n          case 'textarea': {\n            if (value === '' || isNullOrUndefined) {\n              hoistedValue = fallbackValue\n            }\n            break\n          }\n\n          default: {\n            if (isNullOrUndefined) {\n              hoistedValue = fallbackValue\n            }\n            break\n          }\n        }\n      }\n    }\n\n    siblingDoc[field.name] = hoistedValue\n  }\n\n  // Sanitize outgoing field value\n  switch (field.type) {\n    case 'group': {\n      // Fill groups with empty objects so fields with hooks within groups can populate\n      // themselves virtually as necessary\n      if (typeof siblingDoc[field.name] === 'undefined') {\n        siblingDoc[field.name] = {}\n      }\n\n      break\n    }\n    case 'tabs': {\n      field.tabs.forEach((tab) => {\n        if (\n          tabHasName(tab) &&\n          (typeof siblingDoc[tab.name] === 'undefined' || siblingDoc[tab.name] === null)\n        ) {\n          siblingDoc[tab.name] = {}\n        }\n      })\n\n      break\n    }\n\n    case 'richText': {\n      if (!field?.editor) {\n        throw new MissingEditorProp(field) // while we allow disabling editor functionality, you should not have any richText fields defined if you do not have an editor\n      }\n      if (typeof field?.editor === 'function') {\n        throw new Error('Attempted to access unsanitized rich text editor.')\n      }\n\n      // Rich Text fields should use afterRead hooks to do population. The previous editor.populationPromises have been renamed to editor.graphQLPopulationPromises\n      break\n    }\n\n    case 'point': {\n      const pointDoc = siblingDoc[field.name] as Record<string, unknown>\n      if (Array.isArray(pointDoc?.coordinates) && pointDoc.coordinates.length === 2) {\n        siblingDoc[field.name] = pointDoc.coordinates\n      } else {\n        siblingDoc[field.name] = undefined\n      }\n\n      break\n    }\n\n    default: {\n      break\n    }\n  }\n\n  if (fieldAffectsData(field)) {\n    // Execute hooks\n    if (triggerHooks && field.hooks?.afterRead) {\n      await field.hooks.afterRead.reduce(async (priorHook, currentHook) => {\n        await priorHook\n\n        const shouldRunHookOnAllLocales =\n          field.localized &&\n          (locale === 'all' || !flattenLocales) &&\n          typeof siblingDoc[field.name] === 'object'\n\n        if (shouldRunHookOnAllLocales) {\n          const hookPromises = Object.entries(siblingDoc[field.name]).map(([locale, value]) =>\n            (async () => {\n              const hookedValue = await currentHook({\n                collection,\n                context,\n                currentDepth,\n                data: doc,\n                depth,\n                draft,\n                field,\n                findMany,\n                global,\n                operation: 'read',\n                originalDoc: doc,\n                overrideAccess,\n                path: fieldPath,\n                req,\n                schemaPath: fieldSchemaPath,\n                showHiddenFields,\n                siblingData: siblingDoc,\n                value,\n              })\n\n              if (hookedValue !== undefined) {\n                siblingDoc[field.name][locale] = hookedValue\n              }\n            })(),\n          )\n\n          await Promise.all(hookPromises)\n        } else {\n          const hookedValue = await currentHook({\n            collection,\n            context,\n            currentDepth,\n            data: doc,\n            depth,\n            draft,\n            field,\n            findMany,\n            global,\n            operation: 'read',\n            originalDoc: doc,\n            overrideAccess,\n            path: fieldPath,\n            req,\n            schemaPath: fieldSchemaPath,\n            showHiddenFields,\n            siblingData: siblingDoc,\n            value: siblingDoc[field.name],\n          })\n\n          if (hookedValue !== undefined) {\n            siblingDoc[field.name] = hookedValue\n          }\n        }\n      }, Promise.resolve())\n    }\n\n    // Execute access control\n    let allowDefaultValue = true\n    if (triggerAccessControl && field.access && field.access.read) {\n      const result = overrideAccess\n        ? true\n        : await field.access.read({\n            id: doc.id as number | string,\n            data: doc,\n            doc,\n            req,\n            siblingData: siblingDoc,\n          })\n\n      if (!result) {\n        allowDefaultValue = false\n        delete siblingDoc[field.name]\n      }\n    }\n\n    // Set defaultValue on the field for globals being returned without being first created\n    // or collection documents created prior to having a default\n    if (\n      allowDefaultValue &&\n      typeof siblingDoc[field.name] === 'undefined' &&\n      typeof field.defaultValue !== 'undefined'\n    ) {\n      siblingDoc[field.name] = await getDefaultValue({\n        defaultValue: field.defaultValue,\n        locale,\n        user: req.user,\n        value: siblingDoc[field.name],\n      })\n    }\n\n    if (field.type === 'relationship' || field.type === 'upload' || field.type === 'join') {\n      populationPromises.push(\n        relationshipPopulationPromise({\n          currentDepth,\n          depth,\n          draft,\n          fallbackLocale,\n          field,\n          locale,\n          overrideAccess,\n          req,\n          showHiddenFields,\n          siblingDoc,\n        }),\n      )\n    }\n  }\n\n  switch (field.type) {\n    case 'group': {\n      let groupDoc = siblingDoc[field.name] as JsonObject\n      if (typeof siblingDoc[field.name] !== 'object') {\n        groupDoc = {}\n      }\n\n      traverseFields({\n        collection,\n        context,\n        currentDepth,\n        depth,\n        doc,\n        draft,\n        fallbackLocale,\n        fieldPromises,\n        fields: field.fields,\n        findMany,\n        flattenLocales,\n        global,\n        locale,\n        overrideAccess,\n        path: fieldPath,\n        populationPromises,\n        req,\n        schemaPath: fieldSchemaPath,\n        showHiddenFields,\n        siblingDoc: groupDoc,\n        triggerAccessControl,\n        triggerHooks,\n      })\n\n      break\n    }\n\n    case 'array': {\n      const rows = siblingDoc[field.name] as JsonObject\n\n      if (Array.isArray(rows)) {\n        rows.forEach((row, i) => {\n          traverseFields({\n            collection,\n            context,\n            currentDepth,\n            depth,\n            doc,\n            draft,\n            fallbackLocale,\n            fieldPromises,\n            fields: field.fields,\n            findMany,\n            flattenLocales,\n            global,\n            locale,\n            overrideAccess,\n            path: [...fieldPath, i],\n            populationPromises,\n            req,\n            schemaPath: fieldSchemaPath,\n            showHiddenFields,\n            siblingDoc: row || {},\n            triggerAccessControl,\n            triggerHooks,\n          })\n        })\n      } else if (!shouldHoistLocalizedValue && typeof rows === 'object' && rows !== null) {\n        Object.values(rows).forEach((localeRows) => {\n          if (Array.isArray(localeRows)) {\n            localeRows.forEach((row, i) => {\n              traverseFields({\n                collection,\n                context,\n                currentDepth,\n                depth,\n                doc,\n                draft,\n                fallbackLocale,\n                fieldPromises,\n                fields: field.fields,\n                findMany,\n                flattenLocales,\n                global,\n                locale,\n                overrideAccess,\n                path: [...fieldPath, i],\n                populationPromises,\n                req,\n                schemaPath: fieldSchemaPath,\n                showHiddenFields,\n                siblingDoc: (row as JsonObject) || {},\n                triggerAccessControl,\n                triggerHooks,\n              })\n            })\n          }\n        })\n      } else {\n        siblingDoc[field.name] = []\n      }\n      break\n    }\n\n    case 'blocks': {\n      const rows = siblingDoc[field.name]\n\n      if (Array.isArray(rows)) {\n        rows.forEach((row, i) => {\n          const block = field.blocks.find(\n            (blockType) => blockType.slug === (row as JsonObject).blockType,\n          )\n\n          if (block) {\n            traverseFields({\n              collection,\n              context,\n              currentDepth,\n              depth,\n              doc,\n              draft,\n              fallbackLocale,\n              fieldPromises,\n              fields: block.fields,\n              findMany,\n              flattenLocales,\n              global,\n              locale,\n              overrideAccess,\n              path: [...fieldPath, i],\n              populationPromises,\n              req,\n              schemaPath: fieldSchemaPath,\n              showHiddenFields,\n              siblingDoc: (row as JsonObject) || {},\n              triggerAccessControl,\n              triggerHooks,\n            })\n          }\n        })\n      } else if (!shouldHoistLocalizedValue && typeof rows === 'object' && rows !== null) {\n        Object.values(rows).forEach((localeRows) => {\n          if (Array.isArray(localeRows)) {\n            localeRows.forEach((row, i) => {\n              const block = field.blocks.find(\n                (blockType) => blockType.slug === (row as JsonObject).blockType,\n              )\n\n              if (block) {\n                traverseFields({\n                  collection,\n                  context,\n                  currentDepth,\n                  depth,\n                  doc,\n                  draft,\n                  fallbackLocale,\n                  fieldPromises,\n                  fields: block.fields,\n                  findMany,\n                  flattenLocales,\n                  global,\n                  locale,\n                  overrideAccess,\n                  path: [...fieldPath, i],\n                  populationPromises,\n                  req,\n                  schemaPath: fieldSchemaPath,\n                  showHiddenFields,\n                  siblingDoc: (row as JsonObject) || {},\n                  triggerAccessControl,\n                  triggerHooks,\n                })\n              }\n            })\n          }\n        })\n      } else {\n        siblingDoc[field.name] = []\n      }\n\n      break\n    }\n\n    case 'row':\n    case 'collapsible': {\n      traverseFields({\n        collection,\n        context,\n        currentDepth,\n        depth,\n        doc,\n        draft,\n        fallbackLocale,\n        fieldPromises,\n        fields: field.fields,\n        findMany,\n        flattenLocales,\n        global,\n        locale,\n        overrideAccess,\n        path: fieldPath,\n        populationPromises,\n        req,\n        schemaPath: fieldSchemaPath,\n        showHiddenFields,\n        siblingDoc,\n        triggerAccessControl,\n        triggerHooks,\n      })\n\n      break\n    }\n\n    case 'tab': {\n      let tabDoc = siblingDoc\n      if (tabHasName(field)) {\n        tabDoc = siblingDoc[field.name] as JsonObject\n        if (typeof siblingDoc[field.name] !== 'object') {\n          tabDoc = {}\n        }\n      }\n\n      traverseFields({\n        collection,\n        context,\n        currentDepth,\n        depth,\n        doc,\n        draft,\n        fallbackLocale,\n        fieldPromises,\n        fields: field.fields,\n        findMany,\n        flattenLocales,\n        global,\n        locale,\n        overrideAccess,\n        path: fieldPath,\n        populationPromises,\n        req,\n        schemaPath: fieldSchemaPath,\n        showHiddenFields,\n        siblingDoc: tabDoc,\n        triggerAccessControl,\n        triggerHooks,\n      })\n\n      break\n    }\n\n    case 'tabs': {\n      traverseFields({\n        collection,\n        context,\n        currentDepth,\n        depth,\n        doc,\n        draft,\n        fallbackLocale,\n        fieldPromises,\n        fields: field.tabs.map((tab) => ({ ...tab, type: 'tab' })),\n        findMany,\n        flattenLocales,\n        global,\n        locale,\n        overrideAccess,\n        path: fieldPath,\n        populationPromises,\n        req,\n        schemaPath: fieldSchemaPath,\n        showHiddenFields,\n        siblingDoc,\n        triggerAccessControl,\n        triggerHooks,\n      })\n      break\n    }\n\n    case 'richText': {\n      if (!field?.editor) {\n        throw new MissingEditorProp(field) // while we allow disabling editor functionality, you should not have any richText fields defined if you do not have an editor\n      }\n      if (typeof field?.editor === 'function') {\n        throw new Error('Attempted to access unsanitized rich text editor.')\n      }\n\n      const editor: RichTextAdapter = field?.editor\n\n      if (editor?.hooks?.afterRead?.length) {\n        await editor.hooks.afterRead.reduce(async (priorHook, currentHook) => {\n          await priorHook\n\n          const shouldRunHookOnAllLocales =\n            field.localized &&\n            (locale === 'all' || !flattenLocales) &&\n            typeof siblingDoc[field.name] === 'object'\n\n          if (shouldRunHookOnAllLocales) {\n            const hookPromises = Object.entries(siblingDoc[field.name]).map(([locale, value]) =>\n              (async () => {\n                const hookedValue = await currentHook({\n                  collection,\n                  context,\n                  currentDepth,\n                  data: doc,\n                  depth,\n                  draft,\n                  fallbackLocale,\n                  field,\n                  fieldPromises,\n                  findMany,\n                  flattenLocales,\n                  global,\n                  locale,\n                  operation: 'read',\n                  originalDoc: doc,\n                  overrideAccess,\n                  path: fieldPath,\n                  populationPromises,\n                  req,\n                  schemaPath: fieldSchemaPath,\n                  showHiddenFields,\n                  siblingData: siblingDoc,\n                  triggerAccessControl,\n                  triggerHooks,\n                  value,\n                })\n\n                if (hookedValue !== undefined) {\n                  siblingDoc[field.name][locale] = hookedValue\n                }\n              })(),\n            )\n\n            await Promise.all(hookPromises)\n          } else {\n            const hookedValue = await currentHook({\n              collection,\n              context,\n              currentDepth,\n              data: doc,\n              depth,\n              draft,\n              fallbackLocale,\n              field,\n              fieldPromises,\n              findMany,\n              flattenLocales,\n              global,\n              locale,\n              operation: 'read',\n              originalDoc: doc,\n              overrideAccess,\n              path: fieldPath,\n              populationPromises,\n              req,\n              schemaPath: fieldSchemaPath,\n              showHiddenFields,\n              siblingData: siblingDoc,\n              triggerAccessControl,\n              triggerHooks,\n              value: siblingDoc[field.name],\n            })\n\n            if (hookedValue !== undefined) {\n              siblingDoc[field.name] = hookedValue\n            }\n          }\n        }, Promise.resolve())\n      }\n      break\n    }\n\n    default: {\n      break\n    }\n  }\n}\n"],"names":["MissingEditorProp","fieldAffectsData","tabHasName","getDefaultValue","getFieldPaths","relationshipPopulationPromise","traverseFields","promise","collection","context","currentDepth","depth","doc","draft","fallbackLocale","field","fieldPromises","findMany","flattenLocales","global","locale","overrideAccess","parentPath","parentSchemaPath","populationPromises","req","showHiddenFields","siblingDoc","triggerAccessControl","triggerHooks","path","fieldPath","schemaPath","fieldSchemaPath","hidden","name","shouldHoistLocalizedValue","localized","payload","config","localization","value","hoistedValue","fallbackValue","isNullOrUndefined","type","tabs","forEach","tab","editor","Error","pointDoc","Array","isArray","coordinates","length","undefined","hooks","afterRead","reduce","priorHook","currentHook","shouldRunHookOnAllLocales","hookPromises","Object","entries","map","hookedValue","data","operation","originalDoc","siblingData","Promise","all","resolve","allowDefaultValue","access","read","result","id","defaultValue","user","push","groupDoc","fields","rows","row","i","values","localeRows","block","blocks","find","blockType","slug","tabDoc"],"mappings":"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"}},
    {"offset": {"line": 2840, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2846, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/payload/src/fields/hooks/afterRead/traverseFields.ts"],"sourcesContent":["import type { SanitizedCollectionConfig } from '../../../collections/config/types.js'\nimport type { SanitizedGlobalConfig } from '../../../globals/config/types.js'\nimport type { JsonObject, PayloadRequest, RequestContext } from '../../../types/index.js'\nimport type { Field, TabAsField } from '../../config/types.js'\n\nimport { promise } from './promise.js'\n\ntype Args = {\n  collection: null | SanitizedCollectionConfig\n  context: RequestContext\n  currentDepth: number\n  depth: number\n  doc: JsonObject\n  draft: boolean\n  fallbackLocale: null | string\n  /**\n   * fieldPromises are used for things like field hooks. They should be awaited before awaiting populationPromises\n   */\n  fieldPromises: Promise<void>[]\n  fields: (Field | TabAsField)[]\n  findMany: boolean\n  flattenLocales: boolean\n  global: null | SanitizedGlobalConfig\n  locale: null | string\n  overrideAccess: boolean\n  path: (number | string)[]\n  populationPromises: Promise<void>[]\n  req: PayloadRequest\n  schemaPath: string[]\n  showHiddenFields: boolean\n  siblingDoc: JsonObject\n  triggerAccessControl?: boolean\n  triggerHooks?: boolean\n}\n\nexport const traverseFields = ({\n  collection,\n  context,\n  currentDepth,\n  depth,\n  doc,\n  draft,\n  fallbackLocale,\n  fieldPromises,\n  fields,\n  findMany,\n  flattenLocales,\n  global,\n  locale,\n  overrideAccess,\n  path,\n  populationPromises,\n  req,\n  schemaPath,\n  showHiddenFields,\n  siblingDoc,\n  triggerAccessControl = true,\n  triggerHooks = true,\n}: Args): void => {\n  fields.forEach((field) => {\n    fieldPromises.push(\n      promise({\n        collection,\n        context,\n        currentDepth,\n        depth,\n        doc,\n        draft,\n        fallbackLocale,\n        field,\n        fieldPromises,\n        findMany,\n        flattenLocales,\n        global,\n        locale,\n        overrideAccess,\n        parentPath: path,\n        parentSchemaPath: schemaPath,\n        populationPromises,\n        req,\n        showHiddenFields,\n        siblingDoc,\n        triggerAccessControl,\n        triggerHooks,\n      }),\n    )\n  })\n}\n"],"names":["promise","traverseFields","collection","context","currentDepth","depth","doc","draft","fallbackLocale","fieldPromises","fields","findMany","flattenLocales","global","locale","overrideAccess","path","populationPromises","req","schemaPath","showHiddenFields","siblingDoc","triggerAccessControl","triggerHooks","forEach","field","push","parentPath","parentSchemaPath"],"mappings":";;;AAKA,SAASA,OAAO,QAAQ,eAAc;;AA8B/B,MAAMC,iBAAiB,CAAC,EAC7BC,UAAU,EACVC,OAAO,EACPC,YAAY,EACZC,KAAK,EACLC,GAAG,EACHC,KAAK,EACLC,cAAc,EACdC,aAAa,EACbC,MAAM,EACNC,QAAQ,EACRC,cAAc,EACdC,MAAM,EACNC,MAAM,EACNC,cAAc,EACdC,IAAI,EACJC,kBAAkB,EAClBC,GAAG,EACHC,UAAU,EACVC,gBAAgB,EAChBC,UAAU,EACVC,uBAAuB,IAAI,EAC3BC,eAAe,IAAI,EACd;IACLb,OAAOc,OAAO,CAAC,CAACC;QACdhB,cAAciB,IAAI,gLAChB1B,UAAAA,EAAQ;YACNE;YACAC;YACAC;YACAC;YACAC;YACAC;YACAC;YACAiB;YACAhB;YACAE;YACAC;YACAC;YACAC;YACAC;YACAY,YAAYX;YACZY,kBAAkBT;YAClBF;YACAC;YACAE;YACAC;YACAC;YACAC;QACF;IAEJ;AACF,EAAC"}},
    {"offset": {"line": 2879, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2885, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/payload/src/fields/hooks/afterRead/index.ts"],"sourcesContent":["import type { SanitizedCollectionConfig } from '../../../collections/config/types.js'\nimport type { SanitizedGlobalConfig } from '../../../globals/config/types.js'\nimport type { JsonObject, PayloadRequest, RequestContext } from '../../../types/index.js'\n\nimport { deepCopyObjectSimple } from '../../../utilities/deepCopyObject.js'\nimport { traverseFields } from './traverseFields.js'\n\ntype Args<T extends JsonObject> = {\n  collection: null | SanitizedCollectionConfig\n  context: RequestContext\n  currentDepth?: number\n  depth: number\n  doc: T\n  draft: boolean\n  fallbackLocale: null | string\n  findMany?: boolean\n  flattenLocales?: boolean\n  global: null | SanitizedGlobalConfig\n  locale: string\n  overrideAccess: boolean\n  req: PayloadRequest\n  showHiddenFields: boolean\n}\n\n/**\n * This function is responsible for the following actions, in order:\n * - Remove hidden fields from response\n * - Flatten locales into requested locale. If the input doc contains all locales, the output doc after this function will only contain the requested locale.\n * - Sanitize outgoing data (point field, etc.)\n * - Execute field hooks\n * - Execute read access control\n * - Populate relationships\n */\n\nexport async function afterRead<T extends JsonObject>(args: Args<T>): Promise<T> {\n  const {\n    collection,\n    context,\n    currentDepth: incomingCurrentDepth,\n    depth: incomingDepth,\n    doc: incomingDoc,\n    draft,\n    fallbackLocale,\n    findMany,\n    flattenLocales = true,\n    global,\n    locale,\n    overrideAccess,\n    req,\n    showHiddenFields,\n  } = args\n\n  const doc = deepCopyObjectSimple(incomingDoc)\n  const fieldPromises = []\n  const populationPromises = []\n\n  let depth =\n    incomingDepth || incomingDepth === 0\n      ? parseInt(String(incomingDepth), 10)\n      : req.payload.config.defaultDepth\n  if (depth > req.payload.config.maxDepth) {\n    depth = req.payload.config.maxDepth\n  }\n\n  const currentDepth = incomingCurrentDepth || 1\n\n  traverseFields({\n    collection,\n    context,\n    currentDepth,\n    depth,\n    doc,\n    draft,\n    fallbackLocale,\n    fieldPromises,\n    fields: collection?.fields || global?.fields,\n    findMany,\n    flattenLocales,\n    global,\n    locale,\n    overrideAccess,\n    path: [],\n    populationPromises,\n    req,\n    schemaPath: [],\n    showHiddenFields,\n    siblingDoc: doc,\n  })\n\n  await Promise.all(fieldPromises)\n  await Promise.all(populationPromises)\n\n  return doc\n}\n"],"names":["deepCopyObjectSimple","traverseFields","afterRead","args","collection","context","currentDepth","incomingCurrentDepth","depth","incomingDepth","doc","incomingDoc","draft","fallbackLocale","findMany","flattenLocales","global","locale","overrideAccess","req","showHiddenFields","fieldPromises","populationPromises","parseInt","String","payload","config","defaultDepth","maxDepth","fields","path","schemaPath","siblingDoc","Promise","all"],"mappings":";;;AAIA,SAASA,oBAAoB,QAAQ,uCAAsC;AAC3E,SAASC,cAAc,QAAQ,sBAAqB;;;AA6B7C,eAAeC,UAAgCC,IAAa;IACjE,MAAM,EACJC,UAAU,EACVC,OAAO,EACPC,cAAcC,oBAAoB,EAClCC,OAAOC,aAAa,EACpBC,KAAKC,WAAW,EAChBC,KAAK,EACLC,cAAc,EACdC,QAAQ,EACRC,iBAAiB,IAAI,EACrBC,MAAM,EACNC,MAAM,EACNC,cAAc,EACdC,GAAG,EACHC,gBAAgB,EACjB,GAAGjB;IAEJ,MAAMO,OAAMV,yLAAAA,EAAqBW;IACjC,MAAMU,gBAAgB,EAAE;IACxB,MAAMC,qBAAqB,EAAE;IAE7B,IAAId,QACFC,iBAAiBA,kBAAkB,IAC/Bc,SAASC,OAAOf,gBAAgB,MAChCU,IAAIM,OAAO,CAACC,MAAM,CAACC,YAAY;IACrC,IAAInB,QAAQW,IAAIM,OAAO,CAACC,MAAM,CAACE,QAAQ,EAAE;QACvCpB,QAAQW,IAAIM,OAAO,CAACC,MAAM,CAACE,QAAQ;IACrC;IAEA,MAAMtB,eAAeC,wBAAwB;KAE7CN,sMAAAA,EAAe;QACbG;QACAC;QACAC;QACAE;QACAE;QACAE;QACAC;QACAQ;QACAQ,QAAQzB,YAAYyB,UAAUb,QAAQa;QACtCf;QACAC;QACAC;QACAC;QACAC;QACAY,MAAM,EAAE;QACRR;QACAH;QACAY,YAAY,EAAE;QACdX;QACAY,YAAYtB;IACd;IAEA,MAAMuB,QAAQC,GAAG,CAACb;IAClB,MAAMY,QAAQC,GAAG,CAACZ;IAElB,OAAOZ;AACT"}},
    {"offset": {"line": 2928, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2934, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/payload/src/auth/operations/login.ts"],"sourcesContent":["import type {\n  AuthOperationsFromCollectionSlug,\n  Collection,\n  DataFromCollectionSlug,\n} from '../../collections/config/types.js'\nimport type { CollectionSlug } from '../../index.js'\nimport type { PayloadRequest, Where } from '../../types/index.js'\nimport type { User } from '../types.js'\n\nimport { buildAfterOperation } from '../../collections/operations/utils.js'\nimport { AuthenticationError, LockedAuth, ValidationError } from '../../errors/index.js'\nimport { afterRead } from '../../fields/hooks/afterRead/index.js'\nimport { killTransaction } from '../../utilities/killTransaction.js'\nimport sanitizeInternalFields from '../../utilities/sanitizeInternalFields.js'\nimport { getFieldsToSign } from '../getFieldsToSign.js'\nimport isLocked from '../isLocked.js'\nimport { jwtSign } from '../jwt.js'\nimport { authenticateLocalStrategy } from '../strategies/local/authenticate.js'\nimport { incrementLoginAttempts } from '../strategies/local/incrementLoginAttempts.js'\nimport { resetLoginAttempts } from '../strategies/local/resetLoginAttempts.js'\n\nexport type Result = {\n  exp?: number\n  token?: string\n  user?: User\n}\n\nexport type Arguments<TSlug extends CollectionSlug> = {\n  collection: Collection\n  data: AuthOperationsFromCollectionSlug<TSlug>['login']\n  depth?: number\n  overrideAccess?: boolean\n  req: PayloadRequest\n  showHiddenFields?: boolean\n}\n\nexport const loginOperation = async <TSlug extends CollectionSlug>(\n  incomingArgs: Arguments<TSlug>,\n): Promise<{ user: DataFromCollectionSlug<TSlug> } & Result> => {\n  let args = incomingArgs\n\n  try {\n    // /////////////////////////////////////\n    // beforeOperation - Collection\n    // /////////////////////////////////////\n\n    await args.collection.config.hooks.beforeOperation.reduce(async (priorHook, hook) => {\n      await priorHook\n\n      args =\n        (await hook({\n          args,\n          collection: args.collection?.config,\n          context: args.req.context,\n          operation: 'login',\n          req: args.req,\n        })) || args\n    }, Promise.resolve())\n\n    const {\n      collection: { config: collectionConfig },\n      data,\n      depth,\n      overrideAccess,\n      req,\n      req: {\n        fallbackLocale,\n        locale,\n        payload,\n        payload: { secret },\n      },\n      showHiddenFields,\n    } = args\n\n    // /////////////////////////////////////\n    // Login\n    // /////////////////////////////////////\n\n    let user\n    const { email: unsanitizedEmail, password } = data\n    const loginWithUsername = collectionConfig.auth.loginWithUsername\n\n    const sanitizedEmail =\n      typeof unsanitizedEmail === 'string' ? unsanitizedEmail.toLowerCase().trim() : null\n    const sanitizedUsername =\n      'username' in data && typeof data?.username === 'string'\n        ? data.username.toLowerCase().trim()\n        : null\n\n    const canLoginWithUsername = Boolean(loginWithUsername)\n    const canLoginWithEmail = !loginWithUsername || loginWithUsername.allowEmailLogin\n\n    // cannot login with email, did not provide username\n    if (!canLoginWithEmail && !sanitizedUsername) {\n      throw new ValidationError({\n        collection: collectionConfig.slug,\n        errors: [{ field: 'username', message: req.i18n.t('validation:required') }],\n      })\n    }\n\n    // cannot login with username, did not provide email\n    if (!canLoginWithUsername && !sanitizedEmail) {\n      throw new ValidationError({\n        collection: collectionConfig.slug,\n        errors: [{ field: 'email', message: req.i18n.t('validation:required') }],\n      })\n    }\n\n    // can login with either email or username, did not provide either\n    if (!sanitizedUsername && !sanitizedEmail) {\n      throw new ValidationError({\n        collection: collectionConfig.slug,\n        errors: [\n          { field: 'email', message: req.i18n.t('validation:required') },\n          { field: 'username', message: req.i18n.t('validation:required') },\n        ],\n      })\n    }\n\n    // did not provide password for login\n    if (typeof password !== 'string' || password.trim() === '') {\n      throw new ValidationError({\n        collection: collectionConfig.slug,\n        errors: [{ field: 'password', message: req.i18n.t('validation:required') }],\n      })\n    }\n\n    let whereConstraint: Where = {}\n    const emailConstraint: Where = {\n      email: {\n        equals: sanitizedEmail,\n      },\n    }\n    const usernameConstraint: Where = {\n      username: {\n        equals: sanitizedUsername,\n      },\n    }\n\n    if (canLoginWithEmail && canLoginWithUsername && (sanitizedUsername || sanitizedEmail)) {\n      if (sanitizedUsername) {\n        whereConstraint = {\n          or: [\n            usernameConstraint,\n            {\n              email: {\n                equals: sanitizedUsername,\n              },\n            },\n          ],\n        }\n      } else {\n        whereConstraint = {\n          or: [\n            emailConstraint,\n            {\n              username: {\n                equals: sanitizedEmail,\n              },\n            },\n          ],\n        }\n      }\n    } else if (canLoginWithEmail && sanitizedEmail) {\n      whereConstraint = emailConstraint\n    } else if (canLoginWithUsername && sanitizedUsername) {\n      whereConstraint = usernameConstraint\n    }\n\n    user = await payload.db.findOne<any>({\n      collection: collectionConfig.slug,\n      req,\n      where: whereConstraint,\n    })\n\n    if (!user || (args.collection.config.auth.verify && user._verified === false)) {\n      throw new AuthenticationError(req.t, Boolean(canLoginWithUsername && sanitizedUsername))\n    }\n\n    user.collection = collectionConfig.slug\n\n    if (isLocked(new Date(user.lockUntil).getTime())) {\n      throw new LockedAuth(req.t)\n    }\n\n    const authResult = await authenticateLocalStrategy({ doc: user, password })\n\n    user = sanitizeInternalFields(user)\n\n    const maxLoginAttemptsEnabled = args.collection.config.auth.maxLoginAttempts > 0\n\n    if (!authResult) {\n      if (maxLoginAttemptsEnabled) {\n        await incrementLoginAttempts({\n          collection: collectionConfig,\n          doc: user,\n          payload: req.payload,\n          req,\n        })\n      }\n\n      throw new AuthenticationError(req.t)\n    }\n\n    if (maxLoginAttemptsEnabled) {\n      await resetLoginAttempts({\n        collection: collectionConfig,\n        doc: user,\n        payload: req.payload,\n        req,\n      })\n    }\n\n    const fieldsToSign = getFieldsToSign({\n      collectionConfig,\n      email: sanitizedEmail,\n      user,\n    })\n\n    // /////////////////////////////////////\n    // beforeLogin - Collection\n    // /////////////////////////////////////\n\n    await collectionConfig.hooks.beforeLogin.reduce(async (priorHook, hook) => {\n      await priorHook\n\n      user =\n        (await hook({\n          collection: args.collection?.config,\n          context: args.req.context,\n          req: args.req,\n          user,\n        })) || user\n    }, Promise.resolve())\n\n    const { exp, token } = await jwtSign({\n      fieldsToSign,\n      secret,\n      tokenExpiration: collectionConfig.auth.tokenExpiration,\n    })\n\n    req.user = user\n\n    // /////////////////////////////////////\n    // afterLogin - Collection\n    // /////////////////////////////////////\n\n    await collectionConfig.hooks.afterLogin.reduce(async (priorHook, hook) => {\n      await priorHook\n\n      user =\n        (await hook({\n          collection: args.collection?.config,\n          context: args.req.context,\n          req: args.req,\n          token,\n          user,\n        })) || user\n    }, Promise.resolve())\n\n    // /////////////////////////////////////\n    // afterRead - Fields\n    // /////////////////////////////////////\n\n    user = await afterRead({\n      collection: collectionConfig,\n      context: req.context,\n      depth,\n      doc: user,\n      draft: undefined,\n      fallbackLocale,\n      global: null,\n      locale,\n      overrideAccess,\n      req,\n      showHiddenFields,\n    })\n\n    // /////////////////////////////////////\n    // afterRead - Collection\n    // /////////////////////////////////////\n\n    await collectionConfig.hooks.afterRead.reduce(async (priorHook, hook) => {\n      await priorHook\n\n      user =\n        (await hook({\n          collection: args.collection?.config,\n          context: req.context,\n          doc: user,\n          req,\n        })) || user\n    }, Promise.resolve())\n\n    // /////////////////////////////////////\n    // afterRead - Collection\n    // /////////////////////////////////////\n\n    await collectionConfig.hooks.afterRead.reduce(async (priorHook, hook) => {\n      await priorHook\n\n      user =\n        (await hook({\n          collection: args.collection?.config,\n          context: req.context,\n          doc: user,\n          req,\n        })) || user\n    }, Promise.resolve())\n\n    let result: { user: DataFromCollectionSlug<TSlug> } & Result = {\n      exp,\n      token,\n      user,\n    }\n\n    // /////////////////////////////////////\n    // afterOperation - Collection\n    // /////////////////////////////////////\n\n    result = await buildAfterOperation({\n      args,\n      collection: args.collection?.config,\n      operation: 'login',\n      result,\n    })\n\n    // /////////////////////////////////////\n    // Return results\n    // /////////////////////////////////////\n\n    return result\n  } catch (error: unknown) {\n    await killTransaction(args.req)\n    throw error\n  }\n}\n"],"names":["buildAfterOperation","AuthenticationError","LockedAuth","ValidationError","afterRead","killTransaction","sanitizeInternalFields","getFieldsToSign","isLocked","jwtSign","authenticateLocalStrategy","incrementLoginAttempts","resetLoginAttempts","loginOperation","incomingArgs","args","collection","config","hooks","beforeOperation","reduce","priorHook","hook","context","req","operation","Promise","resolve","collectionConfig","data","depth","overrideAccess","fallbackLocale","locale","payload","secret","showHiddenFields","user","email","unsanitizedEmail","password","loginWithUsername","auth","sanitizedEmail","toLowerCase","trim","sanitizedUsername","username","canLoginWithUsername","Boolean","canLoginWithEmail","allowEmailLogin","slug","errors","field","message","i18n","t","whereConstraint","emailConstraint","equals","usernameConstraint","or","db","findOne","where","verify","_verified","Date","lockUntil","getTime","authResult","doc","maxLoginAttemptsEnabled","maxLoginAttempts","fieldsToSign","beforeLogin","exp","token","tokenExpiration","afterLogin","draft","undefined","global","result","error"],"mappings":"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"}},
    {"offset": {"line": 3216, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 3222, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/payload/src/auth/operations/local/login.ts"],"sourcesContent":["import type {\n  AuthOperationsFromCollectionSlug,\n  CollectionSlug,\n  DataFromCollectionSlug,\n  Payload,\n  RequestContext,\n} from '../../../index.js'\nimport type { PayloadRequest } from '../../../types/index.js'\nimport type { Result } from '../login.js'\n\nimport { APIError } from '../../../errors/index.js'\nimport { createLocalReq } from '../../../utilities/createLocalReq.js'\nimport { loginOperation } from '../login.js'\n\nexport type Options<TSlug extends CollectionSlug> = {\n  collection: TSlug\n  context?: RequestContext\n  data: AuthOperationsFromCollectionSlug<TSlug>['login']\n  depth?: number\n  fallbackLocale?: string\n  locale?: string\n  overrideAccess?: boolean\n  req?: PayloadRequest\n  showHiddenFields?: boolean\n}\n\nasync function localLogin<TSlug extends CollectionSlug>(\n  payload: Payload,\n  options: Options<TSlug>,\n): Promise<{ user: DataFromCollectionSlug<TSlug> } & Result> {\n  const {\n    collection: collectionSlug,\n    data,\n    depth,\n    overrideAccess = true,\n    showHiddenFields,\n  } = options\n\n  const collection = payload.collections[collectionSlug]\n\n  if (!collection) {\n    throw new APIError(\n      `The collection with slug ${String(collectionSlug)} can't be found. Login Operation.`,\n    )\n  }\n\n  const args = {\n    collection,\n    data,\n    depth,\n    overrideAccess,\n    req: await createLocalReq(options, payload),\n    showHiddenFields,\n  }\n\n  const result = await loginOperation<TSlug>(args)\n\n  if (collection.config.auth.removeTokenFromResponses) {\n    delete result.token\n  }\n\n  return result\n}\n\nexport default localLogin\n"],"names":["APIError","createLocalReq","loginOperation","localLogin","payload","options","collection","collectionSlug","data","depth","overrideAccess","showHiddenFields","collections","String","args","req","result","config","auth","removeTokenFromResponses","token"],"mappings":";;;AAUA,SAASA,QAAQ,QAAQ,2BAA0B;AACnD,SAASC,cAAc,QAAQ,uCAAsC;AACrE,SAASC,cAAc,QAAQ,cAAa;;;;AAc5C,eAAeC,WACbC,OAAgB,EAChBC,OAAuB;IAEvB,MAAM,EACJC,YAAYC,cAAc,EAC1BC,IAAI,EACJC,KAAK,EACLC,iBAAiB,IAAI,EACrBC,gBAAgB,EACjB,GAAGN;IAEJ,MAAMC,aAAaF,QAAQQ,WAAW,CAACL,eAAe;IAEtD,IAAI,CAACD,YAAY;QACf,MAAM,0JAAIN,WAAAA,CACR,CAAC,yBAAyB,EAAEa,OAAON,gBAAgB,iCAAiC,CAAC;IAEzF;IAEA,MAAMO,OAAO;QACXR;QACAE;QACAC;QACAC;QACAK,KAAK,yKAAMd,iBAAAA,EAAeI,SAASD;QACnCO;IACF;IAEA,MAAMK,SAAS,yKAAMd,iBAAAA,EAAsBY;IAE3C,IAAIR,WAAWW,MAAM,CAACC,IAAI,CAACC,wBAAwB,EAAE;QACnD,OAAOH,OAAOI,KAAK;IACrB;IAEA,OAAOJ;AACT;uCAEeb,WAAU"}},
    {"offset": {"line": 3253, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 3259, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/payload/src/utilities/isNumber.ts"],"sourcesContent":["export function isNumber(value: unknown): value is number {\n  if (value === null || value === undefined || (typeof value === 'string' && value.trim() === '')) {\n    return false\n  }\n\n  return !Number.isNaN(Number(value))\n}\n"],"names":["isNumber","value","undefined","trim","Number","isNaN"],"mappings":";;;AAAO,SAASA,SAASC,KAAc;IACrC,IAAIA,UAAU,QAAQA,UAAUC,aAAc,OAAOD,UAAU,YAAYA,MAAME,IAAI,OAAO,IAAK;QAC/F,OAAO;IACT;IAEA,OAAO,CAACC,OAAOC,KAAK,CAACD,OAAOH;AAC9B"}},
    {"offset": {"line": 3268, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 3274, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/payload/src/fields/validations.ts"],"sourcesContent":["import Ajv from 'ajv'\nimport ObjectIdImport from 'bson-objectid'\n\nconst ObjectId = (ObjectIdImport.default ||\n  ObjectIdImport) as unknown as typeof ObjectIdImport.default\n\nimport type { RichTextAdapter } from '../admin/types.js'\nimport type { CollectionSlug } from '../index.js'\nimport type { Where } from '../types/index.js'\nimport type {\n  ArrayField,\n  BlocksField,\n  CheckboxField,\n  CodeField,\n  DateField,\n  EmailField,\n  JSONField,\n  NumberField,\n  PointField,\n  RadioField,\n  RelationshipField,\n  RelationshipValue,\n  RelationshipValueMany,\n  RelationshipValueSingle,\n  RichTextField,\n  SelectField,\n  TextareaField,\n  TextField,\n  UploadField,\n  Validate,\n} from './config/types.js'\n\nimport { isNumber } from '../utilities/isNumber.js'\nimport { isValidID } from '../utilities/isValidID.js'\n\nexport type TextFieldValidation = Validate<string, unknown, unknown, TextField>\n\nexport type TextFieldManyValidation = Validate<string[], unknown, unknown, TextField>\n\nexport type TextFieldSingleValidation = Validate<string, unknown, unknown, TextField>\n\nexport const text: TextFieldValidation = (\n  value,\n  {\n    hasMany,\n    maxLength: fieldMaxLength,\n    maxRows,\n    minLength,\n    minRows,\n    req: {\n      payload: { config },\n      t,\n    },\n    required,\n  },\n) => {\n  let maxLength: number\n\n  if (!required) {\n    if (!value) {\n      return true\n    }\n  }\n\n  if (hasMany === true) {\n    const lengthValidationResult = validateArrayLength(value, { maxRows, minRows, required, t })\n    if (typeof lengthValidationResult === 'string') {\n      return lengthValidationResult\n    }\n  }\n\n  if (typeof config?.defaultMaxTextLength === 'number') {\n    maxLength = config.defaultMaxTextLength\n  }\n  if (typeof fieldMaxLength === 'number') {\n    maxLength = fieldMaxLength\n  }\n\n  const stringsToValidate: string[] = Array.isArray(value) ? value : [value]\n\n  for (const stringValue of stringsToValidate) {\n    const length = stringValue?.length || 0\n\n    if (typeof maxLength === 'number' && length > maxLength) {\n      return t('validation:shorterThanMax', { label: t('general:value'), maxLength, stringValue })\n    }\n\n    if (typeof minLength === 'number' && length < minLength) {\n      return t('validation:longerThanMin', { label: t('general:value'), minLength, stringValue })\n    }\n  }\n\n  if (required) {\n    if (!(typeof value === 'string' || Array.isArray(value)) || value?.length === 0) {\n      return t('validation:required')\n    }\n  }\n\n  return true\n}\n\nexport type PasswordFieldValidation = Validate<string, unknown, unknown, TextField>\n\nexport const password: PasswordFieldValidation = (\n  value,\n  {\n    maxLength: fieldMaxLength,\n    minLength = 3,\n    req: {\n      payload: { config },\n      t,\n    },\n    required,\n  },\n) => {\n  let maxLength: number\n\n  if (typeof config?.defaultMaxTextLength === 'number') {\n    maxLength = config.defaultMaxTextLength\n  }\n  if (typeof fieldMaxLength === 'number') {\n    maxLength = fieldMaxLength\n  }\n\n  if (value && maxLength && value.length > maxLength) {\n    return t('validation:shorterThanMax', { maxLength })\n  }\n\n  if (value && minLength && value.length < minLength) {\n    return t('validation:longerThanMin', { minLength })\n  }\n\n  if (required && !value) {\n    return t('validation:required')\n  }\n\n  return true\n}\n\nexport type ConfirmPasswordFieldValidation = Validate<\n  string,\n  unknown,\n  { password: string },\n  TextField\n>\n\nexport const confirmPassword: ConfirmPasswordFieldValidation = (\n  value,\n  { req: { t }, required, siblingData },\n) => {\n  if (required && !value) {\n    return t('validation:required')\n  }\n\n  if (value && value !== siblingData.password) {\n    return t('fields:passwordsDoNotMatch')\n  }\n\n  return true\n}\n\nexport type EmailFieldValidation = Validate<string, unknown, { username?: string }, EmailField>\n\nexport const email: EmailFieldValidation = (\n  value,\n  {\n    collectionSlug,\n    req: {\n      payload: { config },\n      t,\n    },\n    required,\n    siblingData,\n  },\n) => {\n  if (collectionSlug) {\n    const collection = config.collections.find(({ slug }) => slug === collectionSlug)\n\n    if (\n      collection.auth.loginWithUsername &&\n      !collection.auth.loginWithUsername?.requireUsername &&\n      !collection.auth.loginWithUsername?.requireEmail\n    ) {\n      if (!value && !siblingData?.username) {\n        return t('validation:required')\n      }\n    }\n  }\n\n  if ((value && !/\\S[^\\s@]*@\\S+\\.\\S+/.test(value)) || (!value && required)) {\n    return t('validation:emailAddress')\n  }\n\n  return true\n}\n\nexport type UsernameFieldValidation = Validate<string, unknown, { email?: string }, TextField>\n\nexport const username: UsernameFieldValidation = (\n  value,\n  {\n    collectionSlug,\n    req: {\n      payload: { config },\n      t,\n    },\n    required,\n    siblingData,\n  },\n) => {\n  let maxLength: number\n\n  if (collectionSlug) {\n    const collection = config.collections.find(({ slug }) => slug === collectionSlug)\n\n    if (\n      collection.auth.loginWithUsername &&\n      !collection.auth.loginWithUsername?.requireUsername &&\n      !collection.auth.loginWithUsername?.requireEmail\n    ) {\n      if (!value && !siblingData?.email) {\n        return t('validation:required')\n      }\n    }\n  }\n\n  if (typeof config?.defaultMaxTextLength === 'number') {\n    maxLength = config.defaultMaxTextLength\n  }\n\n  if (value && maxLength && value.length > maxLength) {\n    return t('validation:shorterThanMax', { maxLength })\n  }\n\n  if ((value && !/^[\\w.-]+$/.test(value)) || (!value && required)) {\n    return t('validation:username')\n  }\n\n  return true\n}\n\nexport type TextareaFieldValidation = Validate<string, unknown, unknown, TextareaField>\n\nexport const textarea: TextareaFieldValidation = (\n  value,\n  {\n    maxLength: fieldMaxLength,\n    minLength,\n    req: {\n      payload: { config },\n      t,\n    },\n    required,\n  },\n) => {\n  let maxLength: number\n\n  if (typeof config?.defaultMaxTextLength === 'number') {\n    maxLength = config.defaultMaxTextLength\n  }\n  if (typeof fieldMaxLength === 'number') {\n    maxLength = fieldMaxLength\n  }\n  if (value && maxLength && value.length > maxLength) {\n    return t('validation:shorterThanMax', { maxLength })\n  }\n\n  if (value && minLength && value.length < minLength) {\n    return t('validation:longerThanMin', { minLength })\n  }\n\n  if (required && !value) {\n    return t('validation:required')\n  }\n\n  return true\n}\n\nexport type CodeFieldValidation = Validate<string, unknown, unknown, CodeField>\n\nexport const code: CodeFieldValidation = (value, { req: { t }, required }) => {\n  if (required && value === undefined) {\n    return t('validation:required')\n  }\n\n  return true\n}\n\nexport type JSONFieldValidation = Validate<\n  string,\n  unknown,\n  unknown,\n  { jsonError?: string } & JSONField\n>\n\nexport const json: JSONFieldValidation = async (\n  value,\n  { jsonError, jsonSchema, req: { t }, required },\n) => {\n  const isNotEmpty = (value) => {\n    if (value === undefined || value === null) {\n      return false\n    }\n\n    if (Array.isArray(value) && value.length === 0) {\n      return false\n    }\n\n    if (typeof value === 'object' && Object.keys(value).length === 0) {\n      return false\n    }\n\n    return true\n  }\n\n  const fetchSchema = ({ schema, uri }: Record<string, unknown>) => {\n    if (uri && schema) {\n      return schema\n    }\n    // @ts-expect-error\n    return fetch(uri)\n      .then((response) => {\n        if (!response.ok) {\n          throw new Error('Network response was not ok')\n        }\n        return response.json()\n      })\n      .then((json) => {\n        const jsonSchemaSanitizations = {\n          id: undefined,\n          $id: json.id,\n          $schema: 'http://json-schema.org/draft-07/schema#',\n        }\n\n        return Object.assign(json, jsonSchemaSanitizations)\n      })\n  }\n\n  if (required && !value) {\n    return t('validation:required')\n  }\n\n  if (jsonError !== undefined) {\n    return t('validation:invalidInput')\n  }\n\n  if (jsonSchema && isNotEmpty(value)) {\n    try {\n      jsonSchema.schema = await fetchSchema(jsonSchema)\n      const { schema } = jsonSchema\n      // @ts-expect-error\n      const ajv = new Ajv()\n\n      if (!ajv.validate(schema, value)) {\n        return t(ajv.errorsText())\n      }\n    } catch (error) {\n      return t(error.message)\n    }\n  }\n  return true\n}\n\nexport type CheckboxFieldValidation = Validate<boolean, unknown, unknown, CheckboxField>\n\nexport const checkbox: CheckboxFieldValidation = (value, { req: { t }, required }) => {\n  if ((value && typeof value !== 'boolean') || (required && typeof value !== 'boolean')) {\n    return t('validation:trueOrFalse')\n  }\n\n  return true\n}\n\nexport type DateFieldValidation = Validate<Date, unknown, unknown, DateField>\n\nexport const date: DateFieldValidation = (value, { req: { t }, required }) => {\n  if (value && !isNaN(Date.parse(value.toString()))) {\n    return true\n  }\n\n  if (value) {\n    return t('validation:notValidDate', { value })\n  }\n\n  if (required) {\n    return t('validation:required')\n  }\n\n  return true\n}\n\nexport type RichTextFieldValidation = Validate<object, unknown, unknown, RichTextField>\n\nexport const richText: RichTextFieldValidation = async (value, options) => {\n  if (!options?.editor) {\n    throw new Error('richText field has no editor property.')\n  }\n  if (typeof options?.editor === 'function') {\n    throw new Error('Attempted to access unsanitized rich text editor.')\n  }\n\n  const editor: RichTextAdapter = options?.editor\n\n  return editor.validate(value, options)\n}\n\nconst validateArrayLength = (\n  value,\n  options: {\n    maxRows?: number\n    minRows?: number\n    required?: boolean\n    t: (key: string, options?: { [key: string]: number | string }) => string\n  },\n) => {\n  const { maxRows, minRows, required, t } = options\n\n  const arrayLength = Array.isArray(value) ? value.length : value || 0\n\n  if (!required && arrayLength === 0) {\n    return true\n  }\n\n  if (minRows && arrayLength < minRows) {\n    return t('validation:requiresAtLeast', { count: minRows, label: t('general:rows') })\n  }\n\n  if (maxRows && arrayLength > maxRows) {\n    return t('validation:requiresNoMoreThan', { count: maxRows, label: t('general:rows') })\n  }\n\n  if (required && !arrayLength) {\n    return t('validation:requiresAtLeast', { count: 1, label: t('general:row') })\n  }\n\n  return true\n}\n\nexport type NumberFieldValidation = Validate<number | number[], unknown, unknown, NumberField>\n\nexport type NumberFieldManyValidation = Validate<number[], unknown, unknown, NumberField>\n\nexport type NumberFieldSingleValidation = Validate<number, unknown, unknown, NumberField>\n\nexport const number: NumberFieldValidation = (\n  value,\n  { hasMany, max, maxRows, min, minRows, req: { t }, required },\n) => {\n  if (hasMany === true) {\n    const lengthValidationResult = validateArrayLength(value, { maxRows, minRows, required, t })\n    if (typeof lengthValidationResult === 'string') {\n      return lengthValidationResult\n    }\n  }\n\n  if (!value && !isNumber(value)) {\n    // if no value is present, validate based on required\n    if (required) {\n      return t('validation:required')\n    }\n    if (!required) {\n      return true\n    }\n  }\n\n  const numbersToValidate: number[] = Array.isArray(value) ? value : [value]\n\n  for (const number of numbersToValidate) {\n    if (!isNumber(number)) {\n      return t('validation:enterNumber')\n    }\n\n    const numberValue = parseFloat(number as unknown as string)\n\n    if (typeof max === 'number' && numberValue > max) {\n      return t('validation:greaterThanMax', { label: t('general:value'), max, value })\n    }\n\n    if (typeof min === 'number' && numberValue < min) {\n      return t('validation:lessThanMin', { label: t('general:value'), min, value })\n    }\n  }\n\n  return true\n}\n\nexport type ArrayFieldValidation = Validate<unknown[], unknown, unknown, ArrayField>\n\nexport const array: ArrayFieldValidation = (value, { maxRows, minRows, req: { t }, required }) => {\n  return validateArrayLength(value, { maxRows, minRows, required, t })\n}\n\nexport type BlocksFieldValidation = Validate<unknown, unknown, unknown, BlocksField>\n\nexport const blocks: BlocksFieldValidation = (\n  value,\n  { maxRows, minRows, req: { t }, required },\n) => {\n  return validateArrayLength(value, { maxRows, minRows, required, t })\n}\n\nconst validateFilterOptions: Validate<\n  unknown,\n  unknown,\n  unknown,\n  RelationshipField | UploadField\n> = async (\n  value,\n  { id, data, filterOptions, relationTo, req, req: { payload, t, user }, siblingData },\n) => {\n  if (typeof filterOptions !== 'undefined' && value) {\n    const options: {\n      [collection: string]: (number | string)[]\n    } = {}\n\n    const falseCollections: CollectionSlug[] = []\n    const collections = !Array.isArray(relationTo) ? [relationTo] : relationTo\n    const values = Array.isArray(value) ? value : [value]\n\n    for (const collection of collections) {\n      try {\n        let optionFilter =\n          typeof filterOptions === 'function'\n            ? await filterOptions({\n                id,\n                data,\n                relationTo: collection,\n                siblingData,\n                user,\n              })\n            : filterOptions\n\n        if (optionFilter === true) {\n          optionFilter = null\n        }\n\n        const valueIDs: (number | string)[] = []\n\n        values.forEach((val) => {\n          if (typeof val === 'object') {\n            if (val?.value) {\n              valueIDs.push(val.value)\n            } else if (ObjectId.isValid(val)) {\n              valueIDs.push(new ObjectId(val).toHexString())\n            }\n          }\n\n          if (typeof val === 'string' || typeof val === 'number') {\n            valueIDs.push(val)\n          }\n        })\n\n        if (valueIDs.length > 0) {\n          const findWhere: Where = {\n            and: [{ id: { in: valueIDs } }],\n          }\n\n          if (optionFilter && optionFilter !== true) {\n            findWhere.and.push(optionFilter)\n          }\n\n          if (optionFilter === false) {\n            falseCollections.push(collection)\n          }\n\n          const result = await payload.find({\n            collection,\n            depth: 0,\n            limit: 0,\n            pagination: false,\n            req,\n            where: findWhere,\n          })\n\n          options[collection] = result.docs.map((doc) => doc.id)\n        } else {\n          options[collection] = []\n        }\n      } catch (err) {\n        req.payload.logger.error({\n          err,\n          msg: `Error validating filter options for collection ${collection}`,\n        })\n        options[collection] = []\n      }\n    }\n\n    const invalidRelationships = values.filter((val) => {\n      let collection: string\n      let requestedID: number | string\n\n      if (typeof relationTo === 'string') {\n        collection = relationTo\n\n        if (typeof val === 'string' || typeof val === 'number') {\n          requestedID = val\n        }\n\n        if (typeof val === 'object' && ObjectId.isValid(val)) {\n          requestedID = new ObjectId(val).toHexString()\n        }\n      }\n\n      if (Array.isArray(relationTo) && typeof val === 'object' && val?.relationTo) {\n        collection = val.relationTo\n        requestedID = val.value\n      }\n\n      if (falseCollections.find((slug) => relationTo === slug)) {\n        return true\n      }\n\n      if (!options[collection]) {\n        return true\n      }\n\n      return options[collection].indexOf(requestedID) === -1\n    })\n\n    if (invalidRelationships.length > 0) {\n      return invalidRelationships.reduce((err, invalid, i) => {\n        return `${err} ${JSON.stringify(invalid)}${\n          invalidRelationships.length === i + 1 ? ',' : ''\n        } `\n      }, t('validation:invalidSelections')) as string\n    }\n\n    return true\n  }\n\n  return true\n}\n\nexport type UploadFieldValidation = Validate<unknown, unknown, unknown, UploadField>\n\nexport type UploadFieldManyValidation = Validate<unknown[], unknown, unknown, UploadField>\n\nexport type UploadFieldSingleValidation = Validate<unknown, unknown, unknown, UploadField>\n\nexport const upload: UploadFieldValidation = async (value, options) => {\n  const {\n    maxRows,\n    minRows,\n    relationTo,\n    req: { payload, t },\n    required,\n  } = options\n\n  if (\n    ((!value && typeof value !== 'number') || (Array.isArray(value) && value.length === 0)) &&\n    required\n  ) {\n    return t('validation:required')\n  }\n\n  if (Array.isArray(value) && value.length > 0) {\n    if (minRows && value.length < minRows) {\n      return t('validation:lessThanMin', {\n        label: t('general:rows'),\n        min: minRows,\n        value: value.length,\n      })\n    }\n\n    if (maxRows && value.length > maxRows) {\n      return t('validation:greaterThanMax', {\n        label: t('general:rows'),\n        max: maxRows,\n        value: value.length,\n      })\n    }\n  }\n\n  if (typeof value !== 'undefined' && value !== null) {\n    const values = Array.isArray(value) ? value : [value]\n\n    const invalidRelationships = values.filter((val) => {\n      let collectionSlug: string\n      let requestedID\n\n      if (typeof relationTo === 'string') {\n        collectionSlug = relationTo\n\n        // custom id\n        if (val || typeof val === 'number') {\n          requestedID = val\n        }\n      }\n\n      if (Array.isArray(relationTo) && typeof val === 'object' && val?.relationTo) {\n        collectionSlug = val.relationTo\n        requestedID = val.value\n      }\n\n      if (requestedID === null) {\n        return false\n      }\n\n      const idType =\n        payload.collections[collectionSlug]?.customIDType || payload?.db?.defaultIDType || 'text'\n\n      return !isValidID(requestedID, idType)\n    })\n\n    if (invalidRelationships.length > 0) {\n      return `This relationship field has the following invalid relationships: ${invalidRelationships\n        .map((err, invalid) => {\n          return `${err} ${JSON.stringify(invalid)}`\n        })\n        .join(', ')}`\n    }\n  }\n\n  return validateFilterOptions(value, options)\n}\n\nexport type RelationshipFieldValidation = Validate<\n  RelationshipValue,\n  unknown,\n  unknown,\n  RelationshipField\n>\n\nexport type RelationshipFieldManyValidation = Validate<\n  RelationshipValueMany,\n  unknown,\n  unknown,\n  RelationshipField\n>\n\nexport type RelationshipFieldSingleValidation = Validate<\n  RelationshipValueSingle,\n  unknown,\n  unknown,\n  RelationshipField\n>\n\nexport const relationship: RelationshipFieldValidation = async (value, options) => {\n  const {\n    maxRows,\n    minRows,\n    relationTo,\n    req: { payload, t },\n    required,\n  } = options\n\n  if (\n    ((!value && typeof value !== 'number') || (Array.isArray(value) && value.length === 0)) &&\n    required\n  ) {\n    return t('validation:required')\n  }\n\n  if (Array.isArray(value) && value.length > 0) {\n    if (minRows && value.length < minRows) {\n      return t('validation:lessThanMin', {\n        label: t('general:rows'),\n        min: minRows,\n        value: value.length,\n      })\n    }\n\n    if (maxRows && value.length > maxRows) {\n      return t('validation:greaterThanMax', {\n        label: t('general:rows'),\n        max: maxRows,\n        value: value.length,\n      })\n    }\n  }\n\n  if (typeof value !== 'undefined' && value !== null) {\n    const values = Array.isArray(value) ? value : [value]\n\n    const invalidRelationships = values.filter((val) => {\n      let collectionSlug: string\n      let requestedID\n\n      if (typeof relationTo === 'string') {\n        collectionSlug = relationTo\n\n        // custom id\n        if (val || typeof val === 'number') {\n          requestedID = val\n        }\n      }\n\n      if (Array.isArray(relationTo) && typeof val === 'object' && val?.relationTo) {\n        collectionSlug = val.relationTo\n        requestedID = val.value\n      }\n\n      if (requestedID === null) {\n        return false\n      }\n\n      const idType =\n        payload.collections[collectionSlug]?.customIDType || payload?.db?.defaultIDType || 'text'\n\n      return !isValidID(requestedID, idType)\n    })\n\n    if (invalidRelationships.length > 0) {\n      return `This relationship field has the following invalid relationships: ${invalidRelationships\n        .map((err, invalid) => {\n          return `${err} ${JSON.stringify(invalid)}`\n        })\n        .join(', ')}`\n    }\n  }\n\n  return validateFilterOptions(value, options)\n}\n\nexport type SelectFieldValidation = Validate<string | string[], unknown, unknown, SelectField>\n\nexport type SelectFieldManyValidation = Validate<string[], unknown, unknown, SelectField>\n\nexport type SelectFieldSingleValidation = Validate<string, unknown, unknown, SelectField>\n\nexport const select: SelectFieldValidation = (\n  value,\n  { hasMany, options, req: { t }, required },\n) => {\n  if (\n    Array.isArray(value) &&\n    value.some(\n      (input) =>\n        !options.some(\n          (option) => option === input || (typeof option !== 'string' && option?.value === input),\n        ),\n    )\n  ) {\n    return t('validation:invalidSelection')\n  }\n\n  if (\n    typeof value === 'string' &&\n    !options.some(\n      (option) => option === value || (typeof option !== 'string' && option.value === value),\n    )\n  ) {\n    return t('validation:invalidSelection')\n  }\n\n  if (\n    required &&\n    (typeof value === 'undefined' ||\n      value === null ||\n      (hasMany && Array.isArray(value) && (value as [])?.length === 0))\n  ) {\n    return t('validation:required')\n  }\n\n  return true\n}\n\nexport type RadioFieldValidation = Validate<unknown, unknown, unknown, RadioField>\n\nexport const radio: RadioFieldValidation = (value, { options, req: { t }, required }) => {\n  if (value) {\n    const valueMatchesOption = options.some(\n      (option) => option === value || (typeof option !== 'string' && option.value === value),\n    )\n    return valueMatchesOption || t('validation:invalidSelection')\n  }\n\n  return required ? t('validation:required') : true\n}\n\nexport type PointFieldValidation = Validate<\n  [number | string, number | string],\n  unknown,\n  unknown,\n  PointField\n>\n\nexport const point: PointFieldValidation = (value = ['', ''], { req: { t }, required }) => {\n  const lng = parseFloat(String(value[0]))\n  const lat = parseFloat(String(value[1]))\n  if (\n    required &&\n    ((value[0] && value[1] && typeof lng !== 'number' && typeof lat !== 'number') ||\n      Number.isNaN(lng) ||\n      Number.isNaN(lat) ||\n      (Array.isArray(value) && value.length !== 2))\n  ) {\n    return t('validation:requiresTwoNumbers')\n  }\n\n  if ((value[1] && Number.isNaN(lng)) || (value[0] && Number.isNaN(lat))) {\n    return t('validation:invalidInput')\n  }\n\n  return true\n}\n\nexport default {\n  array,\n  blocks,\n  checkbox,\n  code,\n  confirmPassword,\n  date,\n  email,\n  json,\n  number,\n  password,\n  point,\n  radio,\n  relationship,\n  richText,\n  select,\n  text,\n  textarea,\n  upload,\n}\n"],"names":["Ajv","ObjectIdImport","ObjectId","default","isNumber","isValidID","text","value","hasMany","maxLength","fieldMaxLength","maxRows","minLength","minRows","req","payload","config","t","required","lengthValidationResult","validateArrayLength","defaultMaxTextLength","stringsToValidate","Array","isArray","stringValue","length","label","password","confirmPassword","siblingData","email","collectionSlug","collection","collections","find","slug","auth","loginWithUsername","requireUsername","requireEmail","username","test","textarea","code","undefined","json","jsonError","jsonSchema","isNotEmpty","Object","keys","fetchSchema","schema","uri","fetch","then","response","ok","Error","jsonSchemaSanitizations","id","$id","$schema","assign","ajv","validate","errorsText","error","message","checkbox","date","isNaN","Date","parse","toString","richText","options","editor","arrayLength","count","number","max","min","numbersToValidate","numberValue","parseFloat","array","blocks","validateFilterOptions","data","filterOptions","relationTo","user","falseCollections","values","optionFilter","valueIDs","forEach","val","push","isValid","toHexString","findWhere","and","in","result","depth","limit","pagination","where","docs","map","doc","err","logger","msg","invalidRelationships","filter","requestedID","indexOf","reduce","invalid","i","JSON","stringify","upload","idType","customIDType","db","defaultIDType","join","relationship","select","some","input","option","radio","valueMatchesOption","point","lng","String","lat","Number"],"mappings":"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"}},
    {"offset": {"line": 3889, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 3895, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/payload/src/auth/strategies/local/generatePasswordSaltHash.ts"],"sourcesContent":["import crypto from 'crypto'\n\nimport type { SanitizedCollectionConfig } from '../../../collections/config/types.js'\nimport type { PayloadRequest } from '../../../types/index.js'\n\nimport { ValidationError } from '../../../errors/index.js'\nimport { password } from '../../../fields/validations.js'\n\nfunction randomBytes(): Promise<Buffer> {\n  return new Promise((resolve, reject) =>\n    crypto.randomBytes(32, (err, saltBuffer) => (err ? reject(err) : resolve(saltBuffer))),\n  )\n}\n\nfunction pbkdf2Promisified(password: string, salt: string): Promise<Buffer> {\n  return new Promise((resolve, reject) =>\n    crypto.pbkdf2(password, salt, 25000, 512, 'sha256', (err, hashRaw) =>\n      err ? reject(err) : resolve(hashRaw),\n    ),\n  )\n}\n\ntype Args = {\n  collection: SanitizedCollectionConfig\n  password: string\n  req: PayloadRequest\n}\n\nexport const generatePasswordSaltHash = async ({\n  collection,\n  password: passwordToSet,\n  req,\n}: Args): Promise<{ hash: string; salt: string }> => {\n  const validationResult = password(passwordToSet, {\n    name: 'password',\n    type: 'text',\n    data: {},\n    preferences: { fields: {} },\n    req,\n    required: true,\n    siblingData: {},\n  })\n\n  if (typeof validationResult === 'string') {\n    throw new ValidationError({\n      collection: collection?.slug,\n      errors: [{ field: 'password', message: validationResult }],\n    })\n  }\n\n  const saltBuffer = await randomBytes()\n  const salt = saltBuffer.toString('hex')\n\n  const hashRaw = await pbkdf2Promisified(passwordToSet, salt)\n  const hash = hashRaw.toString('hex')\n\n  return { hash, salt }\n}\n"],"names":["crypto","ValidationError","password","randomBytes","Promise","resolve","reject","err","saltBuffer","pbkdf2Promisified","salt","pbkdf2","hashRaw","generatePasswordSaltHash","collection","passwordToSet","req","validationResult","name","type","data","preferences","fields","required","siblingData","slug","errors","field","message","toString","hash"],"mappings":";;;AAAA,OAAOA,YAAY,SAAQ;AAM3B,SAASE,QAAQ,QAAQ,iCAAgC;AADzD,SAASD,eAAe,QAAQ,2BAA0B;;;;AAG1D,SAASE;IACP,OAAO,IAAIC,QAAQ,CAACC,SAASC,yGAC3BN,UAAAA,CAAOG,WAAW,CAAC,IAAI,CAACI,KAAKC,aAAgBD,MAAMD,OAAOC,OAAOF,QAAQG;AAE7E;AAEA,SAASC,kBAAkBP,QAAgB,EAAEQ,IAAY;IACvD,OAAO,IAAIN,QAAQ,CAACC,SAASC,yGAC3BN,UAAAA,CAAOW,MAAM,CAACT,UAAUQ,MAAM,OAAO,KAAK,UAAU,CAACH,KAAKK,UACxDL,MAAMD,OAAOC,OAAOF,QAAQO;AAGlC;AAQO,MAAMC,2BAA2B,OAAO,EAC7CC,UAAU,EACVZ,UAAUa,aAAa,EACvBC,GAAG,EACE;IACL,MAAMC,gLAAmBf,WAAAA,EAASa,eAAe;QAC/CG,MAAM;QACNC,MAAM;QACNC,MAAM,CAAC;QACPC,aAAa;YAAEC,QAAQ,CAAC;QAAE;QAC1BN;QACAO,UAAU;QACVC,aAAa,CAAC;IAChB;IAEA,IAAI,OAAOP,qBAAqB,UAAU;QACxC,MAAM,iKAAIhB,kBAAAA,CAAgB;YACxBa,YAAYA,YAAYW;YACxBC,QAAQ;gBAAC;oBAAEC,OAAO;oBAAYC,SAASX;gBAAiB;aAAE;QAC5D;IACF;IAEA,MAAMT,aAAa,MAAML;IACzB,MAAMO,OAAOF,WAAWqB,QAAQ,CAAC;IAEjC,MAAMjB,UAAU,MAAMH,kBAAkBM,eAAeL;IACvD,MAAMoB,OAAOlB,QAAQiB,QAAQ,CAAC;IAE9B,OAAO;QAAEC;QAAMpB;IAAK;AACtB,EAAC"}},
    {"offset": {"line": 3942, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 3948, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/payload/src/auth/operations/resetPassword.ts"],"sourcesContent":["import httpStatus from 'http-status'\n\nimport type { Collection } from '../../collections/config/types.js'\nimport type { PayloadRequest } from '../../types/index.js'\n\nimport { APIError } from '../../errors/index.js'\nimport { commitTransaction } from '../../utilities/commitTransaction.js'\nimport { initTransaction } from '../../utilities/initTransaction.js'\nimport { killTransaction } from '../../utilities/killTransaction.js'\nimport { getFieldsToSign } from '../getFieldsToSign.js'\nimport { jwtSign } from '../jwt.js'\nimport { authenticateLocalStrategy } from '../strategies/local/authenticate.js'\nimport { generatePasswordSaltHash } from '../strategies/local/generatePasswordSaltHash.js'\n\nexport type Result = {\n  token?: string\n  user: Record<string, unknown>\n}\n\nexport type Arguments = {\n  collection: Collection\n  data: {\n    password: string\n    token: string\n  }\n  depth?: number\n  overrideAccess?: boolean\n  req: PayloadRequest\n}\n\nexport const resetPasswordOperation = async (args: Arguments): Promise<Result> => {\n  if (\n    !Object.prototype.hasOwnProperty.call(args.data, 'token') ||\n    !Object.prototype.hasOwnProperty.call(args.data, 'password')\n  ) {\n    throw new APIError('Missing required data.', httpStatus.BAD_REQUEST)\n  }\n\n  const {\n    collection: { config: collectionConfig },\n    data,\n    depth,\n    overrideAccess,\n    req: {\n      payload: { secret },\n      payload,\n    },\n    req,\n  } = args\n\n  try {\n    const shouldCommit = await initTransaction(req)\n\n    // /////////////////////////////////////\n    // Reset Password\n    // /////////////////////////////////////\n\n    const user = await payload.db.findOne<any>({\n      collection: collectionConfig.slug,\n      req,\n      where: {\n        resetPasswordExpiration: { greater_than: new Date().toISOString() },\n        resetPasswordToken: { equals: data.token },\n      },\n    })\n\n    if (!user) {\n      throw new APIError('Token is either invalid or has expired.', httpStatus.FORBIDDEN)\n    }\n\n    // TODO: replace this method\n    const { hash, salt } = await generatePasswordSaltHash({\n      collection: collectionConfig,\n      password: data.password,\n      req,\n    })\n\n    user.salt = salt\n    user.hash = hash\n\n    user.resetPasswordExpiration = new Date().toISOString()\n\n    if (collectionConfig.auth.verify) {\n      user._verified = Boolean(user._verified)\n    }\n    // /////////////////////////////////////\n    // beforeValidate - Collection\n    // /////////////////////////////////////\n\n    await collectionConfig.hooks.beforeValidate.reduce(async (priorHook, hook) => {\n      await priorHook\n\n      await hook({\n        collection: args.collection?.config,\n        context: req.context,\n        data: user,\n        operation: 'update',\n        req,\n      })\n    }, Promise.resolve())\n\n    // /////////////////////////////////////\n    // Update new password\n    // /////////////////////////////////////\n\n    const doc = await payload.db.updateOne({\n      id: user.id,\n      collection: collectionConfig.slug,\n      data: user,\n      req,\n    })\n\n    await authenticateLocalStrategy({ doc, password: data.password })\n\n    const fieldsToSign = getFieldsToSign({\n      collectionConfig,\n      email: user.email,\n      user,\n    })\n\n    const { token } = await jwtSign({\n      fieldsToSign,\n      secret,\n      tokenExpiration: collectionConfig.auth.tokenExpiration,\n    })\n\n    const fullUser = await payload.findByID({\n      id: user.id,\n      collection: collectionConfig.slug,\n      depth,\n      overrideAccess,\n      req,\n    })\n    if (shouldCommit) {\n      await commitTransaction(req)\n    }\n\n    const result = {\n      token,\n      user: fullUser,\n    }\n\n    return result\n  } catch (error: unknown) {\n    await killTransaction(req)\n    throw error\n  }\n}\n"],"names":["httpStatus","APIError","commitTransaction","initTransaction","killTransaction","getFieldsToSign","jwtSign","authenticateLocalStrategy","generatePasswordSaltHash","resetPasswordOperation","args","Object","prototype","hasOwnProperty","call","data","BAD_REQUEST","collection","config","collectionConfig","depth","overrideAccess","req","payload","secret","shouldCommit","user","db","findOne","slug","where","resetPasswordExpiration","greater_than","Date","toISOString","resetPasswordToken","equals","token","FORBIDDEN","hash","salt","password","auth","verify","_verified","Boolean","hooks","beforeValidate","reduce","priorHook","hook","context","operation","Promise","resolve","doc","updateOne","id","fieldsToSign","email","tokenExpiration","fullUser","findByID","result","error"],"mappings":"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"}},
    {"offset": {"line": 4062, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 4068, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/payload/src/auth/operations/local/resetPassword.ts"],"sourcesContent":["import type { CollectionSlug, Payload, RequestContext } from '../../../index.js'\nimport type { PayloadRequest } from '../../../types/index.js'\nimport type { Result } from '../resetPassword.js'\n\nimport { APIError } from '../../../errors/index.js'\nimport { createLocalReq } from '../../../utilities/createLocalReq.js'\nimport { resetPasswordOperation } from '../resetPassword.js'\n\nexport type Options<T extends CollectionSlug> = {\n  collection: T\n  context?: RequestContext\n  data: {\n    password: string\n    token: string\n  }\n  overrideAccess: boolean\n  req?: PayloadRequest\n}\n\nasync function localResetPassword<T extends CollectionSlug>(\n  payload: Payload,\n  options: Options<T>,\n): Promise<Result> {\n  const { collection: collectionSlug, data, overrideAccess } = options\n\n  const collection = payload.collections[collectionSlug]\n\n  if (!collection) {\n    throw new APIError(\n      `The collection with slug ${String(\n        collectionSlug,\n      )} can't be found. Reset Password Operation.`,\n    )\n  }\n\n  const result = await resetPasswordOperation({\n    collection,\n    data,\n    overrideAccess,\n    req: await createLocalReq(options, payload),\n  })\n\n  if (collection.config.auth.removeTokenFromResponses) {\n    delete result.token\n  }\n\n  return result\n}\n\nexport default localResetPassword\n"],"names":["APIError","createLocalReq","resetPasswordOperation","localResetPassword","payload","options","collection","collectionSlug","data","overrideAccess","collections","String","result","req","config","auth","removeTokenFromResponses","token"],"mappings":";;;AAIA,SAASA,QAAQ,QAAQ,2BAA0B;AAEnD,SAASE,sBAAsB,QAAQ,sBAAqB;AAD5D,SAASD,cAAc,QAAQ,uCAAsC;;;;AAcrE,eAAeE,mBACbC,OAAgB,EAChBC,OAAmB;IAEnB,MAAM,EAAEC,YAAYC,cAAc,EAAEC,IAAI,EAAEC,cAAc,EAAE,GAAGJ;IAE7D,MAAMC,aAAaF,QAAQM,WAAW,CAACH,eAAe;IAEtD,IAAI,CAACD,YAAY;QACf,MAAM,0JAAIN,WAAAA,CACR,CAAC,yBAAyB,EAAEW,OAC1BJ,gBACA,0CAA0C,CAAC;IAEjD;IAEA,MAAMK,SAAS,MAAMV,oMAAAA,EAAuB;QAC1CI;QACAE;QACAC;QACAI,KAAK,yKAAMZ,iBAAAA,EAAeI,SAASD;IACrC;IAEA,IAAIE,WAAWQ,MAAM,CAACC,IAAI,CAACC,wBAAwB,EAAE;QACnD,OAAOJ,OAAOK,KAAK;IACrB;IAEA,OAAOL;AACT;uCAEeT,mBAAkB"}},
    {"offset": {"line": 4096, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 4102, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/payload/src/errors/Forbidden.ts"],"sourcesContent":["import type { TFunction } from '@payloadcms/translations'\n\nimport { en } from '@payloadcms/translations/languages/en'\nimport httpStatus from 'http-status'\n\nimport { APIError } from './APIError.js'\n\nexport class Forbidden extends APIError {\n  constructor(t?: TFunction) {\n    super(\n      t ? t('error:notAllowedToPerformAction') : en.translations.error.notAllowedToPerformAction,\n      httpStatus.FORBIDDEN,\n    )\n  }\n}\n"],"names":["en","httpStatus","APIError","Forbidden","constructor","t","translations","error","notAllowedToPerformAction","FORBIDDEN"],"mappings":";;;AAEA,SAASA,EAAE,QAAQ,wCAAuC;AAC1D,OAAOC,gBAAgB,cAAa;AAEpC,SAASC,QAAQ,QAAQ,gBAAe;;;;AAEjC,MAAMC,wKAAkBD,WAAAA;IAC7BE,YAAYC,CAAa,CAAE;QACzB,KAAK,CACHA,IAAIA,EAAE,6MAAqCL,KAAAA,CAAGM,YAAY,CAACC,KAAK,CAACC,yBAAyB,iJAC1FP,UAAAA,CAAWQ,SAAS;IAExB;AACF"}},
    {"offset": {"line": 4116, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 4122, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/payload/src/auth/executeAccess.ts"],"sourcesContent":["import type { Access, AccessResult } from '../config/types.js'\nimport type { PayloadRequest } from '../types/index.js'\n\nimport { Forbidden } from '../errors/index.js'\n\ntype OperationArgs = {\n  data?: any\n  disableErrors?: boolean\n  id?: number | string\n  isReadingStaticFile?: boolean\n  req: PayloadRequest\n}\nconst executeAccess = async (\n  { id, data, disableErrors, isReadingStaticFile = false, req }: OperationArgs,\n  access: Access,\n): Promise<AccessResult> => {\n  if (access) {\n    const result = await access({\n      id,\n      data,\n      isReadingStaticFile,\n      req,\n    })\n\n    if (!result) {\n      if (!disableErrors) {\n        throw new Forbidden(req.t)\n      }\n    }\n\n    return result\n  }\n\n  if (req.user) {\n    return true\n  }\n\n  if (!disableErrors) {\n    throw new Forbidden(req.t)\n  }\n  return false\n}\n\nexport default executeAccess\n"],"names":["Forbidden","executeAccess","id","data","disableErrors","isReadingStaticFile","req","access","result","t","user"],"mappings":";;;AAGA,SAASA,SAAS,QAAQ,qBAAoB;;AAS9C,MAAMC,gBAAgB,OACpB,EAAEC,EAAE,EAAEC,IAAI,EAAEC,aAAa,EAAEC,sBAAsB,KAAK,EAAEC,GAAG,EAAiB,EAC5EC;IAEA,IAAIA,QAAQ;QACV,MAAMC,SAAS,MAAMD,OAAO;YAC1BL;YACAC;YACAE;YACAC;QACF;QAEA,IAAI,CAACE,QAAQ;YACX,IAAI,CAACJ,eAAe;gBAClB,MAAM,2JAAIJ,YAAAA,CAAUM,IAAIG,CAAC;YAC3B;QACF;QAEA,OAAOD;IACT;IAEA,IAAIF,IAAII,IAAI,EAAE;QACZ,OAAO;IACT;IAEA,IAAI,CAACN,eAAe;QAClB,MAAM,2JAAIJ,YAAAA,CAAUM,IAAIG,CAAC;IAC3B;IACA,OAAO;AACT;uCAEeR,cAAa"}},
    {"offset": {"line": 4152, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 4158, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/payload/src/auth/operations/unlock.ts"],"sourcesContent":["import httpStatus from 'http-status'\n\nimport type {\n  AuthOperationsFromCollectionSlug,\n  Collection,\n} from '../../collections/config/types.js'\nimport type { CollectionSlug } from '../../index.js'\nimport type { PayloadRequest, Where } from '../../types/index.js'\n\nimport { APIError } from '../../errors/index.js'\nimport { commitTransaction } from '../../utilities/commitTransaction.js'\nimport { initTransaction } from '../../utilities/initTransaction.js'\nimport { killTransaction } from '../../utilities/killTransaction.js'\nimport executeAccess from '../executeAccess.js'\nimport { resetLoginAttempts } from '../strategies/local/resetLoginAttempts.js'\n\nexport type Arguments<TSlug extends CollectionSlug> = {\n  collection: Collection\n  data: AuthOperationsFromCollectionSlug<TSlug>['unlock']\n  overrideAccess?: boolean\n  req: PayloadRequest\n}\n\nexport const unlockOperation = async <TSlug extends CollectionSlug>(\n  args: Arguments<TSlug>,\n): Promise<boolean> => {\n  const {\n    collection: { config: collectionConfig },\n    overrideAccess,\n    req: { locale },\n    req,\n  } = args\n\n  const loginWithUsername = collectionConfig.auth.loginWithUsername\n  const canLoginWithUsername = Boolean(loginWithUsername)\n  const canLoginWithEmail = !loginWithUsername || loginWithUsername.allowEmailLogin\n\n  const sanitizedEmail = canLoginWithEmail && (args.data?.email || '').toLowerCase().trim()\n  const sanitizedUsername =\n    (canLoginWithUsername &&\n      'username' in args.data &&\n      typeof args.data.username === 'string' &&\n      args.data.username.toLowerCase().trim()) ||\n    null\n\n  if (!sanitizedEmail && !sanitizedUsername) {\n    throw new APIError(\n      `Missing ${collectionConfig.auth.loginWithUsername ? 'username' : 'email'}.`,\n      httpStatus.BAD_REQUEST,\n    )\n  }\n\n  try {\n    const shouldCommit = await initTransaction(req)\n\n    // /////////////////////////////////////\n    // Access\n    // /////////////////////////////////////\n\n    if (!overrideAccess) {\n      await executeAccess({ req }, collectionConfig.access.unlock)\n    }\n\n    // /////////////////////////////////////\n    // Unlock\n    // /////////////////////////////////////\n\n    let whereConstraint: Where = {}\n\n    if (canLoginWithEmail && sanitizedEmail) {\n      whereConstraint = {\n        email: {\n          equals: sanitizedEmail,\n        },\n      }\n    } else if (canLoginWithUsername && sanitizedUsername) {\n      whereConstraint = {\n        username: {\n          equals: sanitizedUsername,\n        },\n      }\n    }\n\n    const user = await req.payload.db.findOne({\n      collection: collectionConfig.slug,\n      locale,\n      req,\n      where: whereConstraint,\n    })\n\n    let result\n\n    if (user) {\n      await resetLoginAttempts({\n        collection: collectionConfig,\n        doc: user,\n        payload: req.payload,\n        req,\n      })\n      result = true\n    } else {\n      result = null\n    }\n\n    if (shouldCommit) {\n      await commitTransaction(req)\n    }\n\n    return result\n  } catch (error: unknown) {\n    await killTransaction(req)\n    throw error\n  }\n}\n"],"names":["httpStatus","APIError","commitTransaction","initTransaction","killTransaction","executeAccess","resetLoginAttempts","unlockOperation","args","collection","config","collectionConfig","overrideAccess","req","locale","loginWithUsername","auth","canLoginWithUsername","Boolean","canLoginWithEmail","allowEmailLogin","sanitizedEmail","data","email","toLowerCase","trim","sanitizedUsername","username","BAD_REQUEST","shouldCommit","access","unlock","whereConstraint","equals","user","payload","db","findOne","slug","where","result","doc","error"],"mappings":";;;AAAA,OAAOA,gBAAgB,cAAa;AASpC,SAASC,QAAQ,QAAQ,wBAAuB;AAEhD,SAASE,eAAe,QAAQ,qCAAoC;AAEpE,OAAOE,mBAAmB,sBAAqB;AAC/C,SAASC,kBAAkB,QAAQ,4CAA2C;AAJ9E,SAASJ,iBAAiB,QAAQ,uCAAsC;AAExE,SAASE,eAAe,QAAQ,qCAAoC;;;;;;;;AAW7D,MAAMG,kBAAkB,OAC7BC;IAEA,MAAM,EACJC,YAAY,EAAEC,QAAQC,gBAAgB,EAAE,EACxCC,cAAc,EACdC,KAAK,EAAEC,MAAM,EAAE,EACfD,GAAG,EACJ,GAAGL;IAEJ,MAAMO,oBAAoBJ,iBAAiBK,IAAI,CAACD,iBAAiB;IACjE,MAAME,uBAAuBC,QAAQH;IACrC,MAAMI,oBAAoB,CAACJ,qBAAqBA,kBAAkBK,eAAe;IAEjF,MAAMC,iBAAiBF,qBAAsBX,CAAAA,KAAKc,IAAI,EAAEC,SAAS,EAAC,EAAGC,WAAW,GAAGC,IAAI;IACvF,MAAMC,oBACHT,wBACC,cAAcT,KAAKc,IAAI,IACvB,OAAOd,KAAKc,IAAI,CAACK,QAAQ,KAAK,YAC9BnB,KAAKc,IAAI,CAACK,QAAQ,CAACH,WAAW,GAAGC,IAAI,MACvC;IAEF,IAAI,CAACJ,kBAAkB,CAACK,mBAAmB;QACzC,MAAM,0JAAIzB,WAAAA,CACR,CAAC,QAAQ,EAAEU,iBAAiBK,IAAI,CAACD,iBAAiB,GAAG,aAAa,QAAQ,CAAC,CAAC,iJAC5Ef,UAAAA,CAAW4B,WAAW;IAE1B;IAEA,IAAI;QACF,MAAMC,eAAe,OAAM1B,qLAAAA,EAAgBU;QAE3C,wCAAwC;QACxC,SAAS;QACT,wCAAwC;QAExC,IAAI,CAACD,gBAAgB;YACnB,mKAAMP,UAAAA,EAAc;gBAAEQ;YAAI,GAAGF,iBAAiBmB,MAAM,CAACC,MAAM;QAC7D;QAEA,wCAAwC;QACxC,SAAS;QACT,wCAAwC;QAExC,IAAIC,kBAAyB,CAAC;QAE9B,IAAIb,qBAAqBE,gBAAgB;YACvCW,kBAAkB;gBAChBT,OAAO;oBACLU,QAAQZ;gBACV;YACF;QACF,OAAO,IAAIJ,wBAAwBS,mBAAmB;YACpDM,kBAAkB;gBAChBL,UAAU;oBACRM,QAAQP;gBACV;YACF;QACF;QAEA,MAAMQ,OAAO,MAAMrB,IAAIsB,OAAO,CAACC,EAAE,CAACC,OAAO,CAAC;YACxC5B,YAAYE,iBAAiB2B,IAAI;YACjCxB;YACAD;YACA0B,OAAOP;QACT;QAEA,IAAIQ;QAEJ,IAAIN,MAAM;YACR,+LAAM5B,qBAAAA,EAAmB;gBACvBG,YAAYE;gBACZ8B,KAAKP;gBACLC,SAAStB,IAAIsB,OAAO;gBACpBtB;YACF;YACA2B,SAAS;QACX,OAAO;YACLA,SAAS;QACX;QAEA,IAAIX,cAAc;YAChB,4KAAM3B,oBAAAA,EAAkBW;QAC1B;QAEA,OAAO2B;IACT,EAAE,OAAOE,OAAgB;QACvB,0KAAMtC,kBAAAA,EAAgBS;QACtB,MAAM6B;IACR;AACF,EAAC"}},
    {"offset": {"line": 4239, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 4245, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/payload/src/auth/operations/local/unlock.ts"],"sourcesContent":["import type {\n  AuthOperationsFromCollectionSlug,\n  CollectionSlug,\n  Payload,\n  RequestContext,\n} from '../../../index.js'\nimport type { PayloadRequest } from '../../../types/index.js'\n\nimport { APIError } from '../../../errors/index.js'\nimport { createLocalReq } from '../../../utilities/createLocalReq.js'\nimport { unlockOperation } from '../unlock.js'\n\nexport type Options<TSlug extends CollectionSlug> = {\n  collection: TSlug\n  context?: RequestContext\n  data: AuthOperationsFromCollectionSlug<TSlug>['unlock']\n  overrideAccess: boolean\n  req?: PayloadRequest\n}\n\nasync function localUnlock<TSlug extends CollectionSlug>(\n  payload: Payload,\n  options: Options<TSlug>,\n): Promise<boolean> {\n  const { collection: collectionSlug, data, overrideAccess = true } = options\n\n  const collection = payload.collections[collectionSlug]\n\n  if (!collection) {\n    throw new APIError(\n      `The collection with slug ${String(collectionSlug)} can't be found. Unlock Operation.`,\n    )\n  }\n\n  return unlockOperation<TSlug>({\n    collection,\n    data,\n    overrideAccess,\n    req: await createLocalReq(options, payload),\n  })\n}\n\nexport default localUnlock\n"],"names":["APIError","createLocalReq","unlockOperation","localUnlock","payload","options","collection","collectionSlug","data","overrideAccess","collections","String","req"],"mappings":";;;AAQA,SAASA,QAAQ,QAAQ,2BAA0B;AAEnD,SAASE,eAAe,QAAQ,eAAc;AAD9C,SAASD,cAAc,QAAQ,uCAAsC;;;;AAWrE,eAAeE,YACbC,OAAgB,EAChBC,OAAuB;IAEvB,MAAM,EAAEC,YAAYC,cAAc,EAAEC,IAAI,EAAEC,iBAAiB,IAAI,EAAE,GAAGJ;IAEpE,MAAMC,aAAaF,QAAQM,WAAW,CAACH,eAAe;IAEtD,IAAI,CAACD,YAAY;QACf,MAAM,0JAAIN,WAAAA,CACR,CAAC,yBAAyB,EAAEW,OAAOJ,gBAAgB,kCAAkC,CAAC;IAE1F;IAEA,2KAAOL,kBAAAA,EAAuB;QAC5BI;QACAE;QACAC;QACAG,KAAK,yKAAMX,iBAAAA,EAAeI,SAASD;IACrC;AACF;uCAEeD,YAAW"}},
    {"offset": {"line": 4269, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 4275, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/payload/src/auth/operations/verifyEmail.ts"],"sourcesContent":["import httpStatus from 'http-status'\n\nimport type { Collection } from '../../collections/config/types.js'\nimport type { PayloadRequest } from '../../types/index.js'\n\nimport { APIError } from '../../errors/index.js'\nimport { commitTransaction } from '../../utilities/commitTransaction.js'\nimport { initTransaction } from '../../utilities/initTransaction.js'\nimport { killTransaction } from '../../utilities/killTransaction.js'\n\nexport type Args = {\n  collection: Collection\n  req: PayloadRequest\n  token: string\n}\n\nexport const verifyEmailOperation = async (args: Args): Promise<boolean> => {\n  const { collection, req, token } = args\n  if (!Object.prototype.hasOwnProperty.call(args, 'token')) {\n    throw new APIError('Missing required data.', httpStatus.BAD_REQUEST)\n  }\n\n  try {\n    const shouldCommit = await initTransaction(req)\n\n    const user = await req.payload.db.findOne<any>({\n      collection: collection.config.slug,\n      req,\n      where: {\n        _verificationToken: { equals: token },\n      },\n    })\n\n    if (!user) {\n      throw new APIError('Verification token is invalid.', httpStatus.FORBIDDEN)\n    }\n\n    await req.payload.db.updateOne({\n      id: user.id,\n      collection: collection.config.slug,\n      data: {\n        ...user,\n        _verificationToken: null,\n        _verified: true,\n      },\n      req,\n    })\n\n    if (shouldCommit) {\n      await commitTransaction(req)\n    }\n\n    return true\n  } catch (error: unknown) {\n    await killTransaction(req)\n    throw error\n  }\n}\n\nexport default verifyEmailOperation\n"],"names":["httpStatus","APIError","commitTransaction","initTransaction","killTransaction","verifyEmailOperation","args","collection","req","token","Object","prototype","hasOwnProperty","call","BAD_REQUEST","shouldCommit","user","payload","db","findOne","config","slug","where","_verificationToken","equals","FORBIDDEN","updateOne","id","data","_verified","error"],"mappings":";;;;AAAA,OAAOA,gBAAgB,cAAa;AAKpC,SAASC,QAAQ,QAAQ,wBAAuB;AAEhD,SAASE,eAAe,QAAQ,qCAAoC;AADpE,SAASD,iBAAiB,QAAQ,uCAAsC;AAExE,SAASE,eAAe,QAAQ,qCAAoC;;;;;;AAQ7D,MAAMC,uBAAuB,OAAOC;IACzC,MAAM,EAAEC,UAAU,EAAEC,GAAG,EAAEC,KAAK,EAAE,GAAGH;IACnC,IAAI,CAACI,OAAOC,SAAS,CAACC,cAAc,CAACC,IAAI,CAACP,MAAM,UAAU;QACxD,MAAM,0JAAIL,WAAAA,CAAS,yKAA0BD,UAAAA,CAAWc,WAAW;IACrE;IAEA,IAAI;QACF,MAAMC,eAAe,MAAMZ,sLAAAA,EAAgBK;QAE3C,MAAMQ,OAAO,MAAMR,IAAIS,OAAO,CAACC,EAAE,CAACC,OAAO,CAAM;YAC7CZ,YAAYA,WAAWa,MAAM,CAACC,IAAI;YAClCb;YACAc,OAAO;gBACLC,oBAAoB;oBAAEC,QAAQf;gBAAM;YACtC;QACF;QAEA,IAAI,CAACO,MAAM;YACT,MAAM,IAAIf,iKAAAA,CAAS,iLAAkCD,UAAAA,CAAWyB,SAAS;QAC3E;QAEA,MAAMjB,IAAIS,OAAO,CAACC,EAAE,CAACQ,SAAS,CAAC;YAC7BC,IAAIX,KAAKW,EAAE;YACXpB,YAAYA,WAAWa,MAAM,CAACC,IAAI;YAClCO,MAAM;gBACJ,GAAGZ,IAAI;gBACPO,oBAAoB;gBACpBM,WAAW;YACb;YACArB;QACF;QAEA,IAAIO,cAAc;YAChB,4KAAMb,oBAAAA,EAAkBM;QAC1B;QAEA,OAAO;IACT,EAAE,OAAOsB,OAAgB;QACvB,0KAAM1B,kBAAAA,EAAgBI;QACtB,MAAMsB;IACR;AACF,EAAC;uCAEczB,qBAAoB"}},
    {"offset": {"line": 4329, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 4335, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/payload/src/auth/operations/local/verifyEmail.ts"],"sourcesContent":["import type { CollectionSlug, Payload, RequestContext } from '../../../index.js'\nimport type { PayloadRequest } from '../../../types/index.js'\n\nimport { APIError } from '../../../errors/index.js'\nimport { createLocalReq } from '../../../utilities/createLocalReq.js'\nimport { verifyEmailOperation } from '../verifyEmail.js'\n\nexport type Options<T extends CollectionSlug> = {\n  collection: T\n  context?: RequestContext\n  req?: PayloadRequest\n  token: string\n}\n\nasync function localVerifyEmail<T extends CollectionSlug>(\n  payload: Payload,\n  options: Options<T>,\n): Promise<boolean> {\n  const { collection: collectionSlug, token } = options\n\n  const collection = payload.collections[collectionSlug]\n\n  if (!collection) {\n    throw new APIError(\n      `The collection with slug ${String(collectionSlug)} can't be found. Verify Email Operation.`,\n    )\n  }\n\n  return verifyEmailOperation({\n    collection,\n    req: await createLocalReq(options, payload),\n    token,\n  })\n}\n\nexport default localVerifyEmail\n"],"names":["APIError","createLocalReq","verifyEmailOperation","localVerifyEmail","payload","options","collection","collectionSlug","token","collections","String","req"],"mappings":";;;AAGA,SAASA,QAAQ,QAAQ,2BAA0B;AAEnD,SAASE,oBAAoB,QAAQ,oBAAmB;AADxD,SAASD,cAAc,QAAQ,uCAAsC;;;;AAUrE,eAAeE,iBACbC,OAAgB,EAChBC,OAAmB;IAEnB,MAAM,EAAEC,YAAYC,cAAc,EAAEC,KAAK,EAAE,GAAGH;IAE9C,MAAMC,aAAaF,QAAQK,WAAW,CAACF,eAAe;IAEtD,IAAI,CAACD,YAAY;QACf,MAAM,0JAAIN,WAAAA,CACR,CAAC,yBAAyB,EAAEU,OAAOH,gBAAgB,wCAAwC,CAAC;IAEhG;IAEA,gLAAOL,uBAAAA,EAAqB;QAC1BI;QACAK,KAAK,yKAAMV,iBAAAA,EAAeI,SAASD;QACnCI;IACF;AACF;uCAEeL,iBAAgB"}},
    {"offset": {"line": 4358, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 4364, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/payload/src/auth/operations/local/index.ts"],"sourcesContent":["import { auth } from './auth.js'\nimport forgotPassword from './forgotPassword.js'\nimport login from './login.js'\nimport resetPassword from './resetPassword.js'\nimport unlock from './unlock.js'\nimport verifyEmail from './verifyEmail.js'\n\nexport default {\n  auth,\n  forgotPassword,\n  login,\n  resetPassword,\n  unlock,\n  verifyEmail,\n}\n"],"names":["auth","forgotPassword","login","resetPassword","unlock","verifyEmail"],"mappings":";;;AAAA,SAASA,IAAI,QAAQ,YAAW;AAChC,OAAOC,oBAAoB,sBAAqB;AAChD,OAAOC,WAAW,aAAY;AAC9B,OAAOC,mBAAmB,qBAAoB;AAC9C,OAAOC,YAAY,cAAa;AAChC,OAAOC,iBAAiB,mBAAkB;;;;;;;uCAE3B;iLACbL,OAAAA;qMACAC,UAAAA;mLACAC,UAAAA;mMACAC,UAAAA;qLACAC,UAAAA;+LACAC,UAAAA;AACF,EAAC"}},
    {"offset": {"line": 4388, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 4394, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/payload/src/utilities/flattenTopLevelFields.ts"],"sourcesContent":["import type { ClientTab } from '../admin/fields/Tabs.js'\nimport type { ClientField } from '../fields/config/client.js'\nimport type {\n  Field,\n  FieldAffectingData,\n  FieldAffectingDataClient,\n  FieldPresentationalOnly,\n  FieldPresentationalOnlyClient,\n  Tab,\n} from '../fields/config/types.js'\n\nimport {\n  fieldAffectsData,\n  fieldHasSubFields,\n  fieldIsPresentationalOnly,\n  tabHasName,\n} from '../fields/config/types.js'\n\ntype FlattenedField<TField> = TField extends ClientField\n  ? FieldAffectingDataClient | FieldPresentationalOnlyClient\n  : FieldAffectingData | FieldPresentationalOnly\n\ntype TabType<TField> = TField extends ClientField ? ClientTab : Tab\n\n/**\n * Flattens a collection's fields into a single array of fields, as long\n * as the fields do not affect data.\n *\n * @param fields\n * @param keepPresentationalFields if true, will skip flattening fields that are presentational only\n */\nfunction flattenFields<TField extends ClientField | Field>(\n  fields: TField[],\n  keepPresentationalFields?: boolean,\n): FlattenedField<TField>[] {\n  return fields.reduce<FlattenedField<TField>[]>((fieldsToUse, field) => {\n    if (fieldAffectsData(field) || (keepPresentationalFields && fieldIsPresentationalOnly(field))) {\n      return [...fieldsToUse, field as FlattenedField<TField>]\n    }\n\n    if (fieldHasSubFields(field)) {\n      return [...fieldsToUse, ...flattenFields(field.fields as TField[], keepPresentationalFields)]\n    }\n\n    if (field.type === 'tabs' && 'tabs' in field) {\n      return [\n        ...fieldsToUse,\n        ...field.tabs.reduce<FlattenedField<TField>[]>((tabFields, tab: TabType<TField>) => {\n          if (tabHasName(tab)) {\n            return [...tabFields, { ...tab, type: 'tab' } as unknown as FlattenedField<TField>]\n          } else {\n            return [\n              ...tabFields,\n              ...flattenFields(tab.fields as TField[], keepPresentationalFields),\n            ]\n          }\n        }, []),\n      ]\n    }\n\n    return fieldsToUse\n  }, [])\n}\n\nexport default flattenFields\n"],"names":["fieldAffectsData","fieldHasSubFields","fieldIsPresentationalOnly","tabHasName","flattenFields","fields","keepPresentationalFields","reduce","fieldsToUse","field","type","tabs","tabFields","tab"],"mappings":";;;AAWA,SACEA,gBAAgB,EAChBC,iBAAiB,EACjBC,yBAAyB,EACzBC,UAAU,QACL,4BAA2B;;AAQlC;;;;;;CAMC,GACD,SAASC,cACPC,MAAgB,EAChBC,wBAAkC;IAElC,OAAOD,OAAOE,MAAM,CAA2B,CAACC,aAAaC;QAC3D,QAAIT,gLAAAA,EAAiBS,UAAWH,6LAA4BJ,4BAAAA,EAA0BO,QAAS;YAC7F,OAAO;mBAAID;gBAAaC;aAAgC;QAC1D;QAEA,qKAAIR,oBAAAA,EAAkBQ,QAAQ;YAC5B,OAAO;mBAAID;mBAAgBJ,cAAcK,MAAMJ,MAAM,EAAcC;aAA0B;QAC/F;QAEA,IAAIG,MAAMC,IAAI,KAAK,UAAU,UAAUD,OAAO;YAC5C,OAAO;mBACFD;mBACAC,MAAME,IAAI,CAACJ,MAAM,CAA2B,CAACK,WAAWC;oBACzD,qKAAIV,aAAAA,EAAWU,MAAM;wBACnB,OAAO;+BAAID;4BAAW;gCAAE,GAAGC,GAAG;gCAAEH,MAAM;4BAAM;yBAAuC;oBACrF,OAAO;wBACL,OAAO;+BACFE;+BACAR,cAAcS,IAAIR,MAAM,EAAcC;yBAC1C;oBACH;gBACF,GAAG,EAAE;aACN;QACH;QAEA,OAAOE;IACT,GAAG,EAAE;AACP;uCAEeJ,cAAa"}},
    {"offset": {"line": 4445, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 4451, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/payload/src/types/constants.ts"],"sourcesContent":["export const validOperators = [\n  'equals',\n  'contains',\n  'not_equals',\n  'in',\n  'all',\n  'not_in',\n  'exists',\n  'greater_than',\n  'greater_than_equal',\n  'less_than',\n  'less_than_equal',\n  'like',\n  'within',\n  'intersects',\n  'near',\n] as const\n"],"names":["validOperators"],"mappings":";;;AAAO,MAAMA,iBAAiB;IAC5B;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;CACD,CAAS"}},
    {"offset": {"line": 4471, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 4477, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/payload/src/database/getLocalizedPaths.ts"],"sourcesContent":["import type { Field } from '../fields/config/types.js'\nimport type { Payload } from '../index.js'\nimport type { PathToQuery } from './queryValidation/types.js'\n\nimport { fieldAffectsData } from '../fields/config/types.js'\nimport flattenFields from '../utilities/flattenTopLevelFields.js'\n\nexport async function getLocalizedPaths({\n  collectionSlug,\n  fields,\n  globalSlug,\n  incomingPath,\n  locale,\n  overrideAccess = false,\n  payload,\n}: {\n  collectionSlug?: string\n  fields: Field[]\n  globalSlug?: string\n  incomingPath: string\n  locale?: string\n  overrideAccess?: boolean\n  payload: Payload\n}): Promise<PathToQuery[]> {\n  const pathSegments = incomingPath.split('.')\n  const localizationConfig = payload.config.localization\n\n  let paths: PathToQuery[] = [\n    {\n      collectionSlug,\n      complete: false,\n      field: undefined,\n      fields: flattenFields(fields, false),\n      globalSlug,\n      invalid: false,\n      path: '',\n    },\n  ]\n\n  for (let i = 0; i < pathSegments.length; i += 1) {\n    const segment = pathSegments[i]\n\n    const lastIncompletePath = paths.find(({ complete }) => !complete)\n\n    if (lastIncompletePath) {\n      const { path } = lastIncompletePath\n      let currentPath = path ? `${path}.${segment}` : segment\n\n      const matchedField = lastIncompletePath.fields.find(\n        (field) => fieldAffectsData(field) && field.name === segment,\n      )\n      lastIncompletePath.field = matchedField\n\n      if (currentPath === 'globalType' && globalSlug) {\n        lastIncompletePath.path = currentPath\n        lastIncompletePath.complete = true\n        lastIncompletePath.field = {\n          name: 'globalType',\n          type: 'text',\n        }\n\n        return paths\n      }\n\n      if (!matchedField && currentPath === 'id' && i === pathSegments.length - 1) {\n        lastIncompletePath.path = currentPath\n        const idField: Field = {\n          name: 'id',\n          type: payload.db.defaultIDType as 'text',\n        }\n        lastIncompletePath.field = idField\n        lastIncompletePath.complete = true\n        return paths\n      }\n\n      if (matchedField) {\n        if ('hidden' in matchedField && matchedField.hidden && !overrideAccess) {\n          lastIncompletePath.invalid = true\n        }\n\n        const nextSegment = pathSegments[i + 1]\n        const nextSegmentIsLocale =\n          localizationConfig && localizationConfig.localeCodes.includes(nextSegment)\n\n        if (nextSegmentIsLocale) {\n          // Skip the next iteration, because it's a locale\n          i += 1\n          currentPath = `${currentPath}.${nextSegment}`\n        } else if (localizationConfig && 'localized' in matchedField && matchedField.localized) {\n          currentPath = `${currentPath}.${locale}`\n        }\n\n        switch (matchedField.type) {\n          case 'blocks':\n          case 'richText':\n          case 'json': {\n            const upcomingSegments = pathSegments.slice(i + 1).join('.')\n            lastIncompletePath.complete = true\n            lastIncompletePath.path = upcomingSegments\n              ? `${currentPath}.${upcomingSegments}`\n              : currentPath\n            return paths\n          }\n\n          case 'relationship':\n          case 'upload': {\n            // If this is a polymorphic relation,\n            // We only support querying directly (no nested querying)\n            if (typeof matchedField.relationTo !== 'string') {\n              const lastSegmentIsValid =\n                ['relationTo', 'value'].includes(pathSegments[pathSegments.length - 1]) ||\n                pathSegments.length === 1 ||\n                (pathSegments.length === 2 && pathSegments[0] === 'version')\n\n              lastIncompletePath.path = pathSegments.join('.')\n\n              if (lastSegmentIsValid) {\n                lastIncompletePath.complete = true\n              } else {\n                lastIncompletePath.invalid = true\n                return paths\n              }\n            } else {\n              lastIncompletePath.complete = true\n              lastIncompletePath.path = currentPath\n\n              const nestedPathToQuery = pathSegments\n                .slice(nextSegmentIsLocale ? i + 2 : i + 1)\n                .join('.')\n\n              if (nestedPathToQuery) {\n                const relatedCollection = payload.collections[matchedField.relationTo].config\n\n                const remainingPaths = await getLocalizedPaths({\n                  collectionSlug: relatedCollection.slug,\n                  fields: relatedCollection.fields,\n                  globalSlug,\n                  incomingPath: nestedPathToQuery,\n                  locale,\n                  payload,\n                })\n\n                paths = [...paths, ...remainingPaths]\n              }\n\n              return paths\n            }\n\n            break\n          }\n\n          default: {\n            if ('fields' in lastIncompletePath.field) {\n              lastIncompletePath.fields = flattenFields(lastIncompletePath.field.fields, false)\n            }\n\n            if (i + 1 === pathSegments.length) {\n              lastIncompletePath.complete = true\n            }\n            lastIncompletePath.path = currentPath\n          }\n        }\n      } else {\n        lastIncompletePath.invalid = true\n        lastIncompletePath.path = currentPath\n        return paths\n      }\n    }\n  }\n\n  return paths\n}\n"],"names":["fieldAffectsData","flattenFields","getLocalizedPaths","collectionSlug","fields","globalSlug","incomingPath","locale","overrideAccess","payload","pathSegments","split","localizationConfig","config","localization","paths","complete","field","undefined","invalid","path","i","length","segment","lastIncompletePath","find","currentPath","matchedField","name","type","idField","db","defaultIDType","hidden","nextSegment","nextSegmentIsLocale","localeCodes","includes","localized","upcomingSegments","slice","join","relationTo","lastSegmentIsValid","nestedPathToQuery","relatedCollection","collections","remainingPaths","slug"],"mappings":"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"}},
    {"offset": {"line": 4608, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 4614, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/payload/src/utilities/isolateObjectProperty.ts"],"sourcesContent":["/* eslint-disable no-restricted-exports */\n/**\n * Creates a proxy for the given object that has its own property\n */\nexport default function isolateObjectProperty<T extends object>(\n  object: T,\n  key: (keyof T)[] | keyof T,\n): T {\n  const keys = Array.isArray(key) ? key : [key]\n  const delegate = {} as T\n\n  // Initialize delegate with the keys, if they exist in the original object\n  for (const k of keys) {\n    if (k in object) {\n      delegate[k] = object[k]\n    }\n  }\n\n  const handler: ProxyHandler<T> = {\n    deleteProperty(target, p): boolean {\n      return Reflect.deleteProperty(keys.includes(p as keyof T) ? delegate : target, p)\n    },\n    get(target, p, receiver) {\n      return Reflect.get(keys.includes(p as keyof T) ? delegate : target, p, receiver)\n    },\n    has(target, p) {\n      return Reflect.has(keys.includes(p as keyof T) ? delegate : target, p)\n    },\n    set(target, p, newValue, receiver) {\n      if (keys.includes(p as keyof T)) {\n        // in case of transactionID we must ignore any receiver, because\n        // \"If provided and target does not have a setter for propertyKey, the property will be set on receiver instead.\"\n        return Reflect.set(delegate, p, newValue)\n      } else {\n        return Reflect.set(target, p, newValue, receiver)\n      }\n    },\n  }\n  return new Proxy(object, handler)\n}\n"],"names":["isolateObjectProperty","object","key","keys","Array","isArray","delegate","k","handler","deleteProperty","target","p","Reflect","includes","get","receiver","has","set","newValue","Proxy"],"mappings":"AAAA,wCAAwC,GACxC;;CAEC,GACD;;;AAAe,SAASA,sBACtBC,MAAS,EACTC,GAA0B;IAE1B,MAAMC,OAAOC,MAAMC,OAAO,CAACH,OAAOA,MAAM;QAACA;KAAI;IAC7C,MAAMI,WAAW,CAAC;IAElB,0EAA0E;IAC1E,KAAK,MAAMC,KAAKJ,KAAM;QACpB,IAAII,KAAKN,QAAQ;YACfK,QAAQ,CAACC,EAAE,GAAGN,MAAM,CAACM,EAAE;QACzB;IACF;IAEA,MAAMC,UAA2B;QAC/BC,gBAAeC,MAAM,EAAEC,CAAC;YACtB,OAAOC,QAAQH,cAAc,CAACN,KAAKU,QAAQ,CAACF,KAAgBL,WAAWI,QAAQC;QACjF;QACAG,KAAIJ,MAAM,EAAEC,CAAC,EAAEI,QAAQ;YACrB,OAAOH,QAAQE,GAAG,CAACX,KAAKU,QAAQ,CAACF,KAAgBL,WAAWI,QAAQC,GAAGI;QACzE;QACAC,KAAIN,MAAM,EAAEC,CAAC;YACX,OAAOC,QAAQI,GAAG,CAACb,KAAKU,QAAQ,CAACF,KAAgBL,WAAWI,QAAQC;QACtE;QACAM,KAAIP,MAAM,EAAEC,CAAC,EAAEO,QAAQ,EAAEH,QAAQ;YAC/B,IAAIZ,KAAKU,QAAQ,CAACF,IAAe;gBAC/B,gEAAgE;gBAChE,iHAAiH;gBACjH,OAAOC,QAAQK,GAAG,CAACX,UAAUK,GAAGO;YAClC,OAAO;gBACL,OAAON,QAAQK,GAAG,CAACP,QAAQC,GAAGO,UAAUH;YAC1C;QACF;IACF;IACA,OAAO,IAAII,MAAMlB,QAAQO;AAC3B"}},
    {"offset": {"line": 4652, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 4658, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/payload/src/database/queryValidation/validateSearchParams.ts"],"sourcesContent":["import type { SanitizedCollectionConfig } from '../../collections/config/types.js'\nimport type { Field } from '../../fields/config/types.js'\nimport type { SanitizedGlobalConfig } from '../../globals/config/types.js'\nimport type { PayloadRequest } from '../../types/index.js'\nimport type { EntityPolicies, PathToQuery } from './types.js'\n\nimport { fieldAffectsData, fieldIsVirtual } from '../../fields/config/types.js'\nimport { getEntityPolicies } from '../../utilities/getEntityPolicies.js'\nimport isolateObjectProperty from '../../utilities/isolateObjectProperty.js'\nimport { getLocalizedPaths } from '../getLocalizedPaths.js'\nimport { validateQueryPaths } from './validateQueryPaths.js'\n\ntype Args = {\n  collectionConfig?: SanitizedCollectionConfig\n  errors: { path: string }[]\n  fields: Field[]\n  globalConfig?: SanitizedGlobalConfig\n  operator: string\n  overrideAccess: boolean\n  path: string\n  policies: EntityPolicies\n  req: PayloadRequest\n  val: unknown\n  versionFields?: Field[]\n}\n\n/**\n * Validate the Payload key / value / operator\n */\nexport async function validateSearchParam({\n  collectionConfig,\n  errors,\n  fields,\n  globalConfig,\n  operator,\n  overrideAccess,\n  path: incomingPath,\n  policies,\n  req,\n  val,\n  versionFields,\n}: Args): Promise<void> {\n  // Replace GraphQL nested field double underscore formatting\n  let sanitizedPath\n  if (incomingPath === '_id') {\n    sanitizedPath = 'id'\n  } else {\n    sanitizedPath = incomingPath.replace(/__/g, '.')\n  }\n  let paths: PathToQuery[] = []\n  const { slug } = collectionConfig || globalConfig\n\n  if (globalConfig && !policies.globals[slug]) {\n    globalConfig.fields = fields\n\n    policies.globals[slug] = await getEntityPolicies({\n      type: 'global',\n      entity: globalConfig,\n      operations: ['read'],\n      req,\n    })\n  }\n\n  if (sanitizedPath !== 'id') {\n    paths = await getLocalizedPaths({\n      collectionSlug: collectionConfig?.slug,\n      fields,\n      globalSlug: globalConfig?.slug,\n      incomingPath: sanitizedPath,\n      locale: req.locale,\n      overrideAccess,\n      payload: req.payload,\n    })\n  }\n  const promises = []\n  promises.push(\n    ...paths.map(async ({ collectionSlug, field, invalid, path }, i) => {\n      if (invalid) {\n        errors.push({ path })\n        return\n      }\n\n      if (fieldIsVirtual(field)) {\n        errors.push({ path })\n      }\n\n      if (!overrideAccess && fieldAffectsData(field)) {\n        if (collectionSlug) {\n          if (!policies.collections[collectionSlug]) {\n            policies.collections[collectionSlug] = await getEntityPolicies({\n              type: 'collection',\n              entity: req.payload.collections[collectionSlug].config,\n              operations: ['read'],\n              req: isolateObjectProperty(req, 'transactionID'),\n            })\n          }\n\n          if (\n            ['hash', 'salt'].includes(incomingPath) &&\n            collectionConfig.auth &&\n            !collectionConfig.auth?.disableLocalStrategy\n          ) {\n            errors.push({ path: incomingPath })\n          }\n        }\n        let fieldPath = path\n        // remove locale from end of path\n        if (path.endsWith(`.${req.locale}`)) {\n          fieldPath = path.slice(0, -(req.locale.length + 1))\n        }\n        // remove \".value\" from ends of polymorphic relationship paths\n        if (\n          (field.type === 'relationship' || field.type === 'upload') &&\n          Array.isArray(field.relationTo)\n        ) {\n          fieldPath = fieldPath.replace('.value', '')\n        }\n        const entityType: 'collections' | 'globals' = globalConfig ? 'globals' : 'collections'\n        const entitySlug = collectionSlug || globalConfig.slug\n        const segments = fieldPath.split('.')\n\n        let fieldAccess\n        if (versionFields) {\n          fieldAccess = policies[entityType][entitySlug]\n          if (segments[0] === 'parent' || segments[0] === 'version') {\n            segments.shift()\n          }\n        } else {\n          fieldAccess = policies[entityType][entitySlug].fields\n        }\n\n        segments.forEach((segment) => {\n          if (fieldAccess[segment]) {\n            if ('fields' in fieldAccess[segment]) {\n              fieldAccess = fieldAccess[segment].fields\n            } else if ('blocks' in fieldAccess[segment]) {\n              fieldAccess = fieldAccess[segment]\n            } else {\n              fieldAccess = fieldAccess[segment]\n            }\n          }\n        })\n\n        if (!fieldAccess?.read?.permission) {\n          errors.push({ path: fieldPath })\n        }\n      }\n\n      if (i > 1) {\n        // Remove top collection and reverse array\n        // to work backwards from top\n        const pathsToQuery = paths.slice(1).reverse()\n\n        pathsToQuery.forEach(\n          ({ collectionSlug: pathCollectionSlug, path: subPath }, pathToQueryIndex) => {\n            // On the \"deepest\" collection,\n            // validate query of the relationship\n            if (pathToQueryIndex === 0) {\n              promises.push(\n                validateQueryPaths({\n                  collectionConfig: req.payload.collections[pathCollectionSlug].config,\n                  errors,\n                  globalConfig: undefined,\n                  overrideAccess,\n                  policies,\n                  req,\n                  where: {\n                    [subPath]: {\n                      [operator]: val,\n                    },\n                  },\n                }),\n              )\n            }\n          },\n        )\n      }\n    }),\n  )\n  await Promise.all(promises)\n}\n"],"names":["fieldAffectsData","fieldIsVirtual","getEntityPolicies","isolateObjectProperty","getLocalizedPaths","validateQueryPaths","validateSearchParam","collectionConfig","errors","fields","globalConfig","operator","overrideAccess","path","incomingPath","policies","req","val","versionFields","sanitizedPath","replace","paths","slug","globals","type","entity","operations","collectionSlug","globalSlug","locale","payload","promises","push","map","field","invalid","i","collections","config","includes","auth","disableLocalStrategy","fieldPath","endsWith","slice","length","Array","isArray","relationTo","entityType","entitySlug","segments","split","fieldAccess","shift","forEach","segment","read","permission","pathsToQuery","reverse","pathCollectionSlug","subPath","pathToQueryIndex","undefined","where","Promise","all"],"mappings":"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"}},
    {"offset": {"line": 4802, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 4808, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/payload/src/errors/QueryError.ts"],"sourcesContent":["import httpStatus from 'http-status'\n\nimport { APIError } from './APIError.js'\n\nexport class QueryError extends APIError<{ path: string }[]> {\n  constructor(results: { path: string }[]) {\n    const message = `The following path${results.length === 1 ? '' : 's'} cannot be queried:`\n\n    super(\n      `${message} ${results.map((err) => err.path).join(', ')}`,\n      httpStatus.BAD_REQUEST,\n      results,\n    )\n  }\n}\n"],"names":["httpStatus","APIError","QueryError","constructor","results","message","length","map","err","path","join","BAD_REQUEST"],"mappings":";;;AAAA,OAAOA,gBAAgB,cAAa;AAEpC,SAASC,QAAQ,QAAQ,gBAAe;;;AAEjC,MAAMC,yKAAmBD,WAAAA;IAC9BE,YAAYC,OAA2B,CAAE;QACvC,MAAMC,UAAU,CAAC,kBAAkB,EAAED,QAAQE,MAAM,KAAK,IAAI,KAAK,IAAI,mBAAmB,CAAC;QAEzF,KAAK,CACH,CAAC,EAAED,QAAQ,CAAC,EAAED,QAAQG,GAAG,CAAC,CAACC,MAAQA,IAAIC,IAAI,EAAEC,IAAI,CAAC,MAAM,CAAC,iJACzDV,UAAAA,CAAWW,WAAW,EACtBP;IAEJ;AACF"}},
    {"offset": {"line": 4821, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 4827, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/payload/src/database/queryValidation/validateQueryPaths.ts"],"sourcesContent":["import type { SanitizedCollectionConfig } from '../../collections/config/types.js'\nimport type { Field, FieldAffectingData } from '../../fields/config/types.js'\nimport type { SanitizedGlobalConfig } from '../../globals/config/types.js'\nimport type { Operator, PayloadRequest, Where, WhereField } from '../../types/index.js'\nimport type { EntityPolicies } from './types.js'\n\nimport { QueryError } from '../../errors/QueryError.js'\nimport { validOperators } from '../../types/constants.js'\nimport { deepCopyObject } from '../../utilities/deepCopyObject.js'\nimport flattenFields from '../../utilities/flattenTopLevelFields.js'\nimport { validateSearchParam } from './validateSearchParams.js'\n\ntype Args = {\n  errors?: { path: string }[]\n  overrideAccess: boolean\n  policies?: EntityPolicies\n  req: PayloadRequest\n  versionFields?: Field[]\n  where: Where\n} & (\n  | {\n      collectionConfig: SanitizedCollectionConfig\n      globalConfig?: never | undefined\n    }\n  | {\n      collectionConfig?: never | undefined\n      globalConfig: SanitizedGlobalConfig\n    }\n)\n\nconst flattenWhere = (query: Where): WhereField[] =>\n  Object.entries(query).reduce((flattenedConstraints, [key, val]) => {\n    if ((key === 'and' || key === 'or') && Array.isArray(val)) {\n      const subWhereConstraints: Where[] = val.reduce((acc, subVal) => {\n        const subWhere = flattenWhere(subVal)\n        return [...acc, ...subWhere]\n      }, [])\n      return [...flattenedConstraints, ...subWhereConstraints]\n    }\n\n    return [...flattenedConstraints, { [key]: val }]\n  }, [])\n\nexport async function validateQueryPaths({\n  collectionConfig,\n  errors = [],\n  globalConfig,\n  overrideAccess,\n  policies = {\n    collections: {},\n    globals: {},\n  },\n  req,\n  versionFields,\n  where,\n}: Args): Promise<void> {\n  const fields = flattenFields(\n    versionFields || (globalConfig || collectionConfig).fields,\n  ) as FieldAffectingData[]\n  if (typeof where === 'object') {\n    const whereFields = flattenWhere(where)\n    // We need to determine if the whereKey is an AND, OR, or a schema path\n    const promises = []\n    void whereFields.map((constraint) => {\n      void Object.keys(constraint).map((path) => {\n        void Object.entries(constraint[path]).map(([operator, val]) => {\n          if (validOperators.includes(operator as Operator)) {\n            promises.push(\n              validateSearchParam({\n                collectionConfig: deepCopyObject(collectionConfig),\n                errors,\n                fields: fields as Field[],\n                globalConfig: deepCopyObject(globalConfig),\n                operator,\n                overrideAccess,\n                path,\n                policies,\n                req,\n                val,\n                versionFields,\n              }),\n            )\n          }\n        })\n      })\n    })\n    await Promise.all(promises)\n    if (errors.length > 0) {\n      throw new QueryError(errors)\n    }\n  }\n}\n"],"names":["QueryError","validOperators","deepCopyObject","flattenFields","validateSearchParam","flattenWhere","query","Object","entries","reduce","flattenedConstraints","key","val","Array","isArray","subWhereConstraints","acc","subVal","subWhere","validateQueryPaths","collectionConfig","errors","globalConfig","overrideAccess","policies","collections","globals","req","versionFields","where","fields","whereFields","promises","map","constraint","keys","path","operator","includes","push","Promise","all","length"],"mappings":";;;AASA,OAAOG,mBAAmB,2CAA0C;AAFpE,SAASF,cAAc,QAAQ,2BAA0B;AAGzD,SAASG,mBAAmB,QAAQ,4BAA2B;AAF/D,SAASF,cAAc,QAAQ,oCAAmC;AAFlE,SAASF,UAAU,QAAQ,6BAA4B;;;;;;AAwBvD,MAAMK,eAAe,CAACC,QACpBC,OAAOC,OAAO,CAACF,OAAOG,MAAM,CAAC,CAACC,sBAAsB,CAACC,KAAKC,IAAI;QAC5D,IAAKD,CAAAA,QAAQ,SAASA,QAAQ,IAAG,KAAME,MAAMC,OAAO,CAACF,MAAM;YACzD,MAAMG,sBAA+BH,IAAIH,MAAM,CAAC,CAACO,KAAKC;gBACpD,MAAMC,WAAWb,aAAaY;gBAC9B,OAAO;uBAAID;uBAAQE;iBAAS;YAC9B,GAAG,EAAE;YACL,OAAO;mBAAIR;mBAAyBK;aAAoB;QAC1D;QAEA,OAAO;eAAIL;YAAsB;gBAAE,CAACC,IAAI,EAAEC;YAAI;SAAE;IAClD,GAAG,EAAE;AAEA,eAAeO,mBAAmB,EACvCC,gBAAgB,EAChBC,SAAS,EAAE,EACXC,YAAY,EACZC,cAAc,EACdC,WAAW;IACTC,aAAa,CAAC;IACdC,SAAS,CAAC;AACZ,CAAC,EACDC,GAAG,EACHC,aAAa,EACbC,KAAK,EACA;IACL,MAAMC,mLAAS3B,UAAAA,EACbyB,iBAAkBN,CAAAA,gBAAgBF,gBAAe,EAAGU,MAAM;IAE5D,IAAI,OAAOD,UAAU,UAAU;QAC7B,MAAME,cAAc1B,aAAawB;QACjC,uEAAuE;QACvE,MAAMG,WAAW,EAAE;QACnB,KAAKD,YAAYE,GAAG,CAAC,CAACC;YACpB,KAAK3B,OAAO4B,IAAI,CAACD,YAAYD,GAAG,CAAC,CAACG;gBAChC,KAAK7B,OAAOC,OAAO,CAAC0B,UAAU,CAACE,KAAK,EAAEH,GAAG,CAAC,CAAC,CAACI,UAAUzB,IAAI;oBACxD,0JAAIX,iBAAAA,CAAeqC,QAAQ,CAACD,WAAuB;wBACjDL,SAASO,IAAI,4LACXnC,sBAAAA,EAAoB;4BAClBgB,mBAAkBlB,mLAAAA,EAAekB;4BACjCC;4BACAS,QAAQA;4BACRR,iLAAcpB,iBAAAA,EAAeoB;4BAC7Be;4BACAd;4BACAa;4BACAZ;4BACAG;4BACAf;4BACAgB;wBACF;oBAEJ;gBACF;YACF;QACF;QACA,MAAMY,QAAQC,GAAG,CAACT;QAClB,IAAIX,OAAOqB,MAAM,GAAG,GAAG;YACrB,MAAM,4JAAI1C,aAAAA,CAAWqB;QACvB;IACF;AACF"}},
    {"offset": {"line": 4897, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 4903, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/payload/src/collections/operations/count.ts"],"sourcesContent":["import type { AccessResult } from '../../config/types.js'\nimport type { CollectionSlug } from '../../index.js'\nimport type { PayloadRequest, Where } from '../../types/index.js'\nimport type { Collection } from '../config/types.js'\n\nimport executeAccess from '../../auth/executeAccess.js'\nimport { combineQueries } from '../../database/combineQueries.js'\nimport { validateQueryPaths } from '../../database/queryValidation/validateQueryPaths.js'\nimport { killTransaction } from '../../utilities/killTransaction.js'\nimport { buildAfterOperation } from './utils.js'\n\nexport type Arguments = {\n  collection: Collection\n  disableErrors?: boolean\n  overrideAccess?: boolean\n  req?: PayloadRequest\n  where?: Where\n}\n\nexport const countOperation = async <TSlug extends CollectionSlug>(\n  incomingArgs: Arguments,\n): Promise<{ totalDocs: number }> => {\n  let args = incomingArgs\n\n  try {\n    // /////////////////////////////////////\n    // beforeOperation - Collection\n    // /////////////////////////////////////\n\n    await args.collection.config.hooks.beforeOperation.reduce(async (priorHook, hook) => {\n      await priorHook\n\n      args =\n        (await hook({\n          args,\n          collection: args.collection.config,\n          context: args.req.context,\n          operation: 'count',\n          req: args.req,\n        })) || args\n    }, Promise.resolve())\n\n    const {\n      collection: { config: collectionConfig },\n      disableErrors,\n      overrideAccess,\n      req: { payload },\n      req,\n      where,\n    } = args\n\n    // /////////////////////////////////////\n    // Access\n    // /////////////////////////////////////\n\n    let accessResult: AccessResult\n\n    if (!overrideAccess) {\n      accessResult = await executeAccess({ disableErrors, req }, collectionConfig.access.read)\n\n      // If errors are disabled, and access returns false, return empty results\n      if (accessResult === false) {\n        return {\n          totalDocs: 0,\n        }\n      }\n    }\n\n    let result: { totalDocs: number }\n\n    const fullWhere = combineQueries(where, accessResult)\n\n    await validateQueryPaths({\n      collectionConfig,\n      overrideAccess,\n      req,\n      where,\n    })\n\n    result = await payload.db.count({\n      collection: collectionConfig.slug,\n      req,\n      where: fullWhere,\n    })\n\n    // /////////////////////////////////////\n    // afterOperation - Collection\n    // /////////////////////////////////////\n\n    result = await buildAfterOperation({\n      args,\n      collection: collectionConfig,\n      operation: 'count',\n      result,\n    })\n\n    // /////////////////////////////////////\n    // Return results\n    // /////////////////////////////////////\n\n    return result\n  } catch (error: unknown) {\n    await killTransaction(args.req)\n    throw error\n  }\n}\n"],"names":["executeAccess","combineQueries","validateQueryPaths","killTransaction","buildAfterOperation","countOperation","incomingArgs","args","collection","config","hooks","beforeOperation","reduce","priorHook","hook","context","req","operation","Promise","resolve","collectionConfig","disableErrors","overrideAccess","payload","where","accessResult","access","read","totalDocs","result","fullWhere","db","count","slug","error"],"mappings":";;;AAKA,OAAOA,mBAAmB,8BAA6B;AACvD,SAASC,cAAc,QAAQ,mCAAkC;AACjE,SAASC,kBAAkB,QAAQ,uDAAsD;AAEzF,SAASE,mBAAmB,QAAQ,aAAY;AADhD,SAASD,eAAe,QAAQ,qCAAoC;;;;;;AAW7D,MAAME,iBAAiB,OAC5BC;IAEA,IAAIC,OAAOD;IAEX,IAAI;QACF,wCAAwC;QACxC,+BAA+B;QAC/B,wCAAwC;QAExC,MAAMC,KAAKC,UAAU,CAACC,MAAM,CAACC,KAAK,CAACC,eAAe,CAACC,MAAM,CAAC,OAAOC,WAAWC;YAC1E,MAAMD;YAENN,OACG,MAAMO,KAAK;gBACVP;gBACAC,YAAYD,KAAKC,UAAU,CAACC,MAAM;gBAClCM,SAASR,KAAKS,GAAG,CAACD,OAAO;gBACzBE,WAAW;gBACXD,KAAKT,KAAKS,GAAG;YACf,MAAOT;QACX,GAAGW,QAAQC,OAAO;QAElB,MAAM,EACJX,YAAY,EAAEC,QAAQW,gBAAgB,EAAE,EACxCC,aAAa,EACbC,cAAc,EACdN,KAAK,EAAEO,OAAO,EAAE,EAChBP,GAAG,EACHQ,KAAK,EACN,GAAGjB;QAEJ,wCAAwC;QACxC,SAAS;QACT,wCAAwC;QAExC,IAAIkB;QAEJ,IAAI,CAACH,gBAAgB;YACnBG,eAAe,mKAAMzB,UAAAA,EAAc;gBAAEqB;gBAAeL;YAAI,GAAGI,iBAAiBM,MAAM,CAACC,IAAI;YAEvF,yEAAyE;YACzE,IAAIF,iBAAiB,OAAO;gBAC1B,OAAO;oBACLG,WAAW;gBACb;YACF;QACF;QAEA,IAAIC;QAEJ,MAAMC,8KAAY7B,iBAAAA,EAAeuB,OAAOC;QAExC,OAAMvB,6MAAAA,EAAmB;YACvBkB;YACAE;YACAN;YACAQ;QACF;QAEAK,SAAS,MAAMN,QAAQQ,EAAE,CAACC,KAAK,CAAC;YAC9BxB,YAAYY,iBAAiBa,IAAI;YACjCjB;YACAQ,OAAOM;QACT;QAEA,wCAAwC;QACxC,8BAA8B;QAC9B,wCAAwC;QAExCD,SAAS,gLAAMzB,sBAAAA,EAAoB;YACjCG;YACAC,YAAYY;YACZH,WAAW;YACXY;QACF;QAEA,wCAAwC;QACxC,iBAAiB;QACjB,wCAAwC;QAExC,OAAOA;IACT,EAAE,OAAOK,OAAgB;QACvB,0KAAM/B,kBAAAA,EAAgBI,KAAKS,GAAG;QAC9B,MAAMkB;IACR;AACF,EAAC"}},
    {"offset": {"line": 4980, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 4986, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/payload/src/collections/operations/local/count.ts"],"sourcesContent":["import type { CollectionSlug, Payload, TypedLocale } from '../../../index.js'\nimport type { Document, PayloadRequest, RequestContext, Where } from '../../../types/index.js'\n\nimport { APIError } from '../../../errors/index.js'\nimport { createLocalReq } from '../../../utilities/createLocalReq.js'\nimport { countOperation } from '../count.js'\n\nexport type Options<TSlug extends CollectionSlug> = {\n  collection: TSlug\n  /**\n   * context, which will then be passed to req.context, which can be read by hooks\n   */\n  context?: RequestContext\n  depth?: number\n  disableErrors?: boolean\n  locale?: TypedLocale\n  overrideAccess?: boolean\n  req?: PayloadRequest\n  user?: Document\n  where?: Where\n}\n\nexport default async function countLocal<TSlug extends CollectionSlug>(\n  payload: Payload,\n  options: Options<TSlug>,\n): Promise<{ totalDocs: number }> {\n  const { collection: collectionSlug, disableErrors, overrideAccess = true, where } = options\n\n  const collection = payload.collections[collectionSlug]\n\n  if (!collection) {\n    throw new APIError(\n      `The collection with slug ${String(collectionSlug)} can't be found. Count Operation.`,\n    )\n  }\n\n  return countOperation<TSlug>({\n    collection,\n    disableErrors,\n    overrideAccess,\n    req: await createLocalReq(options, payload),\n    where,\n  })\n}\n"],"names":["APIError","createLocalReq","countOperation","countLocal","payload","options","collection","collectionSlug","disableErrors","overrideAccess","where","collections","String","req"],"mappings":";;;AAGA,SAASA,QAAQ,QAAQ,2BAA0B;AAEnD,SAASE,cAAc,QAAQ,cAAa;AAD5C,SAASD,cAAc,QAAQ,uCAAsC;;;;AAkBtD,eAAeE,WAC5BC,OAAgB,EAChBC,OAAuB;IAEvB,MAAM,EAAEC,YAAYC,cAAc,EAAEC,aAAa,EAAEC,iBAAiB,IAAI,EAAEC,KAAK,EAAE,GAAGL;IAEpF,MAAMC,aAAaF,QAAQO,WAAW,CAACJ,eAAe;IAEtD,IAAI,CAACD,YAAY;QACf,MAAM,0JAAIN,WAAAA,CACR,CAAC,yBAAyB,EAAEY,OAAOL,gBAAgB,iCAAiC,CAAC;IAEzF;IAEA,iLAAOL,iBAAAA,EAAsB;QAC3BI;QACAE;QACAC;QACAI,KAAK,yKAAMZ,iBAAAA,EAAeI,SAASD;QACnCM;IACF;AACF"}},
    {"offset": {"line": 5009, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 5015, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/payload/src/uploads/getFileByPath.ts"],"sourcesContent":["import { fileTypeFromFile } from 'file-type'\nimport fs from 'fs'\nimport path from 'path'\n\nimport type { PayloadRequest } from '../types/index.js'\n\nconst mimeTypeEstimate = {\n  svg: 'image/svg+xml',\n}\n\nexport const getFileByPath = async (filePath: string): Promise<PayloadRequest['file']> => {\n  if (typeof filePath === 'string') {\n    const data = fs.readFileSync(filePath)\n    const mimetype = fileTypeFromFile(filePath)\n    const { size } = fs.statSync(filePath)\n\n    const name = path.basename(filePath)\n    const ext = path.extname(filePath).slice(1)\n\n    const mime = (await mimetype)?.mime || mimeTypeEstimate[ext]\n\n    return {\n      name,\n      data,\n      mimetype: mime,\n      size,\n    }\n  }\n\n  return undefined\n}\n"],"names":["fileTypeFromFile","fs","path","mimeTypeEstimate","svg","getFileByPath","filePath","data","readFileSync","mimetype","size","statSync","name","basename","ext","extname","slice","mime","undefined"],"mappings":";;;AACA,OAAOC,QAAQ,KAAI;AACnB,OAAOC,UAAU,OAAM;AAFvB,SAASF,gBAAgB,QAAQ,YAAW;;;;AAM5C,MAAMG,mBAAmB;IACvBC,KAAK;AACP;AAEO,MAAMC,gBAAgB,OAAOC;IAClC,IAAI,OAAOA,aAAa,UAAU;QAChC,MAAMC,mGAAON,UAAAA,CAAGO,YAAY,CAACF;QAC7B,MAAMG,qKAAWT,mBAAAA,EAAiBM;QAClC,MAAM,EAAEI,IAAI,EAAE,+FAAGT,UAAAA,CAAGU,QAAQ,CAACL;QAE7B,MAAMM,qGAAOV,UAAAA,CAAKW,QAAQ,CAACP;QAC3B,MAAMQ,oGAAMZ,UAAAA,CAAKa,OAAO,CAACT,UAAUU,KAAK,CAAC;QAEzC,MAAMC,OAAQ,CAAA,MAAMR,QAAO,GAAIQ,QAAQd,gBAAgB,CAACW,IAAI;QAE5D,OAAO;YACLF;YACAL;YACAE,UAAUQ;YACVP;QACF;IACF;IAEA,OAAOQ;AACT,EAAC"}},
    {"offset": {"line": 5044, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 5050, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/payload/src/auth/ensureUsernameOrEmail.ts"],"sourcesContent":["import type { RequiredDataFromCollectionSlug } from '../collections/config/types.js'\nimport type { AuthCollection, CollectionSlug, PayloadRequest } from '../index.js'\n\nimport { ValidationError } from '../errors/index.js'\n\ntype ValidateUsernameOrEmailArgs<TSlug extends CollectionSlug> = {\n  authOptions: AuthCollection['config']['auth']\n  collectionSlug: string\n  data: RequiredDataFromCollectionSlug<TSlug>\n  req: PayloadRequest\n} & (\n  | {\n      operation: 'create'\n      originalDoc?: never\n    }\n  | {\n      operation: 'update'\n      originalDoc: RequiredDataFromCollectionSlug<TSlug>\n    }\n)\nexport const ensureUsernameOrEmail = <TSlug extends CollectionSlug>({\n  authOptions: { disableLocalStrategy, loginWithUsername },\n  collectionSlug,\n  data,\n  operation,\n  originalDoc,\n  req,\n}: ValidateUsernameOrEmailArgs<TSlug>) => {\n  // neither username or email are required\n  // and neither are provided\n  // so we need to manually validate\n  if (\n    !disableLocalStrategy &&\n    loginWithUsername &&\n    !loginWithUsername.requireEmail &&\n    !loginWithUsername.requireUsername\n  ) {\n    let missingFields = false\n    if (operation === 'create' && !data.email && !data.username) {\n      missingFields = true\n    } else if (operation === 'update') {\n      // prevent clearing both email and username\n      if ('email' in data && !data.email && 'username' in data && !data.username) {\n        missingFields = true\n      }\n      // prevent clearing email if no username\n      if ('email' in data && !data.email && !originalDoc.username && !data?.username) {\n        missingFields = true\n      }\n      // prevent clearing username if no email\n      if ('username' in data && !data.username && !originalDoc.email && !data?.email) {\n        missingFields = true\n      }\n    }\n\n    if (missingFields) {\n      throw new ValidationError(\n        {\n          collection: collectionSlug,\n          errors: [\n            {\n              field: 'username',\n              message: 'Username or email is required',\n            },\n            {\n              field: 'email',\n              message: 'Username or email is required',\n            },\n          ],\n        },\n        req.t,\n      )\n    }\n  }\n\n  return\n}\n"],"names":["ValidationError","ensureUsernameOrEmail","authOptions","disableLocalStrategy","loginWithUsername","collectionSlug","data","operation","originalDoc","req","requireEmail","requireUsername","missingFields","email","username","collection","errors","field","message","t"],"mappings":";;;AAGA,SAASA,eAAe,QAAQ,qBAAoB;;AAiB7C,MAAMC,wBAAwB,CAA+B,EAClEC,aAAa,EAAEC,oBAAoB,EAAEC,iBAAiB,EAAE,EACxDC,cAAc,EACdC,IAAI,EACJC,SAAS,EACTC,WAAW,EACXC,GAAG,EACgC;IACnC,yCAAyC;IACzC,2BAA2B;IAC3B,kCAAkC;IAClC,IACE,CAACN,wBACDC,qBACA,CAACA,kBAAkBM,YAAY,IAC/B,CAACN,kBAAkBO,eAAe,EAClC;QACA,IAAIC,gBAAgB;QACpB,IAAIL,cAAc,YAAY,CAACD,KAAKO,KAAK,IAAI,CAACP,KAAKQ,QAAQ,EAAE;YAC3DF,gBAAgB;QAClB,OAAO,IAAIL,cAAc,UAAU;YACjC,2CAA2C;YAC3C,IAAI,WAAWD,QAAQ,CAACA,KAAKO,KAAK,IAAI,cAAcP,QAAQ,CAACA,KAAKQ,QAAQ,EAAE;gBAC1EF,gBAAgB;YAClB;YACA,wCAAwC;YACxC,IAAI,WAAWN,QAAQ,CAACA,KAAKO,KAAK,IAAI,CAACL,YAAYM,QAAQ,IAAI,CAACR,MAAMQ,UAAU;gBAC9EF,gBAAgB;YAClB;YACA,wCAAwC;YACxC,IAAI,cAAcN,QAAQ,CAACA,KAAKQ,QAAQ,IAAI,CAACN,YAAYK,KAAK,IAAI,CAACP,MAAMO,OAAO;gBAC9ED,gBAAgB;YAClB;QACF;QAEA,IAAIA,eAAe;YACjB,MAAM,iKAAIZ,kBAAAA,CACR;gBACEe,YAAYV;gBACZW,QAAQ;oBACN;wBACEC,OAAO;wBACPC,SAAS;oBACX;oBACA;wBACED,OAAO;wBACPC,SAAS;oBACX;iBACD;YACH,GACAT,IAAIU,CAAC;QAET;IACF;IAEA;AACF,EAAC"}},
    {"offset": {"line": 5095, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 5101, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/payload/src/uploads/getExternalFile.ts"],"sourcesContent":["import type { PayloadRequest } from '../types/index.js'\nimport type { File, FileData, UploadConfig } from './types.js'\n\nimport { APIError } from '../errors/index.js'\n\ntype Args = {\n  data: FileData\n  req: PayloadRequest\n  uploadConfig: UploadConfig\n}\nexport const getExternalFile = async ({ data, req, uploadConfig }: Args): Promise<File> => {\n  const { filename, url } = data\n\n  if (typeof url === 'string') {\n    let fileURL = url\n    if (!url.startsWith('http')) {\n      const baseUrl = req.headers.get('origin') || `${req.protocol}://${req.headers.get('host')}`\n      fileURL = `${baseUrl}${url}`\n    }\n\n    const headers = uploadConfig.externalFileHeaderFilter\n      ? uploadConfig.externalFileHeaderFilter(Object.fromEntries(new Headers(req.headers)))\n      : { cookie: req.headers?.get('cookie') }\n\n    const res = await fetch(fileURL, {\n      credentials: 'include',\n      headers,\n      method: 'GET',\n    })\n\n    if (!res.ok) {\n      throw new APIError(`Failed to fetch file from ${fileURL}`, res.status)\n    }\n\n    const data = await res.arrayBuffer()\n\n    return {\n      name: filename,\n      data: Buffer.from(data),\n      mimetype: res.headers.get('content-type') || undefined,\n      size: Number(res.headers.get('content-length')) || 0,\n    }\n  }\n\n  throw new APIError('Invalid file url', 400)\n}\n"],"names":["APIError","getExternalFile","data","req","uploadConfig","filename","url","fileURL","startsWith","baseUrl","headers","get","protocol","externalFileHeaderFilter","Object","fromEntries","Headers","cookie","res","fetch","credentials","method","ok","status","arrayBuffer","name","Buffer","from","mimetype","undefined","size","Number"],"mappings":";;;AAGA,SAASA,QAAQ,QAAQ,qBAAoB;;AAOtC,MAAMC,kBAAkB,OAAO,EAAEC,IAAI,EAAEC,GAAG,EAAEC,YAAY,EAAQ;IACrE,MAAM,EAAEC,QAAQ,EAAEC,GAAG,EAAE,GAAGJ;IAE1B,IAAI,OAAOI,QAAQ,UAAU;QAC3B,IAAIC,UAAUD;QACd,IAAI,CAACA,IAAIE,UAAU,CAAC,SAAS;YAC3B,MAAMC,UAAUN,IAAIO,OAAO,CAACC,GAAG,CAAC,aAAa,CAAC,EAAER,IAAIS,QAAQ,CAAC,GAAG,EAAET,IAAIO,OAAO,CAACC,GAAG,CAAC,QAAQ,CAAC;YAC3FJ,UAAU,CAAC,EAAEE,QAAQ,EAAEH,IAAI,CAAC;QAC9B;QAEA,MAAMI,UAAUN,aAAaS,wBAAwB,GACjDT,aAAaS,wBAAwB,CAACC,OAAOC,WAAW,CAAC,IAAIC,QAAQb,IAAIO,OAAO,MAChF;YAAEO,QAAQd,IAAIO,OAAO,EAAEC,IAAI;QAAU;QAEzC,MAAMO,MAAM,MAAMC,MAAMZ,SAAS;YAC/Ba,aAAa;YACbV;YACAW,QAAQ;QACV;QAEA,IAAI,CAACH,IAAII,EAAE,EAAE;YACX,MAAM,0JAAItB,WAAAA,CAAS,CAAC,0BAA0B,EAAEO,QAAQ,CAAC,EAAEW,IAAIK,MAAM;QACvE;QAEA,MAAMrB,OAAO,MAAMgB,IAAIM,WAAW;QAElC,OAAO;YACLC,MAAMpB;YACNH,MAAMwB,OAAOC,IAAI,CAACzB;YAClB0B,UAAUV,IAAIR,OAAO,CAACC,GAAG,CAAC,mBAAmBkB;YAC7CC,MAAMC,OAAOb,IAAIR,OAAO,CAACC,GAAG,CAAC,sBAAsB;QACrD;IACF;IAEA,MAAM,0JAAIX,WAAAA,CAAS,oBAAoB;AACzC,EAAC"}},
    {"offset": {"line": 5135, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 5141, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/payload/src/errors/FileRetrievalError.ts"],"sourcesContent":["import type { TFunction } from '@payloadcms/translations'\n\nimport httpStatus from 'http-status'\n\nimport { APIError } from './APIError.js'\n\nexport class FileRetrievalError extends APIError {\n  constructor(t?: TFunction, message?: string) {\n    let msg = t ? t('error:problemUploadingFile') : 'There was a problem while retrieving the file.'\n\n    if (message) {\n      msg += ` ${message}`\n    }\n    super(msg, httpStatus.INTERNAL_SERVER_ERROR)\n  }\n}\n"],"names":["httpStatus","APIError","FileRetrievalError","constructor","t","message","msg","INTERNAL_SERVER_ERROR"],"mappings":";;;AAEA,OAAOA,gBAAgB,cAAa;AAEpC,SAASC,QAAQ,QAAQ,gBAAe;;;AAEjC,MAAMC,iLAA2BD,WAAAA;IACtCE,YAAYC,CAAa,EAAEC,OAAgB,CAAE;QAC3C,IAAIC,MAAMF,IAAIA,EAAE,gCAAgC;QAEhD,IAAIC,SAAS;YACXC,OAAO,CAAC,CAAC,EAAED,QAAQ,CAAC;QACtB;QACA,KAAK,CAACC,oJAAKN,UAAAA,CAAWO,qBAAqB;IAC7C;AACF"}},
    {"offset": {"line": 5157, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 5163, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/payload/src/uploads/canResizeImage.ts"],"sourcesContent":["export function canResizeImage(mimeType: string): boolean {\n  return ['image/jpeg', 'image/png', 'image/gif', 'image/webp', 'image/tiff'].indexOf(mimeType) > -1\n}\n"],"names":["canResizeImage","mimeType","indexOf"],"mappings":";;;AAAO,SAASA,eAAeC,QAAgB;IAC7C,OAAO;QAAC;QAAc;QAAa;QAAa;QAAc;KAAa,CAACC,OAAO,CAACD,YAAY,CAAC;AACnG"}},
    {"offset": {"line": 5175, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 5181, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/payload/src/uploads/isImage.ts"],"sourcesContent":["export function isImage(mimeType: string): boolean {\n  return (\n    ['image/jpeg', 'image/png', 'image/gif', 'image/svg+xml', 'image/webp', 'image/avif'].indexOf(\n      mimeType,\n    ) > -1\n  )\n}\n"],"names":["isImage","mimeType","indexOf"],"mappings":";;;AAAO,SAASA,QAAQC,QAAgB;IACtC,OACE;QAAC;QAAc;QAAa;QAAa;QAAiB;QAAc;KAAa,CAACC,OAAO,CAC3FD,YACE,CAAC;AAET"}},
    {"offset": {"line": 5194, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 5200, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/payload/src/uploads/tempFile.ts"],"sourcesContent":["import { promises as fsPromises } from 'fs'\nimport os from 'node:os'\nimport path from 'node:path'\nimport { v4 as uuid } from 'uuid'\n\nasync function runTask(temporaryPath: string, callback) {\n  try {\n    return await callback(temporaryPath)\n  } finally {\n    await fsPromises.rm(temporaryPath, { force: true, maxRetries: 2, recursive: true })\n  }\n}\n\ntype Options = {\n  extension?: string\n  name?: string\n}\n\nexport const temporaryFileTask = async (callback, options: Options = {}) => {\n  const filePath = await temporaryFile(options)\n  return runTask(filePath, callback)\n}\n\nasync function temporaryFile(options: Options) {\n  if (options.name) {\n    if (options.extension !== undefined && options.extension !== null) {\n      throw new Error('The `name` and `extension` options are mutually exclusive')\n    }\n\n    return path.join(await temporaryDirectory(), options.name)\n  }\n\n  return (\n    (await getPath()) +\n    (options.extension === undefined || options.extension === null\n      ? ''\n      : '.' + options.extension.replace(/^\\./, ''))\n  )\n}\n\nasync function temporaryDirectory({ prefix = '' } = {}) {\n  const directory = await getPath(prefix)\n  await fsPromises.mkdir(directory)\n  return directory\n}\n\nasync function getPath(prefix = ''): Promise<string> {\n  const temporaryDirectory = await fsPromises.realpath(os.tmpdir())\n  return path.join(temporaryDirectory, prefix + uuid())\n}\n"],"names":["promises","fsPromises","os","path","v4","uuid","runTask","temporaryPath","callback","rm","force","maxRetries","recursive","temporaryFileTask","options","filePath","temporaryFile","name","extension","undefined","Error","join","temporaryDirectory","getPath","replace","prefix","directory","mkdir","realpath","tmpdir"],"mappings":";;;AAAA,SAASA,YAAYC,UAAU,QAAQ,KAAI;AAC3C,OAAOC,QAAQ,UAAS;AACxB,OAAOC,UAAU,YAAW;AAC5B,SAASC,MAAMC,IAAI,QAAQ,OAAM;;;;;AAEjC,eAAeC,QAAQC,aAAqB,EAAEC,QAAQ;IACpD,IAAI;QACF,OAAO,MAAMA,SAASD;IACxB,SAAU;QACR,kGAAMN,WAAAA,CAAWQ,EAAE,CAACF,eAAe;YAAEG,OAAO;YAAMC,YAAY;YAAGC,WAAW;QAAK;IACnF;AACF;AAOO,MAAMC,oBAAoB,OAAOL,UAAUM,UAAmB,CAAC,CAAC;IACrE,MAAMC,WAAW,MAAMC,cAAcF;IACrC,OAAOR,QAAQS,UAAUP;AAC3B,EAAC;AAED,eAAeQ,cAAcF,OAAgB;IAC3C,IAAIA,QAAQG,IAAI,EAAE;QAChB,IAAIH,QAAQI,SAAS,KAAKC,aAAaL,QAAQI,SAAS,KAAK,MAAM;YACjE,MAAM,IAAIE,MAAM;QAClB;QAEA,6GAAOjB,UAAAA,CAAKkB,IAAI,CAAC,MAAMC,sBAAsBR,QAAQG,IAAI;IAC3D;IAEA,OACG,MAAMM,YACNT,CAAAA,QAAQI,SAAS,KAAKC,aAAaL,QAAQI,SAAS,KAAK,OACtD,KACA,MAAMJ,QAAQI,SAAS,CAACM,OAAO,CAAC,OAAO,GAAE;AAEjD;AAEA,eAAeF,mBAAmB,EAAEG,SAAS,EAAE,EAAE,GAAG,CAAC,CAAC;IACpD,MAAMC,YAAY,MAAMH,QAAQE;IAChC,kGAAMxB,WAAAA,CAAW0B,KAAK,CAACD;IACvB,OAAOA;AACT;AAEA,eAAeH,QAAQE,SAAS,EAAE;IAChC,MAAMH,qBAAqB,kGAAMrB,WAAAA,CAAW2B,QAAQ,qGAAC1B,UAAAA,CAAG2B,MAAM;IAC9D,6GAAO1B,UAAAA,CAAKkB,IAAI,CAACC,oBAAoBG,gMAASpB,KAAAA;AAChD"}},
    {"offset": {"line": 5244, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 5250, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/payload/src/uploads/getImageSize.ts"],"sourcesContent":["import fs from 'fs'\nimport sizeOfImport from 'image-size'\nimport { promisify } from 'util'\n\nimport type { PayloadRequest } from '../types/index.js'\nimport type { ProbedImageSize } from './types.js'\n\nimport { temporaryFileTask } from './tempFile.js'\n\nconst { imageSize } = sizeOfImport\nconst imageSizePromise = promisify(imageSize)\n\nexport async function getImageSize(file: PayloadRequest['file']): Promise<ProbedImageSize> {\n  if (file.tempFilePath) {\n    return imageSizePromise(file.tempFilePath)\n  }\n\n  // Tiff file do not support buffers or streams, so we must write to file first\n  // then retrieve dimensions. https://github.com/image-size/image-size/issues/103\n  if (file.mimetype === 'image/tiff') {\n    const dimensions = await temporaryFileTask(\n      async (filepath: string) => {\n        fs.writeFileSync(filepath, file.data)\n        return imageSizePromise(filepath)\n      },\n      { extension: 'tiff' },\n    )\n    return dimensions\n  }\n\n  return imageSize(file.data)\n}\n"],"names":["fs","sizeOfImport","promisify","temporaryFileTask","imageSize","imageSizePromise","getImageSize","file","tempFilePath","mimetype","dimensions","filepath","writeFileSync","data","extension"],"mappings":";;;AAAA,OAAOA,QAAQ,KAAI;AACnB,OAAOC,kBAAkB,aAAY;AACrC,SAASC,SAAS,QAAQ,OAAM;AAKhC,SAASC,iBAAiB,QAAQ,gBAAe;;;;;AAEjD,MAAM,EAAEC,SAAS,EAAE,kJAAGH,UAAAA;AACtB,MAAMI,qHAAmBH,YAAAA,EAAUE;AAE5B,eAAeE,aAAaC,IAA4B;IAC7D,IAAIA,KAAKC,YAAY,EAAE;QACrB,OAAOH,iBAAiBE,KAAKC,YAAY;IAC3C;IAEA,8EAA8E;IAC9E,gFAAgF;IAChF,IAAID,KAAKE,QAAQ,KAAK,cAAc;QAClC,MAAMC,aAAa,iKAAMP,oBAAAA,EACvB,OAAOQ;wGACLX,UAAAA,CAAGY,aAAa,CAACD,UAAUJ,KAAKM,IAAI;YACpC,OAAOR,iBAAiBM;QAC1B,GACA;YAAEG,WAAW;QAAO;QAEtB,OAAOJ;IACT;IAEA,OAAON,UAAUG,KAAKM,IAAI;AAC5B"}},
    {"offset": {"line": 5280, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 5286, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/payload/src/uploads/optionallyAppendMetadata.ts"],"sourcesContent":["import type { Sharp, Metadata as SharpMetadata } from 'sharp'\n\nimport type { PayloadRequest } from '../types/index.js'\n\nexport type WithMetadata =\n  | ((options: { metadata: SharpMetadata; req: PayloadRequest }) => Promise<boolean>)\n  | boolean\n\nexport async function optionallyAppendMetadata({\n  req,\n  sharpFile,\n  withMetadata,\n}: {\n  req: PayloadRequest\n  sharpFile: Sharp\n  withMetadata: WithMetadata\n}): Promise<Sharp> {\n  const metadata = await sharpFile.metadata()\n\n  if (withMetadata === true) {\n    return sharpFile.withMetadata()\n  } else if (typeof withMetadata === 'function') {\n    const useMetadata = await withMetadata({ metadata, req })\n\n    if (useMetadata) {\n      return sharpFile.withMetadata()\n    }\n  }\n\n  return sharpFile\n}\n"],"names":["optionallyAppendMetadata","req","sharpFile","withMetadata","metadata","useMetadata"],"mappings":";;;AAQO,eAAeA,yBAAyB,EAC7CC,GAAG,EACHC,SAAS,EACTC,YAAY,EAKb;IACC,MAAMC,WAAW,MAAMF,UAAUE,QAAQ;IAEzC,IAAID,iBAAiB,MAAM;QACzB,OAAOD,UAAUC,YAAY;IAC/B,OAAO,IAAI,OAAOA,iBAAiB,YAAY;QAC7C,MAAME,cAAc,MAAMF,aAAa;YAAEC;YAAUH;QAAI;QAEvD,IAAII,aAAa;YACf,OAAOH,UAAUC,YAAY;QAC/B;IACF;IAEA,OAAOD;AACT"}},
    {"offset": {"line": 5304, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 5310, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/payload/src/uploads/docWithFilenameExists.ts"],"sourcesContent":["import type { PayloadRequest } from '../types/index.js'\n\ntype Args = {\n  collectionSlug: string\n  filename: string\n  path: string\n  req: PayloadRequest\n}\n\nconst docWithFilenameExists = async ({ collectionSlug, filename, req }: Args): Promise<boolean> => {\n  const doc = await req.payload.db.findOne({\n    collection: collectionSlug,\n    req,\n    where: {\n      filename: {\n        equals: filename,\n      },\n    },\n  })\n  if (doc) {\n    return true\n  }\n\n  return false\n}\n\nexport default docWithFilenameExists\n"],"names":["docWithFilenameExists","collectionSlug","filename","req","doc","payload","db","findOne","collection","where","equals"],"mappings":";;;AASA,MAAMA,wBAAwB,OAAO,EAAEC,cAAc,EAAEC,QAAQ,EAAEC,GAAG,EAAQ;IAC1E,MAAMC,MAAM,MAAMD,IAAIE,OAAO,CAACC,EAAE,CAACC,OAAO,CAAC;QACvCC,YAAYP;QACZE;QACAM,OAAO;YACLP,UAAU;gBACRQ,QAAQR;YACV;QACF;IACF;IACA,IAAIE,KAAK;QACP,OAAO;IACT;IAEA,OAAO;AACT;uCAEeJ,sBAAqB"}},
    {"offset": {"line": 5330, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 5336, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/payload/src/uploads/fileExists.ts"],"sourcesContent":["import fs from 'fs'\n\nconst fileExists = async (filename: string): Promise<boolean> => {\n  try {\n    await fs.promises.stat(filename)\n\n    return true\n  } catch (err) {\n    return false\n  }\n}\n\nexport default fileExists\n"],"names":["fs","fileExists","filename","promises","stat","err"],"mappings":";;;AAAA,OAAOA,QAAQ,KAAI;;AAEnB,MAAMC,aAAa,OAAOC;IACxB,IAAI;QACF,kGAAMF,UAAAA,CAAGG,QAAQ,CAACC,IAAI,CAACF;QAEvB,OAAO;IACT,EAAE,OAAOG,KAAK;QACZ,OAAO;IACT;AACF;uCAEeJ,WAAU"}},
    {"offset": {"line": 5351, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 5357, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/payload/src/uploads/getSafeFilename.ts"],"sourcesContent":["import sanitize from 'sanitize-filename'\n\nimport type { PayloadRequest } from '../types/index.js'\n\nimport docWithFilenameExists from './docWithFilenameExists.js'\nimport fileExists from './fileExists.js'\n\nconst incrementName = (name: string) => {\n  const extension = name.split('.').pop()\n  const baseFilename = sanitize(name.substring(0, name.lastIndexOf('.')) || name)\n  let incrementedName = baseFilename\n  const regex = /(.*)-(\\d+)$/\n  const found = baseFilename.match(regex)\n  if (found === null) {\n    incrementedName += '-1'\n  } else {\n    const matchedName = found[1]\n    const matchedNumber = found[2]\n    const incremented = Number(matchedNumber) + 1\n    incrementedName = `${matchedName}-${incremented}`\n  }\n  return `${incrementedName}.${extension}`\n}\n\ntype Args = {\n  collectionSlug: string\n  desiredFilename: string\n  req: PayloadRequest\n  staticPath: string\n}\n\nexport async function getSafeFileName({\n  collectionSlug,\n  desiredFilename,\n  req,\n  staticPath,\n}: Args): Promise<string> {\n  let modifiedFilename = desiredFilename\n\n  while (\n    (await docWithFilenameExists({\n      collectionSlug,\n      filename: modifiedFilename,\n      path: staticPath,\n      req,\n    })) ||\n    (await fileExists(`${staticPath}/${modifiedFilename}`))\n  ) {\n    modifiedFilename = incrementName(modifiedFilename)\n  }\n  return modifiedFilename\n}\n"],"names":["sanitize","docWithFilenameExists","fileExists","incrementName","name","extension","split","pop","baseFilename","substring","lastIndexOf","incrementedName","regex","found","match","matchedName","matchedNumber","incremented","Number","getSafeFileName","collectionSlug","desiredFilename","req","staticPath","modifiedFilename","filename","path"],"mappings":";;;AAAA,OAAOA,cAAc,oBAAmB;AAIxC,OAAOC,2BAA2B,6BAA4B;AAC9D,OAAOC,gBAAgB,kBAAiB;;;;AAExC,MAAMC,gBAAgB,CAACC;IACrB,MAAMC,YAAYD,KAAKE,KAAK,CAAC,KAAKC,GAAG;IACrC,MAAMC,iKAAeR,UAAAA,EAASI,KAAKK,SAAS,CAAC,GAAGL,KAAKM,WAAW,CAAC,SAASN;IAC1E,IAAIO,kBAAkBH;IACtB,MAAMI,QAAQ;IACd,MAAMC,QAAQL,aAAaM,KAAK,CAACF;IACjC,IAAIC,UAAU,MAAM;QAClBF,mBAAmB;IACrB,OAAO;QACL,MAAMI,cAAcF,KAAK,CAAC,EAAE;QAC5B,MAAMG,gBAAgBH,KAAK,CAAC,EAAE;QAC9B,MAAMI,cAAcC,OAAOF,iBAAiB;QAC5CL,kBAAkB,CAAC,EAAEI,YAAY,CAAC,EAAEE,YAAY,CAAC;IACnD;IACA,OAAO,CAAC,EAAEN,gBAAgB,CAAC,EAAEN,UAAU,CAAC;AAC1C;AASO,eAAec,gBAAgB,EACpCC,cAAc,EACdC,eAAe,EACfC,GAAG,EACHC,UAAU,EACL;IACL,IAAIC,mBAAmBH;IAEvB,MACG,8KAAMpB,UAAAA,EAAsB;QAC3BmB;QACAK,UAAUD;QACVE,MAAMH;QACND;IACF,MACC,mKAAMpB,UAAAA,EAAW,CAAC,EAAEqB,WAAW,CAAC,EAAEC,iBAAiB,CAAC,EACrD;QACAA,mBAAmBrB,cAAcqB;IACnC;IACA,OAAOA;AACT"}},
    {"offset": {"line": 5394, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 5400, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/payload/src/uploads/cropImage.ts"],"sourcesContent":["import type { SharpOptions } from 'sharp'\n\nimport type { SanitizedConfig } from '../config/types.js'\nimport type { PayloadRequest } from '../types/index.js'\nimport type { WithMetadata } from './optionallyAppendMetadata.js'\nimport type { UploadEdits } from './types.js'\n\nimport { optionallyAppendMetadata } from './optionallyAppendMetadata.js'\n\nexport const percentToPixel = (value, dimension) => {\n  return Math.floor((parseFloat(value) / 100) * dimension)\n}\n\ntype CropImageArgs = {\n  cropData: UploadEdits['crop']\n  dimensions: { height: number; width: number }\n  file: PayloadRequest['file']\n  heightInPixels: number\n  req?: PayloadRequest\n  sharp: SanitizedConfig['sharp']\n  widthInPixels: number\n  withMetadata?: WithMetadata\n}\nexport async function cropImage({\n  cropData,\n  dimensions,\n  file,\n  heightInPixels,\n  req,\n  sharp,\n  widthInPixels,\n  withMetadata,\n}: CropImageArgs) {\n  try {\n    const { x, y } = cropData\n\n    const fileIsAnimatedType = ['image/avif', 'image/gif', 'image/webp'].includes(file.mimetype)\n\n    const sharpOptions: SharpOptions = {}\n\n    if (fileIsAnimatedType) {\n      sharpOptions.animated = true\n    }\n\n    const formattedCropData = {\n      height: Number(heightInPixels),\n      left: percentToPixel(x, dimensions.width),\n      top: percentToPixel(y, dimensions.height),\n      width: Number(widthInPixels),\n    }\n\n    let cropped = sharp(file.tempFilePath || file.data, sharpOptions).extract(formattedCropData)\n\n    cropped = await optionallyAppendMetadata({\n      req,\n      sharpFile: cropped,\n      withMetadata,\n    })\n\n    return await cropped.toBuffer({\n      resolveWithObject: true,\n    })\n  } catch (error) {\n    console.error(`Error cropping image:`, error)\n    throw error\n  }\n}\n"],"names":["optionallyAppendMetadata","percentToPixel","value","dimension","Math","floor","parseFloat","cropImage","cropData","dimensions","file","heightInPixels","req","sharp","widthInPixels","withMetadata","x","y","fileIsAnimatedType","includes","mimetype","sharpOptions","animated","formattedCropData","height","Number","left","width","top","cropped","tempFilePath","data","extract","sharpFile","toBuffer","resolveWithObject","error","console"],"mappings":";;;;AAOA,SAASA,wBAAwB,QAAQ,gCAA+B;;AAEjE,MAAMC,iBAAiB,CAACC,OAAOC;IACpC,OAAOC,KAAKC,KAAK,CAAEC,WAAWJ,SAAS,MAAOC;AAChD,EAAC;AAYM,eAAeI,UAAU,EAC9BC,QAAQ,EACRC,UAAU,EACVC,IAAI,EACJC,cAAc,EACdC,GAAG,EACHC,KAAK,EACLC,aAAa,EACbC,YAAY,EACE;IACd,IAAI;QACF,MAAM,EAAEC,CAAC,EAAEC,CAAC,EAAE,GAAGT;QAEjB,MAAMU,qBAAqB;YAAC;YAAc;YAAa;SAAa,CAACC,QAAQ,CAACT,KAAKU,QAAQ;QAE3F,MAAMC,eAA6B,CAAC;QAEpC,IAAIH,oBAAoB;YACtBG,aAAaC,QAAQ,GAAG;QAC1B;QAEA,MAAMC,oBAAoB;YACxBC,QAAQC,OAAOd;YACfe,MAAMzB,eAAee,GAAGP,WAAWkB,KAAK;YACxCC,KAAK3B,eAAegB,GAAGR,WAAWe,MAAM;YACxCG,OAAOF,OAAOX;QAChB;QAEA,IAAIe,UAAUhB,MAAMH,KAAKoB,YAAY,IAAIpB,KAAKqB,IAAI,EAAEV,cAAcW,OAAO,CAACT;QAE1EM,UAAU,iLAAM7B,2BAAAA,EAAyB;YACvCY;YACAqB,WAAWJ;YACXd;QACF;QAEA,OAAO,MAAMc,QAAQK,QAAQ,CAAC;YAC5BC,mBAAmB;QACrB;IACF,EAAE,OAAOC,OAAO;QACdC,QAAQD,KAAK,CAAC,CAAC,qBAAqB,CAAC,EAAEA;QACvC,MAAMA;IACR;AACF"}},
    {"offset": {"line": 5441, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 5447, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/payload/src/uploads/imageResizer.ts"],"sourcesContent":["import type { Sharp, Metadata as SharpMetadata, SharpOptions } from 'sharp'\n\nimport { fileTypeFromBuffer } from 'file-type'\nimport fs from 'fs'\nimport sanitize from 'sanitize-filename'\n\nimport type { SanitizedCollectionConfig } from '../collections/config/types.js'\nimport type { SharpDependency } from '../config/types.js'\nimport type { PayloadRequest } from '../types/index.js'\nimport type { WithMetadata } from './optionallyAppendMetadata.js'\nimport type {\n  FileSize,\n  FileSizes,\n  FileToSave,\n  ImageSize,\n  ProbedImageSize,\n  UploadEdits,\n} from './types.js'\n\nimport { isNumber } from '../utilities/isNumber.js'\nimport fileExists from './fileExists.js'\nimport { optionallyAppendMetadata } from './optionallyAppendMetadata.js'\n\ntype ResizeArgs = {\n  config: SanitizedCollectionConfig\n  dimensions: ProbedImageSize\n  file: PayloadRequest['file']\n  mimeType: string\n  req: PayloadRequest\n  savedFilename: string\n  sharp?: SharpDependency\n  staticPath: string\n  uploadEdits?: UploadEdits\n  withMetadata?: WithMetadata\n}\n\n/** Result from resizing and transforming the requested image sizes */\ntype ImageSizesResult = {\n  focalPoint?: UploadEdits['focalPoint']\n  sizeData: FileSizes\n  sizesToSave: FileToSave[]\n}\n\ntype SanitizedImageData = {\n  ext: string\n  name: string\n}\n\n/**\n * Sanitize the image name and extract the extension from the source image\n *\n * @param sourceImage - the source image\n * @returns the sanitized name and extension\n */\nconst getSanitizedImageData = (sourceImage: string): SanitizedImageData => {\n  const extension = sourceImage.split('.').pop()\n  const name = sanitize(sourceImage.substring(0, sourceImage.lastIndexOf('.')) || sourceImage)\n  return { name, ext: extension }\n}\n\n/**\n * Create a new image name based on the output image name, the dimensions and\n * the extension.\n *\n * Ignore the fact that duplicate names could happen if the there is one\n * size with `width AND height` and one with only `height OR width`. Because\n * space is expensive, we will reuse the same image for both sizes.\n *\n * @param outputImageName - the sanitized image name\n * @param bufferInfo - the buffer info\n * @param extension - the extension to use\n * @returns the new image name that is not taken\n */\ntype CreateImageNameArgs = {\n  extension: string\n  height: number\n  outputImageName: string\n  width: number\n}\nconst createImageName = ({\n  extension,\n  height,\n  outputImageName,\n  width,\n}: CreateImageNameArgs): string => {\n  return `${outputImageName}-${width}x${height}.${extension}`\n}\n\ntype CreateResultArgs = {\n  filename?: FileSize['filename']\n  filesize?: FileSize['filesize']\n  height?: FileSize['height']\n  mimeType?: FileSize['mimeType']\n  name: string\n  sizesToSave?: FileToSave[]\n  width?: FileSize['width']\n}\n\n/**\n * Create the result object for the image resize operation based on the\n * provided parameters. If the name is not provided, an empty result object\n * is returned.\n *\n * @param name - the name of the image\n * @param filename - the filename of the image\n * @param width - the width of the image\n * @param height - the height of the image\n * @param filesize - the filesize of the image\n * @param mimeType - the mime type of the image\n * @param sizesToSave - the sizes to save\n * @returns the result object\n */\nconst createResult = ({\n  name,\n  filename = null,\n  filesize = null,\n  height = null,\n  mimeType = null,\n  sizesToSave = [],\n  width = null,\n}: CreateResultArgs): ImageSizesResult => {\n  return {\n    sizeData: {\n      [name]: {\n        filename,\n        filesize,\n        height,\n        mimeType,\n        width,\n      },\n    },\n    sizesToSave,\n  }\n}\n\n/**\n * Determine whether or not to resize the image.\n * - resize using image config\n * - resize using image config with focal adjustments\n * - do not resize at all\n *\n * `imageResizeConfig.withoutEnlargement`:\n * - undefined [default]: uploading images with smaller width AND height than the image size will return null\n * - false: always enlarge images to the image size\n * - true: if the image is smaller than the image size, return the original image\n *\n * `imageResizeConfig.withoutReduction`:\n * - false [default]: always enlarge images to the image size\n * - true: if the image is smaller than the image size, return the original image\n *\n * @return 'omit' | 'resize' | 'resizeWithFocalPoint'\n */\nconst getImageResizeAction = ({\n  dimensions: originalImage,\n  hasFocalPoint,\n  imageResizeConfig,\n}: {\n  dimensions: ProbedImageSize\n  hasFocalPoint?: boolean\n  imageResizeConfig: ImageSize\n}): 'omit' | 'resize' | 'resizeWithFocalPoint' => {\n  const {\n    fit,\n    height: targetHeight,\n    width: targetWidth,\n    withoutEnlargement,\n    withoutReduction,\n  } = imageResizeConfig\n\n  // prevent upscaling by default when x and y are both smaller than target image size\n  if (targetHeight && targetWidth) {\n    const originalImageIsSmallerXAndY =\n      originalImage.width < targetWidth && originalImage.height < targetHeight\n    if (withoutEnlargement === undefined && originalImageIsSmallerXAndY) {\n      return 'omit' // prevent image size from being enlarged\n    }\n  }\n\n  const originalImageIsSmallerXOrY =\n    originalImage.width < targetWidth || originalImage.height < targetHeight\n  if (fit === 'contain' || fit === 'inside') {\n    return 'resize'\n  }\n  if (!isNumber(targetHeight) && !isNumber(targetWidth)) {\n    return 'resize'\n  }\n\n  const targetAspectRatio = targetWidth / targetHeight\n  const originalAspectRatio = originalImage.width / originalImage.height\n  if (originalAspectRatio === targetAspectRatio) {\n    return 'resize'\n  }\n\n  if (withoutEnlargement && originalImageIsSmallerXOrY) {\n    return 'resize'\n  }\n  if (withoutReduction && !originalImageIsSmallerXOrY) {\n    return 'resize'\n  }\n\n  return hasFocalPoint ? 'resizeWithFocalPoint' : 'resize'\n}\n\n/**\n * Sanitize the resize config. If the resize config has the `withoutReduction`\n * property set to true, the `fit` and `position` properties will be set to `contain`\n * and `top left` respectively.\n *\n * @param resizeConfig - the resize config\n * @returns a sanitized resize config\n */\nconst sanitizeResizeConfig = (resizeConfig: ImageSize): ImageSize => {\n  if (resizeConfig.withoutReduction) {\n    return {\n      ...resizeConfig,\n      // Why fit `contain` should also be set to https://github.com/lovell/sharp/issues/3595\n      fit: resizeConfig?.fit || 'contain',\n      position: resizeConfig?.position || 'left top',\n    }\n  }\n  return resizeConfig\n}\n\n/**\n * Used to extract height from images, animated or not.\n *\n * @param sharpMetadata - the sharp metadata\n * @returns the height of the image\n */\nfunction extractHeightFromImage(sharpMetadata: SharpMetadata): number {\n  if (sharpMetadata?.pages) {\n    return sharpMetadata.height / sharpMetadata.pages\n  }\n  return sharpMetadata.height\n}\n\n/**\n * For the provided image sizes, handle the resizing and the transforms\n * (format, trim, etc.) of each requested image size and return the result object.\n * This only handles the image sizes. The transforms of the original image\n * are handled in {@link ./generateFileData.ts}.\n *\n * The image will be resized according to the provided\n * resize config. If no image sizes are requested, the resolved data will be empty.\n * For every image that does not need to be resized, a result object with `null`\n * parameters will be returned.\n *\n * @param resizeConfig - the resize config\n * @returns the result of the resize operation(s)\n */\nexport async function resizeAndTransformImageSizes({\n  config,\n  dimensions,\n  file,\n  mimeType,\n  req,\n  savedFilename,\n  sharp,\n  staticPath,\n  uploadEdits,\n  withMetadata,\n}: ResizeArgs): Promise<ImageSizesResult> {\n  const { focalPoint: focalPointEnabled = true, imageSizes } = config.upload\n\n  // Focal point adjustments\n  const incomingFocalPoint = uploadEdits.focalPoint\n    ? {\n        x: isNumber(uploadEdits.focalPoint.x) ? Math.round(uploadEdits.focalPoint.x) : 50,\n        y: isNumber(uploadEdits.focalPoint.y) ? Math.round(uploadEdits.focalPoint.y) : 50,\n      }\n    : undefined\n\n  const defaultResult: ImageSizesResult = {\n    ...(focalPointEnabled && incomingFocalPoint && { focalPoint: incomingFocalPoint }),\n    sizeData: {},\n    sizesToSave: [],\n  }\n\n  if (!imageSizes || !sharp) {\n    return defaultResult\n  }\n\n  // Determine if the file is animated\n  const fileIsAnimatedType = ['image/avif', 'image/gif', 'image/webp'].includes(file.mimetype)\n  const sharpOptions: SharpOptions = {}\n\n  if (fileIsAnimatedType) {\n    sharpOptions.animated = true\n  }\n\n  const sharpBase: Sharp | undefined = sharp(file.tempFilePath || file.data, sharpOptions).rotate() // pass rotate() to auto-rotate based on EXIF data. https://github.com/payloadcms/payload/pull/3081\n  const originalImageMeta = await sharpBase.metadata()\n\n  let adjustedDimensions = { ...dimensions }\n\n  // Images with an exif orientation of 5, 6, 7, or 8 are auto-rotated by sharp\n  // Need to adjust the dimensions to match the original image\n  if ([5, 6, 7, 8].includes(originalImageMeta.orientation)) {\n    adjustedDimensions = {\n      ...dimensions,\n      height: dimensions.width,\n      width: dimensions.height,\n    }\n  }\n\n  const resizeImageMeta = {\n    height: extractHeightFromImage(originalImageMeta),\n    width: originalImageMeta.width,\n  }\n\n  const results: ImageSizesResult[] = await Promise.all(\n    imageSizes.map(async (imageResizeConfig): Promise<ImageSizesResult> => {\n      imageResizeConfig = sanitizeResizeConfig(imageResizeConfig)\n\n      const resizeAction = getImageResizeAction({\n        dimensions,\n        hasFocalPoint: Boolean(incomingFocalPoint),\n        imageResizeConfig,\n      })\n      if (resizeAction === 'omit') {\n        return createResult({ name: imageResizeConfig.name })\n      }\n\n      const imageToResize = sharpBase.clone()\n      let resized = imageToResize\n\n      if (resizeAction === 'resizeWithFocalPoint') {\n        let { height: resizeHeight, width: resizeWidth } = imageResizeConfig\n\n        const originalAspectRatio = adjustedDimensions.width / adjustedDimensions.height\n\n        // Calculate resizeWidth based on original aspect ratio if it's undefined\n        if (resizeHeight && !resizeWidth) {\n          resizeWidth = Math.round(resizeHeight * originalAspectRatio)\n        }\n\n        // Calculate resizeHeight based on original aspect ratio if it's undefined\n        if (resizeWidth && !resizeHeight) {\n          resizeHeight = Math.round(resizeWidth / originalAspectRatio)\n        }\n\n        if (!resizeHeight) {\n          resizeHeight = resizeImageMeta.height\n        }\n        if (!resizeWidth) {\n          resizeWidth = resizeImageMeta.width\n        }\n\n        const resizeAspectRatio = resizeWidth / resizeHeight\n        const prioritizeHeight = resizeAspectRatio < originalAspectRatio\n        // Scales the image before extracting from it\n        resized = imageToResize.resize({\n          height: prioritizeHeight ? resizeHeight : undefined,\n          width: prioritizeHeight ? undefined : resizeWidth,\n        })\n\n        const metadataAppendedFile = await optionallyAppendMetadata({\n          req,\n          sharpFile: resized,\n          withMetadata,\n        })\n\n        // Must read from buffer, resized.metadata will return the original image metadata\n        const { info } = await metadataAppendedFile.toBuffer({ resolveWithObject: true })\n\n        resizeImageMeta.height = extractHeightFromImage({\n          ...originalImageMeta,\n          height: info.height,\n        })\n        resizeImageMeta.width = info.width\n\n        const halfResizeX = resizeWidth / 2\n        const xFocalCenter = resizeImageMeta.width * (incomingFocalPoint.x / 100)\n        const calculatedRightPixelBound = xFocalCenter + halfResizeX\n        let leftBound = xFocalCenter - halfResizeX\n\n        // if the right bound is greater than the image width, adjust the left bound\n        // keeping focus on the right\n        if (calculatedRightPixelBound > resizeImageMeta.width) {\n          leftBound = resizeImageMeta.width - resizeWidth\n        }\n\n        // if the left bound is less than 0, adjust the left bound to 0\n        // keeping the focus on the left\n        if (leftBound < 0) {\n          leftBound = 0\n        }\n\n        const halfResizeY = resizeHeight / 2\n        const yFocalCenter = resizeImageMeta.height * (incomingFocalPoint.y / 100)\n        const calculatedBottomPixelBound = yFocalCenter + halfResizeY\n        let topBound = yFocalCenter - halfResizeY\n\n        // if the bottom bound is greater than the image height, adjust the top bound\n        // keeping the image as far right as possible\n        if (calculatedBottomPixelBound > resizeImageMeta.height) {\n          topBound = resizeImageMeta.height - resizeHeight\n        }\n\n        // if the top bound is less than 0, adjust the top bound to 0\n        // keeping the image focus near the top\n        if (topBound < 0) {\n          topBound = 0\n        }\n\n        resized = resized.extract({\n          height: resizeHeight,\n          left: Math.floor(leftBound),\n          top: Math.floor(topBound),\n          width: resizeWidth,\n        })\n      } else {\n        resized = imageToResize.resize(imageResizeConfig)\n      }\n\n      if (imageResizeConfig.formatOptions) {\n        resized = resized.toFormat(\n          imageResizeConfig.formatOptions.format,\n          imageResizeConfig.formatOptions.options,\n        )\n      }\n\n      if (imageResizeConfig.trimOptions) {\n        resized = resized.trim(imageResizeConfig.trimOptions)\n      }\n\n      const metadataAppendedFile = await optionallyAppendMetadata({\n        req,\n        sharpFile: resized,\n        withMetadata,\n      })\n\n      const { data: bufferData, info: bufferInfo } = await metadataAppendedFile.toBuffer({\n        resolveWithObject: true,\n      })\n\n      const sanitizedImage = getSanitizedImageData(savedFilename)\n\n      if (req.payloadUploadSizes) {\n        req.payloadUploadSizes[imageResizeConfig.name] = bufferData\n      }\n\n      const mimeInfo = await fileTypeFromBuffer(bufferData)\n\n      const imageNameWithDimensions = imageResizeConfig.generateImageName\n        ? imageResizeConfig.generateImageName({\n            extension: mimeInfo?.ext || sanitizedImage.ext,\n            height: extractHeightFromImage({\n              ...originalImageMeta,\n              height: bufferInfo.height,\n            }),\n            originalName: sanitizedImage.name,\n            sizeName: imageResizeConfig.name,\n            width: bufferInfo.width,\n          })\n        : createImageName({\n            extension: mimeInfo?.ext || sanitizedImage.ext,\n            height: extractHeightFromImage({\n              ...originalImageMeta,\n              height: bufferInfo.height,\n            }),\n            outputImageName: sanitizedImage.name,\n            width: bufferInfo.width,\n          })\n\n      const imagePath = `${staticPath}/${imageNameWithDimensions}`\n\n      if (await fileExists(imagePath)) {\n        try {\n          fs.unlinkSync(imagePath)\n        } catch {\n          // Ignore unlink errors\n        }\n      }\n\n      const { height, size, width } = bufferInfo\n      return createResult({\n        name: imageResizeConfig.name,\n        filename: imageNameWithDimensions,\n        filesize: size,\n        height:\n          fileIsAnimatedType && originalImageMeta.pages ? height / originalImageMeta.pages : height,\n        mimeType: mimeInfo?.mime || mimeType,\n        sizesToSave: [{ buffer: bufferData, path: imagePath }],\n        width,\n      })\n    }),\n  )\n\n  return results.reduce(\n    (acc, result) => {\n      Object.assign(acc.sizeData, result.sizeData)\n      acc.sizesToSave.push(...result.sizesToSave)\n      return acc\n    },\n    { ...defaultResult },\n  )\n}\n"],"names":["fileTypeFromBuffer","fs","sanitize","isNumber","fileExists","optionallyAppendMetadata","getSanitizedImageData","sourceImage","extension","split","pop","name","substring","lastIndexOf","ext","createImageName","height","outputImageName","width","createResult","filename","filesize","mimeType","sizesToSave","sizeData","getImageResizeAction","dimensions","originalImage","hasFocalPoint","imageResizeConfig","fit","targetHeight","targetWidth","withoutEnlargement","withoutReduction","originalImageIsSmallerXAndY","undefined","originalImageIsSmallerXOrY","targetAspectRatio","originalAspectRatio","sanitizeResizeConfig","resizeConfig","position","extractHeightFromImage","sharpMetadata","pages","resizeAndTransformImageSizes","config","file","req","savedFilename","sharp","staticPath","uploadEdits","withMetadata","focalPoint","focalPointEnabled","imageSizes","upload","incomingFocalPoint","x","Math","round","y","defaultResult","fileIsAnimatedType","includes","mimetype","sharpOptions","animated","sharpBase","tempFilePath","data","rotate","originalImageMeta","metadata","adjustedDimensions","orientation","resizeImageMeta","results","Promise","all","map","resizeAction","Boolean","imageToResize","clone","resized","resizeHeight","resizeWidth","resizeAspectRatio","prioritizeHeight","resize","metadataAppendedFile","sharpFile","info","toBuffer","resolveWithObject","halfResizeX","xFocalCenter","calculatedRightPixelBound","leftBound","halfResizeY","yFocalCenter","calculatedBottomPixelBound","topBound","extract","left","floor","top","formatOptions","toFormat","format","options","trimOptions","trim","bufferData","bufferInfo","sanitizedImage","payloadUploadSizes","mimeInfo","imageNameWithDimensions","generateImageName","originalName","sizeName","imagePath","unlinkSync","size","mime","buffer","path","reduce","acc","result","Object","assign","push"],"mappings":"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"}},
    {"offset": {"line": 5789, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 5795, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/payload/src/errors/FileUploadError.ts"],"sourcesContent":["import type { TFunction } from '@payloadcms/translations'\n\nimport { en } from '@payloadcms/translations/languages/en'\nimport httpStatus from 'http-status'\n\nimport { APIError } from './APIError.js'\n\nexport class FileUploadError extends APIError {\n  constructor(t?: TFunction) {\n    super(\n      t ? t('error:problemUploadingFile') : en.translations.error.problemUploadingFile,\n      httpStatus.BAD_REQUEST,\n    )\n  }\n}\n"],"names":["en","httpStatus","APIError","FileUploadError","constructor","t","translations","error","problemUploadingFile","BAD_REQUEST"],"mappings":";;;AAEA,SAASA,EAAE,QAAQ,wCAAuC;AAC1D,OAAOC,gBAAgB,cAAa;AAEpC,SAASC,QAAQ,QAAQ,gBAAe;;;;AAEjC,MAAMC,8KAAwBD,WAAAA;IACnCE,YAAYC,CAAa,CAAE;QACzB,KAAK,CACHA,IAAIA,EAAE,wMAAgCL,KAAAA,CAAGM,YAAY,CAACC,KAAK,CAACC,oBAAoB,iJAChFP,UAAAA,CAAWQ,WAAW;IAE1B;AACF"}},
    {"offset": {"line": 5809, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 5815, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/payload/src/errors/MissingFile.ts"],"sourcesContent":["import type { TFunction } from '@payloadcms/translations'\n\nimport { en } from '@payloadcms/translations/languages/en'\nimport httpStatus from 'http-status'\n\nimport { APIError } from './APIError.js'\n\nexport class MissingFile extends APIError {\n  constructor(t?: TFunction) {\n    super(\n      t ? t('error:noFilesUploaded') : en.translations.error.noFilesUploaded,\n      httpStatus.BAD_REQUEST,\n    )\n  }\n}\n"],"names":["en","httpStatus","APIError","MissingFile","constructor","t","translations","error","noFilesUploaded","BAD_REQUEST"],"mappings":";;;AAEA,SAASA,EAAE,QAAQ,wCAAuC;AAC1D,OAAOC,gBAAgB,cAAa;AAEpC,SAASC,QAAQ,QAAQ,gBAAe;;;;AAEjC,MAAMC,0KAAoBD,WAAAA;IAC/BE,YAAYC,CAAa,CAAE;QACzB,KAAK,CACHA,IAAIA,EAAE,mMAA2BL,KAAAA,CAAGM,YAAY,CAACC,KAAK,CAACC,eAAe,iJACtEP,UAAAA,CAAWQ,WAAW;IAE1B;AACF"}},
    {"offset": {"line": 5829, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 5835, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/payload/src/uploads/generateFileData.ts"],"sourcesContent":["import type { OutputInfo, Sharp, SharpOptions } from 'sharp'\n\nimport { fileTypeFromBuffer } from 'file-type'\nimport fs from 'fs'\nimport { mkdirSync } from 'node:fs'\nimport sanitize from 'sanitize-filename'\n\nimport type { Collection } from '../collections/config/types.js'\nimport type { SanitizedConfig } from '../config/types.js'\nimport type { PayloadRequest } from '../types/index.js'\nimport type { FileData, FileToSave, ProbedImageSize, UploadEdits } from './types.js'\n\nimport { FileRetrievalError, FileUploadError, MissingFile } from '../errors/index.js'\nimport { canResizeImage } from './canResizeImage.js'\nimport { cropImage } from './cropImage.js'\nimport { getExternalFile } from './getExternalFile.js'\nimport { getFileByPath } from './getFileByPath.js'\nimport { getImageSize } from './getImageSize.js'\nimport { getSafeFileName } from './getSafeFilename.js'\nimport { resizeAndTransformImageSizes } from './imageResizer.js'\nimport { isImage } from './isImage.js'\nimport { optionallyAppendMetadata } from './optionallyAppendMetadata.js'\n\ntype Args<T> = {\n  collection: Collection\n  config: SanitizedConfig\n  data: T\n  operation: 'create' | 'update'\n  originalDoc?: T\n  /** pass forceDisable to not overwrite existing files even if they already exist in `data` */\n  overwriteExistingFiles?: 'forceDisable' | boolean\n  req: PayloadRequest\n  throwOnMissingFile?: boolean\n}\n\ntype Result<T> = Promise<{\n  data: T\n  files: FileToSave[]\n}>\n\nexport const generateFileData = async <T>({\n  collection: { config: collectionConfig },\n  data,\n  operation,\n  originalDoc,\n  overwriteExistingFiles,\n  req,\n  throwOnMissingFile,\n}: Args<T>): Result<T> => {\n  if (!collectionConfig.upload) {\n    return {\n      data,\n      files: [],\n    }\n  }\n\n  const { sharp } = req.payload.config\n\n  let file = req.file\n\n  const uploadEdits = parseUploadEditsFromReqOrIncomingData({\n    data,\n    operation,\n    originalDoc,\n    req,\n  })\n\n  const {\n    disableLocalStorage,\n    focalPoint: focalPointEnabled = true,\n    formatOptions,\n    imageSizes,\n    resizeOptions,\n    staticDir,\n    trimOptions,\n    withMetadata,\n  } = collectionConfig.upload\n\n  const staticPath = staticDir\n\n  if (!file && uploadEdits && data) {\n    const { filename, url } = data as FileData\n\n    try {\n      if (url && url.startsWith('/') && !disableLocalStorage) {\n        const filePath = `${staticPath}/${filename}`\n        const response = await getFileByPath(filePath)\n        file = response\n        if (overwriteExistingFiles !== 'forceDisable') {\n          overwriteExistingFiles = true\n        }\n      } else if (filename && url) {\n        file = await getExternalFile({\n          data: data as FileData,\n          req,\n          uploadConfig: collectionConfig.upload,\n        })\n        if (overwriteExistingFiles !== 'forceDisable') {\n          overwriteExistingFiles = true\n        }\n      }\n    } catch (err: unknown) {\n      throw new FileRetrievalError(req.t, err instanceof Error ? err.message : undefined)\n    }\n  }\n\n  if (overwriteExistingFiles === 'forceDisable') {\n    overwriteExistingFiles = false\n  }\n\n  if (!file) {\n    if (throwOnMissingFile) {\n      throw new MissingFile(req.t)\n    }\n\n    return {\n      data,\n      files: [],\n    }\n  }\n\n  if (!disableLocalStorage) {\n    mkdirSync(staticPath, { recursive: true })\n  }\n\n  let newData = data\n  const filesToSave: FileToSave[] = []\n  const fileData: Partial<FileData> = {}\n  const fileIsAnimatedType = ['image/avif', 'image/gif', 'image/webp'].includes(file.mimetype)\n  const cropData =\n    typeof uploadEdits === 'object' && 'crop' in uploadEdits ? uploadEdits.crop : undefined\n\n  try {\n    const fileSupportsResize = canResizeImage(file.mimetype)\n    let fsSafeName: string\n    let sharpFile: Sharp | undefined\n    let dimensions: ProbedImageSize | undefined\n    let fileBuffer: { data: Buffer; info: OutputInfo }\n    let ext\n    let mime: string\n    const fileHasAdjustments =\n      fileSupportsResize &&\n      Boolean(resizeOptions || formatOptions || imageSizes || trimOptions || file.tempFilePath)\n\n    const sharpOptions: SharpOptions = {}\n\n    if (fileIsAnimatedType) {\n      sharpOptions.animated = true\n    }\n\n    if (sharp && (fileIsAnimatedType || fileHasAdjustments)) {\n      if (file.tempFilePath) {\n        sharpFile = sharp(file.tempFilePath, sharpOptions).rotate() // pass rotate() to auto-rotate based on EXIF data. https://github.com/payloadcms/payload/pull/3081\n      } else {\n        sharpFile = sharp(file.data, sharpOptions).rotate() // pass rotate() to auto-rotate based on EXIF data. https://github.com/payloadcms/payload/pull/3081\n      }\n\n      if (fileHasAdjustments) {\n        if (resizeOptions) {\n          sharpFile = sharpFile.resize(resizeOptions)\n        }\n        if (formatOptions) {\n          sharpFile = sharpFile.toFormat(formatOptions.format, formatOptions.options)\n        }\n        if (trimOptions) {\n          sharpFile = sharpFile.trim(trimOptions)\n        }\n      }\n    }\n\n    if (fileSupportsResize || isImage(file.mimetype)) {\n      dimensions = await getImageSize(file)\n      fileData.width = dimensions.width\n      fileData.height = dimensions.height\n    }\n\n    if (sharpFile) {\n      const metadata = await sharpFile.metadata()\n      sharpFile = await optionallyAppendMetadata({\n        req,\n        sharpFile,\n        withMetadata,\n      })\n      fileBuffer = await sharpFile.toBuffer({ resolveWithObject: true })\n      ;({ ext, mime } = await fileTypeFromBuffer(fileBuffer.data)) // This is getting an incorrect gif height back.\n      fileData.width = fileBuffer.info.width\n      fileData.height = fileBuffer.info.height\n      fileData.filesize = fileBuffer.info.size\n\n      // Animated GIFs + WebP aggregate the height from every frame, so we need to use divide by number of pages\n      if (metadata.pages) {\n        fileData.height = fileBuffer.info.height / metadata.pages\n        fileData.filesize = fileBuffer.data.length\n      }\n    } else {\n      mime = file.mimetype\n      fileData.filesize = file.size\n\n      if (file.name.includes('.')) {\n        ext = file.name.split('.').pop().split('?')[0]\n      } else {\n        ext = ''\n      }\n    }\n\n    // Adjust SVG mime type. fromBuffer modifies it.\n    if (mime === 'application/xml' && ext === 'svg') {\n      mime = 'image/svg+xml'\n    }\n    fileData.mimeType = mime\n\n    const baseFilename = sanitize(file.name.substring(0, file.name.lastIndexOf('.')) || file.name)\n    fsSafeName = `${baseFilename}${ext ? `.${ext}` : ''}`\n\n    if (!overwriteExistingFiles) {\n      fsSafeName = await getSafeFileName({\n        collectionSlug: collectionConfig.slug,\n        desiredFilename: fsSafeName,\n        req,\n        staticPath,\n      })\n    }\n\n    fileData.filename = fsSafeName\n    let fileForResize = file\n\n    if (cropData && sharp) {\n      const { data: croppedImage, info } = await cropImage({\n        cropData,\n        dimensions,\n        file,\n        heightInPixels: uploadEdits.heightInPixels,\n        req,\n        sharp,\n        widthInPixels: uploadEdits.widthInPixels,\n        withMetadata,\n      })\n\n      // Apply resize after cropping to ensure it conforms to resizeOptions\n      if (resizeOptions) {\n        const resizedAfterCrop = await sharp(croppedImage)\n          .resize({\n            fit: resizeOptions?.fit || 'cover',\n            height: resizeOptions?.height,\n            position: resizeOptions?.position || 'center',\n            width: resizeOptions?.width,\n          })\n          .toBuffer({ resolveWithObject: true })\n\n        filesToSave.push({\n          buffer: resizedAfterCrop.data,\n          path: `${staticPath}/${fsSafeName}`,\n        })\n\n        fileForResize = {\n          ...fileForResize,\n          data: resizedAfterCrop.data,\n          size: resizedAfterCrop.info.size,\n        }\n\n        fileData.width = resizedAfterCrop.info.width\n        fileData.height = resizedAfterCrop.info.height\n        if (fileIsAnimatedType) {\n          const metadata = await sharpFile.metadata()\n          fileData.height = metadata.pages\n            ? resizedAfterCrop.info.height / metadata.pages\n            : resizedAfterCrop.info.height\n        }\n        fileData.filesize = resizedAfterCrop.info.size\n      } else {\n        // If resizeOptions is not present, just save the cropped image\n        filesToSave.push({\n          buffer: croppedImage,\n          path: `${staticPath}/${fsSafeName}`,\n        })\n\n        fileForResize = {\n          ...file,\n          data: croppedImage,\n          size: info.size,\n        }\n\n        fileData.width = info.width\n        fileData.height = info.height\n        if (fileIsAnimatedType) {\n          const metadata = await sharpFile.metadata()\n          fileData.height = metadata.pages ? info.height / metadata.pages : info.height\n        }\n        fileData.filesize = info.size\n      }\n\n      if (file.tempFilePath) {\n        await fs.promises.writeFile(file.tempFilePath, croppedImage) // write fileBuffer to the temp path\n      } else {\n        req.file = fileForResize\n      }\n    } else {\n      filesToSave.push({\n        buffer: fileBuffer?.data || file.data,\n        path: `${staticPath}/${fsSafeName}`,\n      })\n\n      // If using temp files and the image is being resized, write the file to the temp path\n      if (fileBuffer?.data || file.data.length > 0) {\n        if (file.tempFilePath) {\n          await fs.promises.writeFile(file.tempFilePath, fileBuffer?.data || file.data) // write fileBuffer to the temp path\n        } else {\n          // Assign the _possibly modified_ file to the request object\n          req.file = {\n            ...file,\n            data: fileBuffer?.data || file.data,\n            size: fileBuffer?.info.size,\n          }\n        }\n      }\n    }\n\n    if (fileSupportsResize && (Array.isArray(imageSizes) || focalPointEnabled !== false)) {\n      req.payloadUploadSizes = {}\n      const { focalPoint, sizeData, sizesToSave } = await resizeAndTransformImageSizes({\n        config: collectionConfig,\n        dimensions: !cropData\n          ? dimensions\n          : {\n              ...dimensions,\n              height: fileData.height,\n              width: fileData.width,\n            },\n        file: fileForResize,\n        mimeType: fileData.mimeType,\n        req,\n        savedFilename: fsSafeName || file.name,\n        sharp,\n        staticPath,\n        uploadEdits,\n        withMetadata,\n      })\n\n      fileData.sizes = sizeData\n      fileData.focalX = focalPoint?.x\n      fileData.focalY = focalPoint?.y\n      filesToSave.push(...sizesToSave)\n    }\n  } catch (err) {\n    req.payload.logger.error(err)\n    throw new FileUploadError(req.t)\n  }\n\n  newData = {\n    ...newData,\n    ...fileData,\n  }\n\n  return {\n    data: newData,\n    files: filesToSave,\n  }\n}\n\n/**\n * Parse upload edits from req or incoming data\n */\nfunction parseUploadEditsFromReqOrIncomingData(args: {\n  data: unknown\n  operation: 'create' | 'update'\n  originalDoc: unknown\n  req: PayloadRequest\n}): UploadEdits {\n  const { data, operation, originalDoc, req } = args\n\n  // Get intended focal point change from query string or incoming data\n  const uploadEdits =\n    req.query?.uploadEdits && typeof req.query.uploadEdits === 'object'\n      ? (req.query.uploadEdits as UploadEdits)\n      : {}\n\n  if (uploadEdits.focalPoint) {\n    return uploadEdits\n  }\n\n  const incomingData = data as FileData\n  const origDoc = originalDoc as FileData\n\n  // If no change in focal point, return undefined.\n  // This prevents a refocal operation triggered from admin, because it always sends the focal point.\n  if (origDoc && incomingData.focalX === origDoc.focalX && incomingData.focalY === origDoc.focalY) {\n    return undefined\n  }\n\n  if (incomingData?.focalX && incomingData?.focalY) {\n    uploadEdits.focalPoint = {\n      x: incomingData.focalX,\n      y: incomingData.focalY,\n    }\n    return uploadEdits\n  }\n\n  // If no focal point is set, default to center\n  if (operation === 'create') {\n    uploadEdits.focalPoint = {\n      x: 50,\n      y: 50,\n    }\n  }\n  return uploadEdits\n}\n"],"names":["fileTypeFromBuffer","fs","mkdirSync","sanitize","FileRetrievalError","FileUploadError","MissingFile","canResizeImage","cropImage","getExternalFile","getFileByPath","getImageSize","getSafeFileName","resizeAndTransformImageSizes","isImage","optionallyAppendMetadata","generateFileData","collection","config","collectionConfig","data","operation","originalDoc","overwriteExistingFiles","req","throwOnMissingFile","upload","files","sharp","payload","file","uploadEdits","parseUploadEditsFromReqOrIncomingData","disableLocalStorage","focalPoint","focalPointEnabled","formatOptions","imageSizes","resizeOptions","staticDir","trimOptions","withMetadata","staticPath","filename","url","startsWith","filePath","response","uploadConfig","err","t","Error","message","undefined","recursive","newData","filesToSave","fileData","fileIsAnimatedType","includes","mimetype","cropData","crop","fileSupportsResize","fsSafeName","sharpFile","dimensions","fileBuffer","ext","mime","fileHasAdjustments","Boolean","tempFilePath","sharpOptions","animated","rotate","resize","toFormat","format","options","trim","width","height","metadata","toBuffer","resolveWithObject","info","filesize","size","pages","length","name","split","pop","mimeType","baseFilename","substring","lastIndexOf","collectionSlug","slug","desiredFilename","fileForResize","croppedImage","heightInPixels","widthInPixels","resizedAfterCrop","fit","position","push","buffer","path","promises","writeFile","Array","isArray","payloadUploadSizes","sizeData","sizesToSave","savedFilename","sizes","focalX","x","focalY","y","logger","error","args","query","incomingData","origDoc"],"mappings":"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"}},
    {"offset": {"line": 6169, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 6175, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/payload/src/fields/hooks/beforeChange/cloneDataFromOriginalDoc.ts"],"sourcesContent":["import type { JsonArray, JsonObject } from '../../../types/index.js'\n\nexport const cloneDataFromOriginalDoc = (\n  originalDocData: JsonArray | JsonObject,\n): JsonArray | JsonObject => {\n  if (Array.isArray(originalDocData)) {\n    return originalDocData.map((row) => {\n      if (typeof row === 'object' && row != null) {\n        return {\n          ...row,\n        }\n      }\n\n      return row\n    })\n  }\n\n  if (typeof originalDocData === 'object' && originalDocData !== null) {\n    return { ...originalDocData }\n  }\n\n  return originalDocData\n}\n"],"names":["cloneDataFromOriginalDoc","originalDocData","Array","isArray","map","row"],"mappings":";;;AAEO,MAAMA,2BAA2B,CACtCC;IAEA,IAAIC,MAAMC,OAAO,CAACF,kBAAkB;QAClC,OAAOA,gBAAgBG,GAAG,CAAC,CAACC;YAC1B,IAAI,OAAOA,QAAQ,YAAYA,OAAO,MAAM;gBAC1C,OAAO;oBACL,GAAGA,GAAG;gBACR;YACF;YAEA,OAAOA;QACT;IACF;IAEA,IAAI,OAAOJ,oBAAoB,YAAYA,oBAAoB,MAAM;QACnE,OAAO;YAAE,GAAGA,eAAe;QAAC;IAC9B;IAEA,OAAOA;AACT,EAAC"}},
    {"offset": {"line": 6196, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 6202, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/payload/src/fields/hooks/beforeChange/getExistingRowDoc.ts"],"sourcesContent":["/**\n * If there is an incoming row id,\n * and it matches the existing sibling doc id,\n * this is an existing row, so it should be merged.\n * Otherwise, return an empty object.\n */\nimport type { JsonObject } from '../../../types/index.js'\n\nexport const getExistingRowDoc = (incomingRow: JsonObject, existingRows?: unknown): JsonObject => {\n  if (incomingRow.id && Array.isArray(existingRows)) {\n    const matchedExistingRow = existingRows.find((existingRow) => {\n      if (typeof existingRow === 'object' && 'id' in existingRow) {\n        if (existingRow.id === incomingRow.id) {\n          return existingRow\n        }\n      }\n\n      return false\n    })\n\n    if (matchedExistingRow) {\n      return matchedExistingRow\n    }\n  }\n\n  return {}\n}\n"],"names":["getExistingRowDoc","incomingRow","existingRows","id","Array","isArray","matchedExistingRow","find","existingRow"],"mappings":"AAAA;;;;;CAKC,GAGD;;;AAAO,MAAMA,oBAAoB,CAACC,aAAyBC;IACzD,IAAID,YAAYE,EAAE,IAAIC,MAAMC,OAAO,CAACH,eAAe;QACjD,MAAMI,qBAAqBJ,aAAaK,IAAI,CAAC,CAACC;YAC5C,IAAI,OAAOA,gBAAgB,YAAY,QAAQA,aAAa;gBAC1D,IAAIA,YAAYL,EAAE,KAAKF,YAAYE,EAAE,EAAE;oBACrC,OAAOK;gBACT;YACF;YAEA,OAAO;QACT;QAEA,IAAIF,oBAAoB;YACtB,OAAOA;QACT;IACF;IAEA,OAAO,CAAC;AACV,EAAC"}},
    {"offset": {"line": 6226, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 6232, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/payload/src/fields/hooks/beforeValidate/promise.ts"],"sourcesContent":["import type { RichTextAdapter } from '../../../admin/RichText.js'\nimport type { SanitizedCollectionConfig } from '../../../collections/config/types.js'\nimport type { SanitizedGlobalConfig } from '../../../globals/config/types.js'\nimport type { JsonObject, JsonValue, PayloadRequest, RequestContext } from '../../../types/index.js'\nimport type { Field, TabAsField } from '../../config/types.js'\n\nimport { MissingEditorProp } from '../../../errors/index.js'\nimport { fieldAffectsData, tabHasName, valueIsValueWithRelation } from '../../config/types.js'\nimport { getDefaultValue } from '../../getDefaultValue.js'\nimport { getFieldPaths } from '../../getFieldPaths.js'\nimport { cloneDataFromOriginalDoc } from '../beforeChange/cloneDataFromOriginalDoc.js'\nimport { getExistingRowDoc } from '../beforeChange/getExistingRowDoc.js'\nimport { traverseFields } from './traverseFields.js'\n\ntype Args<T> = {\n  collection: null | SanitizedCollectionConfig\n  context: RequestContext\n  data: T\n  /**\n   * The original data (not modified by any hooks)\n   */\n  doc: T\n  field: Field | TabAsField\n  global: null | SanitizedGlobalConfig\n  id?: number | string\n  operation: 'create' | 'update'\n  overrideAccess: boolean\n  parentPath: (number | string)[]\n  parentSchemaPath: string[]\n  req: PayloadRequest\n  siblingData: JsonObject\n  /**\n   * The original siblingData (not modified by any hooks)\n   */\n  siblingDoc: JsonObject\n}\n\n// This function is responsible for the following actions, in order:\n// - Sanitize incoming data\n// - Execute field hooks\n// - Execute field access control\n// - Merge original document data into incoming data\n// - Compute default values for undefined fields\n\nexport const promise = async <T>({\n  id,\n  collection,\n  context,\n  data,\n  doc,\n  field,\n  global,\n  operation,\n  overrideAccess,\n  parentPath,\n  parentSchemaPath,\n  req,\n  siblingData,\n  siblingDoc,\n}: Args<T>): Promise<void> => {\n  const { path: fieldPath, schemaPath: fieldSchemaPath } = getFieldPaths({\n    field,\n    parentPath,\n    parentSchemaPath,\n  })\n\n  if (fieldAffectsData(field)) {\n    if (field.name === 'id') {\n      if (field.type === 'number' && typeof siblingData[field.name] === 'string') {\n        const value = siblingData[field.name] as string\n\n        siblingData[field.name] = parseFloat(value)\n      }\n\n      if (\n        field.type === 'text' &&\n        typeof siblingData[field.name]?.toString === 'function' &&\n        typeof siblingData[field.name] !== 'string'\n      ) {\n        siblingData[field.name] = siblingData[field.name].toString()\n      }\n    }\n\n    // Sanitize incoming data\n    switch (field.type) {\n      case 'number': {\n        if (typeof siblingData[field.name] === 'string') {\n          const value = siblingData[field.name] as string\n          const trimmed = value.trim()\n          siblingData[field.name] = trimmed.length === 0 ? null : parseFloat(trimmed)\n        }\n\n        break\n      }\n\n      case 'point': {\n        if (Array.isArray(siblingData[field.name])) {\n          siblingData[field.name] = (siblingData[field.name] as string[]).map((coordinate, i) => {\n            if (typeof coordinate === 'string') {\n              const value = siblingData[field.name][i] as string\n              const trimmed = value.trim()\n              return trimmed.length === 0 ? null : parseFloat(trimmed)\n            }\n            return coordinate\n          })\n        }\n\n        break\n      }\n\n      case 'checkbox': {\n        if (siblingData[field.name] === 'true') {\n          siblingData[field.name] = true\n        }\n        if (siblingData[field.name] === 'false') {\n          siblingData[field.name] = false\n        }\n        if (siblingData[field.name] === '') {\n          siblingData[field.name] = false\n        }\n\n        break\n      }\n\n      case 'richText': {\n        if (typeof siblingData[field.name] === 'string') {\n          try {\n            const richTextJSON = JSON.parse(siblingData[field.name] as string)\n            siblingData[field.name] = richTextJSON\n          } catch {\n            // Disregard this data as it is not valid.\n            // Will be reported to user by field validation\n          }\n        }\n\n        break\n      }\n\n      case 'relationship':\n      case 'upload': {\n        if (\n          siblingData[field.name] === '' ||\n          siblingData[field.name] === 'none' ||\n          siblingData[field.name] === 'null' ||\n          siblingData[field.name] === null\n        ) {\n          if (field.hasMany === true) {\n            siblingData[field.name] = []\n          } else {\n            siblingData[field.name] = null\n          }\n        }\n\n        const value = siblingData[field.name]\n\n        if (Array.isArray(field.relationTo)) {\n          if (Array.isArray(value)) {\n            value.forEach((relatedDoc: { relationTo: string; value: JsonValue }, i) => {\n              const relatedCollection = req.payload.config.collections.find(\n                (collection) => collection.slug === relatedDoc.relationTo,\n              )\n              if (relatedCollection?.fields) {\n                const relationshipIDField = relatedCollection.fields.find(\n                  (collectionField) =>\n                    fieldAffectsData(collectionField) && collectionField.name === 'id',\n                )\n                if (relationshipIDField?.type === 'number') {\n                  siblingData[field.name][i] = {\n                    ...relatedDoc,\n                    value: parseFloat(relatedDoc.value as string),\n                  }\n                }\n              }\n            })\n          }\n          if (field.hasMany !== true && valueIsValueWithRelation(value)) {\n            const relatedCollection = req.payload.config.collections.find(\n              (collection) => collection.slug === value.relationTo,\n            )\n            if (relatedCollection?.fields) {\n              const relationshipIDField = relatedCollection.fields.find(\n                (collectionField) =>\n                  fieldAffectsData(collectionField) && collectionField.name === 'id',\n              )\n              if (relationshipIDField?.type === 'number') {\n                siblingData[field.name] = { ...value, value: parseFloat(value.value as string) }\n              }\n            }\n          }\n        } else {\n          if (Array.isArray(value)) {\n            value.forEach((relatedDoc: unknown, i) => {\n              const relatedCollection = req.payload.config.collections.find(\n                (collection) => collection.slug === field.relationTo,\n              )\n\n              if (relatedCollection?.fields) {\n                const relationshipIDField = relatedCollection.fields.find(\n                  (collectionField) =>\n                    fieldAffectsData(collectionField) && collectionField.name === 'id',\n                )\n                if (relationshipIDField?.type === 'number') {\n                  siblingData[field.name][i] = parseFloat(relatedDoc as string)\n                }\n              }\n            })\n          }\n          if (field.hasMany !== true && value) {\n            const relatedCollection = req.payload.config.collections.find(\n              (collection) => collection.slug === field.relationTo,\n            )\n\n            if (relatedCollection?.fields) {\n              const relationshipIDField = relatedCollection.fields.find(\n                (collectionField) =>\n                  fieldAffectsData(collectionField) && collectionField.name === 'id',\n              )\n              if (relationshipIDField?.type === 'number') {\n                siblingData[field.name] = parseFloat(value as string)\n              }\n            }\n          }\n        }\n        break\n      }\n\n      case 'array':\n      case 'blocks': {\n        // Handle cases of arrays being intentionally set to 0\n        if (siblingData[field.name] === '0' || siblingData[field.name] === 0) {\n          siblingData[field.name] = []\n        }\n\n        break\n      }\n\n      default: {\n        break\n      }\n    }\n\n    // Execute hooks\n    if (field.hooks?.beforeValidate) {\n      await field.hooks.beforeValidate.reduce(async (priorHook, currentHook) => {\n        await priorHook\n\n        const hookedValue = await currentHook({\n          collection,\n          context,\n          data,\n          field,\n          global,\n          operation,\n          originalDoc: doc,\n          overrideAccess,\n          path: fieldPath,\n          previousSiblingDoc: siblingDoc,\n          previousValue: siblingData[field.name],\n          req,\n          schemaPath: fieldSchemaPath,\n          siblingData,\n          value: siblingData[field.name],\n        })\n\n        if (hookedValue !== undefined) {\n          siblingData[field.name] = hookedValue\n        }\n      }, Promise.resolve())\n    }\n\n    // Execute access control\n    if (field.access && field.access[operation]) {\n      const result = overrideAccess\n        ? true\n        : await field.access[operation]({ id, data, doc, req, siblingData })\n\n      if (!result) {\n        delete siblingData[field.name]\n      }\n    }\n\n    if (typeof siblingData[field.name] === 'undefined') {\n      // If no incoming data, but existing document data is found, merge it in\n      if (typeof siblingDoc[field.name] !== 'undefined') {\n        siblingData[field.name] = cloneDataFromOriginalDoc(siblingDoc[field.name])\n\n        // Otherwise compute default value\n      } else if (typeof field.defaultValue !== 'undefined') {\n        siblingData[field.name] = await getDefaultValue({\n          defaultValue: field.defaultValue,\n          locale: req.locale,\n          user: req.user,\n          value: siblingData[field.name],\n        })\n      }\n    }\n  }\n\n  // Traverse subfields\n  switch (field.type) {\n    case 'group': {\n      if (typeof siblingData[field.name] !== 'object') {\n        siblingData[field.name] = {}\n      }\n      if (typeof siblingDoc[field.name] !== 'object') {\n        siblingDoc[field.name] = {}\n      }\n\n      const groupData = siblingData[field.name] as Record<string, unknown>\n      const groupDoc = siblingDoc[field.name] as Record<string, unknown>\n\n      await traverseFields({\n        id,\n        collection,\n        context,\n        data,\n        doc,\n        fields: field.fields,\n        global,\n        operation,\n        overrideAccess,\n        path: fieldPath,\n        req,\n        schemaPath: fieldSchemaPath,\n        siblingData: groupData as JsonObject,\n        siblingDoc: groupDoc as JsonObject,\n      })\n\n      break\n    }\n\n    case 'array': {\n      const rows = siblingData[field.name]\n\n      if (Array.isArray(rows)) {\n        const promises = []\n        rows.forEach((row, i) => {\n          promises.push(\n            traverseFields({\n              id,\n              collection,\n              context,\n              data,\n              doc,\n              fields: field.fields,\n              global,\n              operation,\n              overrideAccess,\n              path: [...fieldPath, i],\n              req,\n              schemaPath: fieldSchemaPath,\n              siblingData: row as JsonObject,\n              siblingDoc: getExistingRowDoc(row as JsonObject, siblingDoc[field.name]),\n            }),\n          )\n        })\n        await Promise.all(promises)\n      }\n      break\n    }\n\n    case 'blocks': {\n      const rows = siblingData[field.name]\n\n      if (Array.isArray(rows)) {\n        const promises = []\n        rows.forEach((row, i) => {\n          const rowSiblingDoc = getExistingRowDoc(row as JsonObject, siblingDoc[field.name])\n          const blockTypeToMatch = (row as JsonObject).blockType || rowSiblingDoc.blockType\n          const block = field.blocks.find((blockType) => blockType.slug === blockTypeToMatch)\n\n          if (block) {\n            ;(row as JsonObject).blockType = blockTypeToMatch\n\n            promises.push(\n              traverseFields({\n                id,\n                collection,\n                context,\n                data,\n                doc,\n                fields: block.fields,\n                global,\n                operation,\n                overrideAccess,\n                path: [...fieldPath, i],\n                req,\n                schemaPath: fieldSchemaPath,\n                siblingData: row as JsonObject,\n                siblingDoc: rowSiblingDoc,\n              }),\n            )\n          }\n        })\n        await Promise.all(promises)\n      }\n\n      break\n    }\n\n    case 'row':\n    case 'collapsible': {\n      await traverseFields({\n        id,\n        collection,\n        context,\n        data,\n        doc,\n        fields: field.fields,\n        global,\n        operation,\n        overrideAccess,\n        path: fieldPath,\n        req,\n        schemaPath: fieldSchemaPath,\n        siblingData,\n        siblingDoc,\n      })\n\n      break\n    }\n\n    case 'tab': {\n      let tabSiblingData\n      let tabSiblingDoc\n      if (tabHasName(field)) {\n        if (typeof siblingData[field.name] !== 'object') {\n          siblingData[field.name] = {}\n        }\n        if (typeof siblingDoc[field.name] !== 'object') {\n          siblingDoc[field.name] = {}\n        }\n\n        tabSiblingData = siblingData[field.name] as Record<string, unknown>\n        tabSiblingDoc = siblingDoc[field.name] as Record<string, unknown>\n      } else {\n        tabSiblingData = siblingData\n        tabSiblingDoc = siblingDoc\n      }\n\n      await traverseFields({\n        id,\n        collection,\n        context,\n        data,\n        doc,\n        fields: field.fields,\n        global,\n        operation,\n        overrideAccess,\n        path: fieldPath,\n        req,\n        schemaPath: fieldSchemaPath,\n        siblingData: tabSiblingData,\n        siblingDoc: tabSiblingDoc,\n      })\n\n      break\n    }\n\n    case 'tabs': {\n      await traverseFields({\n        id,\n        collection,\n        context,\n        data,\n        doc,\n        fields: field.tabs.map((tab) => ({ ...tab, type: 'tab' })),\n        global,\n        operation,\n        overrideAccess,\n        path: fieldPath,\n        req,\n        schemaPath: fieldSchemaPath,\n        siblingData,\n        siblingDoc,\n      })\n\n      break\n    }\n\n    case 'richText': {\n      if (!field?.editor) {\n        throw new MissingEditorProp(field) // while we allow disabling editor functionality, you should not have any richText fields defined if you do not have an editor\n      }\n      if (typeof field?.editor === 'function') {\n        throw new Error('Attempted to access unsanitized rich text editor.')\n      }\n\n      const editor: RichTextAdapter = field?.editor\n\n      if (editor?.hooks?.beforeValidate?.length) {\n        await editor.hooks.beforeValidate.reduce(async (priorHook, currentHook) => {\n          await priorHook\n\n          const hookedValue = await currentHook({\n            collection,\n            context,\n            data,\n            field,\n            global,\n            operation,\n            originalDoc: doc,\n            overrideAccess,\n            path: fieldPath,\n            previousSiblingDoc: siblingDoc,\n            previousValue: siblingData[field.name],\n            req,\n            schemaPath: fieldSchemaPath,\n            siblingData,\n            value: siblingData[field.name],\n          })\n\n          if (hookedValue !== undefined) {\n            siblingData[field.name] = hookedValue\n          }\n        }, Promise.resolve())\n      }\n      break\n    }\n\n    default: {\n      break\n    }\n  }\n}\n"],"names":["MissingEditorProp","fieldAffectsData","tabHasName","valueIsValueWithRelation","getDefaultValue","getFieldPaths","cloneDataFromOriginalDoc","getExistingRowDoc","traverseFields","promise","id","collection","context","data","doc","field","global","operation","overrideAccess","parentPath","parentSchemaPath","req","siblingData","siblingDoc","path","fieldPath","schemaPath","fieldSchemaPath","name","type","value","parseFloat","toString","trimmed","trim","length","Array","isArray","map","coordinate","i","richTextJSON","JSON","parse","hasMany","relationTo","forEach","relatedDoc","relatedCollection","payload","config","collections","find","slug","fields","relationshipIDField","collectionField","hooks","beforeValidate","reduce","priorHook","currentHook","hookedValue","originalDoc","previousSiblingDoc","previousValue","undefined","Promise","resolve","access","result","defaultValue","locale","user","groupData","groupDoc","rows","promises","row","push","all","rowSiblingDoc","blockTypeToMatch","blockType","block","blocks","tabSiblingData","tabSiblingDoc","tabs","tab","editor","Error"],"mappings":";;;AASA,SAASK,aAAa,QAAQ,yBAAwB;AAFtD,SAASJ,gBAAgB,EAAEC,UAAU,EAAEC,wBAAwB,QAAQ,wBAAuB;AAC9F,SAASC,eAAe,QAAQ,2BAA0B;AAE1D,SAASE,wBAAwB,QAAQ,8CAA6C;AAEtF,SAASE,cAAc,QAAQ,sBAAqB;AADpD,SAASD,iBAAiB,QAAQ,uCAAsC;AALxE,SAASP,iBAAiB,QAAQ,2BAA0B;;;;;;;;AAsCrD,MAAMS,UAAU,OAAU,EAC/BC,EAAE,EACFC,UAAU,EACVC,OAAO,EACPC,IAAI,EACJC,GAAG,EACHC,KAAK,EACLC,MAAM,EACNC,SAAS,EACTC,cAAc,EACdC,UAAU,EACVC,gBAAgB,EAChBC,GAAG,EACHC,WAAW,EACXC,UAAU,EACF;IACR,MAAM,EAAEC,MAAMC,SAAS,EAAEC,YAAYC,eAAe,EAAE,kKAAGtB,gBAAAA,EAAc;QACrEU;QACAI;QACAC;IACF;IAEA,qKAAInB,mBAAAA,EAAiBc,QAAQ;QAC3B,IAAIA,MAAMa,IAAI,KAAK,MAAM;YACvB,IAAIb,MAAMc,IAAI,KAAK,YAAY,OAAOP,WAAW,CAACP,MAAMa,IAAI,CAAC,KAAK,UAAU;gBAC1E,MAAME,QAAQR,WAAW,CAACP,MAAMa,IAAI,CAAC;gBAErCN,WAAW,CAACP,MAAMa,IAAI,CAAC,GAAGG,WAAWD;YACvC;YAEA,IACEf,MAAMc,IAAI,KAAK,UACf,OAAOP,WAAW,CAACP,MAAMa,IAAI,CAAC,EAAEI,aAAa,cAC7C,OAAOV,WAAW,CAACP,MAAMa,IAAI,CAAC,KAAK,UACnC;gBACAN,WAAW,CAACP,MAAMa,IAAI,CAAC,GAAGN,WAAW,CAACP,MAAMa,IAAI,CAAC,CAACI,QAAQ;YAC5D;QACF;QAEA,yBAAyB;QACzB,OAAQjB,MAAMc,IAAI;YAChB,KAAK;gBAAU;oBACb,IAAI,OAAOP,WAAW,CAACP,MAAMa,IAAI,CAAC,KAAK,UAAU;wBAC/C,MAAME,QAAQR,WAAW,CAACP,MAAMa,IAAI,CAAC;wBACrC,MAAMK,UAAUH,MAAMI,IAAI;wBAC1BZ,WAAW,CAACP,MAAMa,IAAI,CAAC,GAAGK,QAAQE,MAAM,KAAK,IAAI,OAAOJ,WAAWE;oBACrE;oBAEA;gBACF;YAEA,KAAK;gBAAS;oBACZ,IAAIG,MAAMC,OAAO,CAACf,WAAW,CAACP,MAAMa,IAAI,CAAC,GAAG;wBAC1CN,WAAW,CAACP,MAAMa,IAAI,CAAC,GAAIN,WAAW,CAACP,MAAMa,IAAI,CAAC,CAAcU,GAAG,CAAC,CAACC,YAAYC;4BAC/E,IAAI,OAAOD,eAAe,UAAU;gCAClC,MAAMT,QAAQR,WAAW,CAACP,MAAMa,IAAI,CAAC,CAACY,EAAE;gCACxC,MAAMP,UAAUH,MAAMI,IAAI;gCAC1B,OAAOD,QAAQE,MAAM,KAAK,IAAI,OAAOJ,WAAWE;4BAClD;4BACA,OAAOM;wBACT;oBACF;oBAEA;gBACF;YAEA,KAAK;gBAAY;oBACf,IAAIjB,WAAW,CAACP,MAAMa,IAAI,CAAC,KAAK,QAAQ;wBACtCN,WAAW,CAACP,MAAMa,IAAI,CAAC,GAAG;oBAC5B;oBACA,IAAIN,WAAW,CAACP,MAAMa,IAAI,CAAC,KAAK,SAAS;wBACvCN,WAAW,CAACP,MAAMa,IAAI,CAAC,GAAG;oBAC5B;oBACA,IAAIN,WAAW,CAACP,MAAMa,IAAI,CAAC,KAAK,IAAI;wBAClCN,WAAW,CAACP,MAAMa,IAAI,CAAC,GAAG;oBAC5B;oBAEA;gBACF;YAEA,KAAK;gBAAY;oBACf,IAAI,OAAON,WAAW,CAACP,MAAMa,IAAI,CAAC,KAAK,UAAU;wBAC/C,IAAI;4BACF,MAAMa,eAAeC,KAAKC,KAAK,CAACrB,WAAW,CAACP,MAAMa,IAAI,CAAC;4BACvDN,WAAW,CAACP,MAAMa,IAAI,CAAC,GAAGa;wBAC5B,EAAE,OAAM;wBACN,0CAA0C;wBAC1C,+CAA+C;wBACjD;oBACF;oBAEA;gBACF;YAEA,KAAK;YACL,KAAK;gBAAU;oBACb,IACEnB,WAAW,CAACP,MAAMa,IAAI,CAAC,KAAK,MAC5BN,WAAW,CAACP,MAAMa,IAAI,CAAC,KAAK,UAC5BN,WAAW,CAACP,MAAMa,IAAI,CAAC,KAAK,UAC5BN,WAAW,CAACP,MAAMa,IAAI,CAAC,KAAK,MAC5B;wBACA,IAAIb,MAAM6B,OAAO,KAAK,MAAM;4BAC1BtB,WAAW,CAACP,MAAMa,IAAI,CAAC,GAAG,EAAE;wBAC9B,OAAO;4BACLN,WAAW,CAACP,MAAMa,IAAI,CAAC,GAAG;wBAC5B;oBACF;oBAEA,MAAME,QAAQR,WAAW,CAACP,MAAMa,IAAI,CAAC;oBAErC,IAAIQ,MAAMC,OAAO,CAACtB,MAAM8B,UAAU,GAAG;wBACnC,IAAIT,MAAMC,OAAO,CAACP,QAAQ;4BACxBA,MAAMgB,OAAO,CAAC,CAACC,YAAsDP;gCACnE,MAAMQ,oBAAoB3B,IAAI4B,OAAO,CAACC,MAAM,CAACC,WAAW,CAACC,IAAI,CAC3D,CAACzC,aAAeA,WAAW0C,IAAI,KAAKN,WAAWF,UAAU;gCAE3D,IAAIG,mBAAmBM,QAAQ;oCAC7B,MAAMC,sBAAsBP,kBAAkBM,MAAM,CAACF,IAAI,CACvD,CAACI,mLACCvD,mBAAAA,EAAiBuD,oBAAoBA,gBAAgB5B,IAAI,KAAK;oCAElE,IAAI2B,qBAAqB1B,SAAS,UAAU;wCAC1CP,WAAW,CAACP,MAAMa,IAAI,CAAC,CAACY,EAAE,GAAG;4CAC3B,GAAGO,UAAU;4CACbjB,OAAOC,WAAWgB,WAAWjB,KAAK;wCACpC;oCACF;gCACF;4BACF;wBACF;wBACA,IAAIf,MAAM6B,OAAO,KAAK,yKAAQzC,2BAAAA,EAAyB2B,QAAQ;4BAC7D,MAAMkB,oBAAoB3B,IAAI4B,OAAO,CAACC,MAAM,CAACC,WAAW,CAACC,IAAI,CAC3D,CAACzC,aAAeA,WAAW0C,IAAI,KAAKvB,MAAMe,UAAU;4BAEtD,IAAIG,mBAAmBM,QAAQ;gCAC7B,MAAMC,sBAAsBP,kBAAkBM,MAAM,CAACF,IAAI,CACvD,CAACI,mLACCvD,mBAAAA,EAAiBuD,oBAAoBA,gBAAgB5B,IAAI,KAAK;gCAElE,IAAI2B,qBAAqB1B,SAAS,UAAU;oCAC1CP,WAAW,CAACP,MAAMa,IAAI,CAAC,GAAG;wCAAE,GAAGE,KAAK;wCAAEA,OAAOC,WAAWD,MAAMA,KAAK;oCAAY;gCACjF;4BACF;wBACF;oBACF,OAAO;wBACL,IAAIM,MAAMC,OAAO,CAACP,QAAQ;4BACxBA,MAAMgB,OAAO,CAAC,CAACC,YAAqBP;gCAClC,MAAMQ,oBAAoB3B,IAAI4B,OAAO,CAACC,MAAM,CAACC,WAAW,CAACC,IAAI,CAC3D,CAACzC,aAAeA,WAAW0C,IAAI,KAAKtC,MAAM8B,UAAU;gCAGtD,IAAIG,mBAAmBM,QAAQ;oCAC7B,MAAMC,sBAAsBP,kBAAkBM,MAAM,CAACF,IAAI,CACvD,CAACI,mLACCvD,mBAAAA,EAAiBuD,oBAAoBA,gBAAgB5B,IAAI,KAAK;oCAElE,IAAI2B,qBAAqB1B,SAAS,UAAU;wCAC1CP,WAAW,CAACP,MAAMa,IAAI,CAAC,CAACY,EAAE,GAAGT,WAAWgB;oCAC1C;gCACF;4BACF;wBACF;wBACA,IAAIhC,MAAM6B,OAAO,KAAK,QAAQd,OAAO;4BACnC,MAAMkB,oBAAoB3B,IAAI4B,OAAO,CAACC,MAAM,CAACC,WAAW,CAACC,IAAI,CAC3D,CAACzC,aAAeA,WAAW0C,IAAI,KAAKtC,MAAM8B,UAAU;4BAGtD,IAAIG,mBAAmBM,QAAQ;gCAC7B,MAAMC,sBAAsBP,kBAAkBM,MAAM,CAACF,IAAI,CACvD,CAACI,sBACCvD,gLAAAA,EAAiBuD,oBAAoBA,gBAAgB5B,IAAI,KAAK;gCAElE,IAAI2B,qBAAqB1B,SAAS,UAAU;oCAC1CP,WAAW,CAACP,MAAMa,IAAI,CAAC,GAAGG,WAAWD;gCACvC;4BACF;wBACF;oBACF;oBACA;gBACF;YAEA,KAAK;YACL,KAAK;gBAAU;oBACb,sDAAsD;oBACtD,IAAIR,WAAW,CAACP,MAAMa,IAAI,CAAC,KAAK,OAAON,WAAW,CAACP,MAAMa,IAAI,CAAC,KAAK,GAAG;wBACpEN,WAAW,CAACP,MAAMa,IAAI,CAAC,GAAG,EAAE;oBAC9B;oBAEA;gBACF;YAEA;gBAAS;oBACP;gBACF;QACF;QAEA,gBAAgB;QAChB,IAAIb,MAAM0C,KAAK,EAAEC,gBAAgB;YAC/B,MAAM3C,MAAM0C,KAAK,CAACC,cAAc,CAACC,MAAM,CAAC,OAAOC,WAAWC;gBACxD,MAAMD;gBAEN,MAAME,cAAc,MAAMD,YAAY;oBACpClD;oBACAC;oBACAC;oBACAE;oBACAC;oBACAC;oBACA8C,aAAajD;oBACbI;oBACAM,MAAMC;oBACNuC,oBAAoBzC;oBACpB0C,eAAe3C,WAAW,CAACP,MAAMa,IAAI,CAAC;oBACtCP;oBACAK,YAAYC;oBACZL;oBACAQ,OAAOR,WAAW,CAACP,MAAMa,IAAI,CAAC;gBAChC;gBAEA,IAAIkC,gBAAgBI,WAAW;oBAC7B5C,WAAW,CAACP,MAAMa,IAAI,CAAC,GAAGkC;gBAC5B;YACF,GAAGK,QAAQC,OAAO;QACpB;QAEA,yBAAyB;QACzB,IAAIrD,MAAMsD,MAAM,IAAItD,MAAMsD,MAAM,CAACpD,UAAU,EAAE;YAC3C,MAAMqD,SAASpD,iBACX,OACA,MAAMH,MAAMsD,MAAM,CAACpD,UAAU,CAAC;gBAAEP;gBAAIG;gBAAMC;gBAAKO;gBAAKC;YAAY;YAEpE,IAAI,CAACgD,QAAQ;gBACX,OAAOhD,WAAW,CAACP,MAAMa,IAAI,CAAC;YAChC;QACF;QAEA,IAAI,OAAON,WAAW,CAACP,MAAMa,IAAI,CAAC,KAAK,aAAa;YAClD,wEAAwE;YACxE,IAAI,OAAOL,UAAU,CAACR,MAAMa,IAAI,CAAC,KAAK,aAAa;gBACjDN,WAAW,CAACP,MAAMa,IAAI,CAAC,sMAAGtB,2BAAAA,EAAyBiB,UAAU,CAACR,MAAMa,IAAI,CAAC;YAEzE,kCAAkC;YACpC,OAAO,IAAI,OAAOb,MAAMwD,YAAY,KAAK,aAAa;gBACpDjD,WAAW,CAACP,MAAMa,IAAI,CAAC,GAAG,uKAAMxB,kBAAAA,EAAgB;oBAC9CmE,cAAcxD,MAAMwD,YAAY;oBAChCC,QAAQnD,IAAImD,MAAM;oBAClBC,MAAMpD,IAAIoD,IAAI;oBACd3C,OAAOR,WAAW,CAACP,MAAMa,IAAI,CAAC;gBAChC;YACF;QACF;IACF;IAEA,qBAAqB;IACrB,OAAQb,MAAMc,IAAI;QAChB,KAAK;YAAS;gBACZ,IAAI,OAAOP,WAAW,CAACP,MAAMa,IAAI,CAAC,KAAK,UAAU;oBAC/CN,WAAW,CAACP,MAAMa,IAAI,CAAC,GAAG,CAAC;gBAC7B;gBACA,IAAI,OAAOL,UAAU,CAACR,MAAMa,IAAI,CAAC,KAAK,UAAU;oBAC9CL,UAAU,CAACR,MAAMa,IAAI,CAAC,GAAG,CAAC;gBAC5B;gBAEA,MAAM8C,YAAYpD,WAAW,CAACP,MAAMa,IAAI,CAAC;gBACzC,MAAM+C,WAAWpD,UAAU,CAACR,MAAMa,IAAI,CAAC;gBAEvC,iMAAMpB,iBAAAA,EAAe;oBACnBE;oBACAC;oBACAC;oBACAC;oBACAC;oBACAwC,QAAQvC,MAAMuC,MAAM;oBACpBtC;oBACAC;oBACAC;oBACAM,MAAMC;oBACNJ;oBACAK,YAAYC;oBACZL,aAAaoD;oBACbnD,YAAYoD;gBACd;gBAEA;YACF;QAEA,KAAK;YAAS;gBACZ,MAAMC,OAAOtD,WAAW,CAACP,MAAMa,IAAI,CAAC;gBAEpC,IAAIQ,MAAMC,OAAO,CAACuC,OAAO;oBACvB,MAAMC,WAAW,EAAE;oBACnBD,KAAK9B,OAAO,CAAC,CAACgC,KAAKtC;wBACjBqC,SAASE,IAAI,4LACXvE,iBAAAA,EAAe;4BACbE;4BACAC;4BACAC;4BACAC;4BACAC;4BACAwC,QAAQvC,MAAMuC,MAAM;4BACpBtC;4BACAC;4BACAC;4BACAM,MAAM;mCAAIC;gCAAWe;6BAAE;4BACvBnB;4BACAK,YAAYC;4BACZL,aAAawD;4BACbvD,wMAAYhB,oBAAAA,EAAkBuE,KAAmBvD,UAAU,CAACR,MAAMa,IAAI,CAAC;wBACzE;oBAEJ;oBACA,MAAMuC,QAAQa,GAAG,CAACH;gBACpB;gBACA;YACF;QAEA,KAAK;YAAU;gBACb,MAAMD,OAAOtD,WAAW,CAACP,MAAMa,IAAI,CAAC;gBAEpC,IAAIQ,MAAMC,OAAO,CAACuC,OAAO;oBACvB,MAAMC,WAAW,EAAE;oBACnBD,KAAK9B,OAAO,CAAC,CAACgC,KAAKtC;wBACjB,MAAMyC,4MAAgB1E,oBAAAA,EAAkBuE,KAAmBvD,UAAU,CAACR,MAAMa,IAAI,CAAC;wBACjF,MAAMsD,mBAAoBJ,IAAmBK,SAAS,IAAIF,cAAcE,SAAS;wBACjF,MAAMC,QAAQrE,MAAMsE,MAAM,CAACjC,IAAI,CAAC,CAAC+B,YAAcA,UAAU9B,IAAI,KAAK6B;wBAElE,IAAIE,OAAO;4BACPN,IAAmBK,SAAS,GAAGD;4BAEjCL,SAASE,IAAI,4LACXvE,iBAAAA,EAAe;gCACbE;gCACAC;gCACAC;gCACAC;gCACAC;gCACAwC,QAAQ8B,MAAM9B,MAAM;gCACpBtC;gCACAC;gCACAC;gCACAM,MAAM;uCAAIC;oCAAWe;iCAAE;gCACvBnB;gCACAK,YAAYC;gCACZL,aAAawD;gCACbvD,YAAY0D;4BACd;wBAEJ;oBACF;oBACA,MAAMd,QAAQa,GAAG,CAACH;gBACpB;gBAEA;YACF;QAEA,KAAK;QACL,KAAK;YAAe;gBAClB,MAAMrE,4MAAAA,EAAe;oBACnBE;oBACAC;oBACAC;oBACAC;oBACAC;oBACAwC,QAAQvC,MAAMuC,MAAM;oBACpBtC;oBACAC;oBACAC;oBACAM,MAAMC;oBACNJ;oBACAK,YAAYC;oBACZL;oBACAC;gBACF;gBAEA;YACF;QAEA,KAAK;YAAO;gBACV,IAAI+D;gBACJ,IAAIC;gBACJ,qKAAIrF,aAAAA,EAAWa,QAAQ;oBACrB,IAAI,OAAOO,WAAW,CAACP,MAAMa,IAAI,CAAC,KAAK,UAAU;wBAC/CN,WAAW,CAACP,MAAMa,IAAI,CAAC,GAAG,CAAC;oBAC7B;oBACA,IAAI,OAAOL,UAAU,CAACR,MAAMa,IAAI,CAAC,KAAK,UAAU;wBAC9CL,UAAU,CAACR,MAAMa,IAAI,CAAC,GAAG,CAAC;oBAC5B;oBAEA0D,iBAAiBhE,WAAW,CAACP,MAAMa,IAAI,CAAC;oBACxC2D,gBAAgBhE,UAAU,CAACR,MAAMa,IAAI,CAAC;gBACxC,OAAO;oBACL0D,iBAAiBhE;oBACjBiE,gBAAgBhE;gBAClB;gBAEA,iMAAMf,iBAAAA,EAAe;oBACnBE;oBACAC;oBACAC;oBACAC;oBACAC;oBACAwC,QAAQvC,MAAMuC,MAAM;oBACpBtC;oBACAC;oBACAC;oBACAM,MAAMC;oBACNJ;oBACAK,YAAYC;oBACZL,aAAagE;oBACb/D,YAAYgE;gBACd;gBAEA;YACF;QAEA,KAAK;YAAQ;gBACX,iMAAM/E,iBAAAA,EAAe;oBACnBE;oBACAC;oBACAC;oBACAC;oBACAC;oBACAwC,QAAQvC,MAAMyE,IAAI,CAAClD,GAAG,CAAC,CAACmD,MAAS,CAAA;4BAAE,GAAGA,GAAG;4BAAE5D,MAAM;wBAAM,CAAA;oBACvDb;oBACAC;oBACAC;oBACAM,MAAMC;oBACNJ;oBACAK,YAAYC;oBACZL;oBACAC;gBACF;gBAEA;YACF;QAEA,KAAK;YAAY;gBACf,IAAI,CAACR,OAAO2E,QAAQ;oBAClB,MAAM,mKAAI1F,oBAAAA,CAAkBe,OAAO,8HAA8H;;gBACnK;gBACA,IAAI,OAAOA,OAAO2E,WAAW,YAAY;oBACvC,MAAM,IAAIC,MAAM;gBAClB;gBAEA,MAAMD,SAA0B3E,OAAO2E;gBAEvC,IAAIA,QAAQjC,OAAOC,gBAAgBvB,QAAQ;oBACzC,MAAMuD,OAAOjC,KAAK,CAACC,cAAc,CAACC,MAAM,CAAC,OAAOC,WAAWC;wBACzD,MAAMD;wBAEN,MAAME,cAAc,MAAMD,YAAY;4BACpClD;4BACAC;4BACAC;4BACAE;4BACAC;4BACAC;4BACA8C,aAAajD;4BACbI;4BACAM,MAAMC;4BACNuC,oBAAoBzC;4BACpB0C,eAAe3C,WAAW,CAACP,MAAMa,IAAI,CAAC;4BACtCP;4BACAK,YAAYC;4BACZL;4BACAQ,OAAOR,WAAW,CAACP,MAAMa,IAAI,CAAC;wBAChC;wBAEA,IAAIkC,gBAAgBI,WAAW;4BAC7B5C,WAAW,CAACP,MAAMa,IAAI,CAAC,GAAGkC;wBAC5B;oBACF,GAAGK,QAAQC,OAAO;gBACpB;gBACA;YACF;QAEA;YAAS;gBACP;YACF;IACF;AACF,EAAC"}},
    {"offset": {"line": 6664, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 6670, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/payload/src/fields/hooks/beforeValidate/traverseFields.ts"],"sourcesContent":["import type { SanitizedCollectionConfig } from '../../../collections/config/types.js'\nimport type { SanitizedGlobalConfig } from '../../../globals/config/types.js'\nimport type { JsonObject, PayloadRequest, RequestContext } from '../../../types/index.js'\nimport type { Field, TabAsField } from '../../config/types.js'\n\nimport { promise } from './promise.js'\n\ntype Args<T> = {\n  collection: null | SanitizedCollectionConfig\n  context: RequestContext\n  data: T\n  /**\n   * The original data (not modified by any hooks)\n   */\n  doc: T\n  fields: (Field | TabAsField)[]\n  global: null | SanitizedGlobalConfig\n  id?: number | string\n  operation: 'create' | 'update'\n  overrideAccess: boolean\n  path: (number | string)[]\n  req: PayloadRequest\n  schemaPath: string[]\n  siblingData: JsonObject\n  /**\n   * The original siblingData (not modified by any hooks)\n   */\n  siblingDoc: JsonObject\n}\n\nexport const traverseFields = async <T>({\n  id,\n  collection,\n  context,\n  data,\n  doc,\n  fields,\n  global,\n  operation,\n  overrideAccess,\n  path,\n  req,\n  schemaPath,\n  siblingData,\n  siblingDoc,\n}: Args<T>): Promise<void> => {\n  const promises = []\n  fields.forEach((field) => {\n    promises.push(\n      promise({\n        id,\n        collection,\n        context,\n        data,\n        doc,\n        field,\n        global,\n        operation,\n        overrideAccess,\n        parentPath: path,\n        parentSchemaPath: schemaPath,\n        req,\n        siblingData,\n        siblingDoc,\n      }),\n    )\n  })\n  await Promise.all(promises)\n}\n"],"names":["promise","traverseFields","id","collection","context","data","doc","fields","global","operation","overrideAccess","path","req","schemaPath","siblingData","siblingDoc","promises","forEach","field","push","parentPath","parentSchemaPath","Promise","all"],"mappings":";;;AAKA,SAASA,OAAO,QAAQ,eAAc;;AAyB/B,MAAMC,iBAAiB,OAAU,EACtCC,EAAE,EACFC,UAAU,EACVC,OAAO,EACPC,IAAI,EACJC,GAAG,EACHC,MAAM,EACNC,MAAM,EACNC,SAAS,EACTC,cAAc,EACdC,IAAI,EACJC,GAAG,EACHC,UAAU,EACVC,WAAW,EACXC,UAAU,EACF;IACR,MAAMC,WAAW,EAAE;IACnBT,OAAOU,OAAO,CAAC,CAACC;QACdF,SAASG,IAAI,qLACXnB,UAAAA,EAAQ;YACNE;YACAC;YACAC;YACAC;YACAC;YACAY;YACAV;YACAC;YACAC;YACAU,YAAYT;YACZU,kBAAkBR;YAClBD;YACAE;YACAC;QACF;IAEJ;IACA,MAAMO,QAAQC,GAAG,CAACP;AACpB,EAAC"}},
    {"offset": {"line": 6697, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 6703, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/payload/src/fields/hooks/beforeValidate/index.ts"],"sourcesContent":["import type { SanitizedCollectionConfig } from '../../../collections/config/types.js'\nimport type { SanitizedGlobalConfig } from '../../../globals/config/types.js'\nimport type { JsonObject, PayloadRequest, RequestContext } from '../../../types/index.js'\n\nimport { deepCopyObjectSimple } from '../../../utilities/deepCopyObject.js'\nimport { traverseFields } from './traverseFields.js'\n\ntype Args<T extends JsonObject> = {\n  collection: null | SanitizedCollectionConfig\n  context: RequestContext\n  data: T\n  doc?: T\n  duplicate?: boolean\n  global: null | SanitizedGlobalConfig\n  id?: number | string\n  operation: 'create' | 'update'\n  overrideAccess: boolean\n  req: PayloadRequest\n}\n\n/**\n * This function is responsible for the following actions, in order:\n * - Sanitize incoming data\n * - Execute field hooks\n * - Execute field access control\n * - Merge original document data into incoming data\n * - Compute default values for undefined fields\n */\nexport const beforeValidate = async <T extends JsonObject>({\n  id,\n  collection,\n  context,\n  data: incomingData,\n  doc,\n  global,\n  operation,\n  overrideAccess,\n  req,\n}: Args<T>): Promise<T> => {\n  const data = deepCopyObjectSimple(incomingData)\n\n  await traverseFields({\n    id,\n    collection,\n    context,\n    data,\n    doc,\n    fields: collection?.fields || global?.fields,\n    global,\n    operation,\n    overrideAccess,\n    path: [],\n    req,\n    schemaPath: [],\n    siblingData: data,\n    siblingDoc: doc,\n  })\n\n  return data\n}\n"],"names":["deepCopyObjectSimple","traverseFields","beforeValidate","id","collection","context","data","incomingData","doc","global","operation","overrideAccess","req","fields","path","schemaPath","siblingData","siblingDoc"],"mappings":";;;AAIA,SAASA,oBAAoB,QAAQ,uCAAsC;AAC3E,SAASC,cAAc,QAAQ,sBAAqB;;;AAuB7C,MAAMC,iBAAiB,OAA6B,EACzDC,EAAE,EACFC,UAAU,EACVC,OAAO,EACPC,MAAMC,YAAY,EAClBC,GAAG,EACHC,MAAM,EACNC,SAAS,EACTC,cAAc,EACdC,GAAG,EACK;IACR,MAAMN,0KAAON,uBAAAA,EAAqBO;IAElC,OAAMN,2MAAAA,EAAe;QACnBE;QACAC;QACAC;QACAC;QACAE;QACAK,QAAQT,YAAYS,UAAUJ,QAAQI;QACtCJ;QACAC;QACAC;QACAG,MAAM,EAAE;QACRF;QACAG,YAAY,EAAE;QACdC,aAAaV;QACbW,YAAYT;IACd;IAEA,OAAOF;AACT,EAAC"}},
    {"offset": {"line": 6730, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 6736, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/payload/src/utilities/isReactComponent.ts"],"sourcesContent":["import type React from 'react'\n\nconst clientRefSymbol = Symbol.for('react.client.reference')\n\nexport function isReactServerComponentOrFunction<T extends any>(\n  component: any | React.ComponentType,\n): component is T {\n  if (component === null || component === undefined) {\n    return false\n  }\n  const hasClientComponentSymbol = component.$$typeof == clientRefSymbol\n\n  const isFunctionalComponent = typeof component === 'function'\n  // Anonymous functions are Client Components in Turbopack. RSCs should have a name\n  const isAnonymousFunction = typeof component === 'function' && component.name === ''\n\n  const isRSC = isFunctionalComponent && !isAnonymousFunction && !hasClientComponentSymbol\n\n  return isRSC\n}\n\nexport function isReactClientComponent<T extends any>(\n  component: any | React.ComponentType,\n): component is T {\n  if (component === null || component === undefined) {\n    return false\n  }\n  return !isReactServerComponentOrFunction(component) && component.$$typeof == clientRefSymbol\n}\n\nexport function isReactComponentOrFunction<T extends any>(\n  component: any | React.ComponentType,\n): component is T {\n  return isReactServerComponentOrFunction(component) || isReactClientComponent(component)\n}\n"],"names":["clientRefSymbol","Symbol","for","isReactServerComponentOrFunction","component","undefined","hasClientComponentSymbol","$$typeof","isFunctionalComponent","isAnonymousFunction","name","isRSC","isReactClientComponent","isReactComponentOrFunction"],"mappings":";;;;;AAEA,MAAMA,kBAAkBC,OAAOC,GAAG,CAAC;AAE5B,SAASC,iCACdC,SAAoC;IAEpC,IAAIA,cAAc,QAAQA,cAAcC,WAAW;QACjD,OAAO;IACT;IACA,MAAMC,2BAA2BF,UAAUG,QAAQ,IAAIP;IAEvD,MAAMQ,wBAAwB,OAAOJ,cAAc;IACnD,kFAAkF;IAClF,MAAMK,sBAAsB,OAAOL,cAAc,cAAcA,UAAUM,IAAI,KAAK;IAElF,MAAMC,QAAQH,yBAAyB,CAACC,uBAAuB,CAACH;IAEhE,OAAOK;AACT;AAEO,SAASC,uBACdR,SAAoC;IAEpC,IAAIA,cAAc,QAAQA,cAAcC,WAAW;QACjD,OAAO;IACT;IACA,OAAO,CAACF,iCAAiCC,cAAcA,UAAUG,QAAQ,IAAIP;AAC/E;AAEO,SAASa,2BACdT,SAAoC;IAEpC,OAAOD,iCAAiCC,cAAcQ,uBAAuBR;AAC/E"}},
    {"offset": {"line": 6762, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 6768, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/payload/src/utilities/isPlainObject.ts"],"sourcesContent":["import { isReactComponentOrFunction } from './isReactComponent.js'\n\nexport function isPlainObject(o: any): boolean {\n  // Is this a React component?\n  if (isReactComponentOrFunction(o)) {\n    return false\n  }\n\n  // from https://github.com/fastify/deepmerge/blob/master/index.js#L77\n  return typeof o === 'object' && o !== null && !(o instanceof RegExp) && !(o instanceof Date)\n}\n"],"names":["isReactComponentOrFunction","isPlainObject","o","RegExp","Date"],"mappings":";;;AAAA,SAASA,0BAA0B,QAAQ,wBAAuB;;AAE3D,SAASC,cAAcC,CAAM;IAClC,6BAA6B;IAC7B,yKAAIF,6BAAAA,EAA2BE,IAAI;QACjC,OAAO;IACT;IAEA,qEAAqE;IACrE,OAAO,OAAOA,MAAM,YAAYA,MAAM,QAAQ,CAAEA,CAAAA,aAAaC,MAAK,KAAM,CAAED,CAAAA,aAAaE,IAAG;AAC5F"}},
    {"offset": {"line": 6781, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 6787, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/payload/src/utilities/deepMerge.ts"],"sourcesContent":["import deepMerge from 'deepmerge'\n\nimport { isPlainObject } from './isPlainObject.js'\n\nexport { deepMerge }\n/**\n * Fully-featured deepMerge.\n *\n * Array handling: Arrays in the target object are combined with the source object's arrays.\n */\nexport function deepMergeWithCombinedArrays<T extends object>(obj1: object, obj2: object): T {\n  return deepMerge<T>(obj1, obj2, {\n    arrayMerge: (target, source, options) => {\n      const destination = target.slice()\n\n      source.forEach((item, index) => {\n        if (typeof destination[index] === 'undefined') {\n          destination[index] = options.cloneUnlessOtherwiseSpecified(item, options)\n        } else if (options.isMergeableObject(item)) {\n          destination[index] = deepMerge(target[index], item, options)\n        } else if (target.indexOf(item) === -1) {\n          destination.push(item)\n        }\n      })\n      return destination\n    },\n  })\n}\n\n/**\n * Fully-featured deepMerge.\n *\n * Array handling: Arrays in the target object are replaced by the source object's arrays.\n */\nexport function deepMergeWithSourceArrays<T extends object>(obj1: object, obj2: object): T {\n  return deepMerge<T>(obj1, obj2, { arrayMerge: (_, source) => source })\n}\n\n/**\n * Fully-featured deepMerge. Does not clone React components by default.\n */\nexport function deepMergeWithReactComponents<T extends object>(obj1: object, obj2: object): T {\n  return deepMerge<T>(obj1, obj2, {\n    isMergeableObject: isPlainObject,\n  })\n}\n"],"names":["deepMerge","isPlainObject","deepMergeWithCombinedArrays","obj1","obj2","arrayMerge","target","source","options","destination","slice","forEach","item","index","cloneUnlessOtherwiseSpecified","isMergeableObject","indexOf","push","deepMergeWithSourceArrays","_","deepMergeWithReactComponents"],"mappings":";;;;;AAAA,OAAOA,eAAe,YAAW;AAEjC,SAASC,aAAa,QAAQ,qBAAoB;;;;AAQ3C,SAASC,4BAA8CC,IAAY,EAAEC,IAAY;IACtF,oJAAOJ,UAAAA,EAAaG,MAAMC,MAAM;QAC9BC,YAAY,CAACC,QAAQC,QAAQC;YAC3B,MAAMC,cAAcH,OAAOI,KAAK;YAEhCH,OAAOI,OAAO,CAAC,CAACC,MAAMC;gBACpB,IAAI,OAAOJ,WAAW,CAACI,MAAM,KAAK,aAAa;oBAC7CJ,WAAW,CAACI,MAAM,GAAGL,QAAQM,6BAA6B,CAACF,MAAMJ;gBACnE,OAAO,IAAIA,QAAQO,iBAAiB,CAACH,OAAO;oBAC1CH,WAAW,CAACI,MAAM,IAAGb,sJAAAA,EAAUM,MAAM,CAACO,MAAM,EAAED,MAAMJ;gBACtD,OAAO,IAAIF,OAAOU,OAAO,CAACJ,UAAU,CAAC,GAAG;oBACtCH,YAAYQ,IAAI,CAACL;gBACnB;YACF;YACA,OAAOH;QACT;IACF;AACF;AAOO,SAASS,0BAA4Cf,IAAY,EAAEC,IAAY;IACpF,oJAAOJ,UAAAA,EAAaG,MAAMC,MAAM;QAAEC,YAAY,CAACc,GAAGZ,SAAWA;IAAO;AACtE;AAKO,SAASa,6BAA+CjB,IAAY,EAAEC,IAAY;IACvF,oJAAOJ,UAAAA,EAAaG,MAAMC,MAAM;QAC9BW,iLAAmBd,gBAAAA;IACrB;AACF"}},
    {"offset": {"line": 6824, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 6830, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/payload/src/fields/hooks/beforeChange/promise.ts"],"sourcesContent":["import type { RichTextAdapter } from '../../../admin/RichText.js'\nimport type { SanitizedCollectionConfig } from '../../../collections/config/types.js'\nimport type { SanitizedGlobalConfig } from '../../../globals/config/types.js'\nimport type { JsonObject, Operation, PayloadRequest, RequestContext } from '../../../types/index.js'\nimport type { Field, FieldHookArgs, TabAsField, ValidateOptions } from '../../config/types.js'\n\nimport { MissingEditorProp } from '../../../errors/index.js'\nimport { deepMergeWithSourceArrays } from '../../../utilities/deepMerge.js'\nimport { fieldAffectsData, tabHasName } from '../../config/types.js'\nimport { getFieldPaths } from '../../getFieldPaths.js'\nimport { getExistingRowDoc } from './getExistingRowDoc.js'\nimport { traverseFields } from './traverseFields.js'\n\ntype Args = {\n  collection: null | SanitizedCollectionConfig\n  context: RequestContext\n  data: JsonObject\n  doc: JsonObject\n  docWithLocales: JsonObject\n  errors: { field: string; message: string }[]\n  field: Field | TabAsField\n  global: null | SanitizedGlobalConfig\n  id?: number | string\n  mergeLocaleActions: (() => Promise<void>)[]\n  operation: Operation\n  /**\n   * The parent's path.\n   */\n  parentPath: (number | string)[]\n  /**\n   * The parent's schemaPath (path without indexes).\n   */\n  parentSchemaPath: string[]\n  req: PayloadRequest\n  siblingData: JsonObject\n  siblingDoc: JsonObject\n  siblingDocWithLocales?: JsonObject\n  skipValidation: boolean\n}\n\n// This function is responsible for the following actions, in order:\n// - Run condition\n// - Execute field hooks\n// - Validate data\n// - Transform data for storage\n// - beforeDuplicate hooks (if duplicate)\n// - Unflatten locales\n\nexport const promise = async ({\n  id,\n  collection,\n  context,\n  data,\n  doc,\n  docWithLocales,\n  errors,\n  field,\n  global,\n  mergeLocaleActions,\n  operation,\n  parentPath,\n  parentSchemaPath,\n  req,\n  siblingData,\n  siblingDoc,\n  siblingDocWithLocales,\n  skipValidation,\n}: Args): Promise<void> => {\n  const passesCondition = field.admin?.condition\n    ? Boolean(field.admin.condition(data, siblingData, { user: req.user }))\n    : true\n  let skipValidationFromHere = skipValidation || !passesCondition\n  const { localization } = req.payload.config\n  const defaultLocale = localization ? localization?.defaultLocale : 'en'\n  const operationLocale = req.locale || defaultLocale\n\n  const { path: fieldPath, schemaPath: fieldSchemaPath } = getFieldPaths({\n    field,\n    parentPath,\n    parentSchemaPath,\n  })\n\n  if (fieldAffectsData(field)) {\n    // skip validation if the field is localized and the incoming data is null\n    if (field.localized && operationLocale !== defaultLocale) {\n      if (['array', 'blocks'].includes(field.type) && siblingData[field.name] === null) {\n        skipValidationFromHere = true\n      }\n    }\n\n    // Execute hooks\n    if (field.hooks?.beforeChange) {\n      await field.hooks.beforeChange.reduce(async (priorHook, currentHook) => {\n        await priorHook\n\n        const hookedValue = await currentHook({\n          collection,\n          context,\n          data,\n          field,\n          global,\n          operation,\n          originalDoc: doc,\n          path: fieldPath,\n          previousSiblingDoc: siblingDoc,\n          previousValue: siblingDoc[field.name],\n          req,\n          schemaPath: parentSchemaPath,\n          siblingData,\n          siblingDocWithLocales,\n          value: siblingData[field.name],\n        })\n\n        if (hookedValue !== undefined) {\n          siblingData[field.name] = hookedValue\n        }\n      }, Promise.resolve())\n    }\n\n    // Validate\n    if (!skipValidationFromHere && 'validate' in field && field.validate) {\n      const valueToValidate = siblingData[field.name]\n      let jsonError: object\n\n      if (field.type === 'json' && typeof siblingData[field.name] === 'string') {\n        try {\n          JSON.parse(siblingData[field.name] as string)\n        } catch (e) {\n          jsonError = e\n        }\n      }\n\n      const validationResult = await field.validate(\n        valueToValidate as never,\n        {\n          ...field,\n          id,\n          collectionSlug: collection?.slug,\n          data: deepMergeWithSourceArrays(doc, data),\n          jsonError,\n          operation,\n          preferences: { fields: {} },\n          previousValue: siblingDoc[field.name],\n          req,\n          siblingData: deepMergeWithSourceArrays(siblingDoc, siblingData),\n        } as any,\n      )\n\n      if (typeof validationResult === 'string') {\n        errors.push({\n          field: fieldPath.join('.'),\n          message: validationResult,\n        })\n      }\n    }\n\n    const beforeDuplicateArgs: FieldHookArgs = {\n      collection,\n      context,\n      data,\n      field,\n      global: undefined,\n      path: fieldPath,\n      previousSiblingDoc: siblingDoc,\n      previousValue: siblingDoc[field.name],\n      req,\n      schemaPath: parentSchemaPath,\n      siblingData,\n      siblingDocWithLocales,\n      value: siblingData[field.name],\n    }\n\n    // Push merge locale action if applicable\n    if (localization && field.localized) {\n      mergeLocaleActions.push(async () => {\n        const localeData = await localization.localeCodes.reduce(\n          async (localizedValuesPromise: Promise<JsonObject>, locale) => {\n            const localizedValues = await localizedValuesPromise\n            const fieldValue =\n              locale === req.locale\n                ? siblingData[field.name]\n                : siblingDocWithLocales?.[field.name]?.[locale]\n\n            // const result = await localizedValues\n            // update locale value if it's not undefined\n            if (typeof fieldValue !== 'undefined') {\n              return {\n                ...localizedValues,\n                [locale]: fieldValue,\n              }\n            }\n\n            return localizedValuesPromise\n          },\n          Promise.resolve({}),\n        )\n\n        // If there are locales with data, set the data\n        if (Object.keys(localeData).length > 0) {\n          siblingData[field.name] = localeData\n        }\n      })\n    }\n  }\n\n  switch (field.type) {\n    case 'point': {\n      // Transform point data for storage\n      if (\n        Array.isArray(siblingData[field.name]) &&\n        siblingData[field.name][0] !== null &&\n        siblingData[field.name][1] !== null\n      ) {\n        siblingData[field.name] = {\n          type: 'Point',\n          coordinates: [\n            parseFloat(siblingData[field.name][0]),\n            parseFloat(siblingData[field.name][1]),\n          ],\n        }\n      }\n\n      break\n    }\n\n    case 'group': {\n      if (typeof siblingData[field.name] !== 'object') {\n        siblingData[field.name] = {}\n      }\n      if (typeof siblingDoc[field.name] !== 'object') {\n        siblingDoc[field.name] = {}\n      }\n      if (typeof siblingDocWithLocales[field.name] !== 'object') {\n        siblingDocWithLocales[field.name] = {}\n      }\n\n      await traverseFields({\n        id,\n        collection,\n        context,\n        data,\n        doc,\n        docWithLocales,\n        errors,\n        fields: field.fields,\n        global,\n        mergeLocaleActions,\n        operation,\n        path: fieldPath,\n        req,\n        schemaPath: fieldSchemaPath,\n        siblingData: siblingData[field.name] as JsonObject,\n        siblingDoc: siblingDoc[field.name] as JsonObject,\n        siblingDocWithLocales: siblingDocWithLocales[field.name] as JsonObject,\n        skipValidation: skipValidationFromHere,\n      })\n\n      break\n    }\n\n    case 'array': {\n      const rows = siblingData[field.name]\n\n      if (Array.isArray(rows)) {\n        const promises = []\n        rows.forEach((row, i) => {\n          promises.push(\n            traverseFields({\n              id,\n              collection,\n              context,\n              data,\n              doc,\n              docWithLocales,\n              errors,\n              fields: field.fields,\n              global,\n              mergeLocaleActions,\n              operation,\n              path: [...fieldPath, i],\n              req,\n              schemaPath: fieldSchemaPath,\n              siblingData: row as JsonObject,\n              siblingDoc: getExistingRowDoc(row as JsonObject, siblingDoc[field.name]),\n              siblingDocWithLocales: getExistingRowDoc(\n                row as JsonObject,\n                siblingDocWithLocales[field.name],\n              ),\n              skipValidation: skipValidationFromHere,\n            }),\n          )\n        })\n\n        await Promise.all(promises)\n      }\n\n      break\n    }\n\n    case 'blocks': {\n      const rows = siblingData[field.name]\n      if (Array.isArray(rows)) {\n        const promises = []\n        rows.forEach((row, i) => {\n          const rowSiblingDoc = getExistingRowDoc(row as JsonObject, siblingDoc[field.name])\n          const rowSiblingDocWithLocales = getExistingRowDoc(\n            row as JsonObject,\n            siblingDocWithLocales ? siblingDocWithLocales[field.name] : {},\n          )\n\n          const blockTypeToMatch = (row as JsonObject).blockType || rowSiblingDoc.blockType\n          const block = field.blocks.find((blockType) => blockType.slug === blockTypeToMatch)\n\n          if (block) {\n            promises.push(\n              traverseFields({\n                id,\n                collection,\n                context,\n                data,\n                doc,\n                docWithLocales,\n                errors,\n                fields: block.fields,\n                global,\n                mergeLocaleActions,\n                operation,\n                path: [...fieldPath, i],\n                req,\n                schemaPath: fieldSchemaPath,\n                siblingData: row as JsonObject,\n                siblingDoc: rowSiblingDoc,\n                siblingDocWithLocales: rowSiblingDocWithLocales,\n                skipValidation: skipValidationFromHere,\n              }),\n            )\n          }\n        })\n\n        await Promise.all(promises)\n      }\n\n      break\n    }\n\n    case 'row':\n    case 'collapsible': {\n      await traverseFields({\n        id,\n        collection,\n        context,\n        data,\n        doc,\n        docWithLocales,\n        errors,\n        fields: field.fields,\n        global,\n        mergeLocaleActions,\n        operation,\n        path: fieldPath,\n        req,\n        schemaPath: fieldSchemaPath,\n        siblingData,\n        siblingDoc,\n        siblingDocWithLocales,\n        skipValidation: skipValidationFromHere,\n      })\n\n      break\n    }\n\n    case 'tab': {\n      let tabSiblingData = siblingData\n      let tabSiblingDoc = siblingDoc\n      let tabSiblingDocWithLocales = siblingDocWithLocales\n\n      if (tabHasName(field)) {\n        if (typeof siblingData[field.name] !== 'object') {\n          siblingData[field.name] = {}\n        }\n        if (typeof siblingDoc[field.name] !== 'object') {\n          siblingDoc[field.name] = {}\n        }\n        if (typeof siblingDocWithLocales[field.name] !== 'object') {\n          siblingDocWithLocales[field.name] = {}\n        }\n\n        tabSiblingData = siblingData[field.name] as JsonObject\n        tabSiblingDoc = siblingDoc[field.name] as JsonObject\n        tabSiblingDocWithLocales = siblingDocWithLocales[field.name] as JsonObject\n      }\n\n      await traverseFields({\n        id,\n        collection,\n        context,\n        data,\n        doc,\n        docWithLocales,\n        errors,\n        fields: field.fields,\n        global,\n        mergeLocaleActions,\n        operation,\n        path: fieldPath,\n        req,\n        schemaPath: fieldSchemaPath,\n        siblingData: tabSiblingData,\n        siblingDoc: tabSiblingDoc,\n        siblingDocWithLocales: tabSiblingDocWithLocales,\n        skipValidation: skipValidationFromHere,\n      })\n\n      break\n    }\n\n    case 'tabs': {\n      await traverseFields({\n        id,\n        collection,\n        context,\n        data,\n        doc,\n        docWithLocales,\n        errors,\n        fields: field.tabs.map((tab) => ({ ...tab, type: 'tab' })),\n        global,\n        mergeLocaleActions,\n        operation,\n        path: fieldPath,\n        req,\n        schemaPath: fieldSchemaPath,\n        siblingData,\n        siblingDoc,\n        siblingDocWithLocales,\n        skipValidation: skipValidationFromHere,\n      })\n\n      break\n    }\n\n    case 'richText': {\n      if (!field?.editor) {\n        throw new MissingEditorProp(field) // while we allow disabling editor functionality, you should not have any richText fields defined if you do not have an editor\n      }\n      if (typeof field?.editor === 'function') {\n        throw new Error('Attempted to access unsanitized rich text editor.')\n      }\n\n      const editor: RichTextAdapter = field?.editor\n\n      if (editor?.hooks?.beforeChange?.length) {\n        await editor.hooks.beforeChange.reduce(async (priorHook, currentHook) => {\n          await priorHook\n\n          const hookedValue = await currentHook({\n            collection,\n            context,\n            data,\n            docWithLocales,\n            errors,\n            field,\n            global,\n            mergeLocaleActions,\n            operation,\n            originalDoc: doc,\n            path: fieldPath,\n            previousSiblingDoc: siblingDoc,\n            previousValue: siblingDoc[field.name],\n            req,\n            schemaPath: parentSchemaPath,\n            siblingData,\n            siblingDocWithLocales,\n            skipValidation,\n            value: siblingData[field.name],\n          })\n\n          if (hookedValue !== undefined) {\n            siblingData[field.name] = hookedValue\n          }\n        }, Promise.resolve())\n      }\n\n      break\n    }\n\n    default: {\n      break\n    }\n  }\n}\n"],"names":["MissingEditorProp","deepMergeWithSourceArrays","fieldAffectsData","tabHasName","getFieldPaths","getExistingRowDoc","traverseFields","promise","id","collection","context","data","doc","docWithLocales","errors","field","global","mergeLocaleActions","operation","parentPath","parentSchemaPath","req","siblingData","siblingDoc","siblingDocWithLocales","skipValidation","passesCondition","admin","condition","Boolean","user","skipValidationFromHere","localization","payload","config","defaultLocale","operationLocale","locale","path","fieldPath","schemaPath","fieldSchemaPath","localized","includes","type","name","hooks","beforeChange","reduce","priorHook","currentHook","hookedValue","originalDoc","previousSiblingDoc","previousValue","value","undefined","Promise","resolve","validate","valueToValidate","jsonError","JSON","parse","e","validationResult","collectionSlug","slug","preferences","fields","push","join","message","beforeDuplicateArgs","localeData","localeCodes","localizedValuesPromise","localizedValues","fieldValue","Object","keys","length","Array","isArray","coordinates","parseFloat","rows","promises","forEach","row","i","all","rowSiblingDoc","rowSiblingDocWithLocales","blockTypeToMatch","blockType","block","blocks","find","tabSiblingData","tabSiblingDoc","tabSiblingDocWithLocales","tabs","map","tab","editor","Error"],"mappings":"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"}},
    {"offset": {"line": 7226, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 7232, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/payload/src/fields/hooks/beforeChange/traverseFields.ts"],"sourcesContent":["import type { SanitizedCollectionConfig } from '../../../collections/config/types.js'\nimport type { SanitizedGlobalConfig } from '../../../globals/config/types.js'\nimport type { JsonObject, Operation, PayloadRequest, RequestContext } from '../../../types/index.js'\nimport type { Field, TabAsField } from '../../config/types.js'\n\nimport { promise } from './promise.js'\n\ntype Args = {\n  collection: null | SanitizedCollectionConfig\n  context: RequestContext\n  data: JsonObject\n  /**\n   * The original data (not modified by any hooks)\n   */\n  doc: JsonObject\n  /**\n   * The original data with locales (not modified by any hooks)\n   */\n  docWithLocales: JsonObject\n  errors: { field: string; message: string }[]\n  fields: (Field | TabAsField)[]\n  global: null | SanitizedGlobalConfig\n  id?: number | string\n  mergeLocaleActions: (() => Promise<void>)[]\n  operation: Operation\n  path: (number | string)[]\n  req: PayloadRequest\n  schemaPath: string[]\n  siblingData: JsonObject\n  /**\n   * The original siblingData (not modified by any hooks)\n   */\n  siblingDoc: JsonObject\n  /**\n   * The original siblingData with locales (not modified by any hooks)\n   */\n  siblingDocWithLocales: JsonObject\n  skipValidation?: boolean\n}\n\n/**\n * This function is responsible for the following actions, in order:\n * - Run condition\n * - Execute field hooks\n * - Validate data\n * - Transform data for storage\n * - Unflatten locales. The input `data` is the normal document for one locale. The output result will become the document with locales.\n */\nexport const traverseFields = async ({\n  id,\n  collection,\n  context,\n  data,\n  doc,\n  docWithLocales,\n  errors,\n  fields,\n  global,\n  mergeLocaleActions,\n  operation,\n  path,\n  req,\n  schemaPath,\n  siblingData,\n  siblingDoc,\n  siblingDocWithLocales,\n  skipValidation,\n}: Args): Promise<void> => {\n  const promises = []\n\n  fields.forEach((field) => {\n    promises.push(\n      promise({\n        id,\n        collection,\n        context,\n        data,\n        doc,\n        docWithLocales,\n        errors,\n        field,\n        global,\n        mergeLocaleActions,\n        operation,\n        parentPath: path,\n        parentSchemaPath: schemaPath,\n        req,\n        siblingData,\n        siblingDoc,\n        siblingDocWithLocales,\n        skipValidation,\n      }),\n    )\n  })\n\n  await Promise.all(promises)\n}\n"],"names":["promise","traverseFields","id","collection","context","data","doc","docWithLocales","errors","fields","global","mergeLocaleActions","operation","path","req","schemaPath","siblingData","siblingDoc","siblingDocWithLocales","skipValidation","promises","forEach","field","push","parentPath","parentSchemaPath","Promise","all"],"mappings":";;;AAKA,SAASA,OAAO,QAAQ,eAAc;;AA2C/B,MAAMC,iBAAiB,OAAO,EACnCC,EAAE,EACFC,UAAU,EACVC,OAAO,EACPC,IAAI,EACJC,GAAG,EACHC,cAAc,EACdC,MAAM,EACNC,MAAM,EACNC,MAAM,EACNC,kBAAkB,EAClBC,SAAS,EACTC,IAAI,EACJC,GAAG,EACHC,UAAU,EACVC,WAAW,EACXC,UAAU,EACVC,qBAAqB,EACrBC,cAAc,EACT;IACL,MAAMC,WAAW,EAAE;IAEnBX,OAAOY,OAAO,CAAC,CAACC;QACdF,SAASG,IAAI,mLACXvB,UAAAA,EAAQ;YACNE;YACAC;YACAC;YACAC;YACAC;YACAC;YACAC;YACAc;YACAZ;YACAC;YACAC;YACAY,YAAYX;YACZY,kBAAkBV;YAClBD;YACAE;YACAC;YACAC;YACAC;QACF;IAEJ;IAEA,MAAMO,QAAQC,GAAG,CAACP;AACpB,EAAC"}},
    {"offset": {"line": 7263, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 7269, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/payload/src/fields/hooks/beforeChange/index.ts"],"sourcesContent":["import type { SanitizedCollectionConfig } from '../../../collections/config/types.js'\nimport type { SanitizedGlobalConfig } from '../../../globals/config/types.js'\nimport type { JsonObject, Operation, PayloadRequest, RequestContext } from '../../../types/index.js'\n\nimport { ValidationError } from '../../../errors/index.js'\nimport { deepCopyObjectSimple } from '../../../utilities/deepCopyObject.js'\nimport { traverseFields } from './traverseFields.js'\nexport type Args<T extends JsonObject> = {\n  collection: null | SanitizedCollectionConfig\n  context: RequestContext\n  data: T\n  doc: T\n  docWithLocales: JsonObject\n  global: null | SanitizedGlobalConfig\n  id?: number | string\n  operation: Operation\n  req: PayloadRequest\n  skipValidation?: boolean\n}\n\n/**\n * This function is responsible for the following actions, in order:\n * - Run condition\n * - Execute field hooks\n * - Validate data\n * - Transform data for storage\n * - Unflatten locales. The input `data` is the normal document for one locale. The output result will become the document with locales.\n */\nexport const beforeChange = async <T extends JsonObject>({\n  id,\n  collection,\n  context,\n  data: incomingData,\n  doc,\n  docWithLocales,\n  global,\n  operation,\n  req,\n  skipValidation,\n}: Args<T>): Promise<T> => {\n  const data = deepCopyObjectSimple(incomingData)\n  const mergeLocaleActions = []\n  const errors: { field: string; message: string }[] = []\n\n  await traverseFields({\n    id,\n    collection,\n    context,\n    data,\n    doc,\n    docWithLocales,\n    errors,\n    fields: collection?.fields || global?.fields,\n    global,\n    mergeLocaleActions,\n    operation,\n    path: [],\n    req,\n    schemaPath: [],\n    siblingData: data,\n    siblingDoc: doc,\n    siblingDocWithLocales: docWithLocales,\n    skipValidation,\n  })\n\n  if (errors.length > 0) {\n    throw new ValidationError(\n      {\n        id,\n        collection: collection?.slug,\n        errors,\n        global: global?.slug,\n      },\n      req.t,\n    )\n  }\n\n  await mergeLocaleActions.reduce(async (priorAction, action) => {\n    await priorAction\n    await action()\n  }, Promise.resolve())\n\n  return data\n}\n"],"names":["ValidationError","deepCopyObjectSimple","traverseFields","beforeChange","id","collection","context","data","incomingData","doc","docWithLocales","global","operation","req","skipValidation","mergeLocaleActions","errors","fields","path","schemaPath","siblingData","siblingDoc","siblingDocWithLocales","length","slug","t","reduce","priorAction","action","Promise","resolve"],"mappings":";;;AAKA,SAASC,oBAAoB,QAAQ,uCAAsC;AAC3E,SAASC,cAAc,QAAQ,sBAAqB;AAFpD,SAASF,eAAe,QAAQ,2BAA0B;;;;AAwBnD,MAAMG,eAAe,OAA6B,EACvDC,EAAE,EACFC,UAAU,EACVC,OAAO,EACPC,MAAMC,YAAY,EAClBC,GAAG,EACHC,cAAc,EACdC,MAAM,EACNC,SAAS,EACTC,GAAG,EACHC,cAAc,EACN;IACR,MAAMP,0KAAON,uBAAAA,EAAqBO;IAClC,MAAMO,qBAAqB,EAAE;IAC7B,MAAMC,SAA+C,EAAE;IAEvD,+LAAMd,iBAAAA,EAAe;QACnBE;QACAC;QACAC;QACAC;QACAE;QACAC;QACAM;QACAC,QAAQZ,YAAYY,UAAUN,QAAQM;QACtCN;QACAI;QACAH;QACAM,MAAM,EAAE;QACRL;QACAM,YAAY,EAAE;QACdC,aAAab;QACbc,YAAYZ;QACZa,uBAAuBZ;QACvBI;IACF;IAEA,IAAIE,OAAOO,MAAM,GAAG,GAAG;QACrB,MAAM,iKAAIvB,kBAAAA,CACR;YACEI;YACAC,YAAYA,YAAYmB;YACxBR;YACAL,QAAQA,QAAQa;QAClB,GACAX,IAAIY,CAAC;IAET;IAEA,MAAMV,mBAAmBW,MAAM,CAAC,OAAOC,aAAaC;QAClD,MAAMD;QACN,MAAMC;IACR,GAAGC,QAAQC,OAAO;IAElB,OAAOvB;AACT,EAAC"}},
    {"offset": {"line": 7316, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 7322, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/payload/src/uploads/saveBufferToFile.ts"],"sourcesContent":["import fs from 'fs'\nimport { Readable } from 'stream'\n\n/**\n * Save buffer data to a file.\n * @param {Buffer} buffer - buffer to save to a file.\n * @param {string} filePath - path to a file.\n */\nconst saveBufferToFile = async (buffer: Buffer, filePath: string): Promise<void> => {\n  // Setup readable stream from buffer.\n  let streamData = buffer\n  const readStream = new Readable()\n  readStream._read = () => {\n    readStream.push(streamData)\n    streamData = null\n  }\n  // Setup file system writable stream.\n  return fs.writeFileSync(filePath, buffer)\n}\n\nexport default saveBufferToFile\n"],"names":["fs","Readable","saveBufferToFile","buffer","filePath","streamData","readStream","_read","push","writeFileSync"],"mappings":";;;AAAA,OAAOA,QAAQ,KAAI;AACnB,SAASC,QAAQ,QAAQ,SAAQ;;;AAEjC;;;;CAIC,GACD,MAAMC,mBAAmB,OAAOC,QAAgBC;IAC9C,qCAAqC;IACrC,IAAIC,aAAaF;IACjB,MAAMG,aAAa,oGAAIL,WAAAA;IACvBK,WAAWC,KAAK,GAAG;QACjBD,WAAWE,IAAI,CAACH;QAChBA,aAAa;IACf;IACA,qCAAqC;IACrC,mGAAOL,UAAAA,CAAGS,aAAa,CAACL,UAAUD;AACpC;uCAEeD,iBAAgB"}},
    {"offset": {"line": 7346, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 7352, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/payload/src/uploads/uploadFiles.ts"],"sourcesContent":["import type { Payload } from '../index.js'\nimport type { PayloadRequest } from '../types/index.js'\nimport type { FileToSave } from './types.js'\n\nimport { FileUploadError } from '../errors/index.js'\nimport saveBufferToFile from './saveBufferToFile.js'\n\nexport const uploadFiles = async (\n  payload: Payload,\n  files: FileToSave[],\n  req: PayloadRequest,\n): Promise<void> => {\n  try {\n    await Promise.all(\n      files.map(async ({ buffer, path }) => {\n        await saveBufferToFile(buffer, path)\n      }),\n    )\n  } catch (err) {\n    payload.logger.error(err)\n    throw new FileUploadError(req.t)\n  }\n}\n"],"names":["FileUploadError","saveBufferToFile","uploadFiles","payload","files","req","Promise","all","map","buffer","path","err","logger","error","t"],"mappings":";;;AAKA,OAAOC,sBAAsB,wBAAuB;AADpD,SAASD,eAAe,QAAQ,qBAAoB;;;AAG7C,MAAME,cAAc,OACzBC,SACAC,OACAC;IAEA,IAAI;QACF,MAAMC,QAAQC,GAAG,CACfH,MAAMI,GAAG,CAAC,OAAO,EAAEC,MAAM,EAAEC,IAAI,EAAE;YAC/B,yKAAMT,UAAAA,EAAiBQ,QAAQC;QACjC;IAEJ,EAAE,OAAOC,KAAK;QACZR,QAAQS,MAAM,CAACC,KAAK,CAACF;QACrB,MAAM,iKAAIX,kBAAAA,CAAgBK,IAAIS,CAAC;IACjC;AACF,EAAC"}},
    {"offset": {"line": 7369, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 7375, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/payload/src/auth/strategies/local/register.ts"],"sourcesContent":["import type { SanitizedCollectionConfig } from '../../../collections/config/types.js'\nimport type { JsonObject, Payload } from '../../../index.js'\nimport type { PayloadRequest, Where } from '../../../types/index.js'\n\nimport { ValidationError } from '../../../errors/index.js'\nimport { generatePasswordSaltHash } from './generatePasswordSaltHash.js'\n\ntype Args = {\n  collection: SanitizedCollectionConfig\n  doc: JsonObject\n  password: string\n  payload: Payload\n  req: PayloadRequest\n}\n\nexport const registerLocalStrategy = async ({\n  collection,\n  doc,\n  password,\n  payload,\n  req,\n}: Args): Promise<Record<string, unknown>> => {\n  const loginWithUsername = collection?.auth?.loginWithUsername\n\n  let whereConstraint: Where\n\n  if (!loginWithUsername) {\n    whereConstraint = {\n      email: {\n        equals: doc.email,\n      },\n    }\n  } else {\n    whereConstraint = {\n      or: [],\n    }\n\n    if (doc.email) {\n      whereConstraint.or.push({\n        email: {\n          equals: doc.email,\n        },\n      })\n    }\n\n    if (doc.username) {\n      whereConstraint.or.push({\n        username: {\n          equals: doc.username,\n        },\n      })\n    }\n  }\n\n  const existingUser = await payload.find({\n    collection: collection.slug,\n    depth: 0,\n    limit: 1,\n    pagination: false,\n    req,\n    where: whereConstraint,\n  })\n\n  if (existingUser.docs.length > 0) {\n    throw new ValidationError({\n      collection: collection.slug,\n      errors: [\n        loginWithUsername\n          ? {\n              field: 'username',\n              message: req.t('error:usernameAlreadyRegistered'),\n            }\n          : { field: 'email', message: req.t('error:userEmailAlreadyRegistered') },\n      ],\n    })\n  }\n\n  const { hash, salt } = await generatePasswordSaltHash({ collection, password, req })\n\n  const sanitizedDoc = { ...doc }\n  if (sanitizedDoc.password) {\n    delete sanitizedDoc.password\n  }\n\n  return payload.db.create({\n    collection: collection.slug,\n    data: {\n      ...sanitizedDoc,\n      hash,\n      salt,\n    },\n    req,\n  })\n}\n"],"names":["ValidationError","generatePasswordSaltHash","registerLocalStrategy","collection","doc","password","payload","req","loginWithUsername","auth","whereConstraint","email","equals","or","push","username","existingUser","find","slug","depth","limit","pagination","where","docs","length","errors","field","message","t","hash","salt","sanitizedDoc","db","create","data"],"mappings":";;;AAIA,SAASA,eAAe,QAAQ,2BAA0B;AAC1D,SAASC,wBAAwB,QAAQ,gCAA+B;;;AAUjE,MAAMC,wBAAwB,OAAO,EAC1CC,UAAU,EACVC,GAAG,EACHC,QAAQ,EACRC,OAAO,EACPC,GAAG,EACE;IACL,MAAMC,oBAAoBL,YAAYM,MAAMD;IAE5C,IAAIE;IAEJ,IAAI,CAACF,mBAAmB;QACtBE,kBAAkB;YAChBC,OAAO;gBACLC,QAAQR,IAAIO,KAAK;YACnB;QACF;IACF,OAAO;QACLD,kBAAkB;YAChBG,IAAI,EAAE;QACR;QAEA,IAAIT,IAAIO,KAAK,EAAE;YACbD,gBAAgBG,EAAE,CAACC,IAAI,CAAC;gBACtBH,OAAO;oBACLC,QAAQR,IAAIO,KAAK;gBACnB;YACF;QACF;QAEA,IAAIP,IAAIW,QAAQ,EAAE;YAChBL,gBAAgBG,EAAE,CAACC,IAAI,CAAC;gBACtBC,UAAU;oBACRH,QAAQR,IAAIW,QAAQ;gBACtB;YACF;QACF;IACF;IAEA,MAAMC,eAAe,MAAMV,QAAQW,IAAI,CAAC;QACtCd,YAAYA,WAAWe,IAAI;QAC3BC,OAAO;QACPC,OAAO;QACPC,YAAY;QACZd;QACAe,OAAOZ;IACT;IAEA,IAAIM,aAAaO,IAAI,CAACC,MAAM,GAAG,GAAG;QAChC,MAAM,IAAIxB,+KAAAA,CAAgB;YACxBG,YAAYA,WAAWe,IAAI;YAC3BO,QAAQ;gBACNjB,oBACI;oBACEkB,OAAO;oBACPC,SAASpB,IAAIqB,CAAC,CAAC;gBACjB,IACA;oBAAEF,OAAO;oBAASC,SAASpB,IAAIqB,CAAC,CAAC;gBAAoC;aAC1E;QACH;IACF;IAEA,MAAM,EAAEC,IAAI,EAAEC,IAAI,EAAE,GAAG,qMAAM7B,2BAAAA,EAAyB;QAAEE;QAAYE;QAAUE;IAAI;IAElF,MAAMwB,eAAe;QAAE,GAAG3B,GAAG;IAAC;IAC9B,IAAI2B,aAAa1B,QAAQ,EAAE;QACzB,OAAO0B,aAAa1B,QAAQ;IAC9B;IAEA,OAAOC,QAAQ0B,EAAE,CAACC,MAAM,CAAC;QACvB9B,YAAYA,WAAWe,IAAI;QAC3BgB,MAAM;YACJ,GAAGH,YAAY;YACfF;YACAC;QACF;QACAvB;IACF;AACF,EAAC"}},
    {"offset": {"line": 7453, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 7459, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/payload/src/versions/enforceMaxVersions.ts"],"sourcesContent":["import type { SanitizedCollectionConfig } from '../collections/config/types.js'\nimport type { SanitizedGlobalConfig } from '../globals/config/types.js'\nimport type { Payload, PayloadRequest, Where } from '../types/index.js'\n\ntype Args = {\n  collection?: SanitizedCollectionConfig\n  global?: SanitizedGlobalConfig\n  id?: number | string\n  max: number\n  payload: Payload\n  req?: PayloadRequest\n}\n\nexport const enforceMaxVersions = async ({\n  id,\n  collection,\n  global,\n  max,\n  payload,\n  req,\n}: Args): Promise<void> => {\n  const entityType = collection ? 'collection' : 'global'\n  const slug = collection ? collection.slug : global?.slug\n\n  try {\n    const where: Where = {}\n    let oldestAllowedDoc\n\n    if (collection) {\n      where.parent = {\n        equals: id,\n      }\n\n      const query = await payload.db.findVersions({\n        collection: collection.slug,\n        limit: 1,\n        pagination: false,\n        req,\n        skip: max,\n        sort: '-updatedAt',\n        where,\n      })\n\n      ;[oldestAllowedDoc] = query.docs\n    } else if (global) {\n      const query = await payload.db.findGlobalVersions({\n        global: global.slug,\n        limit: 1,\n        pagination: false,\n        req,\n        skip: max,\n        sort: '-updatedAt',\n        where,\n      })\n\n      ;[oldestAllowedDoc] = query.docs\n    }\n\n    if (oldestAllowedDoc?.updatedAt) {\n      const deleteQuery: Where = {\n        updatedAt: {\n          less_than_equal: oldestAllowedDoc.updatedAt,\n        },\n      }\n\n      if (collection) {\n        deleteQuery.parent = {\n          equals: id,\n        }\n      }\n\n      await payload.db.deleteVersions({\n        collection: slug,\n        req,\n        where: deleteQuery,\n      })\n    }\n  } catch (err) {\n    payload.logger.error(\n      `There was an error cleaning up old versions for the ${entityType} ${slug}`,\n    )\n  }\n}\n"],"names":["enforceMaxVersions","id","collection","global","max","payload","req","entityType","slug","where","oldestAllowedDoc","parent","equals","query","db","findVersions","limit","pagination","skip","sort","docs","findGlobalVersions","updatedAt","deleteQuery","less_than_equal","deleteVersions","err","logger","error"],"mappings":";;;AAaO,MAAMA,qBAAqB,OAAO,EACvCC,EAAE,EACFC,UAAU,EACVC,MAAM,EACNC,GAAG,EACHC,OAAO,EACPC,GAAG,EACE;IACL,MAAMC,aAAaL,aAAa,eAAe;IAC/C,MAAMM,OAAON,aAAaA,WAAWM,IAAI,GAAGL,QAAQK;IAEpD,IAAI;QACF,MAAMC,QAAe,CAAC;QACtB,IAAIC;QAEJ,IAAIR,YAAY;YACdO,MAAME,MAAM,GAAG;gBACbC,QAAQX;YACV;YAEA,MAAMY,QAAQ,MAAMR,QAAQS,EAAE,CAACC,YAAY,CAAC;gBAC1Cb,YAAYA,WAAWM,IAAI;gBAC3BQ,OAAO;gBACPC,YAAY;gBACZX;gBACAY,MAAMd;gBACNe,MAAM;gBACNV;YACF;YAEC,CAACC,iBAAiB,GAAGG,MAAMO,IAAI;QAClC,OAAO,IAAIjB,QAAQ;YACjB,MAAMU,QAAQ,MAAMR,QAAQS,EAAE,CAACO,kBAAkB,CAAC;gBAChDlB,QAAQA,OAAOK,IAAI;gBACnBQ,OAAO;gBACPC,YAAY;gBACZX;gBACAY,MAAMd;gBACNe,MAAM;gBACNV;YACF;YAEC,CAACC,iBAAiB,GAAGG,MAAMO,IAAI;QAClC;QAEA,IAAIV,kBAAkBY,WAAW;YAC/B,MAAMC,cAAqB;gBACzBD,WAAW;oBACTE,iBAAiBd,iBAAiBY,SAAS;gBAC7C;YACF;YAEA,IAAIpB,YAAY;gBACdqB,YAAYZ,MAAM,GAAG;oBACnBC,QAAQX;gBACV;YACF;YAEA,MAAMI,QAAQS,EAAE,CAACW,cAAc,CAAC;gBAC9BvB,YAAYM;gBACZF;gBACAG,OAAOc;YACT;QACF;IACF,EAAE,OAAOG,KAAK;QACZrB,QAAQsB,MAAM,CAACC,KAAK,CAClB,CAAC,oDAAoD,EAAErB,WAAW,CAAC,EAAEC,KAAK,CAAC;IAE/E;AACF,EAAC"}},
    {"offset": {"line": 7515, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 7521, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/payload/src/versions/saveVersion.ts"],"sourcesContent":["import type { SanitizedCollectionConfig, TypeWithID } from '../collections/config/types.js'\nimport type { SanitizedGlobalConfig } from '../globals/config/types.js'\nimport type { Payload } from '../index.js'\nimport type { PayloadRequest } from '../types/index.js'\n\nimport { deepCopyObjectSimple } from '../index.js'\nimport sanitizeInternalFields from '../utilities/sanitizeInternalFields.js'\nimport { enforceMaxVersions } from './enforceMaxVersions.js'\n\ntype Args = {\n  autosave?: boolean\n  collection?: SanitizedCollectionConfig\n  docWithLocales: any\n  draft?: boolean\n  global?: SanitizedGlobalConfig\n  id?: number | string\n  payload: Payload\n  publishSpecificLocale?: string\n  req?: PayloadRequest\n  snapshot?: any\n}\n\nexport const saveVersion = async ({\n  id,\n  autosave,\n  collection,\n  docWithLocales: doc,\n  draft,\n  global,\n  payload,\n  publishSpecificLocale,\n  req,\n  snapshot,\n}: Args): Promise<TypeWithID> => {\n  let result\n  let createNewVersion = true\n  const now = new Date().toISOString()\n  const versionData = deepCopyObjectSimple(doc)\n  if (draft) {\n    versionData._status = 'draft'\n  }\n  if (versionData._id) {\n    delete versionData._id\n  }\n\n  try {\n    if (autosave) {\n      let docs\n      const findVersionArgs = {\n        limit: 1,\n        pagination: false,\n        req,\n        sort: '-updatedAt',\n      }\n      if (collection) {\n        ;({ docs } = await payload.db.findVersions({\n          ...findVersionArgs,\n          collection: collection.slug,\n          limit: 1,\n          pagination: false,\n          req,\n          where: {\n            parent: {\n              equals: id,\n            },\n          },\n        }))\n      } else {\n        ;({ docs } = await payload.db.findGlobalVersions({\n          ...findVersionArgs,\n          global: global.slug,\n          limit: 1,\n          pagination: false,\n          req,\n        }))\n      }\n      const [latestVersion] = docs\n\n      // overwrite the latest version if it's set to autosave\n      if (latestVersion?.autosave === true) {\n        createNewVersion = false\n\n        const data: Record<string, unknown> = {\n          createdAt: new Date(latestVersion.createdAt).toISOString(),\n          updatedAt: now,\n          version: {\n            ...versionData,\n          },\n        }\n\n        const updateVersionArgs = {\n          id: latestVersion.id,\n          req,\n          versionData: data as TypeWithID,\n        }\n\n        if (collection) {\n          result = await payload.db.updateVersion({\n            ...updateVersionArgs,\n            collection: collection.slug,\n            req,\n          })\n        } else {\n          result = await payload.db.updateGlobalVersion({\n            ...updateVersionArgs,\n            global: global.slug,\n            req,\n          })\n        }\n      }\n    }\n\n    if (createNewVersion) {\n      const createVersionArgs = {\n        autosave: Boolean(autosave),\n        collectionSlug: undefined,\n        createdAt: now,\n        globalSlug: undefined,\n        parent: collection ? id : undefined,\n        publishedLocale: publishSpecificLocale || undefined,\n        req,\n        updatedAt: now,\n        versionData,\n      }\n\n      if (collection) {\n        createVersionArgs.collectionSlug = collection.slug\n        result = await payload.db.createVersion(createVersionArgs)\n      }\n\n      if (global) {\n        createVersionArgs.globalSlug = global.slug\n        result = await payload.db.createGlobalVersion(createVersionArgs)\n      }\n\n      if (publishSpecificLocale && snapshot) {\n        const snapshotData = deepCopyObjectSimple(snapshot)\n        if (snapshotData._id) {\n          delete snapshotData._id\n        }\n\n        snapshotData._status = 'draft'\n\n        const snapshotDate = new Date().toISOString()\n\n        const updatedArgs = {\n          ...createVersionArgs,\n          createdAt: snapshotDate,\n          snapshot: true,\n          updatedAt: snapshotDate,\n          versionData: snapshotData,\n        } as any\n\n        if (collection) {\n          await payload.db.createVersion(updatedArgs)\n        }\n        if (global) {\n          await payload.db.createGlobalVersion(updatedArgs)\n        }\n      }\n    }\n  } catch (err) {\n    let errorMessage: string\n\n    if (collection) {\n      errorMessage = `There was an error while saving a version for the ${collection.labels.singular} with ID ${id}.`\n    }\n    if (global) {\n      errorMessage = `There was an error while saving a version for the global ${global.label}.`\n    }\n    payload.logger.error(errorMessage)\n    payload.logger.error(err)\n    return\n  }\n\n  let max = 100\n\n  if (collection && typeof collection.versions.maxPerDoc === 'number') {\n    max = collection.versions.maxPerDoc\n  }\n  if (global && typeof global.versions.max === 'number') {\n    max = global.versions.max\n  }\n\n  if (createNewVersion && max > 0) {\n    await enforceMaxVersions({\n      id,\n      collection,\n      global,\n      max,\n      payload,\n      req,\n    })\n  }\n\n  let createdVersion = result.version\n\n  createdVersion = sanitizeInternalFields(createdVersion)\n  createdVersion.id = result.parent\n\n  return createdVersion\n}\n"],"names":["deepCopyObjectSimple","sanitizeInternalFields","enforceMaxVersions","saveVersion","id","autosave","collection","docWithLocales","doc","draft","global","payload","publishSpecificLocale","req","snapshot","result","createNewVersion","now","Date","toISOString","versionData","_status","_id","docs","findVersionArgs","limit","pagination","sort","db","findVersions","slug","where","parent","equals","findGlobalVersions","latestVersion","data","createdAt","updatedAt","version","updateVersionArgs","updateVersion","updateGlobalVersion","createVersionArgs","Boolean","collectionSlug","undefined","globalSlug","publishedLocale","createVersion","createGlobalVersion","snapshotData","snapshotDate","updatedArgs","err","errorMessage","labels","singular","label","logger","error","max","versions","maxPerDoc","createdVersion"],"mappings":"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"}},
    {"offset": {"line": 7679, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 7685, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/payload/src/auth/sendVerificationEmail.ts"],"sourcesContent":["import { URL } from 'url'\n\nimport type { Collection } from '../collections/config/types.js'\nimport type { SanitizedConfig } from '../config/types.js'\nimport type { InitializedEmailAdapter } from '../email/types.js'\nimport type { PayloadRequest } from '../types/index.js'\nimport type { User, VerifyConfig } from './types.js'\n\ntype Args = {\n  collection: Collection\n  config: SanitizedConfig\n  disableEmail: boolean\n  email: InitializedEmailAdapter\n  req: PayloadRequest\n  token: string\n  user: User\n}\n\nexport async function sendVerificationEmail(args: Args): Promise<void> {\n  // Verify token from e-mail\n  const {\n    collection: { config: collectionConfig },\n    config,\n    disableEmail,\n    email,\n    req,\n    token,\n    user,\n  } = args\n\n  if (!disableEmail) {\n    const protocol = new URL(req.url).protocol // includes the final :\n    const serverURL =\n      config.serverURL !== null && config.serverURL !== ''\n        ? config.serverURL\n        : `${protocol}//${req.headers.get('host')}`\n\n    const verificationURL = `${serverURL}${config.routes.admin}/${collectionConfig.slug}/verify/${token}`\n\n    let html = `${req.t('authentication:newAccountCreated', {\n      serverURL: config.serverURL,\n      verificationURL,\n    })}`\n\n    const verify = collectionConfig.auth.verify as VerifyConfig\n\n    // Allow config to override email content\n    if (typeof verify.generateEmailHTML === 'function') {\n      html = await verify.generateEmailHTML({\n        req,\n        token,\n        user,\n      })\n    }\n\n    let subject = req.t('authentication:verifyYourEmail')\n\n    // Allow config to override email subject\n    if (typeof verify.generateEmailSubject === 'function') {\n      subject = await verify.generateEmailSubject({\n        req,\n        token,\n        user,\n      })\n    }\n\n    await email.sendEmail({\n      from: `\"${email.defaultFromName}\" <${email.defaultFromAddress}>`,\n      html,\n      subject,\n      to: user.email,\n    })\n  }\n}\n"],"names":["URL","sendVerificationEmail","args","collection","config","collectionConfig","disableEmail","email","req","token","user","protocol","url","serverURL","headers","get","verificationURL","routes","admin","slug","html","t","verify","auth","generateEmailHTML","subject","generateEmailSubject","sendEmail","from","defaultFromName","defaultFromAddress","to"],"mappings":";;;AAAA,SAASA,GAAG,QAAQ,MAAK;;AAkBlB,eAAeC,sBAAsBC,IAAU;IACpD,2BAA2B;IAC3B,MAAM,EACJC,YAAY,EAAEC,QAAQC,gBAAgB,EAAE,EACxCD,MAAM,EACNE,YAAY,EACZC,KAAK,EACLC,GAAG,EACHC,KAAK,EACLC,IAAI,EACL,GAAGR;IAEJ,IAAI,CAACI,cAAc;QACjB,MAAMK,WAAW,iGAAIX,MAAAA,CAAIQ,IAAII,GAAG,EAAED,QAAQ,CAAC,uBAAuB;;QAClE,MAAME,YACJT,OAAOS,SAAS,KAAK,QAAQT,OAAOS,SAAS,KAAK,KAC9CT,OAAOS,SAAS,GAChB,CAAC,EAAEF,SAAS,EAAE,EAAEH,IAAIM,OAAO,CAACC,GAAG,CAAC,QAAQ,CAAC;QAE/C,MAAMC,kBAAkB,CAAC,EAAEH,UAAU,EAAET,OAAOa,MAAM,CAACC,KAAK,CAAC,CAAC,EAAEb,iBAAiBc,IAAI,CAAC,QAAQ,EAAEV,MAAM,CAAC;QAErG,IAAIW,OAAO,CAAC,EAAEZ,IAAIa,CAAC,CAAC,oCAAoC;YACtDR,WAAWT,OAAOS,SAAS;YAC3BG;QACF,GAAG,CAAC;QAEJ,MAAMM,SAASjB,iBAAiBkB,IAAI,CAACD,MAAM;QAE3C,yCAAyC;QACzC,IAAI,OAAOA,OAAOE,iBAAiB,KAAK,YAAY;YAClDJ,OAAO,MAAME,OAAOE,iBAAiB,CAAC;gBACpChB;gBACAC;gBACAC;YACF;QACF;QAEA,IAAIe,UAAUjB,IAAIa,CAAC,CAAC;QAEpB,yCAAyC;QACzC,IAAI,OAAOC,OAAOI,oBAAoB,KAAK,YAAY;YACrDD,UAAU,MAAMH,OAAOI,oBAAoB,CAAC;gBAC1ClB;gBACAC;gBACAC;YACF;QACF;QAEA,MAAMH,MAAMoB,SAAS,CAAC;YACpBC,MAAM,CAAC,CAAC,EAAErB,MAAMsB,eAAe,CAAC,GAAG,EAAEtB,MAAMuB,kBAAkB,CAAC,CAAC,CAAC;YAChEV;YACAK;YACAM,IAAIrB,KAAKH,KAAK;QAChB;IACF;AACF"}},
    {"offset": {"line": 7728, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 7734, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/payload/src/fields/hooks/afterChange/promise.ts"],"sourcesContent":["import type { RichTextAdapter } from '../../../admin/RichText.js'\nimport type { SanitizedCollectionConfig } from '../../../collections/config/types.js'\nimport type { SanitizedGlobalConfig } from '../../../globals/config/types.js'\nimport type { JsonObject, PayloadRequest, RequestContext } from '../../../types/index.js'\nimport type { Field, TabAsField } from '../../config/types.js'\n\nimport { MissingEditorProp } from '../../../errors/index.js'\nimport { fieldAffectsData, tabHasName } from '../../config/types.js'\nimport { getFieldPaths } from '../../getFieldPaths.js'\nimport { traverseFields } from './traverseFields.js'\n\ntype Args = {\n  collection: null | SanitizedCollectionConfig\n  context: RequestContext\n  data: JsonObject\n  doc: JsonObject\n  field: Field | TabAsField\n  global: null | SanitizedGlobalConfig\n  operation: 'create' | 'update'\n  /**\n   * The parent's path\n   */\n  parentPath: (number | string)[]\n  /**\n   * The parent's schemaPath (path without indexes).\n   */\n  parentSchemaPath: string[]\n  previousDoc: JsonObject\n  previousSiblingDoc: JsonObject\n  req: PayloadRequest\n  siblingData: JsonObject\n  siblingDoc: JsonObject\n}\n\n// This function is responsible for the following actions, in order:\n// - Execute field hooks\n\nexport const promise = async ({\n  collection,\n  context,\n  data,\n  doc,\n  field,\n  global,\n  operation,\n  parentPath,\n  parentSchemaPath,\n  previousDoc,\n  previousSiblingDoc,\n  req,\n  siblingData,\n  siblingDoc,\n}: Args): Promise<void> => {\n  const { path: fieldPath, schemaPath: fieldSchemaPath } = getFieldPaths({\n    field,\n    parentPath,\n    parentSchemaPath,\n  })\n\n  if (fieldAffectsData(field)) {\n    // Execute hooks\n    if (field.hooks?.afterChange) {\n      await field.hooks.afterChange.reduce(async (priorHook, currentHook) => {\n        await priorHook\n\n        const hookedValue = await currentHook({\n          collection,\n          context,\n          data,\n          field,\n          global,\n          operation,\n          originalDoc: doc,\n          path: fieldPath,\n          previousDoc,\n          previousSiblingDoc,\n          previousValue: previousDoc[field.name],\n          req,\n          schemaPath: fieldSchemaPath,\n          siblingData,\n          value: siblingDoc[field.name],\n        })\n\n        if (hookedValue !== undefined) {\n          siblingDoc[field.name] = hookedValue\n        }\n      }, Promise.resolve())\n    }\n  }\n\n  // Traverse subfields\n  switch (field.type) {\n    case 'group': {\n      await traverseFields({\n        collection,\n        context,\n        data,\n        doc,\n        fields: field.fields,\n        global,\n        operation,\n        path: fieldPath,\n        previousDoc,\n        previousSiblingDoc: previousDoc[field.name] as JsonObject,\n        req,\n        schemaPath: fieldSchemaPath,\n        siblingData: (siblingData?.[field.name] as JsonObject) || {},\n        siblingDoc: siblingDoc[field.name] as JsonObject,\n      })\n\n      break\n    }\n\n    case 'array': {\n      const rows = siblingDoc[field.name]\n\n      if (Array.isArray(rows)) {\n        const promises = []\n        rows.forEach((row, i) => {\n          promises.push(\n            traverseFields({\n              collection,\n              context,\n              data,\n              doc,\n              fields: field.fields,\n              global,\n              operation,\n              path: [...fieldPath, i],\n              previousDoc,\n              previousSiblingDoc: previousDoc?.[field.name]?.[i] || ({} as JsonObject),\n              req,\n              schemaPath: fieldSchemaPath,\n              siblingData: siblingData?.[field.name]?.[i] || {},\n              siblingDoc: row ? { ...row } : {},\n            }),\n          )\n        })\n        await Promise.all(promises)\n      }\n      break\n    }\n\n    case 'blocks': {\n      const rows = siblingDoc[field.name]\n\n      if (Array.isArray(rows)) {\n        const promises = []\n        rows.forEach((row, i) => {\n          const block = field.blocks.find(\n            (blockType) => blockType.slug === (row as JsonObject).blockType,\n          )\n\n          if (block) {\n            promises.push(\n              traverseFields({\n                collection,\n                context,\n                data,\n                doc,\n                fields: block.fields,\n                global,\n                operation,\n                path: [...fieldPath, i],\n                previousDoc,\n                previousSiblingDoc: previousDoc?.[field.name]?.[i] || ({} as JsonObject),\n                req,\n                schemaPath: fieldSchemaPath,\n                siblingData: siblingData?.[field.name]?.[i] || {},\n                siblingDoc: row ? { ...row } : {},\n              }),\n            )\n          }\n        })\n        await Promise.all(promises)\n      }\n\n      break\n    }\n\n    case 'row':\n    case 'collapsible': {\n      await traverseFields({\n        collection,\n        context,\n        data,\n        doc,\n        fields: field.fields,\n        global,\n        operation,\n        path: fieldPath,\n        previousDoc,\n        previousSiblingDoc: { ...previousSiblingDoc },\n        req,\n        schemaPath: fieldSchemaPath,\n        siblingData: siblingData || {},\n        siblingDoc: { ...siblingDoc },\n      })\n\n      break\n    }\n\n    case 'tab': {\n      let tabSiblingData = siblingData\n      let tabSiblingDoc = siblingDoc\n      let tabPreviousSiblingDoc = siblingDoc\n\n      if (tabHasName(field)) {\n        tabSiblingData = siblingData[field.name] as JsonObject\n        tabSiblingDoc = siblingDoc[field.name] as JsonObject\n        tabPreviousSiblingDoc = previousDoc[field.name] as JsonObject\n      }\n\n      await traverseFields({\n        collection,\n        context,\n        data,\n        doc,\n        fields: field.fields,\n        global,\n        operation,\n        path: fieldPath,\n        previousDoc,\n        previousSiblingDoc: tabPreviousSiblingDoc,\n        req,\n        schemaPath: fieldSchemaPath,\n        siblingData: tabSiblingData,\n        siblingDoc: tabSiblingDoc,\n      })\n\n      break\n    }\n\n    case 'tabs': {\n      await traverseFields({\n        collection,\n        context,\n        data,\n        doc,\n        fields: field.tabs.map((tab) => ({ ...tab, type: 'tab' })),\n        global,\n        operation,\n        path: fieldPath,\n        previousDoc,\n        previousSiblingDoc: { ...previousSiblingDoc },\n        req,\n        schemaPath: fieldSchemaPath,\n        siblingData: siblingData || {},\n        siblingDoc: { ...siblingDoc },\n      })\n      break\n    }\n\n    case 'richText': {\n      if (!field?.editor) {\n        throw new MissingEditorProp(field) // while we allow disabling editor functionality, you should not have any richText fields defined if you do not have an editor\n      }\n      if (typeof field?.editor === 'function') {\n        throw new Error('Attempted to access unsanitized rich text editor.')\n      }\n\n      const editor: RichTextAdapter = field?.editor\n\n      if (editor?.hooks?.afterChange?.length) {\n        await editor.hooks.afterChange.reduce(async (priorHook, currentHook) => {\n          await priorHook\n\n          const hookedValue = await currentHook({\n            collection,\n            context,\n            data,\n            field,\n            global,\n            operation,\n            originalDoc: doc,\n            path: fieldPath,\n            previousDoc,\n            previousSiblingDoc,\n            previousValue: previousDoc[field.name],\n            req,\n            schemaPath: fieldSchemaPath,\n            siblingData,\n            value: siblingDoc[field.name],\n          })\n\n          if (hookedValue !== undefined) {\n            siblingDoc[field.name] = hookedValue\n          }\n        }, Promise.resolve())\n      }\n      break\n    }\n\n    default: {\n      break\n    }\n  }\n}\n"],"names":["MissingEditorProp","fieldAffectsData","tabHasName","getFieldPaths","traverseFields","promise","collection","context","data","doc","field","global","operation","parentPath","parentSchemaPath","previousDoc","previousSiblingDoc","req","siblingData","siblingDoc","path","fieldPath","schemaPath","fieldSchemaPath","hooks","afterChange","reduce","priorHook","currentHook","hookedValue","originalDoc","previousValue","name","value","undefined","Promise","resolve","type","fields","rows","Array","isArray","promises","forEach","row","i","push","all","block","blocks","find","blockType","slug","tabSiblingData","tabSiblingDoc","tabPreviousSiblingDoc","tabs","map","tab","editor","Error","length"],"mappings":"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"}},
    {"offset": {"line": 7991, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 7997, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/payload/src/fields/hooks/afterChange/traverseFields.ts"],"sourcesContent":["import type { SanitizedCollectionConfig } from '../../../collections/config/types.js'\nimport type { SanitizedGlobalConfig } from '../../../globals/config/types.js'\nimport type { JsonObject, PayloadRequest, RequestContext } from '../../../types/index.js'\nimport type { Field, TabAsField } from '../../config/types.js'\n\nimport { promise } from './promise.js'\n\ntype Args = {\n  collection: null | SanitizedCollectionConfig\n  context: RequestContext\n  data: JsonObject\n  doc: JsonObject\n  fields: (Field | TabAsField)[]\n  global: null | SanitizedGlobalConfig\n  operation: 'create' | 'update'\n  path: (number | string)[]\n  previousDoc: JsonObject\n  previousSiblingDoc: JsonObject\n  req: PayloadRequest\n  schemaPath: string[]\n  siblingData: JsonObject\n  siblingDoc: JsonObject\n}\n\nexport const traverseFields = async ({\n  collection,\n  context,\n  data,\n  doc,\n  fields,\n  global,\n  operation,\n  path,\n  previousDoc,\n  previousSiblingDoc,\n  req,\n  schemaPath,\n  siblingData,\n  siblingDoc,\n}: Args): Promise<void> => {\n  const promises = []\n\n  fields.forEach((field) => {\n    promises.push(\n      promise({\n        collection,\n        context,\n        data,\n        doc,\n        field,\n        global,\n        operation,\n        parentPath: path,\n        parentSchemaPath: schemaPath,\n        previousDoc,\n        previousSiblingDoc,\n        req,\n        siblingData,\n        siblingDoc,\n      }),\n    )\n  })\n\n  await Promise.all(promises)\n}\n"],"names":["promise","traverseFields","collection","context","data","doc","fields","global","operation","path","previousDoc","previousSiblingDoc","req","schemaPath","siblingData","siblingDoc","promises","forEach","field","push","parentPath","parentSchemaPath","Promise","all"],"mappings":";;;AAKA,SAASA,OAAO,QAAQ,eAAc;;AAmB/B,MAAMC,iBAAiB,OAAO,EACnCC,UAAU,EACVC,OAAO,EACPC,IAAI,EACJC,GAAG,EACHC,MAAM,EACNC,MAAM,EACNC,SAAS,EACTC,IAAI,EACJC,WAAW,EACXC,kBAAkB,EAClBC,GAAG,EACHC,UAAU,EACVC,WAAW,EACXC,UAAU,EACL;IACL,MAAMC,WAAW,EAAE;IAEnBV,OAAOW,OAAO,CAAC,CAACC;QACdF,SAASG,IAAI,kLACXnB,UAAAA,EAAQ;YACNE;YACAC;YACAC;YACAC;YACAa;YACAX;YACAC;YACAY,YAAYX;YACZY,kBAAkBR;YAClBH;YACAC;YACAC;YACAE;YACAC;QACF;IAEJ;IAEA,MAAMO,QAAQC,GAAG,CAACP;AACpB,EAAC"}},
    {"offset": {"line": 8024, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 8030, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/payload/src/fields/hooks/afterChange/index.ts"],"sourcesContent":["import type { SanitizedCollectionConfig } from '../../../collections/config/types.js'\nimport type { SanitizedGlobalConfig } from '../../../globals/config/types.js'\nimport type { JsonObject, PayloadRequest, RequestContext } from '../../../types/index.js'\n\nimport { deepCopyObjectSimple } from '../../../utilities/deepCopyObject.js'\nimport { traverseFields } from './traverseFields.js'\n\ntype Args<T extends JsonObject> = {\n  collection: null | SanitizedCollectionConfig\n  context: RequestContext\n  /**\n   * The data before hooks\n   */\n  data: T\n  /**\n   * The data after hooks\n   */\n  doc: T\n  global: null | SanitizedGlobalConfig\n  operation: 'create' | 'update'\n  previousDoc: T\n  req: PayloadRequest\n}\n\n/**\n * This function is responsible for the following actions, in order:\n * - Execute field hooks\n */\nexport const afterChange = async <T extends JsonObject>({\n  collection,\n  context,\n  data,\n  doc: incomingDoc,\n  global,\n  operation,\n  previousDoc,\n  req,\n}: Args<T>): Promise<T> => {\n  const doc = deepCopyObjectSimple(incomingDoc)\n\n  await traverseFields({\n    collection,\n    context,\n    data,\n    doc,\n    fields: collection?.fields || global?.fields,\n    global,\n    operation,\n    path: [],\n    previousDoc,\n    previousSiblingDoc: previousDoc,\n    req,\n    schemaPath: [],\n    siblingData: data,\n    siblingDoc: doc,\n  })\n\n  return doc\n}\n"],"names":["deepCopyObjectSimple","traverseFields","afterChange","collection","context","data","doc","incomingDoc","global","operation","previousDoc","req","fields","path","previousSiblingDoc","schemaPath","siblingData","siblingDoc"],"mappings":";;;AAIA,SAASA,oBAAoB,QAAQ,uCAAsC;AAC3E,SAASC,cAAc,QAAQ,sBAAqB;;;AAuB7C,MAAMC,cAAc,OAA6B,EACtDC,UAAU,EACVC,OAAO,EACPC,IAAI,EACJC,KAAKC,WAAW,EAChBC,MAAM,EACNC,SAAS,EACTC,WAAW,EACXC,GAAG,EACK;IACR,MAAML,yKAAMN,uBAAAA,EAAqBO;IAEjC,8LAAMN,iBAAAA,EAAe;QACnBE;QACAC;QACAC;QACAC;QACAM,QAAQT,YAAYS,UAAUJ,QAAQI;QACtCJ;QACAC;QACAI,MAAM,EAAE;QACRH;QACAI,oBAAoBJ;QACpBC;QACAI,YAAY,EAAE;QACdC,aAAaX;QACbY,YAAYX;IACd;IAEA,OAAOA;AACT,EAAC"}},
    {"offset": {"line": 8057, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 8063, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/payload/src/utilities/mapAsync.ts"],"sourcesContent":["export async function mapAsync<T, U>(\n  arr: T[],\n  callbackfn: (item: T, index: number, array: T[]) => Promise<U>,\n): Promise<U[]> {\n  return Promise.all(arr.map(callbackfn))\n}\n"],"names":["mapAsync","arr","callbackfn","Promise","all","map"],"mappings":";;;AAAO,eAAeA,SACpBC,GAAQ,EACRC,UAA8D;IAE9D,OAAOC,QAAQC,GAAG,CAACH,IAAII,GAAG,CAACH;AAC7B"}},
    {"offset": {"line": 8069, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 8075, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/payload/src/uploads/unlinkTempFiles.ts"],"sourcesContent":["import fs from 'fs'\nimport { promisify } from 'util'\n\nimport type { SanitizedCollectionConfig } from '../collections/config/types.js'\nimport type { SanitizedConfig } from '../config/types.js'\nimport type { PayloadRequest } from '../types/index.js'\n\nimport { mapAsync } from '../utilities/mapAsync.js'\n\nconst unlinkFile = promisify(fs.unlink)\n\ntype Args = {\n  collectionConfig: SanitizedCollectionConfig\n  config: SanitizedConfig\n  req: PayloadRequest\n}\n/**\n * Cleanup temp files after operation lifecycle\n */\nexport const unlinkTempFiles: (args: Args) => Promise<void> = async ({\n  collectionConfig,\n  config,\n  req,\n}) => {\n  if (config.upload?.useTempFiles && collectionConfig.upload) {\n    const { file } = req\n    const fileArray = [{ file }]\n    await mapAsync(fileArray, async ({ file }) => {\n      // Still need this check because this will not be populated if using local API\n      if (file?.tempFilePath) {\n        await unlinkFile(file.tempFilePath)\n      }\n    })\n  }\n}\n"],"names":["fs","promisify","mapAsync","unlinkFile","unlink","unlinkTempFiles","collectionConfig","config","req","upload","useTempFiles","file","fileArray","tempFilePath"],"mappings":";;;AAAA,OAAOA,QAAQ,KAAI;AACnB,SAASC,SAAS,QAAQ,OAAM;AAMhC,SAASC,QAAQ,QAAQ,2BAA0B;;;;AAEnD,MAAMC,+GAAaF,YAAAA,8FAAUD,UAAAA,CAAGI,MAAM;AAU/B,MAAMC,kBAAiD,OAAO,EACnEC,gBAAgB,EAChBC,MAAM,EACNC,GAAG,EACJ;IACC,IAAID,OAAOE,MAAM,EAAEC,gBAAgBJ,iBAAiBG,MAAM,EAAE;QAC1D,MAAM,EAAEE,IAAI,EAAE,GAAGH;QACjB,MAAMI,YAAY;YAAC;gBAAED;YAAK;SAAE;QAC5B,mKAAMT,WAAAA,EAASU,WAAW,OAAO,EAAED,IAAI,EAAE;YACvC,8EAA8E;YAC9E,IAAIA,MAAME,cAAc;gBACtB,MAAMV,WAAWQ,KAAKE,YAAY;YACpC;QACF;IACF;AACF,EAAC"}},
    {"offset": {"line": 8101, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 8107, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/payload/src/collections/operations/create.ts"],"sourcesContent":["import crypto from 'crypto'\n\nimport type { CollectionSlug, JsonObject } from '../../index.js'\nimport type { Document, PayloadRequest } from '../../types/index.js'\nimport type {\n  AfterChangeHook,\n  BeforeOperationHook,\n  BeforeValidateHook,\n  Collection,\n  DataFromCollectionSlug,\n  RequiredDataFromCollectionSlug,\n} from '../config/types.js'\n\nimport { ensureUsernameOrEmail } from '../../auth/ensureUsernameOrEmail.js'\nimport executeAccess from '../../auth/executeAccess.js'\nimport { sendVerificationEmail } from '../../auth/sendVerificationEmail.js'\nimport { registerLocalStrategy } from '../../auth/strategies/local/register.js'\nimport { afterChange } from '../../fields/hooks/afterChange/index.js'\nimport { afterRead } from '../../fields/hooks/afterRead/index.js'\nimport { beforeChange } from '../../fields/hooks/beforeChange/index.js'\nimport { beforeValidate } from '../../fields/hooks/beforeValidate/index.js'\nimport { generateFileData } from '../../uploads/generateFileData.js'\nimport { unlinkTempFiles } from '../../uploads/unlinkTempFiles.js'\nimport { uploadFiles } from '../../uploads/uploadFiles.js'\nimport { commitTransaction } from '../../utilities/commitTransaction.js'\nimport { initTransaction } from '../../utilities/initTransaction.js'\nimport { killTransaction } from '../../utilities/killTransaction.js'\nimport sanitizeInternalFields from '../../utilities/sanitizeInternalFields.js'\nimport { saveVersion } from '../../versions/saveVersion.js'\nimport { buildAfterOperation } from './utils.js'\n\nexport type Arguments<TSlug extends CollectionSlug> = {\n  autosave?: boolean\n  collection: Collection\n  data: RequiredDataFromCollectionSlug<TSlug>\n  depth?: number\n  disableTransaction?: boolean\n  disableVerificationEmail?: boolean\n  draft?: boolean\n  overrideAccess?: boolean\n  overwriteExistingFiles?: boolean\n  req: PayloadRequest\n  showHiddenFields?: boolean\n}\n\nexport const createOperation = async <TSlug extends CollectionSlug>(\n  incomingArgs: Arguments<TSlug>,\n): Promise<DataFromCollectionSlug<TSlug>> => {\n  let args = incomingArgs\n\n  try {\n    const shouldCommit = !args.disableTransaction && (await initTransaction(args.req))\n\n    ensureUsernameOrEmail<TSlug>({\n      authOptions: args.collection.config.auth,\n      collectionSlug: args.collection.config.slug,\n      data: args.data,\n      operation: 'create',\n      req: args.req,\n    })\n\n    // /////////////////////////////////////\n    // beforeOperation - Collection\n    // /////////////////////////////////////\n\n    await args.collection.config.hooks.beforeOperation.reduce(\n      async (priorHook: BeforeOperationHook | Promise<void>, hook: BeforeOperationHook) => {\n        await priorHook\n\n        args =\n          (await hook({\n            args,\n            collection: args.collection.config,\n            context: args.req.context,\n            operation: 'create',\n            req: args.req,\n          })) || args\n      },\n      Promise.resolve(),\n    )\n\n    const {\n      autosave = false,\n      collection: { config: collectionConfig },\n      collection,\n      depth,\n      disableVerificationEmail,\n      draft = false,\n      overrideAccess,\n      overwriteExistingFiles = false,\n      req: {\n        fallbackLocale,\n        locale,\n        payload,\n        payload: { config, email },\n      },\n      req,\n      showHiddenFields,\n    } = args\n\n    let { data } = args\n\n    const shouldSaveDraft = Boolean(draft && collectionConfig.versions.drafts)\n\n    // /////////////////////////////////////\n    // Access\n    // /////////////////////////////////////\n\n    if (!overrideAccess) {\n      await executeAccess({ data, req }, collectionConfig.access.create)\n    }\n\n    // /////////////////////////////////////\n    // Custom id\n    // /////////////////////////////////////\n\n    if (payload.collections[collectionConfig.slug].customIDType) {\n      data = {\n        _id: data.id,\n        ...data,\n      }\n    }\n\n    // /////////////////////////////////////\n    // Generate data for all files and sizes\n    // /////////////////////////////////////\n\n    const { data: newFileData, files: filesToUpload } = await generateFileData({\n      collection,\n      config,\n      data,\n      operation: 'create',\n      overwriteExistingFiles,\n      req,\n      throwOnMissingFile:\n        !shouldSaveDraft && collection.config.upload.filesRequiredOnCreate !== false,\n    })\n\n    data = newFileData\n\n    // /////////////////////////////////////\n    // beforeValidate - Fields\n    // /////////////////////////////////////\n\n    data = await beforeValidate({\n      collection: collectionConfig,\n      context: req.context,\n      data,\n      doc: {},\n      global: null,\n      operation: 'create',\n      overrideAccess,\n      req,\n    })\n\n    // /////////////////////////////////////\n    // beforeValidate - Collections\n    // /////////////////////////////////////\n\n    await collectionConfig.hooks.beforeValidate.reduce(\n      async (priorHook: BeforeValidateHook | Promise<void>, hook: BeforeValidateHook) => {\n        await priorHook\n\n        data =\n          (await hook({\n            collection: collectionConfig,\n            context: req.context,\n            data,\n            operation: 'create',\n            req,\n          })) || data\n      },\n      Promise.resolve(),\n    )\n\n    // /////////////////////////////////////\n    // beforeChange - Collection\n    // /////////////////////////////////////\n\n    await collectionConfig.hooks.beforeChange.reduce(async (priorHook, hook) => {\n      await priorHook\n\n      data =\n        (await hook({\n          collection: collectionConfig,\n          context: req.context,\n          data,\n          operation: 'create',\n          req,\n        })) || data\n    }, Promise.resolve())\n\n    // /////////////////////////////////////\n    // beforeChange - Fields\n    // /////////////////////////////////////\n\n    const resultWithLocales = await beforeChange<JsonObject>({\n      collection: collectionConfig,\n      context: req.context,\n      data,\n      doc: {},\n      docWithLocales: {},\n      global: null,\n      operation: 'create',\n      req,\n      skipValidation:\n        shouldSaveDraft &&\n        collectionConfig.versions.drafts &&\n        !collectionConfig.versions.drafts.validate,\n    })\n\n    // /////////////////////////////////////\n    // Write files to local storage\n    // /////////////////////////////////////\n\n    if (!collectionConfig.upload.disableLocalStorage) {\n      await uploadFiles(payload, filesToUpload, req)\n    }\n\n    // /////////////////////////////////////\n    // Create\n    // /////////////////////////////////////\n\n    let doc\n\n    if (collectionConfig.auth && !collectionConfig.auth.disableLocalStrategy) {\n      if (collectionConfig.auth.verify) {\n        resultWithLocales._verified = Boolean(resultWithLocales._verified) || false\n        resultWithLocales._verificationToken = crypto.randomBytes(20).toString('hex')\n      }\n\n      doc = await registerLocalStrategy({\n        collection: collectionConfig,\n        doc: resultWithLocales,\n        password: data.password as string,\n        payload: req.payload,\n        req,\n      })\n    } else {\n      doc = await payload.db.create({\n        collection: collectionConfig.slug,\n        data: resultWithLocales,\n        req,\n      })\n    }\n\n    const verificationToken = doc._verificationToken\n    let result: Document = sanitizeInternalFields(doc)\n\n    // /////////////////////////////////////\n    // Create version\n    // /////////////////////////////////////\n\n    if (collectionConfig.versions) {\n      await saveVersion({\n        id: result.id,\n        autosave,\n        collection: collectionConfig,\n        docWithLocales: result,\n        payload,\n        req,\n      })\n    }\n\n    // /////////////////////////////////////\n    // Send verification email if applicable\n    // /////////////////////////////////////\n\n    if (collectionConfig.auth && collectionConfig.auth.verify && result.email) {\n      await sendVerificationEmail({\n        collection: { config: collectionConfig },\n        config: payload.config,\n        disableEmail: disableVerificationEmail,\n        email: payload.email,\n        req,\n        token: verificationToken,\n        user: result,\n      })\n    }\n\n    // /////////////////////////////////////\n    // afterRead - Fields\n    // /////////////////////////////////////\n\n    result = await afterRead({\n      collection: collectionConfig,\n      context: req.context,\n      depth,\n      doc: result,\n      draft,\n      fallbackLocale,\n      global: null,\n      locale,\n      overrideAccess,\n      req,\n      showHiddenFields,\n    })\n\n    // /////////////////////////////////////\n    // afterRead - Collection\n    // /////////////////////////////////////\n\n    await collectionConfig.hooks.afterRead.reduce(async (priorHook, hook) => {\n      await priorHook\n\n      result =\n        (await hook({\n          collection: collectionConfig,\n          context: req.context,\n          doc: result,\n          req,\n        })) || result\n    }, Promise.resolve())\n\n    // /////////////////////////////////////\n    // afterChange - Fields\n    // /////////////////////////////////////\n\n    result = await afterChange({\n      collection: collectionConfig,\n      context: req.context,\n      data,\n      doc: result,\n      global: null,\n      operation: 'create',\n      previousDoc: {},\n      req,\n    })\n\n    // /////////////////////////////////////\n    // afterChange - Collection\n    // /////////////////////////////////////\n\n    await collectionConfig.hooks.afterChange.reduce(\n      async (priorHook: AfterChangeHook | Promise<void>, hook: AfterChangeHook) => {\n        await priorHook\n\n        result =\n          (await hook({\n            collection: collectionConfig,\n            context: req.context,\n            doc: result,\n            operation: 'create',\n            previousDoc: {},\n            req: args.req,\n          })) || result\n      },\n      Promise.resolve(),\n    )\n\n    // /////////////////////////////////////\n    // afterOperation - Collection\n    // /////////////////////////////////////\n\n    result = await buildAfterOperation<TSlug>({\n      args,\n      collection: collectionConfig,\n      operation: 'create',\n      result,\n    })\n\n    await unlinkTempFiles({ collectionConfig, config, req })\n\n    // /////////////////////////////////////\n    // Return results\n    // /////////////////////////////////////\n\n    if (shouldCommit) {\n      await commitTransaction(req)\n    }\n\n    return result\n  } catch (error: unknown) {\n    await killTransaction(args.req)\n    throw error\n  }\n}\n"],"names":["crypto","ensureUsernameOrEmail","executeAccess","sendVerificationEmail","registerLocalStrategy","afterChange","afterRead","beforeChange","beforeValidate","generateFileData","unlinkTempFiles","uploadFiles","commitTransaction","initTransaction","killTransaction","sanitizeInternalFields","saveVersion","buildAfterOperation","createOperation","incomingArgs","args","shouldCommit","disableTransaction","req","authOptions","collection","config","auth","collectionSlug","slug","data","operation","hooks","beforeOperation","reduce","priorHook","hook","context","Promise","resolve","autosave","collectionConfig","depth","disableVerificationEmail","draft","overrideAccess","overwriteExistingFiles","fallbackLocale","locale","payload","email","showHiddenFields","shouldSaveDraft","Boolean","versions","drafts","access","create","collections","customIDType","_id","id","newFileData","files","filesToUpload","throwOnMissingFile","upload","filesRequiredOnCreate","doc","global","resultWithLocales","docWithLocales","skipValidation","validate","disableLocalStorage","disableLocalStrategy","verify","_verified","_verificationToken","randomBytes","toString","password","db","verificationToken","result","disableEmail","token","user","previousDoc","error"],"mappings":"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"}},
    {"offset": {"line": 8398, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 8404, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/payload/src/collections/operations/local/create.ts"],"sourcesContent":["import type { CollectionSlug, Payload, TypedLocale } from '../../../index.js'\nimport type { Document, PayloadRequest, RequestContext } from '../../../types/index.js'\nimport type { File } from '../../../uploads/types.js'\nimport type { DataFromCollectionSlug, RequiredDataFromCollectionSlug } from '../../config/types.js'\n\nimport { APIError } from '../../../errors/index.js'\nimport { getFileByPath } from '../../../uploads/getFileByPath.js'\nimport { createLocalReq } from '../../../utilities/createLocalReq.js'\nimport { createOperation } from '../create.js'\n\nexport type Options<TSlug extends CollectionSlug> = {\n  collection: TSlug\n  /**\n   * context, which will then be passed to req.context, which can be read by hooks\n   */\n  context?: RequestContext\n  data: RequiredDataFromCollectionSlug<TSlug>\n  depth?: number\n  disableTransaction?: boolean\n  disableVerificationEmail?: boolean\n  draft?: boolean\n  fallbackLocale?: TypedLocale\n  file?: File\n  filePath?: string\n  locale?: TypedLocale\n  overrideAccess?: boolean\n  overwriteExistingFiles?: boolean\n  req?: PayloadRequest\n  showHiddenFields?: boolean\n  user?: Document\n}\n\n// eslint-disable-next-line no-restricted-exports\nexport default async function createLocal<TSlug extends CollectionSlug>(\n  payload: Payload,\n  options: Options<TSlug>,\n): Promise<DataFromCollectionSlug<TSlug>> {\n  const {\n    collection: collectionSlug,\n    data,\n    depth,\n    disableTransaction,\n    disableVerificationEmail,\n    draft,\n    file,\n    filePath,\n    overrideAccess = true,\n    overwriteExistingFiles = false,\n    showHiddenFields,\n  } = options\n  const collection = payload.collections[collectionSlug]\n\n  if (!collection) {\n    throw new APIError(\n      `The collection with slug ${String(collectionSlug)} can't be found. Create Operation.`,\n    )\n  }\n\n  const req = await createLocalReq(options, payload)\n  req.file = file ?? (await getFileByPath(filePath))\n\n  return createOperation<TSlug>({\n    collection,\n    data,\n    depth,\n    disableTransaction,\n    disableVerificationEmail,\n    draft,\n    overrideAccess,\n    overwriteExistingFiles,\n    req,\n    showHiddenFields,\n  })\n}\n"],"names":["APIError","getFileByPath","createLocalReq","createOperation","createLocal","payload","options","collection","collectionSlug","data","depth","disableTransaction","disableVerificationEmail","draft","file","filePath","overrideAccess","overwriteExistingFiles","showHiddenFields","collections","String","req"],"mappings":";;;AAKA,SAASA,QAAQ,QAAQ,2BAA0B;AAEnD,SAASE,cAAc,QAAQ,uCAAsC;AADrE,SAASD,aAAa,QAAQ,oCAAmC;AAEjE,SAASE,eAAe,QAAQ,eAAc;;;;;AAyB/B,eAAeC,YAC5BC,OAAgB,EAChBC,OAAuB;IAEvB,MAAM,EACJC,YAAYC,cAAc,EAC1BC,IAAI,EACJC,KAAK,EACLC,kBAAkB,EAClBC,wBAAwB,EACxBC,KAAK,EACLC,IAAI,EACJC,QAAQ,EACRC,iBAAiB,IAAI,EACrBC,yBAAyB,KAAK,EAC9BC,gBAAgB,EACjB,GAAGZ;IACJ,MAAMC,aAAaF,QAAQc,WAAW,CAACX,eAAe;IAEtD,IAAI,CAACD,YAAY;QACf,MAAM,0JAAIP,WAAAA,CACR,CAAC,yBAAyB,EAAEoB,OAAOZ,gBAAgB,kCAAkC,CAAC;IAE1F;IAEA,MAAMa,MAAM,yKAAMnB,iBAAAA,EAAeI,SAASD;IAC1CgB,IAAIP,IAAI,GAAGA,QAAS,sKAAMb,gBAAAA,EAAcc;IAExC,kLAAOZ,kBAAAA,EAAuB;QAC5BI;QACAE;QACAC;QACAC;QACAC;QACAC;QACAG;QACAC;QACAI;QACAH;IACF;AACF"}},
    {"offset": {"line": 8436, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 8442, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/payload/src/errors/Locked.ts"],"sourcesContent":["import httpStatus from 'http-status'\n\nimport { APIError } from './APIError.js'\n\nexport class Locked extends APIError {\n  constructor(message: string) {\n    super(message, httpStatus.LOCKED)\n  }\n}\n"],"names":["httpStatus","APIError","Locked","constructor","message","LOCKED"],"mappings":";;;AAAA,OAAOA,gBAAgB,cAAa;AAEpC,SAASC,QAAQ,QAAQ,gBAAe;;;AAEjC,MAAMC,qKAAeD,WAAAA;IAC1BE,YAAYC,OAAe,CAAE;QAC3B,KAAK,CAACA,wJAASJ,UAAAA,CAAWK,MAAM;IAClC;AACF"}},
    {"offset": {"line": 8454, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 8460, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/payload/src/utilities/checkDocumentLockStatus.ts"],"sourcesContent":["import type { TypeWithID } from '../collections/config/types.js'\nimport type { PaginatedDocs } from '../database/types.js'\nimport type { JsonObject, PayloadRequest } from '../types/index.js'\n\nimport { Locked } from '../errors/index.js'\n\ntype CheckDocumentLockStatusArgs = {\n  collectionSlug?: string\n  globalSlug?: string\n  id?: number | string\n  lockDurationDefault?: number\n  lockErrorMessage?: string\n  overrideLock?: boolean\n  req: PayloadRequest\n}\n\nexport const checkDocumentLockStatus = async ({\n  id,\n  collectionSlug,\n  globalSlug,\n  lockDurationDefault = 300, // Default 5 minutes in seconds\n  lockErrorMessage,\n  overrideLock = true,\n  req,\n}: CheckDocumentLockStatusArgs): Promise<void> => {\n  const { payload } = req\n\n  // Retrieve the lockDocuments property for either collection or global\n  const lockDocumentsProp = collectionSlug\n    ? payload.config?.collections?.find((c) => c.slug === collectionSlug)?.lockDocuments\n    : payload.config?.globals?.find((g) => g.slug === globalSlug)?.lockDocuments\n\n  const isLockingEnabled = lockDocumentsProp !== false\n\n  let lockedDocumentQuery = {}\n\n  if (collectionSlug) {\n    lockedDocumentQuery = {\n      and: [\n        { 'document.relationTo': { equals: collectionSlug } },\n        { 'document.value': { equals: id } },\n      ],\n    }\n  } else if (globalSlug) {\n    lockedDocumentQuery = { globalSlug: { equals: globalSlug } }\n  } else {\n    throw new Error('Either collectionSlug or globalSlug must be provided.')\n  }\n\n  if (!isLockingEnabled) {\n    return\n  }\n\n  // Only perform lock checks if overrideLock is false and locking is enabled\n  if (!overrideLock) {\n    const defaultLockErrorMessage = collectionSlug\n      ? `Document with ID ${id} is currently locked by another user and cannot be modified.`\n      : `Global document with slug \"${globalSlug}\" is currently locked by another user and cannot be modified.`\n\n    const finalLockErrorMessage = lockErrorMessage || defaultLockErrorMessage\n\n    const lockedDocumentResult: PaginatedDocs<JsonObject & TypeWithID> = await payload.db.find({\n      collection: 'payload-locked-documents',\n      limit: 1,\n      pagination: false,\n      req,\n      sort: '-updatedAt',\n      where: lockedDocumentQuery,\n    })\n\n    // If there's a locked document, check lock conditions\n    const lockedDoc = lockedDocumentResult?.docs[0]\n    if (lockedDoc) {\n      const lastEditedAt = new Date(lockedDoc?.updatedAt).getTime()\n      const now = new Date().getTime()\n\n      const lockDuration =\n        typeof lockDocumentsProp === 'object' ? lockDocumentsProp.duration : lockDurationDefault\n\n      const lockDurationInMilliseconds = lockDuration * 1000\n      const currentUserId = req.user?.id\n\n      // document is locked by another user and the lock hasn't expired\n      if (\n        lockedDoc.user?.value !== currentUserId &&\n        now - lastEditedAt <= lockDurationInMilliseconds\n      ) {\n        throw new Locked(finalLockErrorMessage)\n      }\n    }\n  }\n\n  // Perform the delete operation regardless of overrideLock status\n  await payload.db.deleteMany({\n    collection: 'payload-locked-documents',\n    req,\n    where: lockedDocumentQuery,\n  })\n}\n"],"names":["Locked","checkDocumentLockStatus","id","collectionSlug","globalSlug","lockDurationDefault","lockErrorMessage","overrideLock","req","payload","lockDocumentsProp","config","collections","find","c","slug","lockDocuments","globals","g","isLockingEnabled","lockedDocumentQuery","and","equals","Error","defaultLockErrorMessage","finalLockErrorMessage","lockedDocumentResult","db","collection","limit","pagination","sort","where","lockedDoc","docs","lastEditedAt","Date","updatedAt","getTime","now","lockDuration","duration","lockDurationInMilliseconds","currentUserId","user","value","deleteMany"],"mappings":";;;AAIA,SAASA,MAAM,QAAQ,qBAAoB;;AAYpC,MAAMC,0BAA0B,OAAO,EAC5CC,EAAE,EACFC,cAAc,EACdC,UAAU,EACVC,sBAAsB,GAAG,EACzBC,gBAAgB,EAChBC,eAAe,IAAI,EACnBC,GAAG,EACyB;IAC5B,MAAM,EAAEC,OAAO,EAAE,GAAGD;IAEpB,sEAAsE;IACtE,MAAME,oBAAoBP,iBACtBM,QAAQE,MAAM,EAAEC,aAAaC,KAAK,CAACC,IAAMA,EAAEC,IAAI,KAAKZ,iBAAiBa,gBACrEP,QAAQE,MAAM,EAAEM,SAASJ,KAAK,CAACK,IAAMA,EAAEH,IAAI,KAAKX,aAAaY;IAEjE,MAAMG,mBAAmBT,sBAAsB;IAE/C,IAAIU,sBAAsB,CAAC;IAE3B,IAAIjB,gBAAgB;QAClBiB,sBAAsB;YACpBC,KAAK;gBACH;oBAAE,uBAAuB;wBAAEC,QAAQnB;oBAAe;gBAAE;gBACpD;oBAAE,kBAAkB;wBAAEmB,QAAQpB;oBAAG;gBAAE;aACpC;QACH;IACF,OAAO,IAAIE,YAAY;QACrBgB,sBAAsB;YAAEhB,YAAY;gBAAEkB,QAAQlB;YAAW;QAAE;IAC7D,OAAO;QACL,MAAM,IAAImB,MAAM;IAClB;IAEA,IAAI,CAACJ,kBAAkB;QACrB;IACF;IAEA,2EAA2E;IAC3E,IAAI,CAACZ,cAAc;QACjB,MAAMiB,0BAA0BrB,iBAC5B,CAAC,iBAAiB,EAAED,GAAG,4DAA4D,CAAC,GACpF,CAAC,2BAA2B,EAAEE,WAAW,6DAA6D,CAAC;QAE3G,MAAMqB,wBAAwBnB,oBAAoBkB;QAElD,MAAME,uBAA+D,MAAMjB,QAAQkB,EAAE,CAACd,IAAI,CAAC;YACzFe,YAAY;YACZC,OAAO;YACPC,YAAY;YACZtB;YACAuB,MAAM;YACNC,OAAOZ;QACT;QAEA,sDAAsD;QACtD,MAAMa,YAAYP,sBAAsBQ,IAAI,CAAC,EAAE;QAC/C,IAAID,WAAW;YACb,MAAME,eAAe,IAAIC,KAAKH,WAAWI,WAAWC,OAAO;YAC3D,MAAMC,MAAM,IAAIH,OAAOE,OAAO;YAE9B,MAAME,eACJ,OAAO9B,sBAAsB,WAAWA,kBAAkB+B,QAAQ,GAAGpC;YAEvE,MAAMqC,6BAA6BF,eAAe;YAClD,MAAMG,gBAAgBnC,IAAIoC,IAAI,EAAE1C;YAEhC,iEAAiE;YACjE,IACE+B,UAAUW,IAAI,EAAEC,UAAUF,iBAC1BJ,MAAMJ,gBAAgBO,4BACtB;gBACA,MAAM,wJAAI1C,SAAAA,CAAOyB;YACnB;QACF;IACF;IAEA,iEAAiE;IACjE,MAAMhB,QAAQkB,EAAE,CAACmB,UAAU,CAAC;QAC1BlB,YAAY;QACZpB;QACAwB,OAAOZ;IACT;AACF,EAAC"}},
    {"offset": {"line": 8531, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 8537, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/payload/src/errors/ErrorDeletingFile.ts"],"sourcesContent":["import type { TFunction } from '@payloadcms/translations'\n\nimport { en } from '@payloadcms/translations/languages/en'\nimport httpStatus from 'http-status'\n\nimport { APIError } from './APIError.js'\n\nexport class ErrorDeletingFile extends APIError {\n  constructor(t?: TFunction) {\n    super(\n      t ? t('error:deletingFile') : en.translations.error.deletingFile,\n      httpStatus.INTERNAL_SERVER_ERROR,\n    )\n  }\n}\n"],"names":["en","httpStatus","APIError","ErrorDeletingFile","constructor","t","translations","error","deletingFile","INTERNAL_SERVER_ERROR"],"mappings":";;;AAEA,SAASA,EAAE,QAAQ,wCAAuC;AAC1D,OAAOC,gBAAgB,cAAa;AAEpC,SAASC,QAAQ,QAAQ,gBAAe;;;;AAEjC,MAAMC,gLAA0BD,WAAAA;IACrCE,YAAYC,CAAa,CAAE;QACzB,KAAK,CACHA,IAAIA,EAAE,gMAAwBL,KAAAA,CAAGM,YAAY,CAACC,KAAK,CAACC,YAAY,iJAChEP,UAAAA,CAAWQ,qBAAqB;IAEpC;AACF"}},
    {"offset": {"line": 8551, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 8557, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/payload/src/uploads/deleteAssociatedFiles.ts"],"sourcesContent":["import fs from 'fs'\n\nimport type { SanitizedCollectionConfig } from '../collections/config/types.js'\nimport type { SanitizedConfig } from '../config/types.js'\nimport type { PayloadRequest } from '../types/index.js'\nimport type { FileData, FileToSave } from './types.js'\n\nimport { ErrorDeletingFile } from '../errors/index.js'\nimport fileExists from './fileExists.js'\n\ntype Args = {\n  collectionConfig: SanitizedCollectionConfig\n  config: SanitizedConfig\n  doc: Record<string, unknown>\n  files?: FileToSave[]\n  overrideDelete: boolean\n  req: PayloadRequest\n}\n\nexport const deleteAssociatedFiles: (args: Args) => Promise<void> = async ({\n  collectionConfig,\n  doc,\n  files = [],\n  overrideDelete,\n  req,\n}) => {\n  if (!collectionConfig.upload) {\n    return\n  }\n  if (overrideDelete || files.length > 0) {\n    const { staticDir: staticPath } = collectionConfig.upload\n\n    const fileToDelete = `${staticPath}/${doc.filename as string}`\n\n    try {\n      if (await fileExists(fileToDelete)) {\n        fs.unlinkSync(fileToDelete)\n      }\n    } catch (err) {\n      throw new ErrorDeletingFile(req.t)\n    }\n\n    if (doc.sizes) {\n      const sizes: FileData[] = Object.values(doc.sizes)\n      // Since forEach will not wait until unlink is finished it could\n      // happen that two operations will try to delete the same file.\n      // To avoid this it is recommended to use \"sync\" instead\n\n      for (const size of sizes) {\n        const sizeToDelete = `${staticPath}/${size.filename}`\n        try {\n          if (await fileExists(sizeToDelete)) {\n            fs.unlinkSync(sizeToDelete)\n          }\n        } catch (err) {\n          throw new ErrorDeletingFile(req.t)\n        }\n      }\n    }\n  }\n}\n"],"names":["fs","ErrorDeletingFile","fileExists","deleteAssociatedFiles","collectionConfig","doc","files","overrideDelete","req","upload","length","staticDir","staticPath","fileToDelete","filename","unlinkSync","err","t","sizes","Object","values","size","sizeToDelete"],"mappings":";;;AAAA,OAAOA,QAAQ,KAAI;AAQnB,OAAOE,gBAAgB,kBAAiB;AADxC,SAASD,iBAAiB,QAAQ,qBAAoB;;;;AAY/C,MAAME,wBAAuD,OAAO,EACzEC,gBAAgB,EAChBC,GAAG,EACHC,QAAQ,EAAE,EACVC,cAAc,EACdC,GAAG,EACJ;IACC,IAAI,CAACJ,iBAAiBK,MAAM,EAAE;QAC5B;IACF;IACA,IAAIF,kBAAkBD,MAAMI,MAAM,GAAG,GAAG;QACtC,MAAM,EAAEC,WAAWC,UAAU,EAAE,GAAGR,iBAAiBK,MAAM;QAEzD,MAAMI,eAAe,CAAC,EAAED,WAAW,CAAC,EAAEP,IAAIS,QAAQ,CAAW,CAAC;QAE9D,IAAI;YACF,IAAI,mKAAMZ,UAAAA,EAAWW,eAAe;gBAClCb,sGAAAA,CAAGe,UAAU,CAACF;YAChB;QACF,EAAE,OAAOG,KAAK;YACZ,MAAM,mKAAIf,oBAAAA,CAAkBO,IAAIS,CAAC;QACnC;QAEA,IAAIZ,IAAIa,KAAK,EAAE;YACb,MAAMA,QAAoBC,OAAOC,MAAM,CAACf,IAAIa,KAAK;YACjD,gEAAgE;YAChE,+DAA+D;YAC/D,wDAAwD;YAExD,KAAK,MAAMG,QAAQH,MAAO;gBACxB,MAAMI,eAAe,CAAC,EAAEV,WAAW,CAAC,EAAES,KAAKP,QAAQ,CAAC,CAAC;gBACrD,IAAI;oBACF,IAAI,OAAMZ,sKAAAA,EAAWoB,eAAe;oHAClCtB,UAAAA,CAAGe,UAAU,CAACO;oBAChB;gBACF,EAAE,OAAON,KAAK;oBACZ,MAAM,mKAAIf,oBAAAA,CAAkBO,IAAIS,CAAC;gBACnC;YACF;QACF;IACF;AACF,EAAC"}},
    {"offset": {"line": 8598, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 8604, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/payload/src/versions/deleteCollectionVersions.ts"],"sourcesContent":["import type { Payload } from '../index.js'\nimport type { PayloadRequest } from '../types/index.js'\n\ntype Args = {\n  id?: number | string\n  payload: Payload\n  req?: PayloadRequest\n  slug: string\n}\n\nexport const deleteCollectionVersions = async ({ id, slug, payload, req }: Args): Promise<void> => {\n  try {\n    await payload.db.deleteVersions({\n      collection: slug,\n      req,\n      where: {\n        parent: {\n          equals: id,\n        },\n      },\n    })\n  } catch (err) {\n    payload.logger.error(\n      `There was an error removing versions for the deleted ${slug} document with ID ${id}.`,\n    )\n  }\n}\n"],"names":["deleteCollectionVersions","id","slug","payload","req","db","deleteVersions","collection","where","parent","equals","err","logger","error"],"mappings":";;;AAUO,MAAMA,2BAA2B,OAAO,EAAEC,EAAE,EAAEC,IAAI,EAAEC,OAAO,EAAEC,GAAG,EAAQ;IAC7E,IAAI;QACF,MAAMD,QAAQE,EAAE,CAACC,cAAc,CAAC;YAC9BC,YAAYL;YACZE;YACAI,OAAO;gBACLC,QAAQ;oBACNC,QAAQT;gBACV;YACF;QACF;IACF,EAAE,OAAOU,KAAK;QACZR,QAAQS,MAAM,CAACC,KAAK,CAClB,CAAC,qDAAqD,EAAEX,KAAK,kBAAkB,EAAED,GAAG,CAAC,CAAC;IAE1F;AACF,EAAC"}},
    {"offset": {"line": 8622, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 8628, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/payload/src/preferences/deleteUserPreferences.ts"],"sourcesContent":["import type { SanitizedCollectionConfig } from '../collections/config/types.js'\nimport type { Payload } from '../index.js'\nimport type { PayloadRequest } from '../types/index.js'\n\ntype Args = {\n  collectionConfig: SanitizedCollectionConfig\n  /**\n   * User IDs to delete\n   */\n  ids: (number | string)[]\n  payload: Payload\n  req: PayloadRequest\n}\nexport const deleteUserPreferences = async ({ collectionConfig, ids, payload, req }: Args) => {\n  if (collectionConfig.auth) {\n    await payload.db.deleteMany({\n      collection: 'payload-preferences',\n      req,\n      where: {\n        and: [\n          {\n            'user.value': { in: ids },\n          },\n          {\n            'user.relationTo': { equals: collectionConfig.slug },\n          },\n        ],\n      },\n    })\n  }\n  await payload.db.deleteMany({\n    collection: 'payload-preferences',\n    req,\n    where: {\n      key: { in: ids.map((id) => `collection-${collectionConfig.slug}-${id}`) },\n    },\n  })\n}\n"],"names":["deleteUserPreferences","collectionConfig","ids","payload","req","auth","db","deleteMany","collection","where","and","in","equals","slug","key","map","id"],"mappings":";;;AAaO,MAAMA,wBAAwB,OAAO,EAAEC,gBAAgB,EAAEC,GAAG,EAAEC,OAAO,EAAEC,GAAG,EAAQ;IACvF,IAAIH,iBAAiBI,IAAI,EAAE;QACzB,MAAMF,QAAQG,EAAE,CAACC,UAAU,CAAC;YAC1BC,YAAY;YACZJ;YACAK,OAAO;gBACLC,KAAK;oBACH;wBACE,cAAc;4BAAEC,IAAIT;wBAAI;oBAC1B;oBACA;wBACE,mBAAmB;4BAAEU,QAAQX,iBAAiBY,IAAI;wBAAC;oBACrD;iBACD;YACH;QACF;IACF;IACA,MAAMV,QAAQG,EAAE,CAACC,UAAU,CAAC;QAC1BC,YAAY;QACZJ;QACAK,OAAO;YACLK,KAAK;gBAAEH,IAAIT,IAAIa,GAAG,CAAC,CAACC,KAAO,CAAC,WAAW,EAAEf,iBAAiBY,IAAI,CAAC,CAAC,EAAEG,GAAG,CAAC;YAAE;QAC1E;IACF;AACF,EAAC"}},
    {"offset": {"line": 8662, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 8668, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/payload/src/collections/operations/delete.ts"],"sourcesContent":["import httpStatus from 'http-status'\n\nimport type { AccessResult } from '../../config/types.js'\nimport type { CollectionSlug } from '../../index.js'\nimport type { PayloadRequest, Where } from '../../types/index.js'\nimport type { BeforeOperationHook, Collection, DataFromCollectionSlug } from '../config/types.js'\n\nimport executeAccess from '../../auth/executeAccess.js'\nimport { combineQueries } from '../../database/combineQueries.js'\nimport { validateQueryPaths } from '../../database/queryValidation/validateQueryPaths.js'\nimport { APIError } from '../../errors/index.js'\nimport { afterRead } from '../../fields/hooks/afterRead/index.js'\nimport { deleteUserPreferences } from '../../preferences/deleteUserPreferences.js'\nimport { deleteAssociatedFiles } from '../../uploads/deleteAssociatedFiles.js'\nimport { checkDocumentLockStatus } from '../../utilities/checkDocumentLockStatus.js'\nimport { commitTransaction } from '../../utilities/commitTransaction.js'\nimport { initTransaction } from '../../utilities/initTransaction.js'\nimport { killTransaction } from '../../utilities/killTransaction.js'\nimport { deleteCollectionVersions } from '../../versions/deleteCollectionVersions.js'\nimport { buildAfterOperation } from './utils.js'\n\nexport type Arguments = {\n  collection: Collection\n  depth?: number\n  disableTransaction?: boolean\n  overrideAccess?: boolean\n  overrideLock?: boolean\n  req: PayloadRequest\n  showHiddenFields?: boolean\n  where: Where\n}\n\nexport const deleteOperation = async <TSlug extends CollectionSlug>(\n  incomingArgs: Arguments,\n): Promise<{\n  docs: DataFromCollectionSlug<TSlug>[]\n  errors: {\n    id: DataFromCollectionSlug<TSlug>['id']\n    message: string\n  }[]\n}> => {\n  let args = incomingArgs\n\n  try {\n    const shouldCommit = !args.disableTransaction && (await initTransaction(args.req))\n    // /////////////////////////////////////\n    // beforeOperation - Collection\n    // /////////////////////////////////////\n\n    await args.collection.config.hooks.beforeOperation.reduce(\n      async (priorHook: BeforeOperationHook | Promise<void>, hook: BeforeOperationHook) => {\n        await priorHook\n\n        args =\n          (await hook({\n            args,\n            collection: args.collection.config,\n            context: args.req.context,\n            operation: 'delete',\n            req: args.req,\n          })) || args\n      },\n      Promise.resolve(),\n    )\n\n    const {\n      collection: { config: collectionConfig },\n      depth,\n      overrideAccess,\n      overrideLock,\n      req: {\n        fallbackLocale,\n        locale,\n        payload: { config },\n        payload,\n      },\n      req,\n      showHiddenFields,\n      where,\n    } = args\n\n    if (!where) {\n      throw new APIError(\"Missing 'where' query of documents to delete.\", httpStatus.BAD_REQUEST)\n    }\n\n    // /////////////////////////////////////\n    // Access\n    // /////////////////////////////////////\n\n    let accessResult: AccessResult\n\n    if (!overrideAccess) {\n      accessResult = await executeAccess({ req }, collectionConfig.access.delete)\n    }\n\n    await validateQueryPaths({\n      collectionConfig,\n      overrideAccess,\n      req,\n      where,\n    })\n\n    const fullWhere = combineQueries(where, accessResult)\n\n    // /////////////////////////////////////\n    // Retrieve documents\n    // /////////////////////////////////////\n\n    const { docs } = await payload.db.find<DataFromCollectionSlug<TSlug>>({\n      collection: collectionConfig.slug,\n      locale,\n      req,\n      where: fullWhere,\n    })\n\n    const errors = []\n\n    const promises = docs.map(async (doc) => {\n      let result\n\n      const { id } = doc\n\n      try {\n        // /////////////////////////////////////\n        // Handle potentially locked documents\n        // /////////////////////////////////////\n\n        await checkDocumentLockStatus({\n          id,\n          collectionSlug: collectionConfig.slug,\n          lockErrorMessage: `Document with ID ${id} is currently locked and cannot be deleted.`,\n          overrideLock,\n          req,\n        })\n\n        // /////////////////////////////////////\n        // beforeDelete - Collection\n        // /////////////////////////////////////\n\n        await collectionConfig.hooks.beforeDelete.reduce(async (priorHook, hook) => {\n          await priorHook\n\n          return hook({\n            id,\n            collection: collectionConfig,\n            context: req.context,\n            req,\n          })\n        }, Promise.resolve())\n\n        await deleteAssociatedFiles({\n          collectionConfig,\n          config,\n          doc,\n          overrideDelete: true,\n          req,\n        })\n\n        // /////////////////////////////////////\n        // Delete versions\n        // /////////////////////////////////////\n\n        if (collectionConfig.versions) {\n          await deleteCollectionVersions({\n            id,\n            slug: collectionConfig.slug,\n            payload,\n            req,\n          })\n        }\n\n        // /////////////////////////////////////\n        // Delete document\n        // /////////////////////////////////////\n\n        await payload.db.deleteOne({\n          collection: collectionConfig.slug,\n          req,\n          where: {\n            id: {\n              equals: id,\n            },\n          },\n        })\n\n        // /////////////////////////////////////\n        // afterRead - Fields\n        // /////////////////////////////////////\n\n        result = await afterRead({\n          collection: collectionConfig,\n          context: req.context,\n          depth,\n          doc: result || doc,\n          draft: undefined,\n          fallbackLocale,\n          global: null,\n          locale,\n          overrideAccess,\n          req,\n          showHiddenFields,\n        })\n\n        // /////////////////////////////////////\n        // afterRead - Collection\n        // /////////////////////////////////////\n\n        await collectionConfig.hooks.afterRead.reduce(async (priorHook, hook) => {\n          await priorHook\n\n          result =\n            (await hook({\n              collection: collectionConfig,\n              context: req.context,\n              doc: result || doc,\n              req,\n            })) || result\n        }, Promise.resolve())\n\n        // /////////////////////////////////////\n        // afterDelete - Collection\n        // /////////////////////////////////////\n\n        await collectionConfig.hooks.afterDelete.reduce(async (priorHook, hook) => {\n          await priorHook\n\n          result =\n            (await hook({\n              id,\n              collection: collectionConfig,\n              context: req.context,\n              doc: result,\n              req,\n            })) || result\n        }, Promise.resolve())\n\n        // /////////////////////////////////////\n        // 8. Return results\n        // /////////////////////////////////////\n\n        return result\n      } catch (error) {\n        errors.push({\n          id: doc.id,\n          message: error.message,\n        })\n      }\n      return null\n    })\n\n    const awaitedDocs = await Promise.all(promises)\n\n    // /////////////////////////////////////\n    // Delete Preferences\n    // /////////////////////////////////////\n\n    await deleteUserPreferences({\n      collectionConfig,\n      ids: docs.map(({ id }) => id),\n      payload,\n      req,\n    })\n\n    let result = {\n      docs: awaitedDocs.filter(Boolean),\n      errors,\n    }\n\n    // /////////////////////////////////////\n    // afterOperation - Collection\n    // /////////////////////////////////////\n\n    result = await buildAfterOperation({\n      args,\n      collection: collectionConfig,\n      operation: 'delete',\n      result,\n    })\n\n    if (shouldCommit) {\n      await commitTransaction(req)\n    }\n\n    return result\n  } catch (error: unknown) {\n    await killTransaction(args.req)\n    throw error\n  }\n}\n"],"names":["httpStatus","executeAccess","combineQueries","validateQueryPaths","APIError","afterRead","deleteUserPreferences","deleteAssociatedFiles","checkDocumentLockStatus","commitTransaction","initTransaction","killTransaction","deleteCollectionVersions","buildAfterOperation","deleteOperation","incomingArgs","args","shouldCommit","disableTransaction","req","collection","config","hooks","beforeOperation","reduce","priorHook","hook","context","operation","Promise","resolve","collectionConfig","depth","overrideAccess","overrideLock","fallbackLocale","locale","payload","showHiddenFields","where","BAD_REQUEST","accessResult","access","delete","fullWhere","docs","db","find","slug","errors","promises","map","doc","result","id","collectionSlug","lockErrorMessage","beforeDelete","overrideDelete","versions","deleteOne","equals","draft","undefined","global","afterDelete","error","push","message","awaitedDocs","all","ids","filter","Boolean"],"mappings":"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"}},
    {"offset": {"line": 8887, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 8893, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/payload/src/errors/NotFound.ts"],"sourcesContent":["import type { TFunction } from '@payloadcms/translations'\n\nimport { en } from '@payloadcms/translations/languages/en'\nimport httpStatus from 'http-status'\n\nimport { APIError } from './APIError.js'\n\nexport class NotFound extends APIError {\n  constructor(t?: TFunction) {\n    super(t ? t('general:notFound') : en.translations.general.notFound, httpStatus.NOT_FOUND)\n  }\n}\n"],"names":["en","httpStatus","APIError","NotFound","constructor","t","translations","general","notFound","NOT_FOUND"],"mappings":";;;AAEA,SAASA,EAAE,QAAQ,wCAAuC;AAC1D,OAAOC,gBAAgB,cAAa;AAEpC,SAASC,QAAQ,QAAQ,gBAAe;;;;AAEjC,MAAMC,uKAAiBD,WAAAA;IAC5BE,YAAYC,CAAa,CAAE;QACzB,KAAK,CAACA,IAAIA,EAAE,8LAAsBL,KAAAA,CAAGM,YAAY,CAACC,OAAO,CAACC,QAAQ,iJAAEP,UAAAA,CAAWQ,SAAS;IAC1F;AACF"}},
    {"offset": {"line": 8907, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 8913, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/payload/src/collections/operations/deleteByID.ts"],"sourcesContent":["import type { CollectionSlug } from '../../index.js'\nimport type { PayloadRequest } from '../../types/index.js'\nimport type { BeforeOperationHook, Collection, DataFromCollectionSlug } from '../config/types.js'\n\nimport executeAccess from '../../auth/executeAccess.js'\nimport { hasWhereAccessResult } from '../../auth/types.js'\nimport { combineQueries } from '../../database/combineQueries.js'\nimport { Forbidden, NotFound } from '../../errors/index.js'\nimport { afterRead } from '../../fields/hooks/afterRead/index.js'\nimport { deleteUserPreferences } from '../../preferences/deleteUserPreferences.js'\nimport { deleteAssociatedFiles } from '../../uploads/deleteAssociatedFiles.js'\nimport { checkDocumentLockStatus } from '../../utilities/checkDocumentLockStatus.js'\nimport { commitTransaction } from '../../utilities/commitTransaction.js'\nimport { initTransaction } from '../../utilities/initTransaction.js'\nimport { killTransaction } from '../../utilities/killTransaction.js'\nimport { deleteCollectionVersions } from '../../versions/deleteCollectionVersions.js'\nimport { buildAfterOperation } from './utils.js'\n\nexport type Arguments = {\n  collection: Collection\n  depth?: number\n  disableTransaction?: boolean\n  id: number | string\n  overrideAccess?: boolean\n  overrideLock?: boolean\n  req: PayloadRequest\n  showHiddenFields?: boolean\n}\n\nexport const deleteByIDOperation = async <TSlug extends CollectionSlug>(\n  incomingArgs: Arguments,\n): Promise<DataFromCollectionSlug<TSlug>> => {\n  let args = incomingArgs\n\n  try {\n    const shouldCommit = !args.disableTransaction && (await initTransaction(args.req))\n\n    // /////////////////////////////////////\n    // beforeOperation - Collection\n    // /////////////////////////////////////\n\n    await args.collection.config.hooks.beforeOperation.reduce(\n      async (priorHook: BeforeOperationHook | Promise<void>, hook: BeforeOperationHook) => {\n        await priorHook\n\n        args =\n          (await hook({\n            args,\n            collection: args.collection.config,\n            context: args.req.context,\n            operation: 'delete',\n            req: args.req,\n          })) || args\n      },\n      Promise.resolve(),\n    )\n\n    const {\n      id,\n      collection: { config: collectionConfig },\n      depth,\n      overrideAccess,\n      overrideLock,\n      req: {\n        fallbackLocale,\n        locale,\n        payload: { config },\n        payload,\n      },\n      req,\n      showHiddenFields,\n    } = args\n\n    // /////////////////////////////////////\n    // Access\n    // /////////////////////////////////////\n\n    const accessResults = !overrideAccess\n      ? await executeAccess({ id, req }, collectionConfig.access.delete)\n      : true\n    const hasWhereAccess = hasWhereAccessResult(accessResults)\n\n    // /////////////////////////////////////\n    // beforeDelete - Collection\n    // /////////////////////////////////////\n\n    await collectionConfig.hooks.beforeDelete.reduce(async (priorHook, hook) => {\n      await priorHook\n\n      return hook({\n        id,\n        collection: collectionConfig,\n        context: req.context,\n        req,\n      })\n    }, Promise.resolve())\n\n    // /////////////////////////////////////\n    // Retrieve document\n    // /////////////////////////////////////\n\n    const docToDelete = await req.payload.db.findOne({\n      collection: collectionConfig.slug,\n      locale: req.locale,\n      req,\n      where: combineQueries({ id: { equals: id } }, accessResults),\n    })\n\n    if (!docToDelete && !hasWhereAccess) {\n      throw new NotFound(req.t)\n    }\n    if (!docToDelete && hasWhereAccess) {\n      throw new Forbidden(req.t)\n    }\n\n    // /////////////////////////////////////\n    // Handle potentially locked documents\n    // /////////////////////////////////////\n\n    await checkDocumentLockStatus({\n      id,\n      collectionSlug: collectionConfig.slug,\n      lockErrorMessage: `Document with ID ${id} is currently locked and cannot be deleted.`,\n      overrideLock,\n      req,\n    })\n\n    await deleteAssociatedFiles({\n      collectionConfig,\n      config,\n      doc: docToDelete,\n      overrideDelete: true,\n      req,\n    })\n\n    // /////////////////////////////////////\n    // Delete versions\n    // /////////////////////////////////////\n\n    if (collectionConfig.versions) {\n      await deleteCollectionVersions({\n        id,\n        slug: collectionConfig.slug,\n        payload,\n        req,\n      })\n    }\n\n    // /////////////////////////////////////\n    // Delete document\n    // /////////////////////////////////////\n\n    let result: DataFromCollectionSlug<TSlug> = await req.payload.db.deleteOne({\n      collection: collectionConfig.slug,\n      req,\n      where: { id: { equals: id } },\n    })\n\n    // /////////////////////////////////////\n    // Delete Preferences\n    // /////////////////////////////////////\n\n    await deleteUserPreferences({\n      collectionConfig,\n      ids: [id],\n      payload,\n      req,\n    })\n\n    // /////////////////////////////////////\n    // afterRead - Fields\n    // /////////////////////////////////////\n\n    result = await afterRead({\n      collection: collectionConfig,\n      context: req.context,\n      depth,\n      doc: result,\n      draft: undefined,\n      fallbackLocale,\n      global: null,\n      locale,\n      overrideAccess,\n      req,\n      showHiddenFields,\n    })\n\n    // /////////////////////////////////////\n    // afterRead - Collection\n    // /////////////////////////////////////\n\n    await collectionConfig.hooks.afterRead.reduce(async (priorHook, hook) => {\n      await priorHook\n\n      result =\n        (await hook({\n          collection: collectionConfig,\n          context: req.context,\n          doc: result,\n          req,\n        })) || result\n    }, Promise.resolve())\n\n    // /////////////////////////////////////\n    // afterDelete - Collection\n    // /////////////////////////////////////\n\n    await collectionConfig.hooks.afterDelete.reduce(async (priorHook, hook) => {\n      await priorHook\n\n      result =\n        (await hook({\n          id,\n          collection: collectionConfig,\n          context: req.context,\n          doc: result,\n          req,\n        })) || result\n    }, Promise.resolve())\n\n    // /////////////////////////////////////\n    // afterOperation - Collection\n    // /////////////////////////////////////\n\n    result = await buildAfterOperation({\n      args,\n      collection: collectionConfig,\n      operation: 'deleteByID',\n      result,\n    })\n\n    // /////////////////////////////////////\n    // 8. Return results\n    // /////////////////////////////////////\n\n    if (shouldCommit) {\n      await commitTransaction(req)\n    }\n\n    return result\n  } catch (error: unknown) {\n    await killTransaction(args.req)\n    throw error\n  }\n}\n"],"names":["executeAccess","hasWhereAccessResult","combineQueries","Forbidden","NotFound","afterRead","deleteUserPreferences","deleteAssociatedFiles","checkDocumentLockStatus","commitTransaction","initTransaction","killTransaction","deleteCollectionVersions","buildAfterOperation","deleteByIDOperation","incomingArgs","args","shouldCommit","disableTransaction","req","collection","config","hooks","beforeOperation","reduce","priorHook","hook","context","operation","Promise","resolve","id","collectionConfig","depth","overrideAccess","overrideLock","fallbackLocale","locale","payload","showHiddenFields","accessResults","access","delete","hasWhereAccess","beforeDelete","docToDelete","db","findOne","slug","where","equals","t","collectionSlug","lockErrorMessage","doc","overrideDelete","versions","result","deleteOne","ids","draft","undefined","global","afterDelete","error"],"mappings":"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"}},
    {"offset": {"line": 9113, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 9119, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/payload/src/collections/operations/local/delete.ts"],"sourcesContent":["import type { CollectionSlug, Payload, TypedLocale } from '../../../index.js'\nimport type { Document, PayloadRequest, RequestContext, Where } from '../../../types/index.js'\nimport type { BulkOperationResult, DataFromCollectionSlug } from '../../config/types.js'\n\nimport { APIError } from '../../../errors/index.js'\nimport { createLocalReq } from '../../../utilities/createLocalReq.js'\nimport { deleteOperation } from '../delete.js'\nimport { deleteByIDOperation } from '../deleteByID.js'\n\nexport type BaseOptions<TSlug extends CollectionSlug> = {\n  collection: TSlug\n  /**\n   * context, which will then be passed to req.context, which can be read by hooks\n   */\n  context?: RequestContext\n  depth?: number\n  disableTransaction?: boolean\n  fallbackLocale?: TypedLocale\n  locale?: TypedLocale\n  overrideAccess?: boolean\n  overrideLock?: boolean\n  req?: PayloadRequest\n  showHiddenFields?: boolean\n  user?: Document\n}\n\nexport type ByIDOptions<TSlug extends CollectionSlug> = {\n  id: number | string\n  where?: never\n} & BaseOptions<TSlug>\n\nexport type ManyOptions<TSlug extends CollectionSlug> = {\n  id?: never\n  where: Where\n} & BaseOptions<TSlug>\n\nexport type Options<TSlug extends CollectionSlug> = ByIDOptions<TSlug> | ManyOptions<TSlug>\n\nasync function deleteLocal<TSlug extends CollectionSlug>(\n  payload: Payload,\n  options: ByIDOptions<TSlug>,\n): Promise<DataFromCollectionSlug<TSlug>>\nasync function deleteLocal<TSlug extends CollectionSlug>(\n  payload: Payload,\n  options: ManyOptions<TSlug>,\n): Promise<BulkOperationResult<TSlug>>\nasync function deleteLocal<TSlug extends CollectionSlug>(\n  payload: Payload,\n  options: Options<TSlug>,\n): Promise<BulkOperationResult<TSlug> | DataFromCollectionSlug<TSlug>>\nasync function deleteLocal<TSlug extends CollectionSlug>(\n  payload: Payload,\n  options: Options<TSlug>,\n): Promise<BulkOperationResult<TSlug> | DataFromCollectionSlug<TSlug>> {\n  const {\n    id,\n    collection: collectionSlug,\n    depth,\n    disableTransaction,\n    overrideAccess = true,\n    overrideLock,\n    showHiddenFields,\n    where,\n  } = options\n\n  const collection = payload.collections[collectionSlug]\n\n  if (!collection) {\n    throw new APIError(\n      `The collection with slug ${String(collectionSlug)} can't be found. Delete Operation.`,\n    )\n  }\n\n  const args = {\n    id,\n    collection,\n    depth,\n    disableTransaction,\n    overrideAccess,\n    overrideLock,\n    req: await createLocalReq(options, payload),\n    showHiddenFields,\n    where,\n  }\n\n  if (options.id) {\n    return deleteByIDOperation<TSlug>(args)\n  }\n  return deleteOperation<TSlug>(args)\n}\n\nexport default deleteLocal\n"],"names":["APIError","createLocalReq","deleteOperation","deleteByIDOperation","deleteLocal","payload","options","id","collection","collectionSlug","depth","disableTransaction","overrideAccess","overrideLock","showHiddenFields","where","collections","String","args","req"],"mappings":";;;AAIA,SAASA,QAAQ,QAAQ,2BAA0B;AACnD,SAASC,cAAc,QAAQ,uCAAsC;AACrE,SAASC,eAAe,QAAQ,eAAc;AAC9C,SAASC,mBAAmB,QAAQ,mBAAkB;;;;;AA2CtD,eAAeC,YACbC,OAAgB,EAChBC,OAAuB;IAEvB,MAAM,EACJC,EAAE,EACFC,YAAYC,cAAc,EAC1BC,KAAK,EACLC,kBAAkB,EAClBC,iBAAiB,IAAI,EACrBC,YAAY,EACZC,gBAAgB,EAChBC,KAAK,EACN,GAAGT;IAEJ,MAAME,aAAaH,QAAQW,WAAW,CAACP,eAAe;IAEtD,IAAI,CAACD,YAAY;QACf,MAAM,0JAAIR,WAAAA,CACR,CAAC,yBAAyB,EAAEiB,OAAOR,gBAAgB,kCAAkC,CAAC;IAE1F;IAEA,MAAMS,OAAO;QACXX;QACAC;QACAE;QACAC;QACAC;QACAC;QACAM,KAAK,yKAAMlB,iBAAAA,EAAeK,SAASD;QACnCS;QACAC;IACF;IAEA,IAAIT,QAAQC,EAAE,EAAE;QACd,sLAAOJ,sBAAAA,EAA2Be;IACpC;IACA,kLAAOhB,kBAAAA,EAAuBgB;AAChC;uCAEed,YAAW"}},
    {"offset": {"line": 9154, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 9160, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/payload/src/versions/drafts/appendVersionToQueryKey.ts"],"sourcesContent":["import type { Where } from '../../types/index.js'\n\nexport const appendVersionToQueryKey = (query: Where = {}): Where => {\n  return Object.entries(query).reduce((res, [key, val]) => {\n    if (['AND', 'and', 'OR', 'or'].includes(key) && Array.isArray(val)) {\n      return {\n        ...res,\n        [key.toLowerCase()]: val.map((subQuery) => appendVersionToQueryKey(subQuery)),\n      }\n    }\n\n    if (key !== 'id') {\n      return {\n        ...res,\n        [`version.${key}`]: val,\n      }\n    }\n\n    return {\n      ...res,\n      parent: val,\n    }\n  }, {})\n}\n"],"names":["appendVersionToQueryKey","query","Object","entries","reduce","res","key","val","includes","Array","isArray","toLowerCase","map","subQuery","parent"],"mappings":";;;AAEO,MAAMA,0BAA0B,CAACC,QAAe,CAAC,CAAC;IACvD,OAAOC,OAAOC,OAAO,CAACF,OAAOG,MAAM,CAAC,CAACC,KAAK,CAACC,KAAKC,IAAI;QAClD,IAAI;YAAC;YAAO;YAAO;YAAM;SAAK,CAACC,QAAQ,CAACF,QAAQG,MAAMC,OAAO,CAACH,MAAM;YAClE,OAAO;gBACL,GAAGF,GAAG;gBACN,CAACC,IAAIK,WAAW,GAAG,EAAEJ,IAAIK,GAAG,CAAC,CAACC,WAAab,wBAAwBa;YACrE;QACF;QAEA,IAAIP,QAAQ,MAAM;YAChB,OAAO;gBACL,GAAGD,GAAG;gBACN,CAAC,CAAC,QAAQ,EAAEC,IAAI,CAAC,CAAC,EAAEC;YACtB;QACF;QAEA,OAAO;YACL,GAAGF,GAAG;YACNS,QAAQP;QACV;IACF,GAAG,CAAC;AACN,EAAC"}},
    {"offset": {"line": 9188, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 9194, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/payload/src/versions/getLatestCollectionVersion.ts"],"sourcesContent":["import type { SanitizedCollectionConfig, TypeWithID } from '../collections/config/types.js'\nimport type { FindOneArgs } from '../database/types.js'\nimport type { Payload, PayloadRequest } from '../types/index.js'\nimport type { TypeWithVersion } from './types.js'\n\nimport { combineQueries } from '../database/combineQueries.js'\nimport { appendVersionToQueryKey } from './drafts/appendVersionToQueryKey.js'\n\ntype Args = {\n  config: SanitizedCollectionConfig\n  id: number | string\n  payload: Payload\n  published?: boolean\n  query: FindOneArgs\n  req?: PayloadRequest\n}\n\nexport const getLatestCollectionVersion = async <T extends TypeWithID = any>({\n  id,\n  config,\n  payload,\n  published,\n  query,\n  req,\n}: Args): Promise<T> => {\n  let latestVersion: TypeWithVersion<T>\n\n  const whereQuery = published\n    ? { and: [{ parent: { equals: id } }, { 'version._status': { equals: 'published' } }] }\n    : { and: [{ parent: { equals: id } }, { latest: { equals: true } }] }\n\n  if (config.versions?.drafts) {\n    const { docs } = await payload.db.findVersions<T>({\n      collection: config.slug,\n      limit: 1,\n      pagination: false,\n      req,\n      sort: '-updatedAt',\n      where: combineQueries(appendVersionToQueryKey(query.where), whereQuery),\n    })\n    ;[latestVersion] = docs\n  }\n\n  if (!latestVersion) {\n    if (!published) {\n      const doc = await payload.db.findOne<T>({ ...query, req })\n\n      return doc\n    }\n\n    return undefined\n  }\n\n  latestVersion.version.id = id\n\n  return latestVersion.version\n}\n"],"names":["combineQueries","appendVersionToQueryKey","getLatestCollectionVersion","id","config","payload","published","query","req","latestVersion","whereQuery","and","parent","equals","latest","versions","drafts","docs","db","findVersions","collection","slug","limit","pagination","sort","where","doc","findOne","undefined","version"],"mappings":";;;AAKA,SAASA,cAAc,QAAQ,gCAA+B;AAC9D,SAASC,uBAAuB,QAAQ,sCAAqC;;;AAWtE,MAAMC,6BAA6B,OAAmC,EAC3EC,EAAE,EACFC,MAAM,EACNC,OAAO,EACPC,SAAS,EACTC,KAAK,EACLC,GAAG,EACE;IACL,IAAIC;IAEJ,MAAMC,aAAaJ,YACf;QAAEK,KAAK;YAAC;gBAAEC,QAAQ;oBAAEC,QAAQV;gBAAG;YAAE;YAAG;gBAAE,mBAAmB;oBAAEU,QAAQ;gBAAY;YAAE;SAAE;IAAC,IACpF;QAAEF,KAAK;YAAC;gBAAEC,QAAQ;oBAAEC,QAAQV;gBAAG;YAAE;YAAG;gBAAEW,QAAQ;oBAAED,QAAQ;gBAAK;YAAE;SAAE;IAAC;IAEtE,IAAIT,OAAOW,QAAQ,EAAEC,QAAQ;QAC3B,MAAM,EAAEC,IAAI,EAAE,GAAG,MAAMZ,QAAQa,EAAE,CAACC,YAAY,CAAI;YAChDC,YAAYhB,OAAOiB,IAAI;YACvBC,OAAO;YACPC,YAAY;YACZf;YACAgB,MAAM;YACNC,yKAAOzB,iBAAAA,uLAAeC,0BAAAA,EAAwBM,MAAMkB,KAAK,GAAGf;QAC9D;QACC,CAACD,cAAc,GAAGQ;IACrB;IAEA,IAAI,CAACR,eAAe;QAClB,IAAI,CAACH,WAAW;YACd,MAAMoB,MAAM,MAAMrB,QAAQa,EAAE,CAACS,OAAO,CAAI;gBAAE,GAAGpB,KAAK;gBAAEC;YAAI;YAExD,OAAOkB;QACT;QAEA,OAAOE;IACT;IAEAnB,cAAcoB,OAAO,CAAC1B,EAAE,GAAGA;IAE3B,OAAOM,cAAcoB,OAAO;AAC9B,EAAC"}},
    {"offset": {"line": 9254, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 9260, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/payload/src/fields/hooks/beforeDuplicate/runHook.ts"],"sourcesContent":["import type { FieldHookArgs } from '../../config/types.js'\n\nexport const runBeforeDuplicateHooks = async (args: FieldHookArgs) =>\n  await args.field.hooks.beforeDuplicate.reduce(async (priorHook, currentHook) => {\n    await priorHook\n    return await currentHook(args)\n  }, Promise.resolve())\n"],"names":["runBeforeDuplicateHooks","args","field","hooks","beforeDuplicate","reduce","priorHook","currentHook","Promise","resolve"],"mappings":";;;AAEO,MAAMA,0BAA0B,OAAOC,OAC5C,MAAMA,KAAKC,KAAK,CAACC,KAAK,CAACC,eAAe,CAACC,MAAM,CAAC,OAAOC,WAAWC;QAC9D,MAAMD;QACN,OAAO,MAAMC,YAAYN;IAC3B,GAAGO,QAAQC,OAAO,IAAG"}},
    {"offset": {"line": 9267, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 9273, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/payload/src/fields/hooks/beforeDuplicate/promise.ts"],"sourcesContent":["import type { SanitizedCollectionConfig } from '../../../collections/config/types.js'\nimport type { JsonObject, PayloadRequest, RequestContext } from '../../../types/index.js'\nimport type { Field, FieldHookArgs, TabAsField } from '../../config/types.js'\n\nimport { fieldAffectsData, tabHasName } from '../../config/types.js'\nimport { getFieldPaths } from '../../getFieldPaths.js'\nimport { runBeforeDuplicateHooks } from './runHook.js'\nimport { traverseFields } from './traverseFields.js'\n\ntype Args<T> = {\n  collection: null | SanitizedCollectionConfig\n  context: RequestContext\n  doc: T\n  field: Field | TabAsField\n  id?: number | string\n  overrideAccess: boolean\n  parentPath: (number | string)[]\n  parentSchemaPath: string[]\n  req: PayloadRequest\n  siblingDoc: JsonObject\n}\n\nexport const promise = async <T>({\n  id,\n  collection,\n  context,\n  doc,\n  field,\n  overrideAccess,\n  parentPath,\n  parentSchemaPath,\n  req,\n  siblingDoc,\n}: Args<T>): Promise<void> => {\n  const { localization } = req.payload.config\n\n  const { path: fieldPath, schemaPath: fieldSchemaPath } = getFieldPaths({\n    field,\n    parentPath,\n    parentSchemaPath,\n  })\n\n  // Handle unnamed tabs\n  if (field.type === 'tab' && !tabHasName(field)) {\n    await traverseFields({\n      id,\n      collection,\n      context,\n      doc,\n      fields: field.fields,\n      overrideAccess,\n      path: fieldPath,\n      req,\n      schemaPath: fieldSchemaPath,\n      siblingDoc,\n    })\n\n    return\n  }\n\n  if (fieldAffectsData(field)) {\n    let fieldData = siblingDoc?.[field.name]\n    const fieldIsLocalized = field.localized && localization\n\n    // Run field beforeDuplicate hooks\n    if (Array.isArray(field.hooks?.beforeDuplicate)) {\n      if (fieldIsLocalized) {\n        const localeData = await localization.localeCodes.reduce(\n          async (localizedValuesPromise: Promise<JsonObject>, locale) => {\n            const localizedValues = await localizedValuesPromise\n\n            const beforeDuplicateArgs: FieldHookArgs = {\n              collection,\n              context,\n              data: doc,\n              field,\n              global: undefined,\n              path: fieldPath,\n              previousSiblingDoc: siblingDoc,\n              previousValue: siblingDoc[field.name]?.[locale],\n              req,\n              schemaPath: parentSchemaPath,\n              siblingData: siblingDoc,\n              siblingDocWithLocales: siblingDoc,\n              value: siblingDoc[field.name]?.[locale],\n            }\n\n            const hookResult = await runBeforeDuplicateHooks(beforeDuplicateArgs)\n\n            if (typeof hookResult !== 'undefined') {\n              return {\n                ...localizedValues,\n                [locale]: hookResult,\n              }\n            }\n\n            return localizedValuesPromise\n          },\n          Promise.resolve({}),\n        )\n\n        siblingDoc[field.name] = localeData\n      } else {\n        const beforeDuplicateArgs: FieldHookArgs = {\n          collection,\n          context,\n          data: doc,\n          field,\n          global: undefined,\n          path: fieldPath,\n          previousSiblingDoc: siblingDoc,\n          previousValue: siblingDoc[field.name],\n          req,\n          schemaPath: parentSchemaPath,\n          siblingData: siblingDoc,\n          siblingDocWithLocales: siblingDoc,\n          value: siblingDoc[field.name],\n        }\n\n        const hookResult = await runBeforeDuplicateHooks(beforeDuplicateArgs)\n        if (typeof hookResult !== 'undefined') {\n          siblingDoc[field.name] = hookResult\n        }\n      }\n    }\n\n    // First, for any localized fields, we will loop over locales\n    // and if locale data is present, traverse the sub fields.\n    // There are only a few different fields where this is possible.\n    if (fieldIsLocalized) {\n      if (typeof fieldData !== 'object' || fieldData === null) {\n        siblingDoc[field.name] = {}\n        fieldData = siblingDoc[field.name]\n      }\n\n      const promises = []\n\n      localization.localeCodes.forEach((locale) => {\n        if (fieldData[locale]) {\n          switch (field.type) {\n            case 'tab':\n            case 'group': {\n              promises.push(\n                traverseFields({\n                  id,\n                  collection,\n                  context,\n                  doc,\n                  fields: field.fields,\n                  overrideAccess,\n                  path: fieldSchemaPath,\n                  req,\n                  schemaPath: fieldSchemaPath,\n                  siblingDoc: fieldData[locale],\n                }),\n              )\n\n              break\n            }\n\n            case 'array': {\n              const rows = fieldData[locale]\n\n              if (Array.isArray(rows)) {\n                const promises = []\n                rows.forEach((row, i) => {\n                  promises.push(\n                    traverseFields({\n                      id,\n                      collection,\n                      context,\n                      doc,\n                      fields: field.fields,\n                      overrideAccess,\n                      path: [...fieldPath, i],\n                      req,\n                      schemaPath: fieldSchemaPath,\n                      siblingDoc: row,\n                    }),\n                  )\n                })\n              }\n              break\n            }\n\n            case 'blocks': {\n              const rows = fieldData[locale]\n\n              if (Array.isArray(rows)) {\n                const promises = []\n                rows.forEach((row, i) => {\n                  const blockTypeToMatch = row.blockType\n\n                  const block = field.blocks.find(\n                    (blockType) => blockType.slug === blockTypeToMatch,\n                  )\n\n                  promises.push(\n                    traverseFields({\n                      id,\n                      collection,\n                      context,\n                      doc,\n                      fields: block.fields,\n                      overrideAccess,\n                      path: [...fieldPath, i],\n                      req,\n                      schemaPath: fieldSchemaPath,\n                      siblingDoc: row,\n                    }),\n                  )\n                })\n              }\n              break\n            }\n          }\n        }\n      })\n\n      await Promise.all(promises)\n    } else {\n      // If the field is not localized, but it affects data,\n      // we need to further traverse its children\n      // so the child fields can run beforeDuplicate hooks\n      switch (field.type) {\n        case 'tab':\n        case 'group': {\n          if (typeof siblingDoc[field.name] !== 'object') {\n            siblingDoc[field.name] = {}\n          }\n\n          const groupDoc = siblingDoc[field.name] as Record<string, unknown>\n\n          await traverseFields({\n            id,\n            collection,\n            context,\n            doc,\n            fields: field.fields,\n            overrideAccess,\n            path: fieldPath,\n            req,\n            schemaPath: fieldSchemaPath,\n            siblingDoc: groupDoc as JsonObject,\n          })\n\n          break\n        }\n\n        case 'array': {\n          const rows = siblingDoc[field.name]\n\n          if (Array.isArray(rows)) {\n            const promises = []\n            rows.forEach((row, i) => {\n              promises.push(\n                traverseFields({\n                  id,\n                  collection,\n                  context,\n                  doc,\n                  fields: field.fields,\n                  overrideAccess,\n                  path: [...fieldPath, i],\n                  req,\n                  schemaPath: fieldSchemaPath,\n                  siblingDoc: row,\n                }),\n              )\n            })\n            await Promise.all(promises)\n          }\n          break\n        }\n\n        case 'blocks': {\n          const rows = siblingDoc[field.name]\n\n          if (Array.isArray(rows)) {\n            const promises = []\n            rows.forEach((row, i) => {\n              const blockTypeToMatch = row.blockType\n              const block = field.blocks.find((blockType) => blockType.slug === blockTypeToMatch)\n\n              if (block) {\n                ;(row as JsonObject).blockType = blockTypeToMatch\n\n                promises.push(\n                  traverseFields({\n                    id,\n                    collection,\n                    context,\n                    doc,\n                    fields: block.fields,\n                    overrideAccess,\n                    path: [...fieldPath, i],\n                    req,\n                    schemaPath: fieldSchemaPath,\n                    siblingDoc: row,\n                  }),\n                )\n              }\n            })\n            await Promise.all(promises)\n          }\n\n          break\n        }\n      }\n    }\n  } else {\n    // Finally, we traverse fields which do not affect data here\n    switch (field.type) {\n      case 'row':\n      case 'collapsible': {\n        await traverseFields({\n          id,\n          collection,\n          context,\n          doc,\n          fields: field.fields,\n          overrideAccess,\n          path: fieldPath,\n          req,\n          schemaPath: fieldSchemaPath,\n          siblingDoc,\n        })\n\n        break\n      }\n\n      case 'tabs': {\n        await traverseFields({\n          id,\n          collection,\n          context,\n          doc,\n          fields: field.tabs.map((tab) => ({ ...tab, type: 'tab' })),\n          overrideAccess,\n          path: fieldPath,\n          req,\n          schemaPath: fieldSchemaPath,\n          siblingDoc,\n        })\n\n        break\n      }\n\n      default: {\n        break\n      }\n    }\n  }\n}\n"],"names":["fieldAffectsData","tabHasName","getFieldPaths","runBeforeDuplicateHooks","traverseFields","promise","id","collection","context","doc","field","overrideAccess","parentPath","parentSchemaPath","req","siblingDoc","localization","payload","config","path","fieldPath","schemaPath","fieldSchemaPath","type","fields","fieldData","name","fieldIsLocalized","localized","Array","isArray","hooks","beforeDuplicate","localeData","localeCodes","reduce","localizedValuesPromise","locale","localizedValues","beforeDuplicateArgs","data","global","undefined","previousSiblingDoc","previousValue","siblingData","siblingDocWithLocales","value","hookResult","Promise","resolve","promises","forEach","push","rows","row","i","blockTypeToMatch","blockType","block","blocks","find","slug","all","groupDoc","tabs","map","tab"],"mappings":"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"}},
    {"offset": {"line": 9578, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 9584, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/payload/src/fields/hooks/beforeDuplicate/traverseFields.ts"],"sourcesContent":["import type { SanitizedCollectionConfig } from '../../../collections/config/types.js'\nimport type { JsonObject, PayloadRequest, RequestContext } from '../../../types/index.js'\nimport type { Field, TabAsField } from '../../config/types.js'\n\nimport { promise } from './promise.js'\n\ntype Args<T> = {\n  collection: null | SanitizedCollectionConfig\n  context: RequestContext\n  doc: T\n  fields: (Field | TabAsField)[]\n  id?: number | string\n  overrideAccess: boolean\n  path: (number | string)[]\n  req: PayloadRequest\n  schemaPath: string[]\n  siblingDoc: JsonObject\n}\n\nexport const traverseFields = async <T>({\n  id,\n  collection,\n  context,\n  doc,\n  fields,\n  overrideAccess,\n  path,\n  req,\n  schemaPath,\n  siblingDoc,\n}: Args<T>): Promise<void> => {\n  const promises = []\n  fields.forEach((field) => {\n    promises.push(\n      promise({\n        id,\n        collection,\n        context,\n        doc,\n        field,\n        overrideAccess,\n        parentPath: path,\n        parentSchemaPath: schemaPath,\n        req,\n        siblingDoc,\n      }),\n    )\n  })\n  await Promise.all(promises)\n}\n"],"names":["promise","traverseFields","id","collection","context","doc","fields","overrideAccess","path","req","schemaPath","siblingDoc","promises","forEach","field","push","parentPath","parentSchemaPath","Promise","all"],"mappings":";;;AAIA,SAASA,OAAO,QAAQ,eAAc;;AAe/B,MAAMC,iBAAiB,OAAU,EACtCC,EAAE,EACFC,UAAU,EACVC,OAAO,EACPC,GAAG,EACHC,MAAM,EACNC,cAAc,EACdC,IAAI,EACJC,GAAG,EACHC,UAAU,EACVC,UAAU,EACF;IACR,MAAMC,WAAW,EAAE;IACnBN,OAAOO,OAAO,CAAC,CAACC;QACdF,SAASG,IAAI,sLACXf,UAAAA,EAAQ;YACNE;YACAC;YACAC;YACAC;YACAS;YACAP;YACAS,YAAYR;YACZS,kBAAkBP;YAClBD;YACAE;QACF;IAEJ;IACA,MAAMO,QAAQC,GAAG,CAACP;AACpB,EAAC"}},
    {"offset": {"line": 9607, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 9613, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/payload/src/fields/hooks/beforeDuplicate/index.ts"],"sourcesContent":["import type { SanitizedCollectionConfig } from '../../../collections/config/types.js'\nimport type { JsonObject, PayloadRequest, RequestContext } from '../../../types/index.js'\n\nimport { deepCopyObjectSimple } from '../../../utilities/deepCopyObject.js'\nimport { traverseFields } from './traverseFields.js'\n\ntype Args<T extends JsonObject> = {\n  collection: null | SanitizedCollectionConfig\n  context: RequestContext\n  doc?: T\n  id?: number | string\n  overrideAccess: boolean\n  req: PayloadRequest\n}\n\n/**\n * This function is responsible for running beforeDuplicate hooks\n * against a document including all locale data.\n * It will run each field's beforeDuplicate hook\n * and return the resulting docWithLocales.\n */\nexport const beforeDuplicate = async <T extends JsonObject>({\n  id,\n  collection,\n  context,\n  doc,\n  overrideAccess,\n  req,\n}: Args<T>): Promise<T> => {\n  const newDoc = deepCopyObjectSimple(doc)\n\n  await traverseFields({\n    id,\n    collection,\n    context,\n    doc: newDoc,\n    fields: collection?.fields,\n    overrideAccess,\n    path: [],\n    req,\n    schemaPath: [],\n    siblingDoc: newDoc,\n  })\n\n  return newDoc\n}\n"],"names":["deepCopyObjectSimple","traverseFields","beforeDuplicate","id","collection","context","doc","overrideAccess","req","newDoc","fields","path","schemaPath","siblingDoc"],"mappings":";;;AAGA,SAASA,oBAAoB,QAAQ,uCAAsC;AAC3E,SAASC,cAAc,QAAQ,sBAAqB;;;AAiB7C,MAAMC,kBAAkB,OAA6B,EAC1DC,EAAE,EACFC,UAAU,EACVC,OAAO,EACPC,GAAG,EACHC,cAAc,EACdC,GAAG,EACK;IACR,MAAMC,4KAAST,uBAAAA,EAAqBM;IAEpC,kMAAML,iBAAAA,EAAe;QACnBE;QACAC;QACAC;QACAC,KAAKG;QACLC,QAAQN,YAAYM;QACpBH;QACAI,MAAM,EAAE;QACRH;QACAI,YAAY,EAAE;QACdC,YAAYJ;IACd;IAEA,OAAOA;AACT,EAAC"}},
    {"offset": {"line": 9636, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 9642, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/payload/src/collections/operations/duplicate.ts"],"sourcesContent":["import type { DeepPartial } from 'ts-essentials'\n\nimport httpStatus from 'http-status'\n\nimport type { FindOneArgs } from '../../database/types.js'\nimport type { CollectionSlug } from '../../index.js'\nimport type { PayloadRequest } from '../../types/index.js'\nimport type { Collection, DataFromCollectionSlug } from '../config/types.js'\n\nimport executeAccess from '../../auth/executeAccess.js'\nimport { hasWhereAccessResult } from '../../auth/types.js'\nimport { combineQueries } from '../../database/combineQueries.js'\nimport { APIError, Forbidden, NotFound } from '../../errors/index.js'\nimport { afterChange } from '../../fields/hooks/afterChange/index.js'\nimport { afterRead } from '../../fields/hooks/afterRead/index.js'\nimport { beforeChange } from '../../fields/hooks/beforeChange/index.js'\nimport { beforeDuplicate } from '../../fields/hooks/beforeDuplicate/index.js'\nimport { beforeValidate } from '../../fields/hooks/beforeValidate/index.js'\nimport { generateFileData } from '../../uploads/generateFileData.js'\nimport { uploadFiles } from '../../uploads/uploadFiles.js'\nimport { commitTransaction } from '../../utilities/commitTransaction.js'\nimport { initTransaction } from '../../utilities/initTransaction.js'\nimport { killTransaction } from '../../utilities/killTransaction.js'\nimport { getLatestCollectionVersion } from '../../versions/getLatestCollectionVersion.js'\nimport { saveVersion } from '../../versions/saveVersion.js'\nimport { buildAfterOperation } from './utils.js'\n\nexport type Arguments = {\n  collection: Collection\n  depth?: number\n  disableTransaction?: boolean\n  draft?: boolean\n  id: number | string\n  overrideAccess?: boolean\n  req: PayloadRequest\n  showHiddenFields?: boolean\n}\n\nexport const duplicateOperation = async <TSlug extends CollectionSlug>(\n  incomingArgs: Arguments,\n): Promise<DataFromCollectionSlug<TSlug>> => {\n  let args = incomingArgs\n  const operation = 'create'\n\n  try {\n    const shouldCommit = !args.disableTransaction && (await initTransaction(args.req))\n\n    // /////////////////////////////////////\n    // beforeOperation - Collection\n    // /////////////////////////////////////\n\n    await args.collection.config.hooks.beforeOperation.reduce(async (priorHook, hook) => {\n      await priorHook\n\n      args =\n        (await hook({\n          args,\n          collection: args.collection.config,\n          context: args.req.context,\n          operation,\n          req: args.req,\n        })) || args\n    }, Promise.resolve())\n\n    const {\n      id,\n      collection: { config: collectionConfig },\n      depth,\n      draft: draftArg = true,\n      overrideAccess,\n      req: { fallbackLocale, locale: localeArg, payload },\n      req,\n      showHiddenFields,\n    } = args\n\n    if (!id) {\n      throw new APIError('Missing ID of document to duplicate.', httpStatus.BAD_REQUEST)\n    }\n    const shouldSaveDraft = Boolean(draftArg && collectionConfig.versions.drafts)\n\n    // /////////////////////////////////////\n    // Read Access\n    // /////////////////////////////////////\n\n    const accessResults = !overrideAccess\n      ? await executeAccess({ id, req }, collectionConfig.access.read)\n      : true\n    const hasWherePolicy = hasWhereAccessResult(accessResults)\n\n    // /////////////////////////////////////\n    // Retrieve document\n    // /////////////////////////////////////\n    const findOneArgs: FindOneArgs = {\n      collection: collectionConfig.slug,\n      locale: req.locale,\n      req,\n      where: combineQueries({ id: { equals: id } }, accessResults),\n    }\n\n    let docWithLocales = await getLatestCollectionVersion({\n      id,\n      config: collectionConfig,\n      payload,\n      query: findOneArgs,\n      req,\n    })\n\n    if (!docWithLocales && !hasWherePolicy) {\n      throw new NotFound(req.t)\n    }\n    if (!docWithLocales && hasWherePolicy) {\n      throw new Forbidden(req.t)\n    }\n\n    // remove the createdAt timestamp and id to rely on the db to set the default it\n    delete docWithLocales.createdAt\n    delete docWithLocales.id\n\n    docWithLocales = await beforeDuplicate({\n      id,\n      collection: collectionConfig,\n      context: req.context,\n      doc: docWithLocales,\n      overrideAccess,\n      req,\n    })\n\n    // for version enabled collections, override the current status with draft, unless draft is explicitly set to false\n    if (shouldSaveDraft) {\n      docWithLocales._status = 'draft'\n    }\n\n    let result\n\n    let originalDoc = await afterRead({\n      collection: collectionConfig,\n      context: req.context,\n      depth: 0,\n      doc: docWithLocales,\n      draft: draftArg,\n      fallbackLocale: null,\n      global: null,\n      locale: req.locale,\n      overrideAccess: true,\n      req,\n      showHiddenFields: true,\n    })\n\n    const { data: newFileData, files: filesToUpload } = await generateFileData({\n      collection: args.collection,\n      config: req.payload.config,\n      data: originalDoc,\n      operation: 'create',\n      overwriteExistingFiles: 'forceDisable',\n      req,\n      throwOnMissingFile: true,\n    })\n\n    originalDoc = newFileData\n\n    // /////////////////////////////////////\n    // Create Access\n    // /////////////////////////////////////\n\n    if (!overrideAccess) {\n      await executeAccess({ data: originalDoc, req }, collectionConfig.access.create)\n    }\n\n    // /////////////////////////////////////\n    // beforeValidate - Fields\n    // /////////////////////////////////////\n\n    let data = await beforeValidate<DeepPartial<DataFromCollectionSlug<TSlug>>>({\n      id,\n      collection: collectionConfig,\n      context: req.context,\n      data: originalDoc,\n      doc: originalDoc,\n      duplicate: true,\n      global: null,\n      operation,\n      overrideAccess,\n      req,\n    })\n\n    // /////////////////////////////////////\n    // beforeValidate - Collection\n    // /////////////////////////////////////\n\n    await collectionConfig.hooks.beforeValidate.reduce(async (priorHook, hook) => {\n      await priorHook\n\n      data =\n        (await hook({\n          collection: collectionConfig,\n          context: req.context,\n          data,\n          operation,\n          originalDoc,\n          req,\n        })) || result\n    }, Promise.resolve())\n\n    // /////////////////////////////////////\n    // beforeChange - Collection\n    // /////////////////////////////////////\n\n    await collectionConfig.hooks.beforeChange.reduce(async (priorHook, hook) => {\n      await priorHook\n\n      data =\n        (await hook({\n          collection: collectionConfig,\n          context: req.context,\n          data,\n          operation,\n          originalDoc: result,\n          req,\n        })) || result\n    }, Promise.resolve())\n\n    // /////////////////////////////////////\n    // beforeChange - Fields\n    // /////////////////////////////////////\n\n    result = await beforeChange({\n      id,\n      collection: collectionConfig,\n      context: req.context,\n      data,\n      doc: originalDoc,\n      docWithLocales,\n      global: null,\n      operation,\n      req,\n      skipValidation:\n        shouldSaveDraft &&\n        collectionConfig.versions.drafts &&\n        !collectionConfig.versions.drafts.validate,\n    })\n\n    // set req.locale back to the original locale\n    req.locale = localeArg\n\n    // /////////////////////////////////////\n    // Create / Update\n    // /////////////////////////////////////\n\n    // /////////////////////////////////////\n    // Write files to local storage\n    // /////////////////////////////////////\n\n    if (!collectionConfig.upload.disableLocalStorage) {\n      await uploadFiles(payload, filesToUpload, req)\n    }\n\n    const versionDoc = await payload.db.create({\n      collection: collectionConfig.slug,\n      data: result,\n      req,\n    })\n\n    // /////////////////////////////////////\n    // Create version\n    // /////////////////////////////////////\n\n    if (collectionConfig.versions) {\n      result = await saveVersion({\n        id: versionDoc.id,\n        collection: collectionConfig,\n        docWithLocales: versionDoc,\n        draft: shouldSaveDraft,\n        payload,\n        req,\n      })\n    }\n\n    // /////////////////////////////////////\n    // afterRead - Fields\n    // /////////////////////////////////////\n\n    result = await afterRead({\n      collection: collectionConfig,\n      context: req.context,\n      depth,\n      doc: versionDoc,\n      draft: draftArg,\n      fallbackLocale,\n      global: null,\n      locale: localeArg,\n      overrideAccess,\n      req,\n      showHiddenFields,\n    })\n\n    // /////////////////////////////////////\n    // afterRead - Collection\n    // /////////////////////////////////////\n\n    await collectionConfig.hooks.afterRead.reduce(async (priorHook, hook) => {\n      await priorHook\n\n      result =\n        (await hook({\n          collection: collectionConfig,\n          context: req.context,\n          doc: result,\n          req,\n        })) || result\n    }, Promise.resolve())\n\n    // /////////////////////////////////////\n    // afterChange - Fields\n    // /////////////////////////////////////\n\n    result = await afterChange({\n      collection: collectionConfig,\n      context: req.context,\n      data: versionDoc,\n      doc: result,\n      global: null,\n      operation,\n      previousDoc: {},\n      req,\n    })\n\n    // /////////////////////////////////////\n    // afterChange - Collection\n    // /////////////////////////////////////\n\n    await collectionConfig.hooks.afterChange.reduce(async (priorHook, hook) => {\n      await priorHook\n\n      result =\n        (await hook({\n          collection: collectionConfig,\n          context: req.context,\n          doc: result,\n          operation,\n          previousDoc: {},\n          req,\n        })) || result\n    }, Promise.resolve())\n\n    // /////////////////////////////////////\n    // afterOperation - Collection\n    // /////////////////////////////////////\n\n    result = await buildAfterOperation({\n      args,\n      collection: collectionConfig,\n      operation,\n      result,\n    })\n\n    // /////////////////////////////////////\n    // Return results\n    // /////////////////////////////////////\n\n    if (shouldCommit) {\n      await commitTransaction(req)\n    }\n\n    return result\n  } catch (error: unknown) {\n    await killTransaction(args.req)\n    throw error\n  }\n}\n"],"names":["httpStatus","executeAccess","hasWhereAccessResult","combineQueries","APIError","Forbidden","NotFound","afterChange","afterRead","beforeChange","beforeDuplicate","beforeValidate","generateFileData","uploadFiles","commitTransaction","initTransaction","killTransaction","getLatestCollectionVersion","saveVersion","buildAfterOperation","duplicateOperation","incomingArgs","args","operation","shouldCommit","disableTransaction","req","collection","config","hooks","beforeOperation","reduce","priorHook","hook","context","Promise","resolve","id","collectionConfig","depth","draft","draftArg","overrideAccess","fallbackLocale","locale","localeArg","payload","showHiddenFields","BAD_REQUEST","shouldSaveDraft","Boolean","versions","drafts","accessResults","access","read","hasWherePolicy","findOneArgs","slug","where","equals","docWithLocales","query","t","createdAt","doc","_status","result","originalDoc","global","data","newFileData","files","filesToUpload","overwriteExistingFiles","throwOnMissingFile","create","duplicate","skipValidation","validate","upload","disableLocalStorage","versionDoc","db","previousDoc","error"],"mappings":"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"}},
    {"offset": {"line": 9951, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 9957, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/payload/src/collections/operations/local/duplicate.ts"],"sourcesContent":["import type { CollectionSlug, TypedLocale } from '../../..//index.js'\nimport type { Payload } from '../../../index.js'\nimport type { Document, PayloadRequest, RequestContext } from '../../../types/index.js'\nimport type { DataFromCollectionSlug } from '../../config/types.js'\n\nimport { APIError } from '../../../errors/index.js'\nimport { createLocalReq } from '../../../utilities/createLocalReq.js'\nimport { duplicateOperation } from '../duplicate.js'\n\nexport type Options<TSlug extends CollectionSlug> = {\n  collection: TSlug\n  /**\n   * context, which will then be passed to req.context, which can be read by hooks\n   */\n  context?: RequestContext\n  depth?: number\n  disableTransaction?: boolean\n  draft?: boolean\n  fallbackLocale?: TypedLocale\n  id: number | string\n  locale?: TypedLocale\n  overrideAccess?: boolean\n  req?: PayloadRequest\n  showHiddenFields?: boolean\n  user?: Document\n}\n\nexport async function duplicate<TSlug extends CollectionSlug>(\n  payload: Payload,\n  options: Options<TSlug>,\n): Promise<DataFromCollectionSlug<TSlug>> {\n  const {\n    id,\n    collection: collectionSlug,\n    depth,\n    disableTransaction,\n    draft,\n    overrideAccess = true,\n    showHiddenFields,\n  } = options\n  const collection = payload.collections[collectionSlug]\n\n  if (!collection) {\n    throw new APIError(\n      `The collection with slug ${String(collectionSlug)} can't be found. Duplicate Operation.`,\n    )\n  }\n\n  if (collection.config.disableDuplicate === true) {\n    throw new APIError(\n      `The collection with slug ${String(collectionSlug)} cannot be duplicated.`,\n      400,\n    )\n  }\n\n  const req = await createLocalReq(options, payload)\n\n  return duplicateOperation<TSlug>({\n    id,\n    collection,\n    depth,\n    disableTransaction,\n    draft,\n    overrideAccess,\n    req,\n    showHiddenFields,\n  })\n}\n"],"names":["APIError","createLocalReq","duplicateOperation","duplicate","payload","options","id","collection","collectionSlug","depth","disableTransaction","draft","overrideAccess","showHiddenFields","collections","String","config","disableDuplicate","req"],"mappings":";;;AAKA,SAASA,QAAQ,QAAQ,2BAA0B;AACnD,SAASC,cAAc,QAAQ,uCAAsC;AACrE,SAASC,kBAAkB,QAAQ,kBAAiB;;;;AAoB7C,eAAeC,UACpBC,OAAgB,EAChBC,OAAuB;IAEvB,MAAM,EACJC,EAAE,EACFC,YAAYC,cAAc,EAC1BC,KAAK,EACLC,kBAAkB,EAClBC,KAAK,EACLC,iBAAiB,IAAI,EACrBC,gBAAgB,EACjB,GAAGR;IACJ,MAAME,aAAaH,QAAQU,WAAW,CAACN,eAAe;IAEtD,IAAI,CAACD,YAAY;QACf,MAAM,0JAAIP,WAAAA,CACR,CAAC,yBAAyB,EAAEe,OAAOP,gBAAgB,qCAAqC,CAAC;IAE7F;IAEA,IAAID,WAAWS,MAAM,CAACC,gBAAgB,KAAK,MAAM;QAC/C,MAAM,0JAAIjB,WAAAA,CACR,CAAC,yBAAyB,EAAEe,OAAOP,gBAAgB,sBAAsB,CAAC,EAC1E;IAEJ;IAEA,MAAMU,MAAM,yKAAMjB,iBAAAA,EAAeI,SAASD;IAE1C,qLAAOF,qBAAAA,EAA0B;QAC/BI;QACAC;QACAE;QACAC;QACAC;QACAC;QACAM;QACAL;IACF;AACF"}},
    {"offset": {"line": 9987, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 9993, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/payload/src/versions/baseFields.ts"],"sourcesContent":["import type { Field } from '../fields/config/types.js'\n\nexport const statuses = [\n  {\n    label: ({ t }) => t('version:draft'),\n    value: 'draft',\n  },\n  {\n    label: ({ t }) => t('version:published'),\n    value: 'published',\n  },\n]\n\nconst baseVersionFields: Field[] = [\n  {\n    name: '_status',\n    type: 'select',\n    admin: {\n      components: {\n        Field: false,\n      },\n      disableBulkEdit: true,\n    },\n    defaultValue: 'draft',\n    index: true,\n    label: ({ t }) => t('version:status'),\n    options: statuses,\n  },\n]\n\n// When publishing a specific locale,\n// we need to create a new draft which acts as a\n// \"snapshot\" to retain all existing draft data.\n// This field will be used to exclude any snapshot versions\n// from the admin Versions list\nexport const versionSnapshotField: Field = {\n  name: 'snapshot',\n  type: 'checkbox',\n  admin: {\n    disableBulkEdit: true,\n    disabled: true,\n  },\n  index: true,\n}\n\nexport default baseVersionFields\n"],"names":["statuses","label","t","value","baseVersionFields","name","type","admin","components","Field","disableBulkEdit","defaultValue","index","options","versionSnapshotField","disabled"],"mappings":";;;;;AAEO,MAAMA,WAAW;IACtB;QACEC,OAAO,CAAC,EAAEC,CAAC,EAAE,GAAKA,EAAE;QACpBC,OAAO;IACT;IACA;QACEF,OAAO,CAAC,EAAEC,CAAC,EAAE,GAAKA,EAAE;QACpBC,OAAO;IACT;CACD,CAAA;AAED,MAAMC,oBAA6B;IACjC;QACEC,MAAM;QACNC,MAAM;QACNC,OAAO;YACLC,YAAY;gBACVC,OAAO;YACT;YACAC,iBAAiB;QACnB;QACAC,cAAc;QACdC,OAAO;QACPX,OAAO,CAAC,EAAEC,CAAC,EAAE,GAAKA,EAAE;QACpBW,SAASb;IACX;CACD;AAOM,MAAMc,uBAA8B;IACzCT,MAAM;IACNC,MAAM;IACNC,OAAO;QACLG,iBAAiB;QACjBK,UAAU;IACZ;IACAH,OAAO;AACT,EAAC;uCAEcR,kBAAiB"}},
    {"offset": {"line": 10035, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 10041, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/payload/src/versions/buildCollectionFields.ts"],"sourcesContent":["import type { SanitizedCollectionConfig } from '../collections/config/types.js'\nimport type { SanitizedConfig } from '../config/types.js'\nimport type { Field } from '../fields/config/types.js'\n\nimport { versionSnapshotField } from './baseFields.js'\n\nexport const buildVersionCollectionFields = (\n  config: SanitizedConfig,\n  collection: SanitizedCollectionConfig,\n): Field[] => {\n  const fields: Field[] = [\n    {\n      name: 'parent',\n      type: 'relationship',\n      index: true,\n      relationTo: collection.slug,\n    },\n    {\n      name: 'version',\n      type: 'group',\n      fields: collection.fields.filter((field) => !('name' in field) || field.name !== 'id'),\n    },\n    {\n      name: 'createdAt',\n      type: 'date',\n      admin: {\n        disabled: true,\n      },\n      index: true,\n    },\n    {\n      name: 'updatedAt',\n      type: 'date',\n      admin: {\n        disabled: true,\n      },\n      index: true,\n    },\n  ]\n\n  if (collection?.versions?.drafts) {\n    if (config.localization) {\n      fields.push(versionSnapshotField)\n\n      fields.push({\n        name: 'publishedLocale',\n        type: 'select',\n        admin: {\n          disableBulkEdit: true,\n          disabled: true,\n        },\n        index: true,\n        options: config.localization.locales.map((locale) => {\n          if (typeof locale === 'string') {\n            return locale\n          }\n\n          return locale.code\n        }),\n      })\n    }\n\n    fields.push({\n      name: 'latest',\n      type: 'checkbox',\n      admin: {\n        disabled: true,\n      },\n      index: true,\n    })\n\n    if (collection?.versions?.drafts?.autosave) {\n      fields.push({\n        name: 'autosave',\n        type: 'checkbox',\n        index: true,\n      })\n    }\n  }\n\n  return fields\n}\n"],"names":["versionSnapshotField","buildVersionCollectionFields","config","collection","fields","name","type","index","relationTo","slug","filter","field","admin","disabled","versions","drafts","localization","push","disableBulkEdit","options","locales","map","locale","code","autosave"],"mappings":";;;AAIA,SAASA,oBAAoB,QAAQ,kBAAiB;;AAE/C,MAAMC,+BAA+B,CAC1CC,QACAC;IAEA,MAAMC,SAAkB;QACtB;YACEC,MAAM;YACNC,MAAM;YACNC,OAAO;YACPC,YAAYL,WAAWM,IAAI;QAC7B;QACA;YACEJ,MAAM;YACNC,MAAM;YACNF,QAAQD,WAAWC,MAAM,CAACM,MAAM,CAAC,CAACC,QAAU,CAAE,CAAA,UAAUA,KAAI,KAAMA,MAAMN,IAAI,KAAK;QACnF;QACA;YACEA,MAAM;YACNC,MAAM;YACNM,OAAO;gBACLC,UAAU;YACZ;YACAN,OAAO;QACT;QACA;YACEF,MAAM;YACNC,MAAM;YACNM,OAAO;gBACLC,UAAU;YACZ;YACAN,OAAO;QACT;KACD;IAED,IAAIJ,YAAYW,UAAUC,QAAQ;QAChC,IAAIb,OAAOc,YAAY,EAAE;YACvBZ,OAAOa,IAAI,2JAACjB,uBAAAA;YAEZI,OAAOa,IAAI,CAAC;gBACVZ,MAAM;gBACNC,MAAM;gBACNM,OAAO;oBACLM,iBAAiB;oBACjBL,UAAU;gBACZ;gBACAN,OAAO;gBACPY,SAASjB,OAAOc,YAAY,CAACI,OAAO,CAACC,GAAG,CAAC,CAACC;oBACxC,IAAI,OAAOA,WAAW,UAAU;wBAC9B,OAAOA;oBACT;oBAEA,OAAOA,OAAOC,IAAI;gBACpB;YACF;QACF;QAEAnB,OAAOa,IAAI,CAAC;YACVZ,MAAM;YACNC,MAAM;YACNM,OAAO;gBACLC,UAAU;YACZ;YACAN,OAAO;QACT;QAEA,IAAIJ,YAAYW,UAAUC,QAAQS,UAAU;YAC1CpB,OAAOa,IAAI,CAAC;gBACVZ,MAAM;gBACNC,MAAM;gBACNC,OAAO;YACT;QACF;IACF;IAEA,OAAOH;AACT,EAAC"}},
    {"offset": {"line": 10113, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 10119, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/payload/src/versions/drafts/getQueryDraftsSort.ts"],"sourcesContent":["import type { SanitizedCollectionConfig } from '../../collections/config/types.js'\nimport type { Sort } from '../../types/index.js'\n\n/**\n * Takes the incoming sort argument and prefixes it with `versions.` and preserves any `-` prefixes for descending order\n * @param sort\n */\nexport const getQueryDraftsSort = ({\n  collectionConfig,\n  sort,\n}: {\n  collectionConfig: SanitizedCollectionConfig\n  sort?: Sort\n}): Sort => {\n  if (!sort) {\n    if (collectionConfig.defaultSort) {\n      sort = collectionConfig.defaultSort\n    } else {\n      sort = '-createdAt'\n    }\n  }\n\n  if (typeof sort === 'string') {\n    sort = [sort]\n  }\n\n  return sort.map((field: string) => {\n    let orderBy: string\n    let direction = ''\n    if (field[0] === '-') {\n      orderBy = field.substring(1)\n      direction = '-'\n    } else {\n      orderBy = field\n    }\n\n    if (orderBy === 'id') {\n      return `${direction}parent`\n    }\n\n    return `${direction}version.${orderBy}`\n  })\n}\n"],"names":["getQueryDraftsSort","collectionConfig","sort","defaultSort","map","field","orderBy","direction","substring"],"mappings":"AAGA;;;CAGC,GACD;;;AAAO,MAAMA,qBAAqB,CAAC,EACjCC,gBAAgB,EAChBC,IAAI,EAIL;IACC,IAAI,CAACA,MAAM;QACT,IAAID,iBAAiBE,WAAW,EAAE;YAChCD,OAAOD,iBAAiBE,WAAW;QACrC,OAAO;YACLD,OAAO;QACT;IACF;IAEA,IAAI,OAAOA,SAAS,UAAU;QAC5BA,OAAO;YAACA;SAAK;IACf;IAEA,OAAOA,KAAKE,GAAG,CAAC,CAACC;QACf,IAAIC;QACJ,IAAIC,YAAY;QAChB,IAAIF,KAAK,CAAC,EAAE,KAAK,KAAK;YACpBC,UAAUD,MAAMG,SAAS,CAAC;YAC1BD,YAAY;QACd,OAAO;YACLD,UAAUD;QACZ;QAEA,IAAIC,YAAY,MAAM;YACpB,OAAO,CAAC,EAAEC,UAAU,MAAM,CAAC;QAC7B;QAEA,OAAO,CAAC,EAAEA,UAAU,QAAQ,EAAED,QAAQ,CAAC;IACzC;AACF,EAAC"}},
    {"offset": {"line": 10153, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 10159, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/payload/src/collections/operations/find.ts"],"sourcesContent":["import type { AccessResult } from '../../config/types.js'\nimport type { PaginatedDocs } from '../../database/types.js'\nimport type { CollectionSlug, JoinQuery } from '../../index.js'\nimport type { PayloadRequest, Sort, Where } from '../../types/index.js'\nimport type { Collection, DataFromCollectionSlug } from '../config/types.js'\n\nimport executeAccess from '../../auth/executeAccess.js'\nimport { combineQueries } from '../../database/combineQueries.js'\nimport { validateQueryPaths } from '../../database/queryValidation/validateQueryPaths.js'\nimport { afterRead } from '../../fields/hooks/afterRead/index.js'\nimport { killTransaction } from '../../utilities/killTransaction.js'\nimport { buildVersionCollectionFields } from '../../versions/buildCollectionFields.js'\nimport { appendVersionToQueryKey } from '../../versions/drafts/appendVersionToQueryKey.js'\nimport { getQueryDraftsSort } from '../../versions/drafts/getQueryDraftsSort.js'\nimport { buildAfterOperation } from './utils.js'\n\nexport type Arguments = {\n  collection: Collection\n  currentDepth?: number\n  depth?: number\n  disableErrors?: boolean\n  draft?: boolean\n  includeLockStatus?: boolean\n  joins?: JoinQuery\n  limit?: number\n  overrideAccess?: boolean\n  page?: number\n  pagination?: boolean\n  req?: PayloadRequest\n  showHiddenFields?: boolean\n  sort?: Sort\n  where?: Where\n}\n\nexport const findOperation = async <TSlug extends CollectionSlug>(\n  incomingArgs: Arguments,\n): Promise<PaginatedDocs<DataFromCollectionSlug<TSlug>>> => {\n  let args = incomingArgs\n\n  try {\n    // /////////////////////////////////////\n    // beforeOperation - Collection\n    // /////////////////////////////////////\n\n    await args.collection.config.hooks.beforeOperation.reduce(async (priorHook, hook) => {\n      await priorHook\n\n      args =\n        (await hook({\n          args,\n          collection: args.collection.config,\n          context: args.req.context,\n          operation: 'read',\n          req: args.req,\n        })) || args\n    }, Promise.resolve())\n\n    const {\n      collection: { config: collectionConfig },\n      collection,\n      currentDepth,\n      depth,\n      disableErrors,\n      draft: draftsEnabled,\n      includeLockStatus,\n      joins,\n      limit,\n      overrideAccess,\n      page,\n      pagination = true,\n      req: { fallbackLocale, locale, payload },\n      req,\n      showHiddenFields,\n      sort,\n      where,\n    } = args\n\n    // /////////////////////////////////////\n    // Access\n    // /////////////////////////////////////\n\n    let accessResult: AccessResult\n\n    if (!overrideAccess) {\n      accessResult = await executeAccess({ disableErrors, req }, collectionConfig.access.read)\n\n      // If errors are disabled, and access returns false, return empty results\n      if (accessResult === false) {\n        return {\n          docs: [],\n          hasNextPage: false,\n          hasPrevPage: false,\n          limit,\n          nextPage: null,\n          page: 1,\n          pagingCounter: 1,\n          prevPage: null,\n          totalDocs: 0,\n          totalPages: 1,\n        }\n      }\n    }\n\n    // /////////////////////////////////////\n    // Find\n    // /////////////////////////////////////\n\n    const usePagination = pagination && limit !== 0\n    const sanitizedLimit = limit ?? (usePagination ? 10 : 0)\n    const sanitizedPage = page || 1\n\n    let result: PaginatedDocs<DataFromCollectionSlug<TSlug>>\n\n    let fullWhere = combineQueries(where, accessResult)\n\n    if (collectionConfig.versions?.drafts && draftsEnabled) {\n      fullWhere = appendVersionToQueryKey(fullWhere)\n\n      await validateQueryPaths({\n        collectionConfig: collection.config,\n        overrideAccess,\n        req,\n        versionFields: buildVersionCollectionFields(payload.config, collection.config),\n        where: fullWhere,\n      })\n\n      result = await payload.db.queryDrafts<DataFromCollectionSlug<TSlug>>({\n        collection: collectionConfig.slug,\n        joins: req.payloadAPI === 'GraphQL' ? false : joins,\n        limit: sanitizedLimit,\n        locale,\n        page: sanitizedPage,\n        pagination: usePagination,\n        req,\n        sort: getQueryDraftsSort({ collectionConfig, sort }),\n        where: fullWhere,\n      })\n    } else {\n      await validateQueryPaths({\n        collectionConfig,\n        overrideAccess,\n        req,\n        where,\n      })\n\n      result = await payload.db.find<DataFromCollectionSlug<TSlug>>({\n        collection: collectionConfig.slug,\n        joins: req.payloadAPI === 'GraphQL' ? false : joins,\n        limit: sanitizedLimit,\n        locale,\n        page: sanitizedPage,\n        pagination,\n        req,\n        sort,\n        where: fullWhere,\n      })\n    }\n\n    if (includeLockStatus) {\n      try {\n        const lockedDocuments = await payload.find({\n          collection: 'payload-locked-documents',\n          depth: 1,\n          limit: sanitizedLimit,\n          pagination: false,\n          req,\n          where: {\n            and: [\n              {\n                'document.relationTo': {\n                  equals: collectionConfig.slug,\n                },\n              },\n              {\n                'document.value': {\n                  in: result.docs.map((doc) => doc.id),\n                },\n              },\n            ],\n          },\n        })\n\n        const lockedDocs = Array.isArray(lockedDocuments?.docs) ? lockedDocuments.docs : []\n\n        result.docs = result.docs.map((doc) => {\n          const lockedDoc = lockedDocs.find((lock) => lock?.document?.value === doc.id)\n          return {\n            ...doc,\n            _isLocked: !!lockedDoc,\n            _userEditing: lockedDoc ? lockedDoc?.user?.value : null,\n          }\n        })\n      } catch (error) {\n        result.docs = result.docs.map((doc) => ({\n          ...doc,\n          _isLocked: false,\n          _userEditing: null,\n        }))\n      }\n    }\n\n    // /////////////////////////////////////\n    // beforeRead - Collection\n    // /////////////////////////////////////\n\n    result = {\n      ...result,\n      docs: await Promise.all(\n        result.docs.map(async (doc) => {\n          let docRef = doc\n\n          await collectionConfig.hooks.beforeRead.reduce(async (priorHook, hook) => {\n            await priorHook\n\n            docRef =\n              (await hook({\n                collection: collectionConfig,\n                context: req.context,\n                doc: docRef,\n                query: fullWhere,\n                req,\n              })) || docRef\n          }, Promise.resolve())\n\n          return docRef\n        }),\n      ),\n    }\n\n    // /////////////////////////////////////\n    // afterRead - Fields\n    // /////////////////////////////////////\n\n    result = {\n      ...result,\n      docs: await Promise.all(\n        result.docs.map(async (doc) =>\n          afterRead<DataFromCollectionSlug<TSlug>>({\n            collection: collectionConfig,\n            context: req.context,\n            currentDepth,\n            depth,\n            doc,\n            draft: draftsEnabled,\n            fallbackLocale,\n            findMany: true,\n            global: null,\n            locale,\n            overrideAccess,\n            req,\n            showHiddenFields,\n          }),\n        ),\n      ),\n    }\n\n    // /////////////////////////////////////\n    // afterRead - Collection\n    // /////////////////////////////////////\n\n    result = {\n      ...result,\n      docs: await Promise.all(\n        result.docs.map(async (doc) => {\n          let docRef = doc\n\n          await collectionConfig.hooks.afterRead.reduce(async (priorHook, hook) => {\n            await priorHook\n\n            docRef =\n              (await hook({\n                collection: collectionConfig,\n                context: req.context,\n                doc: docRef,\n                findMany: true,\n                query: fullWhere,\n                req,\n              })) || doc\n          }, Promise.resolve())\n\n          return docRef\n        }),\n      ),\n    }\n\n    // /////////////////////////////////////\n    // afterOperation - Collection\n    // /////////////////////////////////////\n\n    result = await buildAfterOperation({\n      args,\n      collection: collectionConfig,\n      operation: 'find',\n      result,\n    })\n\n    // /////////////////////////////////////\n    // Return results\n    // /////////////////////////////////////\n\n    return result\n  } catch (error: unknown) {\n    await killTransaction(args.req)\n    throw error\n  }\n}\n"],"names":["executeAccess","combineQueries","validateQueryPaths","afterRead","killTransaction","buildVersionCollectionFields","appendVersionToQueryKey","getQueryDraftsSort","buildAfterOperation","findOperation","incomingArgs","args","collection","config","hooks","beforeOperation","reduce","priorHook","hook","context","req","operation","Promise","resolve","collectionConfig","currentDepth","depth","disableErrors","draft","draftsEnabled","includeLockStatus","joins","limit","overrideAccess","page","pagination","fallbackLocale","locale","payload","showHiddenFields","sort","where","accessResult","access","read","docs","hasNextPage","hasPrevPage","nextPage","pagingCounter","prevPage","totalDocs","totalPages","usePagination","sanitizedLimit","sanitizedPage","result","fullWhere","versions","drafts","versionFields","db","queryDrafts","slug","payloadAPI","find","lockedDocuments","and","equals","in","map","doc","id","lockedDocs","Array","isArray","lockedDoc","lock","document","value","_isLocked","_userEditing","user","error","all","docRef","beforeRead","query","findMany","global"],"mappings":"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"}},
    {"offset": {"line": 10392, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 10398, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/payload/src/collections/operations/local/find.ts"],"sourcesContent":["import type { PaginatedDocs } from '../../../database/types.js'\nimport type { CollectionSlug, JoinQuery, Payload, TypedLocale } from '../../../index.js'\nimport type { Document, PayloadRequest, RequestContext, Sort, Where } from '../../../types/index.js'\nimport type { DataFromCollectionSlug } from '../../config/types.js'\n\nimport { APIError } from '../../../errors/index.js'\nimport { createLocalReq } from '../../../utilities/createLocalReq.js'\nimport { findOperation } from '../find.js'\n\nexport type Options<TSlug extends CollectionSlug> = {\n  collection: TSlug\n  /**\n   * context, which will then be passed to req.context, which can be read by hooks\n   */\n  context?: RequestContext\n  currentDepth?: number\n  depth?: number\n  disableErrors?: boolean\n  draft?: boolean\n  fallbackLocale?: TypedLocale\n  includeLockStatus?: boolean\n  joins?: JoinQuery\n  limit?: number\n  locale?: 'all' | TypedLocale\n  overrideAccess?: boolean\n  page?: number\n  pagination?: boolean\n  req?: PayloadRequest\n  showHiddenFields?: boolean\n  sort?: Sort\n  user?: Document\n  where?: Where\n}\n\nexport async function findLocal<TSlug extends CollectionSlug>(\n  payload: Payload,\n  options: Options<TSlug>,\n): Promise<PaginatedDocs<DataFromCollectionSlug<TSlug>>> {\n  const {\n    collection: collectionSlug,\n    currentDepth,\n    depth,\n    disableErrors,\n    draft = false,\n    includeLockStatus,\n    joins,\n    limit,\n    overrideAccess = true,\n    page,\n    pagination = true,\n    showHiddenFields,\n    sort,\n    where,\n  } = options\n\n  const collection = payload.collections[collectionSlug]\n\n  if (!collection) {\n    throw new APIError(\n      `The collection with slug ${String(collectionSlug)} can't be found. Find Operation.`,\n    )\n  }\n\n  return findOperation<TSlug>({\n    collection,\n    currentDepth,\n    depth,\n    disableErrors,\n    draft,\n    includeLockStatus,\n    joins,\n    limit,\n    overrideAccess,\n    page,\n    pagination,\n    req: await createLocalReq(options, payload),\n    showHiddenFields,\n    sort,\n    where,\n  })\n}\n"],"names":["APIError","createLocalReq","findOperation","findLocal","payload","options","collection","collectionSlug","currentDepth","depth","disableErrors","draft","includeLockStatus","joins","limit","overrideAccess","page","pagination","showHiddenFields","sort","where","collections","String","req"],"mappings":";;;AAKA,SAASA,QAAQ,QAAQ,2BAA0B;AAEnD,SAASE,aAAa,QAAQ,aAAY;AAD1C,SAASD,cAAc,QAAQ,uCAAsC;;;;AA4B9D,eAAeE,UACpBC,OAAgB,EAChBC,OAAuB;IAEvB,MAAM,EACJC,YAAYC,cAAc,EAC1BC,YAAY,EACZC,KAAK,EACLC,aAAa,EACbC,QAAQ,KAAK,EACbC,iBAAiB,EACjBC,KAAK,EACLC,KAAK,EACLC,iBAAiB,IAAI,EACrBC,IAAI,EACJC,aAAa,IAAI,EACjBC,gBAAgB,EAChBC,IAAI,EACJC,KAAK,EACN,GAAGf;IAEJ,MAAMC,aAAaF,QAAQiB,WAAW,CAACd,eAAe;IAEtD,IAAI,CAACD,YAAY;QACf,MAAM,0JAAIN,WAAAA,CACR,CAAC,yBAAyB,EAAEsB,OAAOf,gBAAgB,gCAAgC,CAAC;IAExF;IAEA,gLAAOL,gBAAAA,EAAqB;QAC1BI;QACAE;QACAC;QACAC;QACAC;QACAC;QACAC;QACAC;QACAC;QACAC;QACAC;QACAM,KAAK,yKAAMtB,iBAAAA,EAAeI,SAASD;QACnCc;QACAC;QACAC;IACF;AACF"}},
    {"offset": {"line": 10431, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 10437, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/payload/src/types/index.ts"],"sourcesContent":["import type { I18n, TFunction } from '@payloadcms/translations'\nimport type DataLoader from 'dataloader'\nimport type { URL } from 'url'\n\nimport type { TypeWithID, TypeWithTimestamps } from '../collections/config/types.js'\nimport type payload from '../index.js'\nimport type { TypedLocale, TypedUser } from '../index.js'\nimport type { validOperators } from './constants.js'\nexport type { Payload as Payload } from '../index.js'\n\nexport type CustomPayloadRequestProperties = {\n  context: RequestContext\n  /** The locale that should be used for a field when it is not translated to the requested locale */\n  fallbackLocale?: string\n  i18n: I18n\n  /**\n   * The requested locale if specified\n   * Only available for localized collections\n   */\n  locale?: TypedLocale\n  /**\n   * The payload object\n   */\n  payload: typeof payload\n  /**\n   * The context in which the request is being made\n   */\n  payloadAPI: 'GraphQL' | 'local' | 'REST'\n  /** Optimized document loader */\n  payloadDataLoader?: DataLoader<string, TypeWithID>\n  /** Resized versions of the image that was uploaded during this request */\n  payloadUploadSizes?: Record<string, Buffer>\n  /** Query params on the request */\n  query: Record<string, unknown>\n  /** Any response headers that are required to be set when a response is sent */\n  responseHeaders?: Headers\n  /** The route parameters\n   * @example\n   * /:collection/:id -> /posts/123\n   * { collection: 'posts', id: '123' }\n   */\n  routeParams?: Record<string, unknown>\n  /** Translate function - duplicate of i18n.t */\n  t: TFunction\n  /**\n   * Identifier for the database transaction for interactions in a single, all-or-nothing operation.\n   * Can also be used to ensure consistency when multiple operations try to create a transaction concurrently on the same request.\n   */\n  transactionID?: number | Promise<number | string> | string\n  /**\n   * Used to ensure consistency when multiple operations try to create a transaction concurrently on the same request\n   */\n  transactionIDPromise?: Promise<void>\n  /** The signed-in user */\n  user: null | TypedUser\n} & Pick<\n  URL,\n  'hash' | 'host' | 'href' | 'origin' | 'pathname' | 'port' | 'protocol' | 'search' | 'searchParams'\n>\ntype PayloadRequestData = {\n  /**\n   * Data from the request body\n   *\n   * Within Payload operations, i.e. hooks, data will be there\n   * BUT in custom endpoints it will not be, you will need to\n   * use either:\n   *  1. `const data = await req.json()`\n   *\n   *  2. import { addDataAndFileToRequest } from '@payloadcms/next/utilities'\n   *    `await addDataAndFileToRequest(req)`\n   * */\n  data?: JsonObject\n  /** The file on the request, same rules apply as the `data` property */\n  file?: {\n    data: Buffer\n    mimetype: string\n    name: string\n    size: number\n    tempFilePath?: string\n  }\n}\nexport type PayloadRequest = CustomPayloadRequestProperties &\n  Partial<Request> &\n  PayloadRequestData &\n  Required<Pick<Request, 'headers'>>\n\nexport interface RequestContext {\n  [key: string]: unknown\n}\n\nexport type Operator = (typeof validOperators)[number]\n\n// Makes it so things like passing new Date() will error\nexport type JsonValue = JsonArray | JsonObject | unknown //Date | JsonArray | JsonObject | boolean | null | number | string // TODO: Evaluate proper, strong type for this\n\nexport type JsonArray = Array<JsonValue>\n\nexport interface JsonObject {\n  [key: string]: any\n}\n\nexport type WhereField = {\n  // any json-serializable value\n  [key in Operator]?: JsonValue\n}\n\nexport type Where = {\n  [key: string]: Where[] | WhereField\n  and?: Where[]\n  or?: Where[]\n}\n\nexport type Sort = Array<string> | string\n\n/**\n * Applies pagination for join fields for including collection relationships\n */\nexport type JoinQuery =\n  | {\n      [schemaPath: string]: {\n        limit?: number\n        sort?: string\n        where?: Where\n      }\n    }\n  | false\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport type Document = any\n\nexport type Operation = 'create' | 'delete' | 'read' | 'update'\nexport type VersionOperations = 'readVersions'\nexport type AuthOperations = 'unlock'\nexport type AllOperations = AuthOperations | Operation | VersionOperations\n\nexport function docHasTimestamps(doc: any): doc is TypeWithTimestamps {\n  return doc?.createdAt && doc?.updatedAt\n}\n\nexport type IfAny<T, Y, N> = 0 extends 1 & T ? Y : N // This is a commonly used trick to detect 'any'\nexport type IsAny<T> = IfAny<T, true, false>\nexport type ReplaceAny<T, DefaultType> = IsAny<T> extends true ? DefaultType : T\n"],"names":["docHasTimestamps","doc","createdAt","updatedAt"],"mappings":";;;AAuIO,SAASA,iBAAiBC,GAAQ;IACvC,OAAOA,KAAKC,aAAaD,KAAKE;AAChC"}},
    {"offset": {"line": 10443, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 10449, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/payload/src/versions/drafts/replaceWithDraftIfAvailable.ts"],"sourcesContent":["import type { SanitizedCollectionConfig, TypeWithID } from '../../collections/config/types.js'\nimport type { AccessResult } from '../../config/types.js'\nimport type { FindGlobalVersionsArgs, FindVersionsArgs } from '../../database/types.js'\nimport type { SanitizedGlobalConfig } from '../../globals/config/types.js'\nimport type { PayloadRequest, Where } from '../../types/index.js'\n\nimport { hasWhereAccessResult } from '../../auth/index.js'\nimport { combineQueries } from '../../database/combineQueries.js'\nimport { docHasTimestamps } from '../../types/index.js'\nimport { deepCopyObjectSimple } from '../../utilities/deepCopyObject.js'\nimport sanitizeInternalFields from '../../utilities/sanitizeInternalFields.js'\nimport { appendVersionToQueryKey } from './appendVersionToQueryKey.js'\n\ntype Arguments<T> = {\n  accessResult: AccessResult\n  doc: T\n  entity: SanitizedCollectionConfig | SanitizedGlobalConfig\n  entityType: 'collection' | 'global'\n  overrideAccess: boolean\n  req: PayloadRequest\n}\n\nconst replaceWithDraftIfAvailable = async <T extends TypeWithID>({\n  accessResult,\n  doc,\n  entity,\n  entityType,\n  req,\n}: Arguments<T>): Promise<T> => {\n  const { locale } = req\n\n  const queryToBuild: Where = {\n    and: [\n      {\n        'version._status': {\n          equals: 'draft',\n        },\n      },\n    ],\n  }\n\n  if (entityType === 'collection') {\n    queryToBuild.and.push({\n      parent: {\n        equals: doc.id,\n      },\n    })\n  }\n\n  if (docHasTimestamps(doc)) {\n    queryToBuild.and.push({\n      or: [\n        {\n          updatedAt: {\n            greater_than: doc.updatedAt,\n          },\n        },\n        {\n          latest: {\n            equals: true,\n          },\n        },\n      ],\n    })\n  }\n\n  let versionAccessResult\n\n  if (hasWhereAccessResult(accessResult)) {\n    versionAccessResult = appendVersionToQueryKey(accessResult)\n  }\n\n  const findVersionsArgs: FindGlobalVersionsArgs & FindVersionsArgs = {\n    collection: entity.slug,\n    global: entity.slug,\n    limit: 1,\n    locale,\n    pagination: false,\n    req,\n    sort: '-updatedAt',\n    where: combineQueries(queryToBuild, versionAccessResult),\n  }\n\n  let versionDocs\n  if (entityType === 'global') {\n    versionDocs = (await req.payload.db.findGlobalVersions<T>(findVersionsArgs)).docs\n  } else {\n    versionDocs = (await req.payload.db.findVersions<T>(findVersionsArgs)).docs\n  }\n\n  let draft = versionDocs[0]\n\n  if (!draft) {\n    return doc\n  }\n\n  draft = deepCopyObjectSimple(draft)\n  draft = sanitizeInternalFields(draft)\n\n  // Patch globalType onto version doc\n  if (entityType === 'global' && 'globalType' in doc) {\n    draft.version.globalType = doc.globalType\n  }\n\n  // Disregard all other draft content at this point,\n  // Only interested in the version itself.\n  // Operations will handle firing hooks, etc.\n  return {\n    id: doc.id,\n    ...draft.version,\n    createdAt: draft.createdAt,\n    updatedAt: draft.updatedAt,\n  }\n}\n\nexport default replaceWithDraftIfAvailable\n"],"names":["hasWhereAccessResult","combineQueries","docHasTimestamps","deepCopyObjectSimple","sanitizeInternalFields","appendVersionToQueryKey","replaceWithDraftIfAvailable","accessResult","doc","entity","entityType","req","locale","queryToBuild","and","equals","push","parent","id","or","updatedAt","greater_than","latest","versionAccessResult","findVersionsArgs","collection","slug","global","limit","pagination","sort","where","versionDocs","payload","db","findGlobalVersions","docs","findVersions","draft","version","globalType","createdAt"],"mappings":";;;AAQA,SAASE,gBAAgB,QAAQ,uBAAsB;AAFvD,SAASF,oBAAoB,QAAQ,sBAAqB;AAK1D,SAASK,uBAAuB,QAAQ,+BAA8B;AAJtE,SAASJ,cAAc,QAAQ,mCAAkC;AAEjE,SAASE,oBAAoB,QAAQ,oCAAmC;AACxE,OAAOC,4BAA4B,4CAA2C;;;;;;;AAY9E,MAAME,8BAA8B,OAA6B,EAC/DC,YAAY,EACZC,GAAG,EACHC,MAAM,EACNC,UAAU,EACVC,GAAG,EACU;IACb,MAAM,EAAEC,MAAM,EAAE,GAAGD;IAEnB,MAAME,eAAsB;QAC1BC,KAAK;YACH;gBACE,mBAAmB;oBACjBC,QAAQ;gBACV;YACF;SACD;IACH;IAEA,IAAIL,eAAe,cAAc;QAC/BG,aAAaC,GAAG,CAACE,IAAI,CAAC;YACpBC,QAAQ;gBACNF,QAAQP,IAAIU,EAAE;YAChB;QACF;IACF;IAEA,QAAIhB,qKAAAA,EAAiBM,MAAM;QACzBK,aAAaC,GAAG,CAACE,IAAI,CAAC;YACpBG,IAAI;gBACF;oBACEC,WAAW;wBACTC,cAAcb,IAAIY,SAAS;oBAC7B;gBACF;gBACA;oBACEE,QAAQ;wBACNP,QAAQ;oBACV;gBACF;aACD;QACH;IACF;IAEA,IAAIQ;IAEJ,yJAAIvB,uBAAAA,EAAqBO,eAAe;QACtCgB,sBAAsBlB,+MAAAA,EAAwBE;IAChD;IAEA,MAAMiB,mBAA8D;QAClEC,YAAYhB,OAAOiB,IAAI;QACvBC,QAAQlB,OAAOiB,IAAI;QACnBE,OAAO;QACPhB;QACAiB,YAAY;QACZlB;QACAmB,MAAM;QACNC,yKAAO9B,iBAAAA,EAAeY,cAAcU;IACtC;IAEA,IAAIS;IACJ,IAAItB,eAAe,UAAU;QAC3BsB,cAAe,CAAA,MAAMrB,IAAIsB,OAAO,CAACC,EAAE,CAACC,kBAAkB,CAAIX,iBAAgB,EAAGY,IAAI;IACnF,OAAO;QACLJ,cAAe,CAAA,MAAMrB,IAAIsB,OAAO,CAACC,EAAE,CAACG,YAAY,CAAIb,iBAAgB,EAAGY,IAAI;IAC7E;IAEA,IAAIE,QAAQN,WAAW,CAAC,EAAE;IAE1B,IAAI,CAACM,OAAO;QACV,OAAO9B;IACT;IAEA8B,2KAAQnC,uBAAAA,EAAqBmC;IAC7BA,mLAAQlC,UAAAA,EAAuBkC;IAE/B,oCAAoC;IACpC,IAAI5B,eAAe,YAAY,gBAAgBF,KAAK;QAClD8B,MAAMC,OAAO,CAACC,UAAU,GAAGhC,IAAIgC,UAAU;IAC3C;IAEA,mDAAmD;IACnD,yCAAyC;IACzC,4CAA4C;IAC5C,OAAO;QACLtB,IAAIV,IAAIU,EAAE;QACV,GAAGoB,MAAMC,OAAO;QAChBE,WAAWH,MAAMG,SAAS;QAC1BrB,WAAWkB,MAAMlB,SAAS;IAC5B;AACF;uCAEed,4BAA2B"}},
    {"offset": {"line": 10540, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 10546, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/payload/src/collections/operations/findByID.ts"],"sourcesContent":["import type { FindOneArgs } from '../../database/types.js'\nimport type { CollectionSlug, JoinQuery } from '../../index.js'\nimport type { PayloadRequest } from '../../types/index.js'\nimport type { Collection, DataFromCollectionSlug } from '../config/types.js'\n\nimport executeAccess from '../../auth/executeAccess.js'\nimport { combineQueries } from '../../database/combineQueries.js'\nimport { NotFound } from '../../errors/index.js'\nimport { afterRead } from '../../fields/hooks/afterRead/index.js'\nimport { killTransaction } from '../../utilities/killTransaction.js'\nimport replaceWithDraftIfAvailable from '../../versions/drafts/replaceWithDraftIfAvailable.js'\nimport { buildAfterOperation } from './utils.js'\n\nexport type Arguments = {\n  collection: Collection\n  currentDepth?: number\n  depth?: number\n  disableErrors?: boolean\n  draft?: boolean\n  id: number | string\n  includeLockStatus?: boolean\n  joins?: JoinQuery\n  overrideAccess?: boolean\n  req: PayloadRequest\n  showHiddenFields?: boolean\n}\n\nexport const findByIDOperation = async <TSlug extends CollectionSlug>(\n  incomingArgs: Arguments,\n): Promise<DataFromCollectionSlug<TSlug>> => {\n  let args = incomingArgs\n\n  try {\n    // /////////////////////////////////////\n    // beforeOperation - Collection\n    // /////////////////////////////////////\n\n    await args.collection.config.hooks.beforeOperation.reduce(async (priorHook, hook) => {\n      await priorHook\n\n      args =\n        (await hook({\n          args,\n          collection: args.collection.config,\n          context: args.req.context,\n          operation: 'read',\n          req: args.req,\n        })) || args\n    }, Promise.resolve())\n\n    const {\n      id,\n      collection: { config: collectionConfig },\n      currentDepth,\n      depth,\n      disableErrors,\n      draft: draftEnabled = false,\n      includeLockStatus,\n      joins,\n      overrideAccess = false,\n      req: { fallbackLocale, locale, t },\n      req,\n      showHiddenFields,\n    } = args\n\n    // /////////////////////////////////////\n    // Access\n    // /////////////////////////////////////\n\n    const accessResult = !overrideAccess\n      ? await executeAccess({ id, disableErrors, req }, collectionConfig.access.read)\n      : true\n\n    // If errors are disabled, and access returns false, return null\n    if (accessResult === false) {\n      return null\n    }\n\n    const findOneArgs: FindOneArgs = {\n      collection: collectionConfig.slug,\n      joins: req.payloadAPI === 'GraphQL' ? false : joins,\n      locale,\n      req: {\n        transactionID: req.transactionID,\n      } as PayloadRequest,\n      where: combineQueries({ id: { equals: id } }, accessResult),\n    }\n\n    // /////////////////////////////////////\n    // Find by ID\n    // /////////////////////////////////////\n\n    if (!findOneArgs.where.and[0].id) {\n      throw new NotFound(t)\n    }\n\n    let result: DataFromCollectionSlug<TSlug> = await req.payload.db.findOne(findOneArgs)\n\n    if (!result) {\n      if (!disableErrors) {\n        throw new NotFound(req.t)\n      }\n\n      return null\n    }\n\n    // /////////////////////////////////////\n    // Include Lock Status if required\n    // /////////////////////////////////////\n\n    if (includeLockStatus && id) {\n      let lockStatus = null\n\n      try {\n        const lockedDocument = await req.payload.find({\n          collection: 'payload-locked-documents',\n          depth: 1,\n          limit: 1,\n          pagination: false,\n          req,\n          where: {\n            and: [\n              {\n                'document.relationTo': {\n                  equals: collectionConfig.slug,\n                },\n              },\n              {\n                'document.value': {\n                  equals: id,\n                },\n              },\n            ],\n          },\n        })\n\n        if (lockedDocument && lockedDocument.docs.length > 0) {\n          lockStatus = lockedDocument.docs[0]\n        }\n      } catch {\n        // swallow error\n      }\n\n      result._isLocked = !!lockStatus\n      result._userEditing = lockStatus?.user?.value ?? null\n    }\n\n    // /////////////////////////////////////\n    // Replace document with draft if available\n    // /////////////////////////////////////\n\n    if (collectionConfig.versions?.drafts && draftEnabled) {\n      result = await replaceWithDraftIfAvailable({\n        accessResult,\n        doc: result,\n        entity: collectionConfig,\n        entityType: 'collection',\n        overrideAccess,\n        req,\n      })\n    }\n\n    // /////////////////////////////////////\n    // beforeRead - Collection\n    // /////////////////////////////////////\n\n    await collectionConfig.hooks.beforeRead.reduce(async (priorHook, hook) => {\n      await priorHook\n\n      result =\n        (await hook({\n          collection: collectionConfig,\n          context: req.context,\n          doc: result,\n          query: findOneArgs.where,\n          req,\n        })) || result\n    }, Promise.resolve())\n\n    // /////////////////////////////////////\n    // afterRead - Fields\n    // /////////////////////////////////////\n\n    result = await afterRead({\n      collection: collectionConfig,\n      context: req.context,\n      currentDepth,\n      depth,\n      doc: result,\n      draft: draftEnabled,\n      fallbackLocale,\n      global: null,\n      locale,\n      overrideAccess,\n      req,\n      showHiddenFields,\n    })\n\n    // /////////////////////////////////////\n    // afterRead - Collection\n    // /////////////////////////////////////\n\n    await collectionConfig.hooks.afterRead.reduce(async (priorHook, hook) => {\n      await priorHook\n\n      result =\n        (await hook({\n          collection: collectionConfig,\n          context: req.context,\n          doc: result,\n          query: findOneArgs.where,\n          req,\n        })) || result\n    }, Promise.resolve())\n\n    // /////////////////////////////////////\n    // afterOperation - Collection\n    // /////////////////////////////////////\n\n    result = await buildAfterOperation({\n      args,\n      collection: collectionConfig,\n      operation: 'findByID',\n      result,\n    })\n\n    // /////////////////////////////////////\n    // Return results\n    // /////////////////////////////////////\n\n    return result\n  } catch (error: unknown) {\n    await killTransaction(args.req)\n    throw error\n  }\n}\n"],"names":["executeAccess","combineQueries","NotFound","afterRead","killTransaction","replaceWithDraftIfAvailable","buildAfterOperation","findByIDOperation","incomingArgs","args","collection","config","hooks","beforeOperation","reduce","priorHook","hook","context","req","operation","Promise","resolve","id","collectionConfig","currentDepth","depth","disableErrors","draft","draftEnabled","includeLockStatus","joins","overrideAccess","fallbackLocale","locale","t","showHiddenFields","accessResult","access","read","findOneArgs","slug","payloadAPI","transactionID","where","equals","and","result","payload","db","findOne","lockStatus","lockedDocument","find","limit","pagination","docs","length","_isLocked","_userEditing","user","value","versions","drafts","doc","entity","entityType","beforeRead","query","global","error"],"mappings":";;;AAKA,OAAOA,mBAAmB,8BAA6B;AACvD,SAASC,cAAc,QAAQ,mCAAkC;AACjE,SAASC,QAAQ,QAAQ,wBAAuB;AAGhD,OAAOG,iCAAiC,uDAAsD;AAF9F,SAASF,SAAS,QAAQ,wCAAuC;AAGjE,SAASG,mBAAmB,QAAQ,aAAY;AAFhD,SAASF,eAAe,QAAQ,qCAAoC;;;;;;;;AAkB7D,MAAMG,oBAAoB,OAC/BC;IAEA,IAAIC,OAAOD;IAEX,IAAI;QACF,wCAAwC;QACxC,+BAA+B;QAC/B,wCAAwC;QAExC,MAAMC,KAAKC,UAAU,CAACC,MAAM,CAACC,KAAK,CAACC,eAAe,CAACC,MAAM,CAAC,OAAOC,WAAWC;YAC1E,MAAMD;YAENN,OACG,MAAMO,KAAK;gBACVP;gBACAC,YAAYD,KAAKC,UAAU,CAACC,MAAM;gBAClCM,SAASR,KAAKS,GAAG,CAACD,OAAO;gBACzBE,WAAW;gBACXD,KAAKT,KAAKS,GAAG;YACf,MAAOT;QACX,GAAGW,QAAQC,OAAO;QAElB,MAAM,EACJC,EAAE,EACFZ,YAAY,EAAEC,QAAQY,gBAAgB,EAAE,EACxCC,YAAY,EACZC,KAAK,EACLC,aAAa,EACbC,OAAOC,eAAe,KAAK,EAC3BC,iBAAiB,EACjBC,KAAK,EACLC,iBAAiB,KAAK,EACtBb,KAAK,EAAEc,cAAc,EAAEC,MAAM,EAAEC,CAAC,EAAE,EAClChB,GAAG,EACHiB,gBAAgB,EACjB,GAAG1B;QAEJ,wCAAwC;QACxC,SAAS;QACT,wCAAwC;QAExC,MAAM2B,eAAe,CAACL,iBAClB,MAAM/B,uKAAAA,EAAc;YAAEsB;YAAII;YAAeR;QAAI,GAAGK,iBAAiBc,MAAM,CAACC,IAAI,IAC5E;QAEJ,gEAAgE;QAChE,IAAIF,iBAAiB,OAAO;YAC1B,OAAO;QACT;QAEA,MAAMG,cAA2B;YAC/B7B,YAAYa,iBAAiBiB,IAAI;YACjCV,OAAOZ,IAAIuB,UAAU,KAAK,YAAY,QAAQX;YAC9CG;YACAf,KAAK;gBACHwB,eAAexB,IAAIwB,aAAa;YAClC;YACAC,OAAO1C,mLAAAA,EAAe;gBAAEqB,IAAI;oBAAEsB,QAAQtB;gBAAG;YAAE,GAAGc;QAChD;QAEA,wCAAwC;QACxC,aAAa;QACb,wCAAwC;QAExC,IAAI,CAACG,YAAYI,KAAK,CAACE,GAAG,CAAC,EAAE,CAACvB,EAAE,EAAE;YAChC,MAAM,0JAAIpB,WAAAA,CAASgC;QACrB;QAEA,IAAIY,SAAwC,MAAM5B,IAAI6B,OAAO,CAACC,EAAE,CAACC,OAAO,CAACV;QAEzE,IAAI,CAACO,QAAQ;YACX,IAAI,CAACpB,eAAe;gBAClB,MAAM,0JAAIxB,WAAAA,CAASgB,IAAIgB,CAAC;YAC1B;YAEA,OAAO;QACT;QAEA,wCAAwC;QACxC,kCAAkC;QAClC,wCAAwC;QAExC,IAAIL,qBAAqBP,IAAI;YAC3B,IAAI4B,aAAa;YAEjB,IAAI;gBACF,MAAMC,iBAAiB,MAAMjC,IAAI6B,OAAO,CAACK,IAAI,CAAC;oBAC5C1C,YAAY;oBACZe,OAAO;oBACP4B,OAAO;oBACPC,YAAY;oBACZpC;oBACAyB,OAAO;wBACLE,KAAK;4BACH;gCACE,uBAAuB;oCACrBD,QAAQrB,iBAAiBiB,IAAI;gCAC/B;4BACF;4BACA;gCACE,kBAAkB;oCAChBI,QAAQtB;gCACV;4BACF;yBACD;oBACH;gBACF;gBAEA,IAAI6B,kBAAkBA,eAAeI,IAAI,CAACC,MAAM,GAAG,GAAG;oBACpDN,aAAaC,eAAeI,IAAI,CAAC,EAAE;gBACrC;YACF,EAAE,OAAM;YACN,gBAAgB;YAClB;YAEAT,OAAOW,SAAS,GAAG,CAAC,CAACP;YACrBJ,OAAOY,YAAY,GAAGR,YAAYS,MAAMC,SAAS;QACnD;QAEA,wCAAwC;QACxC,2CAA2C;QAC3C,wCAAwC;QAExC,IAAIrC,iBAAiBsC,QAAQ,EAAEC,UAAUlC,cAAc;YACrDkB,SAAS,+LAAMzC,UAAAA,EAA4B;gBACzC+B;gBACA2B,KAAKjB;gBACLkB,QAAQzC;gBACR0C,YAAY;gBACZlC;gBACAb;YACF;QACF;QAEA,wCAAwC;QACxC,0BAA0B;QAC1B,wCAAwC;QAExC,MAAMK,iBAAiBX,KAAK,CAACsD,UAAU,CAACpD,MAAM,CAAC,OAAOC,WAAWC;YAC/D,MAAMD;YAEN+B,SACG,MAAM9B,KAAK;gBACVN,YAAYa;gBACZN,SAASC,IAAID,OAAO;gBACpB8C,KAAKjB;gBACLqB,OAAO5B,YAAYI,KAAK;gBACxBzB;YACF,MAAO4B;QACX,GAAG1B,QAAQC,OAAO;QAElB,wCAAwC;QACxC,qBAAqB;QACrB,wCAAwC;QAExCyB,SAAS,mLAAM3C,YAAAA,EAAU;YACvBO,YAAYa;YACZN,SAASC,IAAID,OAAO;YACpBO;YACAC;YACAsC,KAAKjB;YACLnB,OAAOC;YACPI;YACAoC,QAAQ;YACRnC;YACAF;YACAb;YACAiB;QACF;QAEA,wCAAwC;QACxC,yBAAyB;QACzB,wCAAwC;QAExC,MAAMZ,iBAAiBX,KAAK,CAACT,SAAS,CAACW,MAAM,CAAC,OAAOC,WAAWC;YAC9D,MAAMD;YAEN+B,SACG,MAAM9B,KAAK;gBACVN,YAAYa;gBACZN,SAASC,IAAID,OAAO;gBACpB8C,KAAKjB;gBACLqB,OAAO5B,YAAYI,KAAK;gBACxBzB;YACF,MAAO4B;QACX,GAAG1B,QAAQC,OAAO;QAElB,wCAAwC;QACxC,8BAA8B;QAC9B,wCAAwC;QAExCyB,SAAS,gLAAMxC,sBAAAA,EAAoB;YACjCG;YACAC,YAAYa;YACZJ,WAAW;YACX2B;QACF;QAEA,wCAAwC;QACxC,iBAAiB;QACjB,wCAAwC;QAExC,OAAOA;IACT,EAAE,OAAOuB,OAAgB;QACvB,0KAAMjE,kBAAAA,EAAgBK,KAAKS,GAAG;QAC9B,MAAMmD;IACR;AACF,EAAC"}},
    {"offset": {"line": 10728, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 10734, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/payload/src/collections/operations/local/findByID.ts"],"sourcesContent":["import type { CollectionSlug, JoinQuery, Payload, TypedLocale } from '../../../index.js'\nimport type { Document, PayloadRequest, RequestContext } from '../../../types/index.js'\nimport type { DataFromCollectionSlug } from '../../config/types.js'\n\nimport { APIError } from '../../../errors/index.js'\nimport { createLocalReq } from '../../../utilities/createLocalReq.js'\nimport { findByIDOperation } from '../findByID.js'\n\nexport type Options<TSlug extends CollectionSlug = CollectionSlug> = {\n  collection: TSlug\n  /**\n   * context, which will then be passed to req.context, which can be read by hooks\n   */\n  context?: RequestContext\n  currentDepth?: number\n  depth?: number\n  disableErrors?: boolean\n  draft?: boolean\n  fallbackLocale?: TypedLocale\n  id: number | string\n  includeLockStatus?: boolean\n  joins?: JoinQuery\n  locale?: 'all' | TypedLocale\n  overrideAccess?: boolean\n  req?: PayloadRequest\n  showHiddenFields?: boolean\n  user?: Document\n}\n\nexport default async function findByIDLocal<TOptions extends Options>(\n  payload: Payload,\n  options: TOptions,\n): Promise<\n  TOptions['disableErrors'] extends true\n    ? DataFromCollectionSlug<TOptions['collection']> | null\n    : DataFromCollectionSlug<TOptions['collection']>\n> {\n  const {\n    id,\n    collection: collectionSlug,\n    currentDepth,\n    depth,\n    disableErrors = false,\n    draft = false,\n    includeLockStatus,\n    joins,\n    overrideAccess = true,\n    showHiddenFields,\n  } = options\n\n  const collection = payload.collections[collectionSlug]\n\n  if (!collection) {\n    throw new APIError(\n      `The collection with slug ${String(collectionSlug)} can't be found. Find By ID Operation.`,\n    )\n  }\n\n  return findByIDOperation<TOptions['collection']>({\n    id,\n    collection,\n    currentDepth,\n    depth,\n    disableErrors,\n    draft,\n    includeLockStatus,\n    joins,\n    overrideAccess,\n    req: await createLocalReq(options, payload),\n    showHiddenFields,\n  })\n}\n"],"names":["APIError","createLocalReq","findByIDOperation","findByIDLocal","payload","options","id","collection","collectionSlug","currentDepth","depth","disableErrors","draft","includeLockStatus","joins","overrideAccess","showHiddenFields","collections","String","req"],"mappings":";;;AAIA,SAASA,QAAQ,QAAQ,2BAA0B;AAEnD,SAASE,iBAAiB,QAAQ,iBAAgB;AADlD,SAASD,cAAc,QAAQ,uCAAsC;;;;AAwBtD,eAAeE,cAC5BC,OAAgB,EAChBC,OAAiB;IAMjB,MAAM,EACJC,EAAE,EACFC,YAAYC,cAAc,EAC1BC,YAAY,EACZC,KAAK,EACLC,gBAAgB,KAAK,EACrBC,QAAQ,KAAK,EACbC,iBAAiB,EACjBC,KAAK,EACLC,iBAAiB,IAAI,EACrBC,gBAAgB,EACjB,GAAGX;IAEJ,MAAME,aAAaH,QAAQa,WAAW,CAACT,eAAe;IAEtD,IAAI,CAACD,YAAY;QACf,MAAM,yJAAIP,YAAAA,CACR,CAAC,yBAAyB,EAAEkB,OAAOV,gBAAgB,sCAAsC,CAAC;IAE9F;IAEA,oLAAON,oBAAAA,EAA0C;QAC/CI;QACAC;QACAE;QACAC;QACAC;QACAC;QACAC;QACAC;QACAC;QACAI,KAAK,yKAAMlB,iBAAAA,EAAeI,SAASD;QACnCY;IACF;AACF"}},
    {"offset": {"line": 10763, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 10769, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/payload/src/collections/operations/findVersionByID.ts"],"sourcesContent":["import httpStatus from 'http-status'\n\nimport type { PayloadRequest } from '../../types/index.js'\nimport type { TypeWithVersion } from '../../versions/types.js'\nimport type { Collection, TypeWithID } from '../config/types.js'\n\nimport executeAccess from '../../auth/executeAccess.js'\nimport { combineQueries } from '../../database/combineQueries.js'\nimport { APIError, Forbidden, NotFound } from '../../errors/index.js'\nimport { afterRead } from '../../fields/hooks/afterRead/index.js'\nimport { killTransaction } from '../../utilities/killTransaction.js'\n\nexport type Arguments = {\n  collection: Collection\n  currentDepth?: number\n  depth?: number\n  disableErrors?: boolean\n  id: number | string\n  overrideAccess?: boolean\n  req: PayloadRequest\n  showHiddenFields?: boolean\n}\n\nexport const findVersionByIDOperation = async <TData extends TypeWithID = any>(\n  args: Arguments,\n): Promise<TypeWithVersion<TData>> => {\n  const {\n    id,\n    collection: { config: collectionConfig },\n    currentDepth,\n    depth,\n    disableErrors,\n    overrideAccess,\n    req: { fallbackLocale, locale, payload },\n    req,\n    showHiddenFields,\n  } = args\n\n  if (!id) {\n    throw new APIError('Missing ID of version.', httpStatus.BAD_REQUEST)\n  }\n\n  try {\n    // /////////////////////////////////////\n    // Access\n    // /////////////////////////////////////\n\n    const accessResults = !overrideAccess\n      ? await executeAccess({ id, disableErrors, req }, collectionConfig.access.readVersions)\n      : true\n\n    // If errors are disabled, and access returns false, return null\n    if (accessResults === false) {\n      return null\n    }\n\n    const hasWhereAccess = typeof accessResults === 'object'\n\n    const fullWhere = combineQueries({ id: { equals: id } }, accessResults)\n\n    // /////////////////////////////////////\n    // Find by ID\n    // /////////////////////////////////////\n\n    const versionsQuery = await payload.db.findVersions<TData>({\n      collection: collectionConfig.slug,\n      limit: 1,\n      locale,\n      pagination: false,\n      req,\n      where: fullWhere,\n    })\n\n    const result = versionsQuery.docs[0]\n\n    if (!result) {\n      if (!disableErrors) {\n        if (!hasWhereAccess) {\n          throw new NotFound(req.t)\n        }\n        if (hasWhereAccess) {\n          throw new Forbidden(req.t)\n        }\n      }\n\n      return null\n    }\n\n    // /////////////////////////////////////\n    // beforeRead - Collection\n    // /////////////////////////////////////\n\n    await collectionConfig.hooks.beforeRead.reduce(async (priorHook, hook) => {\n      await priorHook\n\n      result.version =\n        (await hook({\n          collection: collectionConfig,\n          context: req.context,\n          doc: result.version,\n          query: fullWhere,\n          req,\n        })) || result.version\n    }, Promise.resolve())\n\n    // /////////////////////////////////////\n    // afterRead - Fields\n    // /////////////////////////////////////\n\n    result.version = await afterRead({\n      collection: collectionConfig,\n      context: req.context,\n      currentDepth,\n      depth,\n      doc: result.version,\n      draft: undefined,\n      fallbackLocale,\n      global: null,\n      locale,\n      overrideAccess,\n      req,\n      showHiddenFields,\n    })\n\n    // /////////////////////////////////////\n    // afterRead - Collection\n    // /////////////////////////////////////\n\n    await collectionConfig.hooks.afterRead.reduce(async (priorHook, hook) => {\n      await priorHook\n\n      result.version =\n        (await hook({\n          collection: collectionConfig,\n          context: req.context,\n          doc: result.version,\n          query: fullWhere,\n          req,\n        })) || result.version\n    }, Promise.resolve())\n\n    // /////////////////////////////////////\n    // Return results\n    // /////////////////////////////////////\n\n    return result\n  } catch (error: unknown) {\n    await killTransaction(req)\n    throw error\n  }\n}\n"],"names":["httpStatus","executeAccess","combineQueries","APIError","Forbidden","NotFound","afterRead","killTransaction","findVersionByIDOperation","args","id","collection","config","collectionConfig","currentDepth","depth","disableErrors","overrideAccess","req","fallbackLocale","locale","payload","showHiddenFields","BAD_REQUEST","accessResults","access","readVersions","hasWhereAccess","fullWhere","equals","versionsQuery","db","findVersions","slug","limit","pagination","where","result","docs","t","hooks","beforeRead","reduce","priorHook","hook","version","context","doc","query","Promise","resolve","draft","undefined","global","error"],"mappings":"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"}},
    {"offset": {"line": 10885, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 10891, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/payload/src/collections/operations/local/findVersionByID.ts"],"sourcesContent":["import type { CollectionSlug, Payload, TypedLocale } from '../../../index.js'\nimport type { Document, PayloadRequest, RequestContext } from '../../../types/index.js'\nimport type { TypeWithVersion } from '../../../versions/types.js'\nimport type { DataFromCollectionSlug } from '../../config/types.js'\n\nimport { APIError } from '../../../errors/index.js'\nimport { createLocalReq } from '../../../utilities/createLocalReq.js'\nimport { findVersionByIDOperation } from '../findVersionByID.js'\n\nexport type Options<TSlug extends CollectionSlug> = {\n  collection: TSlug\n  /**\n   * context, which will then be passed to req.context, which can be read by hooks\n   */\n  context?: RequestContext\n  depth?: number\n  disableErrors?: boolean\n  draft?: boolean\n  fallbackLocale?: TypedLocale\n  id: string\n  locale?: 'all' | TypedLocale\n  overrideAccess?: boolean\n  req?: PayloadRequest\n  showHiddenFields?: boolean\n  user?: Document\n}\n\nexport default async function findVersionByIDLocal<TSlug extends CollectionSlug>(\n  payload: Payload,\n  options: Options<TSlug>,\n): Promise<TypeWithVersion<DataFromCollectionSlug<TSlug>>> {\n  const {\n    id,\n    collection: collectionSlug,\n    depth,\n    disableErrors = false,\n    overrideAccess = true,\n    showHiddenFields,\n  } = options\n\n  const collection = payload.collections[collectionSlug]\n\n  if (!collection) {\n    throw new APIError(\n      `The collection with slug ${String(\n        collectionSlug,\n      )} can't be found. Find Version By ID Operation.`,\n    )\n  }\n\n  return findVersionByIDOperation({\n    id,\n    collection,\n    depth,\n    disableErrors,\n    overrideAccess,\n    req: await createLocalReq(options, payload),\n    showHiddenFields,\n  })\n}\n"],"names":["APIError","createLocalReq","findVersionByIDOperation","findVersionByIDLocal","payload","options","id","collection","collectionSlug","depth","disableErrors","overrideAccess","showHiddenFields","collections","String","req"],"mappings":";;;AAKA,SAASA,QAAQ,QAAQ,2BAA0B;AAEnD,SAASE,wBAAwB,QAAQ,wBAAuB;AADhE,SAASD,cAAc,QAAQ,uCAAsC;;;;AAqBtD,eAAeE,qBAC5BC,OAAgB,EAChBC,OAAuB;IAEvB,MAAM,EACJC,EAAE,EACFC,YAAYC,cAAc,EAC1BC,KAAK,EACLC,gBAAgB,KAAK,EACrBC,iBAAiB,IAAI,EACrBC,gBAAgB,EACjB,GAAGP;IAEJ,MAAME,aAAaH,QAAQS,WAAW,CAACL,eAAe;IAEtD,IAAI,CAACD,YAAY;QACf,MAAM,0JAAIP,WAAAA,CACR,CAAC,yBAAyB,EAAEc,OAC1BN,gBACA,8CAA8C,CAAC;IAErD;IAEA,2LAAON,2BAAAA,EAAyB;QAC9BI;QACAC;QACAE;QACAC;QACAC;QACAI,KAAK,yKAAMd,iBAAAA,EAAeI,SAASD;QACnCQ;IACF;AACF"}},
    {"offset": {"line": 10916, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 10922, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/payload/src/collections/operations/findVersions.ts"],"sourcesContent":["import type { PaginatedDocs } from '../../database/types.js'\nimport type { PayloadRequest, Sort, Where } from '../../types/index.js'\nimport type { TypeWithVersion } from '../../versions/types.js'\nimport type { Collection } from '../config/types.js'\n\nimport executeAccess from '../../auth/executeAccess.js'\nimport { combineQueries } from '../../database/combineQueries.js'\nimport { validateQueryPaths } from '../../database/queryValidation/validateQueryPaths.js'\nimport { afterRead } from '../../fields/hooks/afterRead/index.js'\nimport { killTransaction } from '../../utilities/killTransaction.js'\nimport sanitizeInternalFields from '../../utilities/sanitizeInternalFields.js'\nimport { buildVersionCollectionFields } from '../../versions/buildCollectionFields.js'\n\nexport type Arguments = {\n  collection: Collection\n  depth?: number\n  limit?: number\n  overrideAccess?: boolean\n  page?: number\n  pagination?: boolean\n  req?: PayloadRequest\n  showHiddenFields?: boolean\n  sort?: Sort\n  where?: Where\n}\n\nexport const findVersionsOperation = async <TData extends TypeWithVersion<TData>>(\n  args: Arguments,\n): Promise<PaginatedDocs<TData>> => {\n  const {\n    collection: { config: collectionConfig },\n    depth,\n    limit,\n    overrideAccess,\n    page,\n    pagination = true,\n    req: { fallbackLocale, locale, payload },\n    req,\n    showHiddenFields,\n    sort,\n    where,\n  } = args\n\n  try {\n    // /////////////////////////////////////\n    // Access\n    // /////////////////////////////////////\n\n    let accessResults\n\n    if (!overrideAccess) {\n      accessResults = await executeAccess({ req }, collectionConfig.access.readVersions)\n    }\n\n    const versionFields = buildVersionCollectionFields(payload.config, collectionConfig)\n\n    await validateQueryPaths({\n      collectionConfig,\n      overrideAccess,\n      req,\n      versionFields,\n      where,\n    })\n\n    const fullWhere = combineQueries(where, accessResults)\n\n    // /////////////////////////////////////\n    // Find\n    // /////////////////////////////////////\n\n    const paginatedDocs = await payload.db.findVersions<TData>({\n      collection: collectionConfig.slug,\n      limit: limit ?? 10,\n      locale,\n      page: page || 1,\n      pagination,\n      req,\n      sort,\n      where: fullWhere,\n    })\n\n    // /////////////////////////////////////\n    // beforeRead - Collection\n    // /////////////////////////////////////\n\n    let result = {\n      ...paginatedDocs,\n      docs: await Promise.all(\n        paginatedDocs.docs.map(async (doc) => {\n          const docRef = doc\n          await collectionConfig.hooks.beforeRead.reduce(async (priorHook, hook) => {\n            await priorHook\n\n            docRef.version =\n              (await hook({\n                collection: collectionConfig,\n                context: req.context,\n                doc: docRef.version,\n                query: fullWhere,\n                req,\n              })) || docRef.version\n          }, Promise.resolve())\n\n          return docRef\n        }),\n      ),\n    } as PaginatedDocs<TData>\n\n    // /////////////////////////////////////\n    // afterRead - Fields\n    // /////////////////////////////////////\n\n    result = {\n      ...result,\n      docs: await Promise.all(\n        result.docs.map(async (data) => ({\n          ...data,\n          version: await afterRead({\n            collection: collectionConfig,\n            context: req.context,\n            depth,\n            doc: data.version,\n            draft: undefined,\n            fallbackLocale,\n            findMany: true,\n            global: null,\n            locale,\n            overrideAccess,\n            req,\n            showHiddenFields,\n          }),\n        })),\n      ),\n    }\n\n    // /////////////////////////////////////\n    // afterRead - Collection\n    // /////////////////////////////////////\n\n    result = {\n      ...result,\n      docs: await Promise.all(\n        result.docs.map(async (doc) => {\n          const docRef = doc\n\n          await collectionConfig.hooks.afterRead.reduce(async (priorHook, hook) => {\n            await priorHook\n\n            docRef.version =\n              (await hook({\n                collection: collectionConfig,\n                context: req.context,\n                doc: doc.version,\n                findMany: true,\n                query: fullWhere,\n                req,\n              })) || doc.version\n          }, Promise.resolve())\n\n          return docRef\n        }),\n      ),\n    }\n\n    // /////////////////////////////////////\n    // Return results\n    // /////////////////////////////////////\n\n    result = {\n      ...result,\n      docs: result.docs.map((doc) => sanitizeInternalFields<TData>(doc)),\n    }\n\n    return result\n  } catch (error: unknown) {\n    await killTransaction(req)\n    throw error\n  }\n}\n"],"names":["executeAccess","combineQueries","validateQueryPaths","afterRead","killTransaction","sanitizeInternalFields","buildVersionCollectionFields","findVersionsOperation","args","collection","config","collectionConfig","depth","limit","overrideAccess","page","pagination","req","fallbackLocale","locale","payload","showHiddenFields","sort","where","accessResults","access","readVersions","versionFields","fullWhere","paginatedDocs","db","findVersions","slug","result","docs","Promise","all","map","doc","docRef","hooks","beforeRead","reduce","priorHook","hook","version","context","query","resolve","data","draft","undefined","findMany","global","error"],"mappings":"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"}},
    {"offset": {"line": 11050, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 11056, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/payload/src/collections/operations/local/findVersions.ts"],"sourcesContent":["import type { PaginatedDocs } from '../../../database/types.js'\nimport type { CollectionSlug, Payload, TypedLocale } from '../../../index.js'\nimport type { Document, PayloadRequest, RequestContext, Sort, Where } from '../../../types/index.js'\nimport type { TypeWithVersion } from '../../../versions/types.js'\nimport type { DataFromCollectionSlug } from '../../config/types.js'\n\nimport { APIError } from '../../../errors/index.js'\nimport { createLocalReq } from '../../../utilities/createLocalReq.js'\nimport { findVersionsOperation } from '../findVersions.js'\n\nexport type Options<TSlug extends CollectionSlug> = {\n  collection: TSlug\n  /**\n   * context, which will then be passed to req.context, which can be read by hooks\n   */\n  context?: RequestContext\n  depth?: number\n  draft?: boolean\n  fallbackLocale?: TypedLocale\n  limit?: number\n  locale?: 'all' | TypedLocale\n  overrideAccess?: boolean\n  page?: number\n  req?: PayloadRequest\n  showHiddenFields?: boolean\n  sort?: Sort\n  user?: Document\n  where?: Where\n}\n\nexport default async function findVersionsLocal<TSlug extends CollectionSlug>(\n  payload: Payload,\n  options: Options<TSlug>,\n): Promise<PaginatedDocs<TypeWithVersion<DataFromCollectionSlug<TSlug>>>> {\n  const {\n    collection: collectionSlug,\n    depth,\n    limit,\n    overrideAccess = true,\n    page,\n    showHiddenFields,\n    sort,\n    where,\n  } = options\n\n  const collection = payload.collections[collectionSlug]\n\n  if (!collection) {\n    throw new APIError(\n      `The collection with slug ${String(collectionSlug)} can't be found. Find Versions Operation.`,\n    )\n  }\n\n  return findVersionsOperation({\n    collection,\n    depth,\n    limit,\n    overrideAccess,\n    page,\n    req: await createLocalReq(options, payload),\n    showHiddenFields,\n    sort,\n    where,\n  })\n}\n"],"names":["APIError","createLocalReq","findVersionsOperation","findVersionsLocal","payload","options","collection","collectionSlug","depth","limit","overrideAccess","page","showHiddenFields","sort","where","collections","String","req"],"mappings":";;;AAMA,SAASA,QAAQ,QAAQ,2BAA0B;AAEnD,SAASE,qBAAqB,QAAQ,qBAAoB;AAD1D,SAASD,cAAc,QAAQ,uCAAsC;;;;AAuBtD,eAAeE,kBAC5BC,OAAgB,EAChBC,OAAuB;IAEvB,MAAM,EACJC,YAAYC,cAAc,EAC1BC,KAAK,EACLC,KAAK,EACLC,iBAAiB,IAAI,EACrBC,IAAI,EACJC,gBAAgB,EAChBC,IAAI,EACJC,KAAK,EACN,GAAGT;IAEJ,MAAMC,aAAaF,QAAQW,WAAW,CAACR,eAAe;IAEtD,IAAI,CAACD,YAAY;QACf,MAAM,0JAAIN,WAAAA,CACR,CAAC,yBAAyB,EAAEgB,OAAOT,gBAAgB,yCAAyC,CAAC;IAEjG;IAEA,wLAAOL,wBAAAA,EAAsB;QAC3BI;QACAE;QACAC;QACAC;QACAC;QACAM,KAAK,yKAAMhB,iBAAAA,EAAeI,SAASD;QACnCQ;QACAC;QACAC;IACF;AACF"}},
    {"offset": {"line": 11083, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 11089, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/payload/src/collections/operations/restoreVersion.ts"],"sourcesContent":["import httpStatus from 'http-status'\n\nimport type { FindOneArgs } from '../../database/types.js'\nimport type { PayloadRequest } from '../../types/index.js'\nimport type { Collection, TypeWithID } from '../config/types.js'\n\nimport executeAccess from '../../auth/executeAccess.js'\nimport { hasWhereAccessResult } from '../../auth/types.js'\nimport { combineQueries } from '../../database/combineQueries.js'\nimport { APIError, Forbidden, NotFound } from '../../errors/index.js'\nimport { afterChange } from '../../fields/hooks/afterChange/index.js'\nimport { afterRead } from '../../fields/hooks/afterRead/index.js'\nimport { killTransaction } from '../../utilities/killTransaction.js'\nimport { getLatestCollectionVersion } from '../../versions/getLatestCollectionVersion.js'\n\nexport type Arguments = {\n  collection: Collection\n  currentDepth?: number\n  depth?: number\n  disableErrors?: boolean\n  draft?: boolean\n  id: number | string\n  overrideAccess?: boolean\n  req: PayloadRequest\n  showHiddenFields?: boolean\n}\n\nexport const restoreVersionOperation = async <TData extends TypeWithID = any>(\n  args: Arguments,\n): Promise<TData> => {\n  const {\n    id,\n    collection: { config: collectionConfig },\n    depth,\n    draft,\n    overrideAccess = false,\n    req,\n    req: { fallbackLocale, locale, payload },\n    showHiddenFields,\n  } = args\n\n  try {\n    if (!id) {\n      throw new APIError('Missing ID of version to restore.', httpStatus.BAD_REQUEST)\n    }\n\n    // /////////////////////////////////////\n    // Retrieve original raw version\n    // /////////////////////////////////////\n\n    const { docs: versionDocs } = await req.payload.db.findVersions({\n      collection: collectionConfig.slug,\n      limit: 1,\n      locale,\n      pagination: false,\n      req,\n      where: { id: { equals: id } },\n    })\n\n    const [rawVersion] = versionDocs\n\n    if (!rawVersion) {\n      throw new NotFound(req.t)\n    }\n\n    const parentDocID = rawVersion.parent\n\n    // /////////////////////////////////////\n    // Access\n    // /////////////////////////////////////\n\n    const accessResults = !overrideAccess\n      ? await executeAccess({ id: parentDocID, req }, collectionConfig.access.update)\n      : true\n    const hasWherePolicy = hasWhereAccessResult(accessResults)\n\n    // /////////////////////////////////////\n    // Retrieve document\n    // /////////////////////////////////////\n\n    const findOneArgs: FindOneArgs = {\n      collection: collectionConfig.slug,\n      locale,\n      req,\n      where: combineQueries({ id: { equals: parentDocID } }, accessResults),\n    }\n\n    const doc = await req.payload.db.findOne(findOneArgs)\n\n    if (!doc && !hasWherePolicy) {\n      throw new NotFound(req.t)\n    }\n    if (!doc && hasWherePolicy) {\n      throw new Forbidden(req.t)\n    }\n\n    // /////////////////////////////////////\n    // fetch previousDoc\n    // /////////////////////////////////////\n\n    const prevDocWithLocales = await getLatestCollectionVersion({\n      id: parentDocID,\n      config: collectionConfig,\n      payload,\n      query: findOneArgs,\n      req,\n    })\n\n    // /////////////////////////////////////\n    // Update\n    // /////////////////////////////////////\n\n    let result = await req.payload.db.updateOne({\n      id: parentDocID,\n      collection: collectionConfig.slug,\n      data: rawVersion.version,\n      req,\n    })\n\n    // /////////////////////////////////////\n    // Save `previousDoc` as a version after restoring\n    // /////////////////////////////////////\n\n    const prevVersion = { ...prevDocWithLocales }\n\n    delete prevVersion.id\n\n    await payload.db.createVersion({\n      autosave: false,\n      collectionSlug: collectionConfig.slug,\n      createdAt: prevVersion.createdAt,\n      parent: parentDocID,\n      req,\n      updatedAt: new Date().toISOString(),\n      versionData: draft ? { ...rawVersion.version, _status: 'draft' } : rawVersion.version,\n    })\n\n    // /////////////////////////////////////\n    // afterRead - Fields\n    // /////////////////////////////////////\n\n    result = await afterRead({\n      collection: collectionConfig,\n      context: req.context,\n      depth,\n      doc: result,\n      draft: undefined,\n      fallbackLocale,\n      global: null,\n      locale,\n      overrideAccess,\n      req,\n      showHiddenFields,\n    })\n\n    // /////////////////////////////////////\n    // afterRead - Collection\n    // /////////////////////////////////////\n\n    await collectionConfig.hooks.afterRead.reduce(async (priorHook, hook) => {\n      await priorHook\n\n      result =\n        (await hook({\n          collection: collectionConfig,\n          context: req.context,\n          doc: result,\n          req,\n        })) || result\n    }, Promise.resolve())\n\n    // /////////////////////////////////////\n    // afterChange - Fields\n    // /////////////////////////////////////\n\n    result = await afterChange({\n      collection: collectionConfig,\n      context: req.context,\n      data: result,\n      doc: result,\n      global: null,\n      operation: 'update',\n      previousDoc: prevDocWithLocales,\n      req,\n    })\n\n    // /////////////////////////////////////\n    // afterChange - Collection\n    // /////////////////////////////////////\n\n    await collectionConfig.hooks.afterChange.reduce(async (priorHook, hook) => {\n      await priorHook\n\n      result =\n        (await hook({\n          collection: collectionConfig,\n          context: req.context,\n          doc: result,\n          operation: 'update',\n          previousDoc: prevDocWithLocales,\n          req,\n        })) || result\n    }, Promise.resolve())\n\n    return result\n  } catch (error: unknown) {\n    await killTransaction(req)\n    throw error\n  }\n}\n"],"names":["httpStatus","executeAccess","hasWhereAccessResult","combineQueries","APIError","Forbidden","NotFound","afterChange","afterRead","killTransaction","getLatestCollectionVersion","restoreVersionOperation","args","id","collection","config","collectionConfig","depth","draft","overrideAccess","req","fallbackLocale","locale","payload","showHiddenFields","BAD_REQUEST","docs","versionDocs","db","findVersions","slug","limit","pagination","where","equals","rawVersion","t","parentDocID","parent","accessResults","access","update","hasWherePolicy","findOneArgs","doc","findOne","prevDocWithLocales","query","result","updateOne","data","version","prevVersion","createVersion","autosave","collectionSlug","createdAt","updatedAt","Date","toISOString","versionData","_status","context","undefined","global","hooks","reduce","priorHook","hook","Promise","resolve","operation","previousDoc","error"],"mappings":"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"}},
    {"offset": {"line": 11265, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 11271, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/payload/src/collections/operations/local/restoreVersion.ts"],"sourcesContent":["import type { CollectionSlug, Payload, TypedLocale } from '../../../index.js'\nimport type { Document, PayloadRequest, RequestContext } from '../../../types/index.js'\nimport type { DataFromCollectionSlug } from '../../config/types.js'\n\nimport { APIError } from '../../../errors/index.js'\nimport { createLocalReq } from '../../../utilities/createLocalReq.js'\nimport { restoreVersionOperation } from '../restoreVersion.js'\n\nexport type Options<TSlug extends CollectionSlug> = {\n  collection: TSlug\n  /**\n   * context, which will then be passed to req.context, which can be read by hooks\n   */\n  context?: RequestContext\n  depth?: number\n  draft?: boolean\n  fallbackLocale?: TypedLocale\n  id: string\n  locale?: TypedLocale\n  overrideAccess?: boolean\n  req?: PayloadRequest\n  showHiddenFields?: boolean\n  user?: Document\n}\n\nexport default async function restoreVersionLocal<TSlug extends CollectionSlug>(\n  payload: Payload,\n  options: Options<TSlug>,\n): Promise<DataFromCollectionSlug<TSlug>> {\n  const { id, collection: collectionSlug, depth, overrideAccess = true, showHiddenFields } = options\n\n  const collection = payload.collections[collectionSlug]\n\n  if (!collection) {\n    throw new APIError(\n      `The collection with slug ${String(\n        collectionSlug,\n      )} can't be found. Restore Version Operation.`,\n    )\n  }\n\n  const args = {\n    id,\n    collection,\n    depth,\n    overrideAccess,\n    payload,\n    req: await createLocalReq(options, payload),\n    showHiddenFields,\n  }\n\n  return restoreVersionOperation(args)\n}\n"],"names":["APIError","createLocalReq","restoreVersionOperation","restoreVersionLocal","payload","options","id","collection","collectionSlug","depth","overrideAccess","showHiddenFields","collections","String","args","req"],"mappings":";;;AAIA,SAASA,QAAQ,QAAQ,2BAA0B;AACnD,SAASC,cAAc,QAAQ,uCAAsC;AACrE,SAASC,uBAAuB,QAAQ,uBAAsB;;;;AAmB/C,eAAeC,oBAC5BC,OAAgB,EAChBC,OAAuB;IAEvB,MAAM,EAAEC,EAAE,EAAEC,YAAYC,cAAc,EAAEC,KAAK,EAAEC,iBAAiB,IAAI,EAAEC,gBAAgB,EAAE,GAAGN;IAE3F,MAAME,aAAaH,QAAQQ,WAAW,CAACJ,eAAe;IAEtD,IAAI,CAACD,YAAY;QACf,MAAM,0JAAIP,WAAAA,CACR,CAAC,yBAAyB,EAAEa,OAC1BL,gBACA,2CAA2C,CAAC;IAElD;IAEA,MAAMM,OAAO;QACXR;QACAC;QACAE;QACAC;QACAN;QACAW,KAAK,yKAAMd,iBAAAA,EAAeI,SAASD;QACnCO;IACF;IAEA,0LAAOT,0BAAAA,EAAwBY;AACjC"}},
    {"offset": {"line": 11297, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 11303, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/payload/src/collections/operations/update.ts"],"sourcesContent":["import type { DeepPartial } from 'ts-essentials'\n\nimport httpStatus from 'http-status'\n\nimport type { AccessResult } from '../../config/types.js'\nimport type { CollectionSlug } from '../../index.js'\nimport type { PayloadRequest, Where } from '../../types/index.js'\nimport type {\n  BulkOperationResult,\n  Collection,\n  DataFromCollectionSlug,\n  RequiredDataFromCollectionSlug,\n} from '../config/types.js'\n\nimport { ensureUsernameOrEmail } from '../../auth/ensureUsernameOrEmail.js'\nimport executeAccess from '../../auth/executeAccess.js'\nimport { combineQueries } from '../../database/combineQueries.js'\nimport { validateQueryPaths } from '../../database/queryValidation/validateQueryPaths.js'\nimport { APIError } from '../../errors/index.js'\nimport { afterChange } from '../../fields/hooks/afterChange/index.js'\nimport { afterRead } from '../../fields/hooks/afterRead/index.js'\nimport { beforeChange } from '../../fields/hooks/beforeChange/index.js'\nimport { beforeValidate } from '../../fields/hooks/beforeValidate/index.js'\nimport { deleteAssociatedFiles } from '../../uploads/deleteAssociatedFiles.js'\nimport { generateFileData } from '../../uploads/generateFileData.js'\nimport { unlinkTempFiles } from '../../uploads/unlinkTempFiles.js'\nimport { uploadFiles } from '../../uploads/uploadFiles.js'\nimport { checkDocumentLockStatus } from '../../utilities/checkDocumentLockStatus.js'\nimport { commitTransaction } from '../../utilities/commitTransaction.js'\nimport { initTransaction } from '../../utilities/initTransaction.js'\nimport { killTransaction } from '../../utilities/killTransaction.js'\nimport { buildVersionCollectionFields } from '../../versions/buildCollectionFields.js'\nimport { appendVersionToQueryKey } from '../../versions/drafts/appendVersionToQueryKey.js'\nimport { saveVersion } from '../../versions/saveVersion.js'\nimport { buildAfterOperation } from './utils.js'\n\nexport type Arguments<TSlug extends CollectionSlug> = {\n  collection: Collection\n  data: DeepPartial<RequiredDataFromCollectionSlug<TSlug>>\n  depth?: number\n  disableTransaction?: boolean\n  disableVerificationEmail?: boolean\n  draft?: boolean\n  limit?: number\n  overrideAccess?: boolean\n  overrideLock?: boolean\n  overwriteExistingFiles?: boolean\n  req: PayloadRequest\n  showHiddenFields?: boolean\n  where: Where\n}\n\nexport const updateOperation = async <TSlug extends CollectionSlug>(\n  incomingArgs: Arguments<TSlug>,\n): Promise<BulkOperationResult<TSlug>> => {\n  let args = incomingArgs\n\n  try {\n    const shouldCommit = !args.disableTransaction && (await initTransaction(args.req))\n\n    // /////////////////////////////////////\n    // beforeOperation - Collection\n    // /////////////////////////////////////\n\n    await args.collection.config.hooks.beforeOperation.reduce(async (priorHook, hook) => {\n      await priorHook\n\n      args =\n        (await hook({\n          args,\n          collection: args.collection.config,\n          context: args.req.context,\n          operation: 'update',\n          req: args.req,\n        })) || args\n    }, Promise.resolve())\n\n    const {\n      collection: { config: collectionConfig },\n      collection,\n      depth,\n      draft: draftArg = false,\n      limit = 0,\n      overrideAccess,\n      overrideLock,\n      overwriteExistingFiles = false,\n      req: {\n        fallbackLocale,\n        locale,\n        payload: { config },\n        payload,\n      },\n      req,\n      showHiddenFields,\n      where,\n    } = args\n\n    if (!where) {\n      throw new APIError(\"Missing 'where' query of documents to update.\", httpStatus.BAD_REQUEST)\n    }\n\n    const { data: bulkUpdateData } = args\n    const shouldSaveDraft = Boolean(draftArg && collectionConfig.versions.drafts)\n\n    // /////////////////////////////////////\n    // Access\n    // /////////////////////////////////////\n\n    let accessResult: AccessResult\n    if (!overrideAccess) {\n      accessResult = await executeAccess({ req }, collectionConfig.access.update)\n    }\n\n    await validateQueryPaths({\n      collectionConfig,\n      overrideAccess,\n      req,\n      where,\n    })\n\n    // /////////////////////////////////////\n    // Retrieve documents\n    // /////////////////////////////////////\n\n    const fullWhere = combineQueries(where, accessResult)\n\n    let docs\n\n    if (collectionConfig.versions?.drafts && shouldSaveDraft) {\n      const versionsWhere = appendVersionToQueryKey(fullWhere)\n\n      await validateQueryPaths({\n        collectionConfig: collection.config,\n        overrideAccess,\n        req,\n        versionFields: buildVersionCollectionFields(payload.config, collection.config),\n        where: versionsWhere,\n      })\n\n      const query = await payload.db.queryDrafts<DataFromCollectionSlug<TSlug>>({\n        collection: collectionConfig.slug,\n        limit,\n        locale,\n        pagination: false,\n        req,\n        where: versionsWhere,\n      })\n\n      docs = query.docs\n    } else {\n      const query = await payload.db.find({\n        collection: collectionConfig.slug,\n        limit,\n        locale,\n        pagination: false,\n        req,\n        where: fullWhere,\n      })\n\n      docs = query.docs\n    }\n\n    // /////////////////////////////////////\n    // Generate data for all files and sizes\n    // /////////////////////////////////////\n\n    const { data: newFileData, files: filesToUpload } = await generateFileData({\n      collection,\n      config,\n      data: bulkUpdateData,\n      operation: 'update',\n      overwriteExistingFiles,\n      req,\n      throwOnMissingFile: false,\n    })\n\n    const errors = []\n\n    const promises = docs.map(async (doc) => {\n      const { id } = doc\n      let data = {\n        ...newFileData,\n        ...bulkUpdateData,\n      }\n\n      try {\n        // /////////////////////////////////////\n        // Handle potentially locked documents\n        // /////////////////////////////////////\n\n        await checkDocumentLockStatus({\n          id,\n          collectionSlug: collectionConfig.slug,\n          lockErrorMessage: `Document with ID ${id} is currently locked by another user and cannot be updated.`,\n          overrideLock,\n          req,\n        })\n\n        const originalDoc = await afterRead({\n          collection: collectionConfig,\n          context: req.context,\n          depth: 0,\n          doc,\n          draft: draftArg,\n          fallbackLocale,\n          global: null,\n          locale,\n          overrideAccess: true,\n          req,\n          showHiddenFields: true,\n        })\n\n        await deleteAssociatedFiles({\n          collectionConfig,\n          config,\n          doc,\n          files: filesToUpload,\n          overrideDelete: false,\n          req,\n        })\n\n        if (args.collection.config.auth) {\n          ensureUsernameOrEmail<TSlug>({\n            authOptions: args.collection.config.auth,\n            collectionSlug: args.collection.config.slug,\n            data: args.data,\n            operation: 'update',\n            originalDoc,\n            req: args.req,\n          })\n        }\n\n        // /////////////////////////////////////\n        // beforeValidate - Fields\n        // /////////////////////////////////////\n\n        data = await beforeValidate<DeepPartial<DataFromCollectionSlug<TSlug>>>({\n          id,\n          collection: collectionConfig,\n          context: req.context,\n          data,\n          doc: originalDoc,\n          global: null,\n          operation: 'update',\n          overrideAccess,\n          req,\n        })\n\n        // /////////////////////////////////////\n        // beforeValidate - Collection\n        // /////////////////////////////////////\n\n        await collectionConfig.hooks.beforeValidate.reduce(async (priorHook, hook) => {\n          await priorHook\n\n          data =\n            (await hook({\n              collection: collectionConfig,\n              context: req.context,\n              data,\n              operation: 'update',\n              originalDoc,\n              req,\n            })) || data\n        }, Promise.resolve())\n\n        // /////////////////////////////////////\n        // Write files to local storage\n        // /////////////////////////////////////\n\n        if (!collectionConfig.upload.disableLocalStorage) {\n          await uploadFiles(payload, filesToUpload, req)\n        }\n\n        // /////////////////////////////////////\n        // beforeChange - Collection\n        // /////////////////////////////////////\n\n        await collectionConfig.hooks.beforeChange.reduce(async (priorHook, hook) => {\n          await priorHook\n\n          data =\n            (await hook({\n              collection: collectionConfig,\n              context: req.context,\n              data,\n              operation: 'update',\n              originalDoc,\n              req,\n            })) || data\n        }, Promise.resolve())\n\n        // /////////////////////////////////////\n        // beforeChange - Fields\n        // /////////////////////////////////////\n\n        let result = await beforeChange({\n          id,\n          collection: collectionConfig,\n          context: req.context,\n          data,\n          doc: originalDoc,\n          docWithLocales: doc,\n          global: null,\n          operation: 'update',\n          req,\n          skipValidation:\n            shouldSaveDraft &&\n            collectionConfig.versions.drafts &&\n            !collectionConfig.versions.drafts.validate &&\n            data._status !== 'published',\n        })\n\n        // /////////////////////////////////////\n        // Update\n        // /////////////////////////////////////\n\n        if (!shouldSaveDraft || data._status === 'published') {\n          result = await req.payload.db.updateOne({\n            id,\n            collection: collectionConfig.slug,\n            data: result,\n            locale,\n            req,\n          })\n        }\n\n        // /////////////////////////////////////\n        // Create version\n        // /////////////////////////////////////\n\n        if (collectionConfig.versions) {\n          result = await saveVersion({\n            id,\n            collection: collectionConfig,\n            docWithLocales: result,\n            payload,\n            req,\n          })\n        }\n\n        // /////////////////////////////////////\n        // afterRead - Fields\n        // /////////////////////////////////////\n\n        result = await afterRead({\n          collection: collectionConfig,\n          context: req.context,\n          depth,\n          doc: result,\n          draft: draftArg,\n          fallbackLocale: null,\n          global: null,\n          locale,\n          overrideAccess,\n          req,\n          showHiddenFields,\n        })\n\n        // /////////////////////////////////////\n        // afterRead - Collection\n        // /////////////////////////////////////\n\n        await collectionConfig.hooks.afterRead.reduce(async (priorHook, hook) => {\n          await priorHook\n\n          result =\n            (await hook({\n              collection: collectionConfig,\n              context: req.context,\n              doc: result,\n              req,\n            })) || result\n        }, Promise.resolve())\n\n        // /////////////////////////////////////\n        // afterChange - Fields\n        // /////////////////////////////////////\n\n        result = await afterChange({\n          collection: collectionConfig,\n          context: req.context,\n          data,\n          doc: result,\n          global: null,\n          operation: 'update',\n          previousDoc: originalDoc,\n          req,\n        })\n\n        // /////////////////////////////////////\n        // afterChange - Collection\n        // /////////////////////////////////////\n\n        await collectionConfig.hooks.afterChange.reduce(async (priorHook, hook) => {\n          await priorHook\n\n          result =\n            (await hook({\n              collection: collectionConfig,\n              context: req.context,\n              doc: result,\n              operation: 'update',\n              previousDoc: originalDoc,\n              req,\n            })) || result\n        }, Promise.resolve())\n\n        await unlinkTempFiles({\n          collectionConfig,\n          config,\n          req,\n        })\n\n        // /////////////////////////////////////\n        // Return results\n        // /////////////////////////////////////\n\n        return result\n      } catch (error) {\n        errors.push({\n          id,\n          message: error.message,\n        })\n      }\n      return null\n    })\n\n    const awaitedDocs = await Promise.all(promises)\n\n    let result = {\n      docs: awaitedDocs.filter(Boolean),\n      errors,\n    }\n\n    // /////////////////////////////////////\n    // afterOperation - Collection\n    // /////////////////////////////////////\n\n    result = await buildAfterOperation({\n      args,\n      collection: collectionConfig,\n      operation: 'update',\n      result,\n    })\n\n    if (shouldCommit) {\n      await commitTransaction(req)\n    }\n\n    return result\n  } catch (error: unknown) {\n    await killTransaction(args.req)\n    throw error\n  }\n}\n"],"names":["httpStatus","ensureUsernameOrEmail","executeAccess","combineQueries","validateQueryPaths","APIError","afterChange","afterRead","beforeChange","beforeValidate","deleteAssociatedFiles","generateFileData","unlinkTempFiles","uploadFiles","checkDocumentLockStatus","commitTransaction","initTransaction","killTransaction","buildVersionCollectionFields","appendVersionToQueryKey","saveVersion","buildAfterOperation","updateOperation","incomingArgs","args","shouldCommit","disableTransaction","req","collection","config","hooks","beforeOperation","reduce","priorHook","hook","context","operation","Promise","resolve","collectionConfig","depth","draft","draftArg","limit","overrideAccess","overrideLock","overwriteExistingFiles","fallbackLocale","locale","payload","showHiddenFields","where","BAD_REQUEST","data","bulkUpdateData","shouldSaveDraft","Boolean","versions","drafts","accessResult","access","update","fullWhere","docs","versionsWhere","versionFields","query","db","queryDrafts","slug","pagination","find","newFileData","files","filesToUpload","throwOnMissingFile","errors","promises","map","doc","id","collectionSlug","lockErrorMessage","originalDoc","global","overrideDelete","auth","authOptions","upload","disableLocalStorage","result","docWithLocales","skipValidation","validate","_status","updateOne","previousDoc","error","push","message","awaitedDocs","all","filter"],"mappings":"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"}},
    {"offset": {"line": 11665, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 11671, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/payload/src/collections/operations/updateByID.ts"],"sourcesContent":["import type { DeepPartial } from 'ts-essentials'\n\nimport httpStatus from 'http-status'\n\nimport type { FindOneArgs } from '../../database/types.js'\nimport type { Args } from '../../fields/hooks/beforeChange/index.js'\nimport type { CollectionSlug } from '../../index.js'\nimport type { PayloadRequest } from '../../types/index.js'\nimport type {\n  Collection,\n  DataFromCollectionSlug,\n  RequiredDataFromCollectionSlug,\n} from '../config/types.js'\n\nimport { ensureUsernameOrEmail } from '../../auth/ensureUsernameOrEmail.js'\nimport executeAccess from '../../auth/executeAccess.js'\nimport { generatePasswordSaltHash } from '../../auth/strategies/local/generatePasswordSaltHash.js'\nimport { hasWhereAccessResult } from '../../auth/types.js'\nimport { combineQueries } from '../../database/combineQueries.js'\nimport { APIError, Forbidden, NotFound } from '../../errors/index.js'\nimport { afterChange } from '../../fields/hooks/afterChange/index.js'\nimport { afterRead } from '../../fields/hooks/afterRead/index.js'\nimport { beforeChange } from '../../fields/hooks/beforeChange/index.js'\nimport { beforeValidate } from '../../fields/hooks/beforeValidate/index.js'\nimport { deleteAssociatedFiles } from '../../uploads/deleteAssociatedFiles.js'\nimport { generateFileData } from '../../uploads/generateFileData.js'\nimport { unlinkTempFiles } from '../../uploads/unlinkTempFiles.js'\nimport { uploadFiles } from '../../uploads/uploadFiles.js'\nimport { checkDocumentLockStatus } from '../../utilities/checkDocumentLockStatus.js'\nimport { commitTransaction } from '../../utilities/commitTransaction.js'\nimport { initTransaction } from '../../utilities/initTransaction.js'\nimport { killTransaction } from '../../utilities/killTransaction.js'\nimport { getLatestCollectionVersion } from '../../versions/getLatestCollectionVersion.js'\nimport { saveVersion } from '../../versions/saveVersion.js'\nimport { buildAfterOperation } from './utils.js'\n\nexport type Arguments<TSlug extends CollectionSlug> = {\n  autosave?: boolean\n  collection: Collection\n  data: DeepPartial<RequiredDataFromCollectionSlug<TSlug>>\n  depth?: number\n  disableTransaction?: boolean\n  disableVerificationEmail?: boolean\n  draft?: boolean\n  id: number | string\n  overrideAccess?: boolean\n  overrideLock?: boolean\n  overwriteExistingFiles?: boolean\n  publishSpecificLocale?: string\n  req: PayloadRequest\n  showHiddenFields?: boolean\n}\n\nexport const updateByIDOperation = async <TSlug extends CollectionSlug>(\n  incomingArgs: Arguments<TSlug>,\n): Promise<DataFromCollectionSlug<TSlug>> => {\n  let args = incomingArgs\n\n  try {\n    const shouldCommit = !args.disableTransaction && (await initTransaction(args.req))\n\n    // /////////////////////////////////////\n    // beforeOperation - Collection\n    // /////////////////////////////////////\n\n    await args.collection.config.hooks.beforeOperation.reduce(async (priorHook, hook) => {\n      await priorHook\n\n      args =\n        (await hook({\n          args,\n          collection: args.collection.config,\n          context: args.req.context,\n          operation: 'update',\n          req: args.req,\n        })) || args\n    }, Promise.resolve())\n\n    if (args.publishSpecificLocale) {\n      args.req.locale = args.publishSpecificLocale\n    }\n\n    const {\n      id,\n      autosave = false,\n      collection: { config: collectionConfig },\n      collection,\n      depth,\n      draft: draftArg = false,\n      overrideAccess,\n      overrideLock,\n      overwriteExistingFiles = false,\n      publishSpecificLocale,\n      req: {\n        fallbackLocale,\n        locale,\n        payload: { config },\n        payload,\n      },\n      req,\n      showHiddenFields,\n    } = args\n\n    if (!id) {\n      throw new APIError('Missing ID of document to update.', httpStatus.BAD_REQUEST)\n    }\n\n    let { data } = args\n    const password = data?.password\n    const shouldSaveDraft = Boolean(draftArg && collectionConfig.versions.drafts)\n    const shouldSavePassword = Boolean(password && collectionConfig.auth && !shouldSaveDraft)\n\n    // /////////////////////////////////////\n    // Access\n    // /////////////////////////////////////\n\n    const accessResults = !overrideAccess\n      ? await executeAccess({ id, data, req }, collectionConfig.access.update)\n      : true\n    const hasWherePolicy = hasWhereAccessResult(accessResults)\n\n    // /////////////////////////////////////\n    // Retrieve document\n    // /////////////////////////////////////\n\n    const findOneArgs: FindOneArgs = {\n      collection: collectionConfig.slug,\n      locale,\n      req,\n      where: combineQueries({ id: { equals: id } }, accessResults),\n    }\n\n    const docWithLocales = await getLatestCollectionVersion({\n      id,\n      config: collectionConfig,\n      payload,\n      query: findOneArgs,\n      req,\n    })\n\n    if (!docWithLocales && !hasWherePolicy) {\n      throw new NotFound(req.t)\n    }\n    if (!docWithLocales && hasWherePolicy) {\n      throw new Forbidden(req.t)\n    }\n\n    // /////////////////////////////////////\n    // Handle potentially locked documents\n    // /////////////////////////////////////\n\n    await checkDocumentLockStatus({\n      id,\n      collectionSlug: collectionConfig.slug,\n      lockErrorMessage: `Document with ID ${id} is currently locked by another user and cannot be updated.`,\n      overrideLock,\n      req,\n    })\n\n    const originalDoc = await afterRead({\n      collection: collectionConfig,\n      context: req.context,\n      depth: 0,\n      doc: docWithLocales,\n      draft: draftArg,\n      fallbackLocale: null,\n      global: null,\n      locale,\n      overrideAccess: true,\n      req,\n      showHiddenFields: true,\n    })\n\n    if (args.collection.config.auth) {\n      ensureUsernameOrEmail<TSlug>({\n        authOptions: args.collection.config.auth,\n        collectionSlug: args.collection.config.slug,\n        data: args.data,\n        operation: 'update',\n        originalDoc,\n        req: args.req,\n      })\n    }\n\n    // /////////////////////////////////////\n    // Generate data for all files and sizes\n    // /////////////////////////////////////\n\n    const { data: newFileData, files: filesToUpload } = await generateFileData({\n      collection,\n      config,\n      data,\n      operation: 'update',\n      overwriteExistingFiles,\n      req,\n      throwOnMissingFile: false,\n    })\n\n    data = newFileData\n\n    // /////////////////////////////////////\n    // Delete any associated files\n    // /////////////////////////////////////\n\n    await deleteAssociatedFiles({\n      collectionConfig,\n      config,\n      doc: docWithLocales,\n      files: filesToUpload,\n      overrideDelete: false,\n      req,\n    })\n\n    // /////////////////////////////////////\n    // beforeValidate - Fields\n    // /////////////////////////////////////\n\n    data = await beforeValidate<DeepPartial<DataFromCollectionSlug<TSlug>>>({\n      id,\n      collection: collectionConfig,\n      context: req.context,\n      data,\n      doc: originalDoc,\n      global: null,\n      operation: 'update',\n      overrideAccess,\n      req,\n    })\n\n    // /////////////////////////////////////\n    // beforeValidate - Collection\n    // /////////////////////////////////////\n\n    await collectionConfig.hooks.beforeValidate.reduce(async (priorHook, hook) => {\n      await priorHook\n\n      data =\n        (await hook({\n          collection: collectionConfig,\n          context: req.context,\n          data,\n          operation: 'update',\n          originalDoc,\n          req,\n        })) || data\n    }, Promise.resolve())\n\n    // /////////////////////////////////////\n    // Write files to local storage\n    // /////////////////////////////////////\n\n    if (!collectionConfig.upload.disableLocalStorage) {\n      await uploadFiles(payload, filesToUpload, req)\n    }\n\n    // /////////////////////////////////////\n    // beforeChange - Collection\n    // /////////////////////////////////////\n\n    await collectionConfig.hooks.beforeChange.reduce(async (priorHook, hook) => {\n      await priorHook\n\n      data =\n        (await hook({\n          collection: collectionConfig,\n          context: req.context,\n          data,\n          operation: 'update',\n          originalDoc,\n          req,\n        })) || data\n    }, Promise.resolve())\n\n    // /////////////////////////////////////\n    // beforeChange - Fields\n    // /////////////////////////////////////\n\n    let publishedDocWithLocales = docWithLocales\n    let versionSnapshotResult\n\n    const beforeChangeArgs: Args<DataFromCollectionSlug<TSlug>> = {\n      id,\n      collection: collectionConfig,\n      context: req.context,\n      data: { ...data, id },\n      doc: originalDoc,\n      docWithLocales: undefined,\n      global: null,\n      operation: 'update',\n      req,\n      skipValidation:\n        shouldSaveDraft &&\n        collectionConfig.versions.drafts &&\n        !collectionConfig.versions.drafts.validate &&\n        data._status !== 'published',\n    }\n\n    if (publishSpecificLocale) {\n      publishedDocWithLocales = await getLatestCollectionVersion({\n        id,\n        config: collectionConfig,\n        payload,\n        published: true,\n        query: findOneArgs,\n        req,\n      })\n\n      versionSnapshotResult = await beforeChange({\n        ...beforeChangeArgs,\n        docWithLocales,\n      })\n    }\n\n    let result = await beforeChange({\n      ...beforeChangeArgs,\n      docWithLocales: publishedDocWithLocales,\n    })\n\n    // /////////////////////////////////////\n    // Handle potential password update\n    // /////////////////////////////////////\n\n    const dataToUpdate: Record<string, unknown> = { ...result }\n\n    if (shouldSavePassword && typeof password === 'string') {\n      const { hash, salt } = await generatePasswordSaltHash({\n        collection: collectionConfig,\n        password,\n        req,\n      })\n      dataToUpdate.salt = salt\n      dataToUpdate.hash = hash\n      delete dataToUpdate.password\n      delete data.password\n    }\n\n    // /////////////////////////////////////\n    // Update\n    // /////////////////////////////////////\n\n    if (!shouldSaveDraft || data._status === 'published') {\n      result = await req.payload.db.updateOne({\n        id,\n        collection: collectionConfig.slug,\n        data: dataToUpdate,\n        locale,\n        req,\n      })\n    }\n\n    // /////////////////////////////////////\n    // Create version\n    // /////////////////////////////////////\n\n    if (collectionConfig.versions) {\n      result = await saveVersion({\n        id,\n        autosave,\n        collection: collectionConfig,\n        docWithLocales: result,\n        draft: shouldSaveDraft,\n        payload,\n        publishSpecificLocale,\n        req,\n        snapshot: versionSnapshotResult,\n      })\n    }\n\n    // /////////////////////////////////////\n    // afterRead - Fields\n    // /////////////////////////////////////\n\n    result = await afterRead({\n      collection: collectionConfig,\n      context: req.context,\n      depth,\n      doc: result,\n      draft: draftArg,\n      fallbackLocale,\n      global: null,\n      locale,\n      overrideAccess,\n      req,\n      showHiddenFields,\n    })\n\n    // /////////////////////////////////////\n    // afterRead - Collection\n    // /////////////////////////////////////\n\n    await collectionConfig.hooks.afterRead.reduce(async (priorHook, hook) => {\n      await priorHook\n\n      result =\n        (await hook({\n          collection: collectionConfig,\n          context: req.context,\n          doc: result,\n          req,\n        })) || result\n    }, Promise.resolve())\n\n    // /////////////////////////////////////\n    // afterChange - Fields\n    // /////////////////////////////////////\n\n    result = await afterChange({\n      collection: collectionConfig,\n      context: req.context,\n      data,\n      doc: result,\n      global: null,\n      operation: 'update',\n      previousDoc: originalDoc,\n      req,\n    })\n\n    // /////////////////////////////////////\n    // afterChange - Collection\n    // /////////////////////////////////////\n\n    await collectionConfig.hooks.afterChange.reduce(async (priorHook, hook) => {\n      await priorHook\n\n      result =\n        (await hook({\n          collection: collectionConfig,\n          context: req.context,\n          doc: result,\n          operation: 'update',\n          previousDoc: originalDoc,\n          req,\n        })) || result\n    }, Promise.resolve())\n\n    // /////////////////////////////////////\n    // afterOperation - Collection\n    // /////////////////////////////////////\n\n    result = await buildAfterOperation({\n      args,\n      collection: collectionConfig,\n      operation: 'updateByID',\n      result,\n    })\n\n    await unlinkTempFiles({\n      collectionConfig,\n      config,\n      req,\n    })\n\n    // /////////////////////////////////////\n    // Return results\n    // /////////////////////////////////////\n\n    if (shouldCommit) {\n      await commitTransaction(req)\n    }\n\n    return result\n  } catch (error: unknown) {\n    await killTransaction(args.req)\n    throw error\n  }\n}\n"],"names":["httpStatus","ensureUsernameOrEmail","executeAccess","generatePasswordSaltHash","hasWhereAccessResult","combineQueries","APIError","Forbidden","NotFound","afterChange","afterRead","beforeChange","beforeValidate","deleteAssociatedFiles","generateFileData","unlinkTempFiles","uploadFiles","checkDocumentLockStatus","commitTransaction","initTransaction","killTransaction","getLatestCollectionVersion","saveVersion","buildAfterOperation","updateByIDOperation","incomingArgs","args","shouldCommit","disableTransaction","req","collection","config","hooks","beforeOperation","reduce","priorHook","hook","context","operation","Promise","resolve","publishSpecificLocale","locale","id","autosave","collectionConfig","depth","draft","draftArg","overrideAccess","overrideLock","overwriteExistingFiles","fallbackLocale","payload","showHiddenFields","BAD_REQUEST","data","password","shouldSaveDraft","Boolean","versions","drafts","shouldSavePassword","auth","accessResults","access","update","hasWherePolicy","findOneArgs","slug","where","equals","docWithLocales","query","t","collectionSlug","lockErrorMessage","originalDoc","doc","global","authOptions","newFileData","files","filesToUpload","throwOnMissingFile","overrideDelete","upload","disableLocalStorage","publishedDocWithLocales","versionSnapshotResult","beforeChangeArgs","undefined","skipValidation","validate","_status","published","result","dataToUpdate","hash","salt","db","updateOne","snapshot","previousDoc","error"],"mappings":"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"}},
    {"offset": {"line": 12052, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 12058, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/payload/src/collections/operations/local/update.ts"],"sourcesContent":["import type { DeepPartial } from 'ts-essentials'\n\nimport type { CollectionSlug, Payload, TypedLocale } from '../../../index.js'\nimport type { Document, PayloadRequest, RequestContext, Where } from '../../../types/index.js'\nimport type { File } from '../../../uploads/types.js'\nimport type {\n  BulkOperationResult,\n  DataFromCollectionSlug,\n  RequiredDataFromCollectionSlug,\n} from '../../config/types.js'\n\nimport { APIError } from '../../../errors/index.js'\nimport { getFileByPath } from '../../../uploads/getFileByPath.js'\nimport { createLocalReq } from '../../../utilities/createLocalReq.js'\nimport { updateOperation } from '../update.js'\nimport { updateByIDOperation } from '../updateByID.js'\n\nexport type BaseOptions<TSlug extends CollectionSlug> = {\n  autosave?: boolean\n  collection: TSlug\n  /**\n   * context, which will then be passed to req.context, which can be read by hooks\n   */\n  context?: RequestContext\n  data: DeepPartial<RequiredDataFromCollectionSlug<TSlug>>\n  depth?: number\n  disableTransaction?: boolean\n  draft?: boolean\n  fallbackLocale?: TypedLocale\n  file?: File\n  filePath?: string\n  locale?: TypedLocale\n  overrideAccess?: boolean\n  overrideLock?: boolean\n  overwriteExistingFiles?: boolean\n  publishSpecificLocale?: string\n  req?: PayloadRequest\n  showHiddenFields?: boolean\n  user?: Document\n}\n\nexport type ByIDOptions<TSlug extends CollectionSlug> = {\n  id: number | string\n  limit?: never\n  where?: never\n} & BaseOptions<TSlug>\n\nexport type ManyOptions<TSlug extends CollectionSlug> = {\n  id?: never\n  limit?: number\n  where: Where\n} & BaseOptions<TSlug>\n\nexport type Options<TSlug extends CollectionSlug> = ByIDOptions<TSlug> | ManyOptions<TSlug>\n\nasync function updateLocal<TSlug extends CollectionSlug>(\n  payload: Payload,\n  options: ByIDOptions<TSlug>,\n): Promise<DataFromCollectionSlug<TSlug>>\nasync function updateLocal<TSlug extends CollectionSlug>(\n  payload: Payload,\n  options: ManyOptions<TSlug>,\n): Promise<BulkOperationResult<TSlug>>\nasync function updateLocal<TSlug extends CollectionSlug>(\n  payload: Payload,\n  options: Options<TSlug>,\n): Promise<BulkOperationResult<TSlug> | DataFromCollectionSlug<TSlug>>\nasync function updateLocal<TSlug extends CollectionSlug>(\n  payload: Payload,\n  options: Options<TSlug>,\n): Promise<BulkOperationResult<TSlug> | DataFromCollectionSlug<TSlug>> {\n  const {\n    id,\n    autosave,\n    collection: collectionSlug,\n    data,\n    depth,\n    disableTransaction,\n    draft,\n    file,\n    filePath,\n    limit,\n    overrideAccess = true,\n    overrideLock,\n    overwriteExistingFiles = false,\n    publishSpecificLocale,\n    showHiddenFields,\n    where,\n  } = options\n\n  const collection = payload.collections[collectionSlug]\n\n  if (!collection) {\n    throw new APIError(\n      `The collection with slug ${String(collectionSlug)} can't be found. Update Operation.`,\n    )\n  }\n\n  const req = await createLocalReq(options, payload)\n  req.file = file ?? (await getFileByPath(filePath))\n\n  const args = {\n    id,\n    autosave,\n    collection,\n    data,\n    depth,\n    disableTransaction,\n    draft,\n    limit,\n    overrideAccess,\n    overrideLock,\n    overwriteExistingFiles,\n    payload,\n    publishSpecificLocale,\n    req,\n    showHiddenFields,\n    where,\n  }\n\n  if (options.id) {\n    return updateByIDOperation<TSlug>(args)\n  }\n  return updateOperation<TSlug>(args)\n}\n\nexport default updateLocal\n"],"names":["APIError","getFileByPath","createLocalReq","updateOperation","updateByIDOperation","updateLocal","payload","options","id","autosave","collection","collectionSlug","data","depth","disableTransaction","draft","file","filePath","limit","overrideAccess","overrideLock","overwriteExistingFiles","publishSpecificLocale","showHiddenFields","where","collections","String","req","args"],"mappings":";;;AAWA,SAASA,QAAQ,QAAQ,2BAA0B;AAEnD,SAASE,cAAc,QAAQ,uCAAsC;AADrE,SAASD,aAAa,QAAQ,oCAAmC;AAEjE,SAASE,eAAe,QAAQ,eAAc;AAC9C,SAASC,mBAAmB,QAAQ,mBAAkB;;;;;;AAoDtD,eAAeC,YACbC,OAAgB,EAChBC,OAAuB;IAEvB,MAAM,EACJC,EAAE,EACFC,QAAQ,EACRC,YAAYC,cAAc,EAC1BC,IAAI,EACJC,KAAK,EACLC,kBAAkB,EAClBC,KAAK,EACLC,IAAI,EACJC,QAAQ,EACRC,KAAK,EACLC,iBAAiB,IAAI,EACrBC,YAAY,EACZC,yBAAyB,KAAK,EAC9BC,qBAAqB,EACrBC,gBAAgB,EAChBC,KAAK,EACN,GAAGjB;IAEJ,MAAMG,aAAaJ,QAAQmB,WAAW,CAACd,eAAe;IAEtD,IAAI,CAACD,YAAY;QACf,MAAM,0JAAIV,WAAAA,CACR,CAAC,yBAAyB,EAAE0B,OAAOf,gBAAgB,kCAAkC,CAAC;IAE1F;IAEA,MAAMgB,MAAM,MAAMzB,oLAAAA,EAAeK,SAASD;IAC1CqB,IAAIX,IAAI,GAAGA,QAAS,OAAMf,+KAAAA,EAAcgB;IAExC,MAAMW,OAAO;QACXpB;QACAC;QACAC;QACAE;QACAC;QACAC;QACAC;QACAG;QACAC;QACAC;QACAC;QACAf;QACAgB;QACAK;QACAJ;QACAC;IACF;IAEA,IAAIjB,QAAQC,EAAE,EAAE;QACd,sLAAOJ,sBAAAA,EAA2BwB;IACpC;IACA,kLAAOzB,kBAAAA,EAAuByB;AAChC;uCAEevB,YAAW"}},
    {"offset": {"line": 12104, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 12110, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/payload/src/collections/operations/local/index.ts"],"sourcesContent":["import auth from '../../../auth/operations/local/index.js'\nimport count from './count.js'\nimport create from './create.js'\nimport deleteLocal from './delete.js'\nimport { duplicate } from './duplicate.js'\nimport { findLocal } from './find.js'\nimport findByID from './findByID.js'\nimport findVersionByID from './findVersionByID.js'\nimport findVersions from './findVersions.js'\nimport restoreVersion from './restoreVersion.js'\nimport update from './update.js'\n\nexport default {\n  auth,\n  count,\n  create,\n  deleteLocal,\n  duplicate,\n  find: findLocal,\n  findByID,\n  findVersionByID,\n  findVersions,\n  restoreVersion,\n  update,\n}\n"],"names":["auth","count","create","deleteLocal","duplicate","findLocal","findByID","findVersionByID","findVersions","restoreVersion","update","find"],"mappings":";;;AAAA,OAAOA,UAAU,0CAAyC;AAC1D,OAAOC,WAAW,aAAY;AAC9B,OAAOC,YAAY,cAAa;AAChC,OAAOC,iBAAiB,cAAa;AACrC,SAASC,SAAS,QAAQ,iBAAgB;AAC1C,SAASC,SAAS,QAAQ,YAAW;AACrC,OAAOC,cAAc,gBAAe;AACpC,OAAOC,qBAAqB,uBAAsB;AAClD,OAAOC,kBAAkB,oBAAmB;AAC5C,OAAOC,oBAAoB,sBAAqB;AAChD,OAAOC,YAAY,cAAa;;;;;;;;;;;;uCAEjB;kLACbV,UAAAA;0LACAC,UAAAA;4LACAC,UAAAA;iMACAC,UAAAA;kMACAC,YAAAA;IACAO,oLAAMN,YAAAA;gMACNC,UAAAA;8MACAC,UAAAA;wMACAC,UAAAA;4MACAC,UAAAA;4LACAC,UAAAA;AACF,EAAC"}},
    {"offset": {"line": 12149, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 12155, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/payload/src/auth/crypto.ts"],"sourcesContent":["import crypto from 'crypto'\n\nconst algorithm = 'aes-256-ctr'\n\nexport function encrypt(text: string): string {\n  const iv = crypto.randomBytes(16)\n  const cipher = crypto.createCipheriv(algorithm, this.secret, iv)\n\n  const encrypted = Buffer.concat([cipher.update(text), cipher.final()])\n\n  const ivString = iv.toString('hex')\n  const encryptedString = encrypted.toString('hex')\n\n  return `${ivString}${encryptedString}`\n}\n\nexport function decrypt(hash: string): string {\n  const iv = hash.slice(0, 32)\n  const content = hash.slice(32)\n\n  const decipher = crypto.createDecipheriv(algorithm, this.secret, Buffer.from(iv, 'hex'))\n\n  const decrypted = Buffer.concat([decipher.update(Buffer.from(content, 'hex')), decipher.final()])\n\n  return decrypted.toString()\n}\n"],"names":["crypto","algorithm","encrypt","text","iv","randomBytes","cipher","createCipheriv","secret","encrypted","Buffer","concat","update","final","ivString","toString","encryptedString","decrypt","hash","slice","content","decipher","createDecipheriv","from","decrypted"],"mappings":";;;;AAAA,OAAOA,YAAY,SAAQ;;AAE3B,MAAMC,YAAY;AAEX,SAASC,QAAQC,IAAY;IAClC,MAAMC,qGAAKJ,UAAAA,CAAOK,WAAW,CAAC;IAC9B,MAAMC,yGAASN,UAAAA,CAAOO,cAAc,CAACN,WAAW,IAAI,CAACO,MAAM,EAAEJ;IAE7D,MAAMK,YAAYC,OAAOC,MAAM,CAAC;QAACL,OAAOM,MAAM,CAACT;QAAOG,OAAOO,KAAK;KAAG;IAErE,MAAMC,WAAWV,GAAGW,QAAQ,CAAC;IAC7B,MAAMC,kBAAkBP,UAAUM,QAAQ,CAAC;IAE3C,OAAO,CAAC,EAAED,SAAS,EAAEE,gBAAgB,CAAC;AACxC;AAEO,SAASC,QAAQC,IAAY;IAClC,MAAMd,KAAKc,KAAKC,KAAK,CAAC,GAAG;IACzB,MAAMC,UAAUF,KAAKC,KAAK,CAAC;IAE3B,MAAME,2GAAWrB,UAAAA,CAAOsB,gBAAgB,CAACrB,WAAW,IAAI,CAACO,MAAM,EAAEE,OAAOa,IAAI,CAACnB,IAAI;IAEjF,MAAMoB,YAAYd,OAAOC,MAAM,CAAC;QAACU,SAAST,MAAM,CAACF,OAAOa,IAAI,CAACH,SAAS;QAASC,SAASR,KAAK;KAAG;IAEhG,OAAOW,UAAUT,QAAQ;AAC3B"}},
    {"offset": {"line": 12183, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 12189, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/payload/src/globals/operations/findOne.ts"],"sourcesContent":["import type { AccessResult } from '../../config/types.js'\nimport type { PayloadRequest, Where } from '../../types/index.js'\nimport type { SanitizedGlobalConfig } from '../config/types.js'\n\nimport executeAccess from '../../auth/executeAccess.js'\nimport { afterRead } from '../../fields/hooks/afterRead/index.js'\nimport { killTransaction } from '../../utilities/killTransaction.js'\nimport replaceWithDraftIfAvailable from '../../versions/drafts/replaceWithDraftIfAvailable.js'\n\ntype Args = {\n  depth?: number\n  draft?: boolean\n  globalConfig: SanitizedGlobalConfig\n  includeLockStatus?: boolean\n  overrideAccess?: boolean\n  req: PayloadRequest\n  showHiddenFields?: boolean\n  slug: string\n}\n\nexport const findOneOperation = async <T extends Record<string, unknown>>(\n  args: Args,\n): Promise<T> => {\n  const {\n    slug,\n    depth,\n    draft: draftEnabled = false,\n    globalConfig,\n    includeLockStatus,\n    overrideAccess = false,\n    req: { fallbackLocale, locale },\n    req,\n    showHiddenFields,\n  } = args\n\n  try {\n    // /////////////////////////////////////\n    // Retrieve and execute access\n    // /////////////////////////////////////\n\n    let accessResult: AccessResult\n\n    if (!overrideAccess) {\n      accessResult = await executeAccess({ req }, globalConfig.access.read)\n    }\n\n    // /////////////////////////////////////\n    // Perform database operation\n    // /////////////////////////////////////\n\n    let doc = await req.payload.db.findGlobal({\n      slug,\n      locale,\n      req,\n      where: overrideAccess ? undefined : (accessResult as Where),\n    })\n    if (!doc) {\n      doc = {}\n    }\n\n    // /////////////////////////////////////\n    // Include Lock Status if required\n    // /////////////////////////////////////\n\n    if (includeLockStatus && slug) {\n      let lockStatus = null\n\n      try {\n        const lockedDocument = await req.payload.find({\n          collection: 'payload-locked-documents',\n          depth: 1,\n          limit: 1,\n          pagination: false,\n          req,\n          where: {\n            globalSlug: {\n              equals: slug,\n            },\n          },\n        })\n\n        if (lockedDocument && lockedDocument.docs.length > 0) {\n          lockStatus = lockedDocument.docs[0]\n        }\n      } catch {\n        // swallow error\n      }\n\n      doc._isLocked = !!lockStatus\n      doc._userEditing = lockStatus?.user?.value ?? null\n    }\n\n    // /////////////////////////////////////\n    // Replace document with draft if available\n    // /////////////////////////////////////\n\n    if (globalConfig.versions?.drafts && draftEnabled) {\n      doc = await replaceWithDraftIfAvailable({\n        accessResult,\n        doc,\n        entity: globalConfig,\n        entityType: 'global',\n        overrideAccess,\n        req,\n      })\n    }\n\n    // /////////////////////////////////////\n    // Execute before global hook\n    // /////////////////////////////////////\n\n    await globalConfig.hooks.beforeRead.reduce(async (priorHook, hook) => {\n      await priorHook\n\n      doc =\n        (await hook({\n          context: req.context,\n          doc,\n          global: globalConfig,\n          req,\n        })) || doc\n    }, Promise.resolve())\n\n    // /////////////////////////////////////\n    // Execute field-level hooks and access\n    // /////////////////////////////////////\n\n    doc = await afterRead({\n      collection: null,\n      context: req.context,\n      depth,\n      doc,\n      draft: draftEnabled,\n      fallbackLocale,\n      global: globalConfig,\n      locale,\n      overrideAccess,\n      req,\n      showHiddenFields,\n    })\n\n    // /////////////////////////////////////\n    // Execute after global hook\n    // /////////////////////////////////////\n\n    await globalConfig.hooks.afterRead.reduce(async (priorHook, hook) => {\n      await priorHook\n\n      doc =\n        (await hook({\n          context: req.context,\n          doc,\n          global: globalConfig,\n          req,\n        })) || doc\n    }, Promise.resolve())\n\n    // /////////////////////////////////////\n    // Return results\n    // /////////////////////////////////////\n\n    return doc\n  } catch (error: unknown) {\n    await killTransaction(req)\n    throw error\n  }\n}\n"],"names":["executeAccess","afterRead","killTransaction","replaceWithDraftIfAvailable","findOneOperation","args","slug","depth","draft","draftEnabled","globalConfig","includeLockStatus","overrideAccess","req","fallbackLocale","locale","showHiddenFields","accessResult","access","read","doc","payload","db","findGlobal","where","undefined","lockStatus","lockedDocument","find","collection","limit","pagination","globalSlug","equals","docs","length","_isLocked","_userEditing","user","value","versions","drafts","entity","entityType","hooks","beforeRead","reduce","priorHook","hook","context","global","Promise","resolve","error"],"mappings":"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"}},
    {"offset": {"line": 12313, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 12319, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/payload/src/globals/operations/local/findOne.ts"],"sourcesContent":["import type { GlobalSlug, Payload, RequestContext, TypedLocale } from '../../../index.js'\nimport type { Document, PayloadRequest } from '../../../types/index.js'\nimport type { DataFromGlobalSlug } from '../../config/types.js'\n\nimport { APIError } from '../../../errors/index.js'\nimport { createLocalReq } from '../../../utilities/createLocalReq.js'\nimport { findOneOperation } from '../findOne.js'\n\nexport type Options<TSlug extends GlobalSlug> = {\n  context?: RequestContext\n  depth?: number\n  draft?: boolean\n  fallbackLocale?: TypedLocale\n  includeLockStatus?: boolean\n  locale?: 'all' | TypedLocale\n  overrideAccess?: boolean\n  req?: PayloadRequest\n  showHiddenFields?: boolean\n  slug: TSlug\n  user?: Document\n}\n\nexport default async function findOneLocal<TSlug extends GlobalSlug>(\n  payload: Payload,\n  options: Options<TSlug>,\n): Promise<DataFromGlobalSlug<TSlug>> {\n  const {\n    slug: globalSlug,\n    depth,\n    draft = false,\n    includeLockStatus,\n    overrideAccess = true,\n    showHiddenFields,\n  } = options\n\n  const globalConfig = payload.globals.config.find((config) => config.slug === globalSlug)\n\n  if (!globalConfig) {\n    throw new APIError(`The global with slug ${String(globalSlug)} can't be found.`)\n  }\n\n  return findOneOperation({\n    slug: globalSlug as string,\n    depth,\n    draft,\n    globalConfig,\n    includeLockStatus,\n    overrideAccess,\n    req: await createLocalReq(options, payload),\n    showHiddenFields,\n  })\n}\n"],"names":["APIError","createLocalReq","findOneOperation","findOneLocal","payload","options","slug","globalSlug","depth","draft","includeLockStatus","overrideAccess","showHiddenFields","globalConfig","globals","config","find","String","req"],"mappings":";;;AAIA,SAASA,QAAQ,QAAQ,2BAA0B;AAEnD,SAASE,gBAAgB,QAAQ,gBAAe;AADhD,SAASD,cAAc,QAAQ,uCAAsC;;;;AAiBtD,eAAeE,aAC5BC,OAAgB,EAChBC,OAAuB;IAEvB,MAAM,EACJC,MAAMC,UAAU,EAChBC,KAAK,EACLC,QAAQ,KAAK,EACbC,iBAAiB,EACjBC,iBAAiB,IAAI,EACrBC,gBAAgB,EACjB,GAAGP;IAEJ,MAAMQ,eAAeT,QAAQU,OAAO,CAACC,MAAM,CAACC,IAAI,CAAC,CAACD,SAAWA,OAAOT,IAAI,KAAKC;IAE7E,IAAI,CAACM,cAAc;QACjB,MAAM,IAAIb,iKAAAA,CAAS,CAAC,qBAAqB,EAAEiB,OAAOV,YAAY,gBAAgB,CAAC;IACjF;IAEA,+KAAOL,mBAAAA,EAAiB;QACtBI,MAAMC;QACNC;QACAC;QACAI;QACAH;QACAC;QACAO,KAAK,yKAAMjB,iBAAAA,EAAeI,SAASD;QACnCQ;IACF;AACF"}},
    {"offset": {"line": 12345, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 12351, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/payload/src/globals/operations/findVersionByID.ts"],"sourcesContent":["import type { FindGlobalVersionsArgs } from '../../database/types.js'\nimport type { PayloadRequest } from '../../types/index.js'\nimport type { TypeWithVersion } from '../../versions/types.js'\nimport type { SanitizedGlobalConfig } from '../config/types.js'\n\nimport executeAccess from '../../auth/executeAccess.js'\nimport { combineQueries } from '../../database/combineQueries.js'\nimport { Forbidden, NotFound } from '../../errors/index.js'\nimport { afterRead } from '../../fields/hooks/afterRead/index.js'\nimport { deepCopyObjectSimple } from '../../utilities/deepCopyObject.js'\nimport { killTransaction } from '../../utilities/killTransaction.js'\n\nexport type Arguments = {\n  currentDepth?: number\n  depth?: number\n  disableErrors?: boolean\n  globalConfig: SanitizedGlobalConfig\n  id: number | string\n  overrideAccess?: boolean\n  req: PayloadRequest\n  showHiddenFields?: boolean\n}\n\nexport const findVersionByIDOperation = async <T extends TypeWithVersion<T> = any>(\n  args: Arguments,\n): Promise<T> => {\n  const {\n    id,\n    currentDepth,\n    depth,\n    disableErrors,\n    globalConfig,\n    overrideAccess,\n    req: { fallbackLocale, locale, payload },\n    req,\n    showHiddenFields,\n  } = args\n\n  try {\n    // /////////////////////////////////////\n    // Access\n    // /////////////////////////////////////\n\n    const accessResults = !overrideAccess\n      ? await executeAccess({ id, disableErrors, req }, globalConfig.access.readVersions)\n      : true\n\n    // If errors are disabled, and access returns false, return null\n    if (accessResults === false) {\n      return null\n    }\n\n    const hasWhereAccess = typeof accessResults === 'object'\n\n    const findGlobalVersionsArgs: FindGlobalVersionsArgs = {\n      global: globalConfig.slug,\n      limit: 1,\n      locale,\n      req,\n      where: combineQueries({ id: { equals: id } }, accessResults),\n    }\n\n    // /////////////////////////////////////\n    // Find by ID\n    // /////////////////////////////////////\n\n    if (!findGlobalVersionsArgs.where.and[0].id) {\n      throw new NotFound(req.t)\n    }\n\n    const { docs: results } = await payload.db.findGlobalVersions(findGlobalVersionsArgs)\n    if (!results || results?.length === 0) {\n      if (!disableErrors) {\n        if (!hasWhereAccess) {\n          throw new NotFound(req.t)\n        }\n        if (hasWhereAccess) {\n          throw new Forbidden(req.t)\n        }\n      }\n\n      return null\n    }\n\n    // Clone the result - it may have come back memoized\n    let result: any = deepCopyObjectSimple(results[0])\n\n    // Patch globalType onto version doc\n    result.version.globalType = globalConfig.slug\n\n    // /////////////////////////////////////\n    // beforeRead - Collection\n    // /////////////////////////////////////\n\n    await globalConfig.hooks.beforeRead.reduce(async (priorHook, hook) => {\n      await priorHook\n\n      result =\n        (await hook({\n          context: req.context,\n          doc: result.version,\n          global: globalConfig,\n          req,\n        })) || result.version\n    }, Promise.resolve())\n\n    // /////////////////////////////////////\n    // afterRead - Fields\n    // /////////////////////////////////////\n\n    result.version = await afterRead({\n      collection: null,\n      context: req.context,\n      currentDepth,\n      depth,\n      doc: result.version,\n      draft: undefined,\n      fallbackLocale,\n      global: globalConfig,\n      locale,\n      overrideAccess,\n      req,\n      showHiddenFields,\n    })\n\n    // /////////////////////////////////////\n    // afterRead - Global\n    // /////////////////////////////////////\n\n    await globalConfig.hooks.afterRead.reduce(async (priorHook, hook) => {\n      await priorHook\n\n      result.version =\n        (await hook({\n          context: req.context,\n          doc: result.version,\n          global: globalConfig,\n          query: findGlobalVersionsArgs.where,\n          req,\n        })) || result.version\n    }, Promise.resolve())\n\n    return result\n  } catch (error: unknown) {\n    await killTransaction(req)\n    throw error\n  }\n}\n"],"names":["executeAccess","combineQueries","Forbidden","NotFound","afterRead","deepCopyObjectSimple","killTransaction","findVersionByIDOperation","args","id","currentDepth","depth","disableErrors","globalConfig","overrideAccess","req","fallbackLocale","locale","payload","showHiddenFields","accessResults","access","readVersions","hasWhereAccess","findGlobalVersionsArgs","global","slug","limit","where","equals","and","t","docs","results","db","findGlobalVersions","length","result","version","globalType","hooks","beforeRead","reduce","priorHook","hook","context","doc","Promise","resolve","collection","draft","undefined","query","error"],"mappings":";;;AAKA,OAAOA,mBAAmB,8BAA6B;AACvD,SAASC,cAAc,QAAQ,mCAAkC;AACjE,SAASC,SAAS,EAAEC,QAAQ,QAAQ,wBAAuB;AAE3D,SAASE,oBAAoB,QAAQ,oCAAmC;AADxE,SAASD,SAAS,QAAQ,wCAAuC;;AAEjE,SAASE,eAAe,QAAQ,qCAAoC;;;;;;;AAa7D,MAAMC,2BAA2B,OACtCC;IAEA,MAAM,EACJC,EAAE,EACFC,YAAY,EACZC,KAAK,EACLC,aAAa,EACbC,YAAY,EACZC,cAAc,EACdC,KAAK,EAAEC,cAAc,EAAEC,MAAM,EAAEC,OAAO,EAAE,EACxCH,GAAG,EACHI,gBAAgB,EACjB,GAAGX;IAEJ,IAAI;QACF,wCAAwC;QACxC,SAAS;QACT,wCAAwC;QAExC,MAAMY,gBAAgB,CAACN,iBACnB,mKAAMd,UAAAA,EAAc;YAAES;YAAIG;YAAeG;QAAI,GAAGF,aAAaQ,MAAM,CAACC,YAAY,IAChF;QAEJ,gEAAgE;QAChE,IAAIF,kBAAkB,OAAO;YAC3B,OAAO;QACT;QAEA,MAAMG,iBAAiB,OAAOH,kBAAkB;QAEhD,MAAMI,yBAAiD;YACrDC,QAAQZ,aAAaa,IAAI;YACzBC,OAAO;YACPV;YACAF;YACAa,yKAAO3B,iBAAAA,EAAe;gBAAEQ,IAAI;oBAAEoB,QAAQpB;gBAAG;YAAE,GAAGW;QAChD;QAEA,wCAAwC;QACxC,aAAa;QACb,wCAAwC;QAExC,IAAI,CAACI,uBAAuBI,KAAK,CAACE,GAAG,CAAC,EAAE,CAACrB,EAAE,EAAE;YAC3C,MAAM,0JAAIN,WAAAA,CAASY,IAAIgB,CAAC;QAC1B;QAEA,MAAM,EAAEC,MAAMC,OAAO,EAAE,GAAG,MAAMf,QAAQgB,EAAE,CAACC,kBAAkB,CAACX;QAC9D,IAAI,CAACS,WAAWA,SAASG,WAAW,GAAG;YACrC,IAAI,CAACxB,eAAe;gBAClB,IAAI,CAACW,gBAAgB;oBACnB,MAAM,0JAAIpB,WAAAA,CAASY,IAAIgB,CAAC;gBAC1B;gBACA,IAAIR,gBAAgB;oBAClB,MAAM,2JAAIrB,YAAAA,CAAUa,IAAIgB,CAAC;gBAC3B;YACF;YAEA,OAAO;QACT;QAEA,oDAAoD;QACpD,IAAIM,UAAchC,yLAAAA,EAAqB4B,OAAO,CAAC,EAAE;QAEjD,oCAAoC;QACpCI,OAAOC,OAAO,CAACC,UAAU,GAAG1B,aAAaa,IAAI;QAE7C,wCAAwC;QACxC,0BAA0B;QAC1B,wCAAwC;QAExC,MAAMb,aAAa2B,KAAK,CAACC,UAAU,CAACC,MAAM,CAAC,OAAOC,WAAWC;YAC3D,MAAMD;YAENN,SACG,MAAMO,KAAK;gBACVC,SAAS9B,IAAI8B,OAAO;gBACpBC,KAAKT,OAAOC,OAAO;gBACnBb,QAAQZ;gBACRE;YACF,MAAOsB,OAAOC,OAAO;QACzB,GAAGS,QAAQC,OAAO;QAElB,wCAAwC;QACxC,qBAAqB;QACrB,wCAAwC;QAExCX,OAAOC,OAAO,GAAG,MAAMlC,yLAAAA,EAAU;YAC/B6C,YAAY;YACZJ,SAAS9B,IAAI8B,OAAO;YACpBnC;YACAC;YACAmC,KAAKT,OAAOC,OAAO;YACnBY,OAAOC;YACPnC;YACAS,QAAQZ;YACRI;YACAH;YACAC;YACAI;QACF;QAEA,wCAAwC;QACxC,qBAAqB;QACrB,wCAAwC;QAExC,MAAMN,aAAa2B,KAAK,CAACpC,SAAS,CAACsC,MAAM,CAAC,OAAOC,WAAWC;YAC1D,MAAMD;YAENN,OAAOC,OAAO,GACX,MAAMM,KAAK;gBACVC,SAAS9B,IAAI8B,OAAO;gBACpBC,KAAKT,OAAOC,OAAO;gBACnBb,QAAQZ;gBACRuC,OAAO5B,uBAAuBI,KAAK;gBACnCb;YACF,MAAOsB,OAAOC,OAAO;QACzB,GAAGS,QAAQC,OAAO;QAElB,OAAOX;IACT,EAAE,OAAOgB,OAAgB;QACvB,0KAAM/C,kBAAAA,EAAgBS;QACtB,MAAMsC;IACR;AACF,EAAC"}},
    {"offset": {"line": 12464, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 12470, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/payload/src/globals/operations/local/findVersionByID.ts"],"sourcesContent":["import type { GlobalSlug, Payload, RequestContext, TypedLocale } from '../../../index.js'\nimport type { Document, PayloadRequest } from '../../../types/index.js'\nimport type { TypeWithVersion } from '../../../versions/types.js'\nimport type { DataFromGlobalSlug } from '../../config/types.js'\n\nimport { APIError } from '../../../errors/index.js'\nimport { createLocalReq } from '../../../utilities/createLocalReq.js'\nimport { findVersionByIDOperation } from '../findVersionByID.js'\n\nexport type Options<TSlug extends GlobalSlug> = {\n  context?: RequestContext\n  depth?: number\n  disableErrors?: boolean\n  fallbackLocale?: TypedLocale\n  id: string\n  locale?: 'all' | TypedLocale\n  overrideAccess?: boolean\n  req?: PayloadRequest\n  showHiddenFields?: boolean\n  slug: TSlug\n  user?: Document\n}\n\n// eslint-disable-next-line no-restricted-exports\nexport default async function findVersionByIDLocal<TSlug extends GlobalSlug>(\n  payload: Payload,\n  options: Options<TSlug>,\n): Promise<TypeWithVersion<DataFromGlobalSlug<TSlug>>> {\n  const {\n    id,\n    slug: globalSlug,\n    depth,\n    disableErrors = false,\n    overrideAccess = true,\n    showHiddenFields,\n  } = options\n\n  const globalConfig = payload.globals.config.find((config) => config.slug === globalSlug)\n\n  if (!globalConfig) {\n    throw new APIError(`The global with slug ${String(globalSlug)} can't be found.`)\n  }\n\n  return findVersionByIDOperation({\n    id,\n    depth,\n    disableErrors,\n    globalConfig,\n    overrideAccess,\n    req: await createLocalReq(options, payload),\n    showHiddenFields,\n  })\n}\n"],"names":["APIError","createLocalReq","findVersionByIDOperation","findVersionByIDLocal","payload","options","id","slug","globalSlug","depth","disableErrors","overrideAccess","showHiddenFields","globalConfig","globals","config","find","String","req"],"mappings":";;;AAKA,SAASA,QAAQ,QAAQ,2BAA0B;AAEnD,SAASE,wBAAwB,QAAQ,wBAAuB;AADhE,SAASD,cAAc,QAAQ,uCAAsC;;;;AAkBtD,eAAeE,qBAC5BC,OAAgB,EAChBC,OAAuB;IAEvB,MAAM,EACJC,EAAE,EACFC,MAAMC,UAAU,EAChBC,KAAK,EACLC,gBAAgB,KAAK,EACrBC,iBAAiB,IAAI,EACrBC,gBAAgB,EACjB,GAAGP;IAEJ,MAAMQ,eAAeT,QAAQU,OAAO,CAACC,MAAM,CAACC,IAAI,CAAC,CAACD,SAAWA,OAAOR,IAAI,KAAKC;IAE7E,IAAI,CAACK,cAAc;QACjB,MAAM,IAAIb,iKAAAA,CAAS,CAAC,qBAAqB,EAAEiB,OAAOT,YAAY,gBAAgB,CAAC;IACjF;IAEA,uLAAON,2BAAAA,EAAyB;QAC9BI;QACAG;QACAC;QACAG;QACAF;QACAO,KAAK,yKAAMjB,iBAAAA,EAAeI,SAASD;QACnCQ;IACF;AACF"}},
    {"offset": {"line": 12495, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 12501, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/payload/src/versions/buildGlobalFields.ts"],"sourcesContent":["import type { SanitizedConfig } from '../config/types.js'\nimport type { Field } from '../fields/config/types.js'\nimport type { SanitizedGlobalConfig } from '../globals/config/types.js'\n\nimport { versionSnapshotField } from './baseFields.js'\n\nexport const buildVersionGlobalFields = (\n  config: SanitizedConfig,\n  global: SanitizedGlobalConfig,\n): Field[] => {\n  const fields: Field[] = [\n    {\n      name: 'version',\n      type: 'group',\n      fields: global.fields,\n    },\n    {\n      name: 'createdAt',\n      type: 'date',\n      admin: {\n        disabled: true,\n      },\n      index: true,\n    },\n    {\n      name: 'updatedAt',\n      type: 'date',\n      admin: {\n        disabled: true,\n      },\n      index: true,\n    },\n  ]\n\n  if (global?.versions?.drafts) {\n    if (config.localization) {\n      fields.push(versionSnapshotField)\n\n      fields.push({\n        name: 'publishedLocale',\n        type: 'select',\n        admin: {\n          disableBulkEdit: true,\n          disabled: true,\n        },\n        index: true,\n        options: config.localization.locales.map((locale) => {\n          if (typeof locale === 'string') {\n            return locale\n          }\n\n          return locale.code\n        }),\n      })\n    }\n\n    fields.push({\n      name: 'latest',\n      type: 'checkbox',\n      admin: {\n        disabled: true,\n      },\n      index: true,\n    })\n\n    if (global?.versions?.drafts?.autosave) {\n      fields.push({\n        name: 'autosave',\n        type: 'checkbox',\n        index: true,\n      })\n    }\n  }\n\n  return fields\n}\n"],"names":["versionSnapshotField","buildVersionGlobalFields","config","global","fields","name","type","admin","disabled","index","versions","drafts","localization","push","disableBulkEdit","options","locales","map","locale","code","autosave"],"mappings":";;;AAIA,SAASA,oBAAoB,QAAQ,kBAAiB;;AAE/C,MAAMC,2BAA2B,CACtCC,QACAC;IAEA,MAAMC,SAAkB;QACtB;YACEC,MAAM;YACNC,MAAM;YACNF,QAAQD,OAAOC,MAAM;QACvB;QACA;YACEC,MAAM;YACNC,MAAM;YACNC,OAAO;gBACLC,UAAU;YACZ;YACAC,OAAO;QACT;QACA;YACEJ,MAAM;YACNC,MAAM;YACNC,OAAO;gBACLC,UAAU;YACZ;YACAC,OAAO;QACT;KACD;IAED,IAAIN,QAAQO,UAAUC,QAAQ;QAC5B,IAAIT,OAAOU,YAAY,EAAE;YACvBR,OAAOS,IAAI,2JAACb,uBAAAA;YAEZI,OAAOS,IAAI,CAAC;gBACVR,MAAM;gBACNC,MAAM;gBACNC,OAAO;oBACLO,iBAAiB;oBACjBN,UAAU;gBACZ;gBACAC,OAAO;gBACPM,SAASb,OAAOU,YAAY,CAACI,OAAO,CAACC,GAAG,CAAC,CAACC;oBACxC,IAAI,OAAOA,WAAW,UAAU;wBAC9B,OAAOA;oBACT;oBAEA,OAAOA,OAAOC,IAAI;gBACpB;YACF;QACF;QAEAf,OAAOS,IAAI,CAAC;YACVR,MAAM;YACNC,MAAM;YACNC,OAAO;gBACLC,UAAU;YACZ;YACAC,OAAO;QACT;QAEA,IAAIN,QAAQO,UAAUC,QAAQS,UAAU;YACtChB,OAAOS,IAAI,CAAC;gBACVR,MAAM;gBACNC,MAAM;gBACNG,OAAO;YACT;QACF;IACF;IAEA,OAAOL;AACT,EAAC"}},
    {"offset": {"line": 12567, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 12573, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/payload/src/globals/operations/findVersions.ts"],"sourcesContent":["import type { PaginatedDocs } from '../../database/types.js'\nimport type { PayloadRequest, Sort, Where } from '../../types/index.js'\nimport type { TypeWithVersion } from '../../versions/types.js'\nimport type { SanitizedGlobalConfig } from '../config/types.js'\n\nimport executeAccess from '../../auth/executeAccess.js'\nimport { combineQueries } from '../../database/combineQueries.js'\nimport { validateQueryPaths } from '../../database/queryValidation/validateQueryPaths.js'\nimport { afterRead } from '../../fields/hooks/afterRead/index.js'\nimport { killTransaction } from '../../utilities/killTransaction.js'\nimport sanitizeInternalFields from '../../utilities/sanitizeInternalFields.js'\nimport { buildVersionGlobalFields } from '../../versions/buildGlobalFields.js'\n\nexport type Arguments = {\n  depth?: number\n  globalConfig: SanitizedGlobalConfig\n  limit?: number\n  overrideAccess?: boolean\n  page?: number\n  pagination?: boolean\n  req?: PayloadRequest\n  showHiddenFields?: boolean\n  sort?: Sort\n  where?: Where\n}\n\nexport const findVersionsOperation = async <T extends TypeWithVersion<T>>(\n  args: Arguments,\n): Promise<PaginatedDocs<T>> => {\n  const {\n    depth,\n    globalConfig,\n    limit,\n    overrideAccess,\n    page,\n    pagination = true,\n    req: { fallbackLocale, locale, payload },\n    req,\n    showHiddenFields,\n    sort,\n    where,\n  } = args\n\n  const versionFields = buildVersionGlobalFields(payload.config, globalConfig)\n\n  try {\n    // /////////////////////////////////////\n    // Access\n    // /////////////////////////////////////\n\n    const accessResults = !overrideAccess\n      ? await executeAccess({ req }, globalConfig.access.readVersions)\n      : true\n\n    await validateQueryPaths({\n      globalConfig,\n      overrideAccess,\n      req,\n      versionFields,\n      where,\n    })\n\n    const fullWhere = combineQueries(where, accessResults)\n\n    // /////////////////////////////////////\n    // Find\n    // /////////////////////////////////////\n\n    const paginatedDocs = await payload.db.findGlobalVersions<T>({\n      global: globalConfig.slug,\n      limit: limit ?? 10,\n      locale,\n      page: page || 1,\n      pagination,\n      req,\n      sort,\n      where: fullWhere,\n    })\n\n    // /////////////////////////////////////\n    // afterRead - Fields\n    // /////////////////////////////////////\n\n    let result = {\n      ...paginatedDocs,\n      docs: await Promise.all(\n        paginatedDocs.docs.map(async (data) => ({\n          ...data,\n          version: await afterRead<T>({\n            collection: null,\n            context: req.context,\n            depth,\n            doc: {\n              ...data.version,\n              // Patch globalType onto version doc\n              globalType: globalConfig.slug,\n            },\n            draft: undefined,\n            fallbackLocale,\n            findMany: true,\n            global: globalConfig,\n            locale,\n            overrideAccess,\n            req,\n            showHiddenFields,\n          }),\n        })),\n      ),\n    } as PaginatedDocs<T>\n\n    // /////////////////////////////////////\n    // afterRead - Global\n    // /////////////////////////////////////\n\n    result = {\n      ...result,\n      docs: await Promise.all(\n        result.docs.map(async (doc) => {\n          const docRef = doc\n\n          await globalConfig.hooks.afterRead.reduce(async (priorHook, hook) => {\n            await priorHook\n\n            docRef.version =\n              (await hook({\n                context: req.context,\n                doc: doc.version,\n                findMany: true,\n                global: globalConfig,\n                query: fullWhere,\n                req,\n              })) || doc.version\n          }, Promise.resolve())\n\n          return docRef\n        }),\n      ),\n    }\n\n    // /////////////////////////////////////\n    // Return results\n    // /////////////////////////////////////\n\n    result = {\n      ...result,\n      docs: result.docs.map((doc) => sanitizeInternalFields<T>(doc)),\n    }\n\n    return result\n  } catch (error: unknown) {\n    await killTransaction(req)\n    throw error\n  }\n}\n"],"names":["executeAccess","combineQueries","validateQueryPaths","afterRead","killTransaction","sanitizeInternalFields","buildVersionGlobalFields","findVersionsOperation","args","depth","globalConfig","limit","overrideAccess","page","pagination","req","fallbackLocale","locale","payload","showHiddenFields","sort","where","versionFields","config","accessResults","access","readVersions","fullWhere","paginatedDocs","db","findGlobalVersions","global","slug","result","docs","Promise","all","map","data","version","collection","context","doc","globalType","draft","undefined","findMany","docRef","hooks","reduce","priorHook","hook","query","resolve","error"],"mappings":"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"}},
    {"offset": {"line": 12682, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 12688, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/payload/src/globals/operations/local/findVersions.ts"],"sourcesContent":["import type { PaginatedDocs } from '../../../database/types.js'\nimport type { GlobalSlug, Payload, RequestContext, TypedLocale } from '../../../index.js'\nimport type { Document, PayloadRequest, Sort, Where } from '../../../types/index.js'\nimport type { TypeWithVersion } from '../../../versions/types.js'\nimport type { DataFromGlobalSlug } from '../../config/types.js'\n\nimport { APIError } from '../../../errors/index.js'\nimport { createLocalReq } from '../../../utilities/createLocalReq.js'\nimport { findVersionsOperation } from '../findVersions.js'\n\nexport type Options<TSlug extends GlobalSlug> = {\n  context?: RequestContext\n  depth?: number\n  fallbackLocale?: TypedLocale\n  limit?: number\n  locale?: 'all' | TypedLocale\n  overrideAccess?: boolean\n  page?: number\n  req?: PayloadRequest\n  showHiddenFields?: boolean\n  slug: TSlug\n  sort?: Sort\n  user?: Document\n  where?: Where\n}\n\nexport default async function findVersionsLocal<TSlug extends GlobalSlug>(\n  payload: Payload,\n  options: Options<TSlug>,\n): Promise<PaginatedDocs<TypeWithVersion<DataFromGlobalSlug<TSlug>>>> {\n  const {\n    slug: globalSlug,\n    depth,\n    limit,\n    overrideAccess = true,\n    page,\n    showHiddenFields,\n    sort,\n    where,\n  } = options\n\n  const globalConfig = payload.globals.config.find((config) => config.slug === globalSlug)\n\n  if (!globalConfig) {\n    throw new APIError(`The global with slug ${String(globalSlug)} can't be found.`)\n  }\n\n  return findVersionsOperation({\n    depth,\n    globalConfig,\n    limit,\n    overrideAccess,\n    page,\n    req: await createLocalReq(options, payload),\n    showHiddenFields,\n    sort,\n    where,\n  })\n}\n"],"names":["APIError","createLocalReq","findVersionsOperation","findVersionsLocal","payload","options","slug","globalSlug","depth","limit","overrideAccess","page","showHiddenFields","sort","where","globalConfig","globals","config","find","String","req"],"mappings":";;;AAMA,SAASA,QAAQ,QAAQ,2BAA0B;AAEnD,SAASE,qBAAqB,QAAQ,qBAAoB;AAD1D,SAASD,cAAc,QAAQ,uCAAsC;;;;AAmBtD,eAAeE,kBAC5BC,OAAgB,EAChBC,OAAuB;IAEvB,MAAM,EACJC,MAAMC,UAAU,EAChBC,KAAK,EACLC,KAAK,EACLC,iBAAiB,IAAI,EACrBC,IAAI,EACJC,gBAAgB,EAChBC,IAAI,EACJC,KAAK,EACN,GAAGT;IAEJ,MAAMU,eAAeX,QAAQY,OAAO,CAACC,MAAM,CAACC,IAAI,CAAC,CAACD,SAAWA,OAAOX,IAAI,KAAKC;IAE7E,IAAI,CAACQ,cAAc;QACjB,MAAM,yJAAIf,YAAAA,CAAS,CAAC,qBAAqB,EAAEmB,OAAOZ,YAAY,gBAAgB,CAAC;IACjF;IAEA,oLAAOL,wBAAAA,EAAsB;QAC3BM;QACAO;QACAN;QACAC;QACAC;QACAS,KAAK,yKAAMnB,iBAAAA,EAAeI,SAASD;QACnCQ;QACAC;QACAC;IACF;AACF"}},
    {"offset": {"line": 12715, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 12721, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/payload/src/globals/operations/restoreVersion.ts"],"sourcesContent":["import type { PayloadRequest } from '../../types/index.js'\nimport type { TypeWithVersion } from '../../versions/types.js'\nimport type { SanitizedGlobalConfig } from '../config/types.js'\n\nimport executeAccess from '../../auth/executeAccess.js'\nimport { NotFound } from '../../errors/index.js'\nimport { afterChange } from '../../fields/hooks/afterChange/index.js'\nimport { afterRead } from '../../fields/hooks/afterRead/index.js'\nimport { commitTransaction } from '../../utilities/commitTransaction.js'\nimport { initTransaction } from '../../utilities/initTransaction.js'\nimport { killTransaction } from '../../utilities/killTransaction.js'\n\nexport type Arguments = {\n  depth?: number\n  draft?: boolean\n  globalConfig: SanitizedGlobalConfig\n  id: number | string\n  overrideAccess?: boolean\n  req?: PayloadRequest\n  showHiddenFields?: boolean\n}\n\nexport const restoreVersionOperation = async <T extends TypeWithVersion<T> = any>(\n  args: Arguments,\n): Promise<T> => {\n  const {\n    id,\n    depth,\n    draft,\n    globalConfig,\n    overrideAccess,\n    req: { fallbackLocale, locale, payload },\n    req,\n    showHiddenFields,\n  } = args\n\n  try {\n    const shouldCommit = await initTransaction(req)\n\n    // /////////////////////////////////////\n    // Access\n    // /////////////////////////////////////\n\n    if (!overrideAccess) {\n      await executeAccess({ req }, globalConfig.access.update)\n    }\n\n    // /////////////////////////////////////\n    // Retrieve original raw version\n    // /////////////////////////////////////\n\n    const { docs: versionDocs } = await payload.db.findGlobalVersions<any>({\n      global: globalConfig.slug,\n      limit: 1,\n      req,\n      where: { id: { equals: id } },\n    })\n\n    if (!versionDocs || versionDocs.length === 0) {\n      throw new NotFound(req.t)\n    }\n\n    const rawVersion = versionDocs[0]\n\n    // Patch globalType onto version doc\n    rawVersion.version.globalType = globalConfig.slug\n\n    // Overwrite draft status if draft is true\n\n    if (draft) {\n      rawVersion.version._status = 'draft'\n    }\n    // /////////////////////////////////////\n    // fetch previousDoc\n    // /////////////////////////////////////\n\n    const previousDoc = await payload.findGlobal({\n      slug: globalConfig.slug,\n      depth,\n      req,\n    })\n\n    // /////////////////////////////////////\n    // Update global\n    // /////////////////////////////////////\n\n    const global = await payload.db.findGlobal({\n      slug: globalConfig.slug,\n      req,\n    })\n\n    let result = rawVersion.version\n\n    if (global) {\n      result = await payload.db.updateGlobal({\n        slug: globalConfig.slug,\n        data: result,\n        req,\n      })\n\n      const now = new Date().toISOString()\n\n      result = await payload.db.createGlobalVersion({\n        autosave: false,\n        createdAt: result.createdAt ? new Date(result.createdAt).toISOString() : now,\n        globalSlug: globalConfig.slug,\n        parent: id,\n        req,\n        updatedAt: draft ? now : new Date(result.updatedAt).toISOString(),\n        versionData: result,\n      })\n    } else {\n      result = await payload.db.createGlobal({\n        slug: globalConfig.slug,\n        data: result,\n        req,\n      })\n    }\n\n    // /////////////////////////////////////\n    // afterRead - Fields\n    // /////////////////////////////////////\n\n    result = await afterRead({\n      collection: null,\n      context: req.context,\n      depth,\n      doc: result,\n      draft: undefined,\n      fallbackLocale,\n      global: globalConfig,\n      locale,\n      overrideAccess,\n      req,\n      showHiddenFields,\n    })\n\n    // /////////////////////////////////////\n    // afterRead - Global\n    // /////////////////////////////////////\n\n    await globalConfig.hooks.afterRead.reduce(async (priorHook, hook) => {\n      await priorHook\n\n      result =\n        (await hook({\n          context: req.context,\n          doc: result,\n          global: globalConfig,\n          req,\n        })) || result\n    }, Promise.resolve())\n\n    // /////////////////////////////////////\n    // afterChange - Fields\n    // /////////////////////////////////////\n\n    result = await afterChange({\n      collection: null,\n      context: req.context,\n      data: result,\n      doc: result,\n      global: globalConfig,\n      operation: 'update',\n      previousDoc,\n      req,\n    })\n\n    // /////////////////////////////////////\n    // afterChange - Global\n    // /////////////////////////////////////\n\n    await globalConfig.hooks.afterChange.reduce(async (priorHook, hook) => {\n      await priorHook\n\n      result =\n        (await hook({\n          context: req.context,\n          doc: result,\n          global: globalConfig,\n          previousDoc,\n          req,\n        })) || result\n    }, Promise.resolve())\n\n    if (shouldCommit) {\n      await commitTransaction(req)\n    }\n\n    return result\n  } catch (error: unknown) {\n    await killTransaction(req)\n    throw error\n  }\n}\n"],"names":["executeAccess","NotFound","afterChange","afterRead","commitTransaction","initTransaction","killTransaction","restoreVersionOperation","args","id","depth","draft","globalConfig","overrideAccess","req","fallbackLocale","locale","payload","showHiddenFields","shouldCommit","access","update","docs","versionDocs","db","findGlobalVersions","global","slug","limit","where","equals","length","t","rawVersion","version","globalType","_status","previousDoc","findGlobal","result","updateGlobal","data","now","Date","toISOString","createGlobalVersion","autosave","createdAt","globalSlug","parent","updatedAt","versionData","createGlobal","collection","context","doc","undefined","hooks","reduce","priorHook","hook","Promise","resolve","operation","error"],"mappings":"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"}},
    {"offset": {"line": 12875, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 12881, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/payload/src/globals/operations/local/restoreVersion.ts"],"sourcesContent":["import type { GlobalSlug, Payload, RequestContext, TypedLocale } from '../../../index.js'\nimport type { Document, PayloadRequest } from '../../../types/index.js'\nimport type { DataFromGlobalSlug } from '../../config/types.js'\n\nimport { APIError } from '../../../errors/index.js'\nimport { createLocalReq } from '../../../utilities/createLocalReq.js'\nimport { restoreVersionOperation } from '../restoreVersion.js'\n\nexport type Options<TSlug extends GlobalSlug> = {\n  context?: RequestContext\n  depth?: number\n  fallbackLocale?: TypedLocale\n  id: string\n  locale?: TypedLocale\n  overrideAccess?: boolean\n  req?: PayloadRequest\n  showHiddenFields?: boolean\n  slug: TSlug\n  user?: Document\n}\n\nexport default async function restoreVersionLocal<TSlug extends GlobalSlug>(\n  payload: Payload,\n  options: Options<TSlug>,\n): Promise<DataFromGlobalSlug<TSlug>> {\n  const { id, slug: globalSlug, depth, overrideAccess = true, showHiddenFields } = options\n\n  const globalConfig = payload.globals.config.find((config) => config.slug === globalSlug)\n\n  if (!globalConfig) {\n    throw new APIError(`The global with slug ${String(globalSlug)} can't be found.`)\n  }\n\n  return restoreVersionOperation({\n    id,\n    depth,\n    globalConfig,\n    overrideAccess,\n    req: await createLocalReq(options, payload),\n    showHiddenFields,\n  })\n}\n"],"names":["APIError","createLocalReq","restoreVersionOperation","restoreVersionLocal","payload","options","id","slug","globalSlug","depth","overrideAccess","showHiddenFields","globalConfig","globals","config","find","String","req"],"mappings":";;;AAIA,SAASA,QAAQ,QAAQ,2BAA0B;AAEnD,SAASE,uBAAuB,QAAQ,uBAAsB;AAD9D,SAASD,cAAc,QAAQ,uCAAsC;;;;AAgBtD,eAAeE,oBAC5BC,OAAgB,EAChBC,OAAuB;IAEvB,MAAM,EAAEC,EAAE,EAAEC,MAAMC,UAAU,EAAEC,KAAK,EAAEC,iBAAiB,IAAI,EAAEC,gBAAgB,EAAE,GAAGN;IAEjF,MAAMO,eAAeR,QAAQS,OAAO,CAACC,MAAM,CAACC,IAAI,CAAC,CAACD,SAAWA,OAAOP,IAAI,KAAKC;IAE7E,IAAI,CAACI,cAAc;QACjB,MAAM,yJAAIZ,YAAAA,CAAS,CAAC,qBAAqB,EAAEgB,OAAOR,YAAY,gBAAgB,CAAC;IACjF;IAEA,sLAAON,0BAAAA,EAAwB;QAC7BI;QACAG;QACAG;QACAF;QACAO,KAAK,yKAAMhB,iBAAAA,EAAeI,SAASD;QACnCO;IACF;AACF"}},
    {"offset": {"line": 12905, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 12911, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/payload/src/versions/getLatestGlobalVersion.ts"],"sourcesContent":["import type { SanitizedGlobalConfig } from '../globals/config/types.js'\nimport type { Document, Payload, PayloadRequest, Where } from '../types/index.js'\n\nimport { docHasTimestamps } from '../types/index.js'\n\ntype Args = {\n  config: SanitizedGlobalConfig\n  locale?: string\n  payload: Payload\n  published?: boolean\n  req?: PayloadRequest\n  slug: string\n  where: Where\n}\n\nexport const getLatestGlobalVersion = async ({\n  slug,\n  config,\n  locale,\n  payload,\n  published,\n  req,\n  where,\n}: Args): Promise<{ global: Document; globalExists: boolean }> => {\n  let latestVersion\n\n  const whereQuery = published\n    ? { 'version._status': { equals: 'published' } }\n    : { latest: { equals: true } }\n\n  if (config.versions?.drafts) {\n    latestVersion = (\n      await payload.db.findGlobalVersions({\n        global: slug,\n        limit: 1,\n        locale,\n        pagination: false,\n        req,\n        where: whereQuery,\n      })\n    ).docs[0]\n  }\n\n  const global = await payload.db.findGlobal({\n    slug,\n    locale,\n    req,\n    where,\n  })\n  const globalExists = Boolean(global)\n\n  if (!latestVersion) {\n    return {\n      global,\n      globalExists,\n    }\n  }\n\n  if (!latestVersion.version.createdAt) {\n    latestVersion.version.createdAt = latestVersion.createdAt\n  }\n\n  if (!latestVersion.version.updatedAt) {\n    latestVersion.version.updatedAt = latestVersion.updatedAt\n  }\n\n  return {\n    global: latestVersion.version,\n    globalExists,\n  }\n}\n"],"names":["getLatestGlobalVersion","slug","config","locale","payload","published","req","where","latestVersion","whereQuery","equals","latest","versions","drafts","db","findGlobalVersions","global","limit","pagination","docs","findGlobal","globalExists","Boolean","version","createdAt","updatedAt"],"mappings":";;;AAeO,MAAMA,yBAAyB,OAAO,EAC3CC,IAAI,EACJC,MAAM,EACNC,MAAM,EACNC,OAAO,EACPC,SAAS,EACTC,GAAG,EACHC,KAAK,EACA;IACL,IAAIC;IAEJ,MAAMC,aAAaJ,YACf;QAAE,mBAAmB;YAAEK,QAAQ;QAAY;IAAE,IAC7C;QAAEC,QAAQ;YAAED,QAAQ;QAAK;IAAE;IAE/B,IAAIR,OAAOU,QAAQ,EAAEC,QAAQ;QAC3BL,gBACE,CAAA,MAAMJ,QAAQU,EAAE,CAACC,kBAAkB,CAAC;YAClCC,QAAQf;YACRgB,OAAO;YACPd;YACAe,YAAY;YACZZ;YACAC,OAAOE;QACT,EAAC,EACDU,IAAI,CAAC,EAAE;IACX;IAEA,MAAMH,SAAS,MAAMZ,QAAQU,EAAE,CAACM,UAAU,CAAC;QACzCnB;QACAE;QACAG;QACAC;IACF;IACA,MAAMc,eAAeC,QAAQN;IAE7B,IAAI,CAACR,eAAe;QAClB,OAAO;YACLQ;YACAK;QACF;IACF;IAEA,IAAI,CAACb,cAAce,OAAO,CAACC,SAAS,EAAE;QACpChB,cAAce,OAAO,CAACC,SAAS,GAAGhB,cAAcgB,SAAS;IAC3D;IAEA,IAAI,CAAChB,cAAce,OAAO,CAACE,SAAS,EAAE;QACpCjB,cAAce,OAAO,CAACE,SAAS,GAAGjB,cAAciB,SAAS;IAC3D;IAEA,OAAO;QACLT,QAAQR,cAAce,OAAO;QAC7BF;IACF;AACF,EAAC"}},
    {"offset": {"line": 12959, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 12965, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/payload/src/globals/operations/update.ts"],"sourcesContent":["import type { DeepPartial } from 'ts-essentials'\n\nimport type { GlobalSlug, JsonObject } from '../../index.js'\nimport type { Operation, PayloadRequest, Where } from '../../types/index.js'\nimport type { DataFromGlobalSlug, SanitizedGlobalConfig } from '../config/types.js'\n\nimport executeAccess from '../../auth/executeAccess.js'\nimport { afterChange } from '../../fields/hooks/afterChange/index.js'\nimport { afterRead } from '../../fields/hooks/afterRead/index.js'\nimport { beforeChange } from '../../fields/hooks/beforeChange/index.js'\nimport { beforeValidate } from '../../fields/hooks/beforeValidate/index.js'\nimport { deepCopyObjectSimple } from '../../index.js'\nimport { checkDocumentLockStatus } from '../../utilities/checkDocumentLockStatus.js'\nimport { commitTransaction } from '../../utilities/commitTransaction.js'\nimport { initTransaction } from '../../utilities/initTransaction.js'\nimport { killTransaction } from '../../utilities/killTransaction.js'\nimport { getLatestGlobalVersion } from '../../versions/getLatestGlobalVersion.js'\nimport { saveVersion } from '../../versions/saveVersion.js'\n\ntype Args<TSlug extends GlobalSlug> = {\n  autosave?: boolean\n  data: DeepPartial<Omit<DataFromGlobalSlug<TSlug>, 'id'>>\n  depth?: number\n  disableTransaction?: boolean\n  draft?: boolean\n  globalConfig: SanitizedGlobalConfig\n  overrideAccess?: boolean\n  overrideLock?: boolean\n  publishSpecificLocale?: string\n  req: PayloadRequest\n  showHiddenFields?: boolean\n  slug: string\n}\n\nexport const updateOperation = async <TSlug extends GlobalSlug>(\n  args: Args<TSlug>,\n): Promise<DataFromGlobalSlug<TSlug>> => {\n  if (args.publishSpecificLocale) {\n    args.req.locale = args.publishSpecificLocale\n  }\n\n  const {\n    slug,\n    autosave,\n    depth,\n    disableTransaction,\n    draft: draftArg,\n    globalConfig,\n    overrideAccess,\n    overrideLock,\n    publishSpecificLocale,\n    req: { fallbackLocale, locale, payload },\n    req,\n    showHiddenFields,\n  } = args\n\n  try {\n    const shouldCommit = !disableTransaction && (await initTransaction(req))\n\n    let { data } = args\n\n    const shouldSaveDraft = Boolean(draftArg && globalConfig.versions?.drafts)\n\n    // /////////////////////////////////////\n    // 1. Retrieve and execute access\n    // /////////////////////////////////////\n\n    const accessResults = !overrideAccess\n      ? await executeAccess(\n          {\n            data,\n            req,\n          },\n          globalConfig.access.update,\n        )\n      : true\n\n    // /////////////////////////////////////\n    // Retrieve document\n    // /////////////////////////////////////\n\n    const query: Where = overrideAccess ? undefined : (accessResults as Where)\n\n    // /////////////////////////////////////\n    // 2. Retrieve document\n    // /////////////////////////////////////\n    const globalVersion = await getLatestGlobalVersion({\n      slug,\n      config: globalConfig,\n      locale,\n      payload,\n      req,\n      where: query,\n    })\n    const { global, globalExists } = globalVersion || {}\n\n    let globalJSON: JsonObject = {}\n\n    if (globalVersion && globalVersion.global) {\n      globalJSON = deepCopyObjectSimple(global)\n\n      if (globalJSON._id) {\n        delete globalJSON._id\n      }\n    }\n\n    const originalDoc = await afterRead({\n      collection: null,\n      context: req.context,\n      depth: 0,\n      doc: globalJSON,\n      draft: draftArg,\n      fallbackLocale,\n      global: globalConfig,\n      locale,\n      overrideAccess: true,\n      req,\n      showHiddenFields,\n    })\n\n    // ///////////////////////////////////////////\n    // Handle potentially locked global documents\n    // ///////////////////////////////////////////\n\n    await checkDocumentLockStatus({\n      globalSlug: slug,\n      lockErrorMessage: `Global with slug \"${slug}\" is currently locked by another user and cannot be updated.`,\n      overrideLock,\n      req,\n    })\n\n    // /////////////////////////////////////\n    // beforeValidate - Fields\n    // /////////////////////////////////////\n\n    data = await beforeValidate({\n      collection: null,\n      context: req.context,\n      data,\n      doc: originalDoc,\n      global: globalConfig,\n      operation: 'update',\n      overrideAccess,\n      req,\n    })\n\n    // /////////////////////////////////////\n    // beforeValidate - Global\n    // /////////////////////////////////////\n\n    await globalConfig.hooks.beforeValidate.reduce(async (priorHook, hook) => {\n      await priorHook\n\n      data =\n        (await hook({\n          context: req.context,\n          data,\n          global: globalConfig,\n          originalDoc,\n          req,\n        })) || data\n    }, Promise.resolve())\n\n    // /////////////////////////////////////\n    // beforeChange - Global\n    // /////////////////////////////////////\n\n    await globalConfig.hooks.beforeChange.reduce(async (priorHook, hook) => {\n      await priorHook\n\n      data =\n        (await hook({\n          context: req.context,\n          data,\n          global: globalConfig,\n          originalDoc,\n          req,\n        })) || data\n    }, Promise.resolve())\n\n    // /////////////////////////////////////\n    // beforeChange - Fields\n    // /////////////////////////////////////\n    let publishedDocWithLocales = globalJSON\n    let versionSnapshotResult\n\n    const beforeChangeArgs = {\n      collection: null,\n      context: req.context,\n      data,\n      doc: originalDoc,\n      docWithLocales: undefined,\n      global: globalConfig,\n      operation: 'update' as Operation,\n      req,\n      skipValidation:\n        shouldSaveDraft && globalConfig.versions.drafts && !globalConfig.versions.drafts.validate,\n    }\n\n    if (publishSpecificLocale) {\n      const latestVersion = await getLatestGlobalVersion({\n        slug,\n        config: globalConfig,\n        payload,\n        published: true,\n        req,\n        where: query,\n      })\n\n      publishedDocWithLocales = latestVersion?.global || {}\n\n      versionSnapshotResult = await beforeChange({\n        ...beforeChangeArgs,\n        docWithLocales: globalJSON,\n      })\n    }\n\n    let result = await beforeChange({\n      ...beforeChangeArgs,\n      docWithLocales: publishedDocWithLocales,\n    })\n\n    // /////////////////////////////////////\n    // Update\n    // /////////////////////////////////////\n\n    if (!shouldSaveDraft) {\n      if (globalExists) {\n        result = await payload.db.updateGlobal({\n          slug,\n          data: result,\n          req,\n        })\n      } else {\n        result = await payload.db.createGlobal({\n          slug,\n          data: result,\n          req,\n        })\n      }\n    }\n\n    // /////////////////////////////////////\n    // Create version\n    // /////////////////////////////////////\n    if (globalConfig.versions) {\n      const { globalType } = result\n      result = await saveVersion({\n        autosave,\n        docWithLocales: result,\n        draft: shouldSaveDraft,\n        global: globalConfig,\n        payload,\n        publishSpecificLocale,\n        req,\n        snapshot: versionSnapshotResult,\n      })\n\n      result = {\n        ...result,\n        globalType,\n      }\n    }\n\n    // /////////////////////////////////////\n    // afterRead - Fields\n    // /////////////////////////////////////\n\n    result = await afterRead({\n      collection: null,\n      context: req.context,\n      depth,\n      doc: result,\n      draft: draftArg,\n      fallbackLocale: null,\n      global: globalConfig,\n      locale,\n      overrideAccess,\n      req,\n      showHiddenFields,\n    })\n\n    // /////////////////////////////////////\n    // afterRead - Global\n    // /////////////////////////////////////\n\n    await globalConfig.hooks.afterRead.reduce(async (priorHook, hook) => {\n      await priorHook\n\n      result =\n        (await hook({\n          context: req.context,\n          doc: result,\n          global: globalConfig,\n          req,\n        })) || result\n    }, Promise.resolve())\n\n    // /////////////////////////////////////\n    // afterChange - Fields\n    // /////////////////////////////////////\n\n    result = await afterChange({\n      collection: null,\n      context: req.context,\n      data,\n      doc: result,\n      global: globalConfig,\n      operation: 'update',\n      previousDoc: originalDoc,\n      req,\n    })\n\n    // /////////////////////////////////////\n    // afterChange - Global\n    // /////////////////////////////////////\n\n    await globalConfig.hooks.afterChange.reduce(async (priorHook, hook) => {\n      await priorHook\n\n      result =\n        (await hook({\n          context: req.context,\n          doc: result,\n          global: globalConfig,\n          previousDoc: originalDoc,\n          req,\n        })) || result\n    }, Promise.resolve())\n\n    // /////////////////////////////////////\n    // Return results\n    // /////////////////////////////////////\n\n    if (shouldCommit) {\n      await commitTransaction(req)\n    }\n\n    return result\n  } catch (error: unknown) {\n    await killTransaction(req)\n    throw error\n  }\n}\n"],"names":["executeAccess","afterChange","afterRead","beforeChange","beforeValidate","deepCopyObjectSimple","checkDocumentLockStatus","commitTransaction","initTransaction","killTransaction","getLatestGlobalVersion","saveVersion","updateOperation","args","publishSpecificLocale","req","locale","slug","autosave","depth","disableTransaction","draft","draftArg","globalConfig","overrideAccess","overrideLock","fallbackLocale","payload","showHiddenFields","shouldCommit","data","shouldSaveDraft","Boolean","versions","drafts","accessResults","access","update","query","undefined","globalVersion","config","where","global","globalExists","globalJSON","_id","originalDoc","collection","context","doc","globalSlug","lockErrorMessage","operation","hooks","reduce","priorHook","hook","Promise","resolve","publishedDocWithLocales","versionSnapshotResult","beforeChangeArgs","docWithLocales","skipValidation","validate","latestVersion","published","result","db","updateGlobal","createGlobal","globalType","snapshot","previousDoc","error"],"mappings":"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"}},
    {"offset": {"line": 13231, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 13237, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/payload/src/globals/operations/local/update.ts"],"sourcesContent":["import type { DeepPartial } from 'ts-essentials'\n\nimport type { GlobalSlug, Payload, RequestContext, TypedLocale } from '../../../index.js'\nimport type { Document, PayloadRequest } from '../../../types/index.js'\nimport type { DataFromGlobalSlug } from '../../config/types.js'\n\nimport { APIError } from '../../../errors/index.js'\nimport { createLocalReq } from '../../../utilities/createLocalReq.js'\nimport { updateOperation } from '../update.js'\n\nexport type Options<TSlug extends GlobalSlug> = {\n  context?: RequestContext\n  data: DeepPartial<Omit<DataFromGlobalSlug<TSlug>, 'id'>>\n  depth?: number\n  draft?: boolean\n  fallbackLocale?: TypedLocale\n  locale?: TypedLocale\n  overrideAccess?: boolean\n  overrideLock?: boolean\n  publishSpecificLocale?: TypedLocale\n  req?: PayloadRequest\n  showHiddenFields?: boolean\n  slug: TSlug\n  user?: Document\n}\n\nexport default async function updateLocal<TSlug extends GlobalSlug>(\n  payload: Payload,\n  options: Options<TSlug>,\n): Promise<DataFromGlobalSlug<TSlug>> {\n  const {\n    slug: globalSlug,\n    data,\n    depth,\n    draft,\n    overrideAccess = true,\n    overrideLock,\n    publishSpecificLocale,\n    showHiddenFields,\n  } = options\n\n  const globalConfig = payload.globals.config.find((config) => config.slug === globalSlug)\n\n  if (!globalConfig) {\n    throw new APIError(`The global with slug ${String(globalSlug)} can't be found.`)\n  }\n\n  return updateOperation<TSlug>({\n    slug: globalSlug as string,\n    data,\n    depth,\n    draft,\n    globalConfig,\n    overrideAccess,\n    overrideLock,\n    publishSpecificLocale,\n    req: await createLocalReq(options, payload),\n    showHiddenFields,\n  })\n}\n"],"names":["APIError","createLocalReq","updateOperation","updateLocal","payload","options","slug","globalSlug","data","depth","draft","overrideAccess","overrideLock","publishSpecificLocale","showHiddenFields","globalConfig","globals","config","find","String","req"],"mappings":";;;AAMA,SAASA,QAAQ,QAAQ,2BAA0B;AAEnD,SAASE,eAAe,QAAQ,eAAc;AAD9C,SAASD,cAAc,QAAQ,uCAAsC;;;;AAmBtD,eAAeE,YAC5BC,OAAgB,EAChBC,OAAuB;IAEvB,MAAM,EACJC,MAAMC,UAAU,EAChBC,IAAI,EACJC,KAAK,EACLC,KAAK,EACLC,iBAAiB,IAAI,EACrBC,YAAY,EACZC,qBAAqB,EACrBC,gBAAgB,EACjB,GAAGT;IAEJ,MAAMU,eAAeX,QAAQY,OAAO,CAACC,MAAM,CAACC,IAAI,CAAC,CAACD,SAAWA,OAAOX,IAAI,KAAKC;IAE7E,IAAI,CAACQ,cAAc;QACjB,MAAM,yJAAIf,YAAAA,CAAS,CAAC,qBAAqB,EAAEmB,OAAOZ,YAAY,gBAAgB,CAAC;IACjF;IAEA,8KAAOL,kBAAAA,EAAuB;QAC5BI,MAAMC;QACNC;QACAC;QACAC;QACAK;QACAJ;QACAC;QACAC;QACAO,KAAK,yKAAMnB,iBAAAA,EAAeI,SAASD;QACnCU;IACF;AACF"}},
    {"offset": {"line": 13265, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 13271, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/payload/src/globals/operations/local/index.ts"],"sourcesContent":["import findOne from './findOne.js'\nimport findVersionByID from './findVersionByID.js'\nimport findVersions from './findVersions.js'\nimport restoreVersion from './restoreVersion.js'\nimport update from './update.js'\n\nexport default {\n  findOne,\n  findVersionByID,\n  findVersions,\n  restoreVersion,\n  update,\n}\n"],"names":["findOne","findVersionByID","findVersions","restoreVersion","update"],"mappings":";;;AAAA,OAAOA,aAAa,eAAc;AAClC,OAAOC,qBAAqB,uBAAsB;AAClD,OAAOC,kBAAkB,oBAAmB;AAC5C,OAAOC,oBAAoB,sBAAqB;AAChD,OAAOC,YAAY,cAAa;;;;;;uCAEjB;0LACbJ,UAAAA;0MACAC,UAAAA;oMACAC,UAAAA;wMACAC,UAAAA;wLACAC,UAAAA;AACF,EAAC"}},
    {"offset": {"line": 13292, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 13298, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/payload/src/versions/payloadPackageList.ts"],"sourcesContent":["export const PAYLOAD_PACKAGE_LIST = [\n  'payload',\n  '@payloadcms/bundler-vite',\n  '@payloadcms/bundler-webpack',\n  '@payloadcms/db-mongodb',\n  '@payloadcms/db-postgres',\n  '@payloadcms/email-nodemailer',\n  '@payloadcms/email-resend',\n  '@payloadcms/graphql',\n  '@payloadcms/live-preview-react',\n  '@payloadcms/live-preview',\n  '@payloadcms/next/utilities',\n  '@payloadcms/plugin-cloud-storage',\n  '@payloadcms/payload-cloud',\n  '@payloadcms/plugin-form-builder',\n  '@payloadcms/plugin-nested-docs',\n  '@payloadcms/plugin-redirects',\n  '@payloadcms/plugin-search',\n  '@payloadcms/plugin-seo',\n  '@payloadcms/plugin-stripe',\n  '@payloadcms/plugin-zapier',\n  '@payloadcms/richtext-lexical',\n  '@payloadcms/richtext-slate',\n  '@payloadcms/storage-azure',\n  '@payloadcms/storage-gcs',\n  '@payloadcms/storage-s3',\n  '@payloadcms/storage-uploadthing',\n  '@payloadcms/storage-vercel-blob',\n  '@payloadcms/translations',\n  '@payloadcms/ui/shared',\n]\n"],"names":["PAYLOAD_PACKAGE_LIST"],"mappings":";;;AAAO,MAAMA,uBAAuB;IAClC;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;CACD,CAAA"}},
    {"offset": {"line": 13332, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 13338, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/payload/src/utilities/dependencies/realPath.ts"],"sourcesContent":["/*\n  This source code has been taken from https://github.com/vercel/next.js/blob/39498d604c3b25d92a483153fe648a7ee456fbda/packages/next/src/lib/realpath.ts\n\n  License:\n\n  The MIT License (MIT)\n\n  Copyright (c) 2024 Vercel, Inc.\n\n  Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n\n  The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n\n  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n*/\nimport fs from 'fs'\n\nconst isWindows = process.platform === 'win32'\n\n// Interesting learning from this, that fs.realpathSync is 70x slower than fs.realpathSync.native:\n// https://sun0day.github.io/blog/vite/why-vite4_3-is-faster.html#fs-realpathsync-issue\n// https://github.com/nodejs/node/issues/2680\n// However, we can't use fs.realpathSync.native on Windows due to behavior differences.\nexport const realpathSync = isWindows ? fs.realpathSync : fs.realpathSync.native\n"],"names":["fs","isWindows","process","platform","realpathSync","native"],"mappings":"AAAA;;;;;;;;;;;;;;AAcA;;;AACA,OAAOA,QAAQ,KAAI;;AAEnB,MAAMC,YAAYC,QAAQC,QAAQ,KAAK;AAMhC,MAAMC,eAAeH,YAAYD,GAAGI,YAAY,8IAAGJ,UAAAA,CAAGI,YAAY,CAACC,MAAM,CAAA"}},
    {"offset": {"line": 13359, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 13365, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/payload/src/utilities/dependencies/isError.ts"],"sourcesContent":["/*\n  This source code has been taken and modified from https://github.com/vercel/next.js/blob/be87132327ea28acd4bf7af09a401bac2374cb64/packages/next/src/lib/is-error.ts\n\n  License:\n\n  The MIT License (MIT)\n\n  Copyright (c) 2024 Vercel, Inc.\n\n  Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n\n  The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n\n  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n*/\n\nexport interface ErrorWithCode extends Error {\n  code?: number | string\n}\n\nexport function isError(err: unknown): err is ErrorWithCode {\n  return typeof err === 'object' && err !== null && 'name' in err && 'message' in err\n}\n"],"names":["isError","err"],"mappings":"AAAA;;;;;;;;;;;;;;AAcA,GAMA;;;AAAO,SAASA,QAAQC,GAAY;IAClC,OAAO,OAAOA,QAAQ,YAAYA,QAAQ,QAAQ,UAAUA,OAAO,aAAaA;AAClF"}},
    {"offset": {"line": 13385, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 13391, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/payload/src/utilities/dependencies/resolveFrom.ts"],"sourcesContent":["/*\n  This source code has been taken and modified from https://github.com/vercel/next.js/blob/39498d604c3b25d92a483153fe648a7ee456fbda/packages/next/src/lib/resolve-from.ts\n\n  License:\n\n  The MIT License (MIT)\n\n  Copyright (c) 2024 Vercel, Inc.\n\n  Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n\n  The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n\n  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n*/\n\n// source: https://github.com/sindresorhus/resolve-from\nimport { createRequire } from 'module'\nimport path from 'path'\n\nimport { isError } from './isError.js'\nimport { realpathSync } from './realPath.js'\n\nexport const resolveFrom = (fromDirectory: string, moduleId: string, silent?: boolean) => {\n  if (typeof fromDirectory !== 'string') {\n    throw new TypeError(\n      `Expected \\`fromDir\\` to be of type \\`string\\`, got \\`${typeof fromDirectory}\\``,\n    )\n  }\n\n  if (typeof moduleId !== 'string') {\n    throw new TypeError(\n      `Expected \\`moduleId\\` to be of type \\`string\\`, got \\`${typeof moduleId}\\``,\n    )\n  }\n\n  try {\n    fromDirectory = realpathSync(fromDirectory)\n  } catch (error: unknown) {\n    if (isError(error) && error.code === 'ENOENT') {\n      fromDirectory = path.resolve(fromDirectory)\n    } else if (silent) {\n      return\n    } else {\n      throw error\n    }\n  }\n\n  const fromFile = path.join(fromDirectory, 'noop.js')\n\n  const require = createRequire(import.meta.url)\n\n  const Module = require('module')\n\n  const resolveFileName = () => {\n    return Module._resolveFilename(moduleId, {\n      id: fromFile,\n      filename: fromFile,\n      paths: Module._nodeModulePaths(fromDirectory),\n    })\n  }\n\n  if (silent) {\n    try {\n      return resolveFileName()\n    } catch (error) {\n      return\n    }\n  }\n\n  return resolveFileName()\n}\n"],"names":["createRequire","path","isError","realpathSync","resolveFrom","fromDirectory","moduleId","silent","TypeError","error","code","resolve","fromFile","join","require","url","Module","resolveFileName","_resolveFilename","id","filename","paths","_nodeModulePaths"],"mappings":"AAAA;;;;;;;;;;;;;;AAcA,GAEA,uDAAuD;;;;AACvD,SAASA,aAAa,QAAQ,SAAQ;AACtC,OAAOC,UAAU,OAAM;AAGvB,SAASE,YAAY,QAAQ,gBAAe;AAD5C,SAASD,OAAO,QAAQ,eAAc;;;;;;;;;;AAG/B,MAAME,cAAc,CAACC,eAAuBC,UAAkBC;IACnE,IAAI,OAAOF,kBAAkB,UAAU;QACrC,MAAM,IAAIG,UACR,CAAC,qDAAqD,EAAE,OAAOH,cAAc,EAAE,CAAC;IAEpF;IAEA,IAAI,OAAOC,aAAa,UAAU;QAChC,MAAM,IAAIE,UACR,CAAC,sDAAsD,EAAE,OAAOF,SAAS,EAAE,CAAC;IAEhF;IAEA,IAAI;QACFD,gBAAgBF,4LAAAA,EAAaE;IAC/B,EAAE,OAAOI,OAAgB;QACvB,KAAIP,qLAAAA,EAAQO,UAAUA,MAAMC,IAAI,KAAK,UAAU;YAC7CL,8GAAgBJ,UAAAA,CAAKU,OAAO,CAACN;QAC/B,OAAO,IAAIE,QAAQ;YACjB;QACF,OAAO;YACL,MAAME;QACR;IACF;IAEA,MAAMG,yGAAWX,UAAAA,CAAKY,IAAI,CAACR,eAAe;IAE1C,MAAMS,WAAUd,mHAAAA,EAAc,8BAAYe,GAAG;IAE7C,MAAMC,SAASF,QAAQ;IAEvB,MAAMG,kBAAkB;QACtB,OAAOD,OAAOE,gBAAgB,CAACZ,UAAU;YACvCa,IAAIP;YACJQ,UAAUR;YACVS,OAAOL,OAAOM,gBAAgB,CAACjB;QACjC;IACF;IAEA,IAAIE,QAAQ;QACV,IAAI;YACF,OAAOU;QACT,EAAE,OAAOR,OAAO;YACd;QACF;IACF;IAEA,OAAOQ;AACT,EAAC"}},
    {"offset": {"line": 13459, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 13465, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/payload/src/utilities/findUp.ts"],"sourcesContent":["import fs from 'fs'\nimport path from 'path'\n\n/**\n * Synchronously walks up parent directories until a condition is met and/or one of the file names within the fileNames array is found.\n */\nexport function findUpSync({\n  condition,\n  dir,\n  fileNames,\n}: {\n  condition?: (dir: string) => boolean | Promise<boolean | string> | string\n  dir: string\n  fileNames?: string[]\n}): null | string {\n  const { root } = path.parse(dir)\n\n  while (true) {\n    if (fileNames?.length) {\n      let found = false\n      for (const fileName of fileNames) {\n        const filePath = path.join(dir, fileName)\n        const exists = pathExistsAndIsAccessibleSync(filePath)\n        if (exists) {\n          if (!condition) {\n            return filePath\n          }\n          found = true\n          break\n        }\n      }\n      if (!found) {\n        dir = path.dirname(dir) // Move up one directory level.\n        continue\n      }\n    }\n    const result = condition(dir)\n    if (result === true) {\n      return dir\n    }\n    if (typeof result === 'string' && result?.length) {\n      return result\n    }\n    if (dir === root) {\n      return null // Reached the root directory without a match.\n    }\n    dir = path.dirname(dir) // Move up one directory level.\n  }\n}\n\n/**\n * Asynchronously walks up parent directories until a condition is met and/or one of the file names within the fileNames array is found.\n */\nexport async function findUp({\n  condition,\n  dir,\n  fileNames,\n}: {\n  condition?: (dir: string) => boolean | Promise<boolean | string> | string\n  dir: string\n  fileNames?: string[]\n}): Promise<null | string> {\n  const { root } = path.parse(dir)\n\n  while (true) {\n    if (fileNames?.length) {\n      let found = false\n      for (const fileName of fileNames) {\n        const filePath = path.resolve(dir, fileName)\n        const exists = await pathExistsAndIsAccessible(filePath)\n        if (exists) {\n          if (!condition) {\n            return filePath\n          }\n          found = true\n          break\n        }\n      }\n      if (!found) {\n        dir = path.dirname(dir) // Move up one directory level.\n        continue\n      }\n    }\n    const result = await condition(dir)\n    if (result === true) {\n      return dir\n    }\n    if (typeof result === 'string' && result?.length) {\n      return result\n    }\n    if (dir === root) {\n      return null // Reached the root directory without a match.\n    }\n    dir = path.dirname(dir) // Move up one directory level.\n  }\n}\n\n// From https://github.com/sindresorhus/path-exists/blob/main/index.js\n// fs.accessSync is preferred over fs.existsSync as it's usually a good idea\n// to check if the process has permission to read/write to a file before doing so.\n// Also see https://github.com/nodejs/node/issues/39960\nexport function pathExistsAndIsAccessibleSync(path: string) {\n  try {\n    fs.accessSync(path)\n    return true\n  } catch {\n    return false\n  }\n}\n\nexport async function pathExistsAndIsAccessible(path: string) {\n  try {\n    await fs.promises.access(path)\n    return true\n  } catch {\n    return false\n  }\n}\n"],"names":["fs","path","findUpSync","condition","dir","fileNames","root","parse","length","found","fileName","filePath","join","exists","pathExistsAndIsAccessibleSync","dirname","result","findUp","resolve","pathExistsAndIsAccessible","accessSync","promises","access"],"mappings":";;;;;;AAAA,OAAOA,QAAQ,KAAI;AACnB,OAAOC,UAAU,OAAM;;;AAKhB,SAASC,WAAW,EACzBC,SAAS,EACTC,GAAG,EACHC,SAAS,EAKV;IACC,MAAM,EAAEC,IAAI,EAAE,iGAAGL,UAAAA,CAAKM,KAAK,CAACH;IAE5B,MAAO,KAAM;QACX,IAAIC,WAAWG,QAAQ;YACrB,IAAIC,QAAQ;YACZ,KAAK,MAAMC,YAAYL,UAAW;gBAChC,MAAMM,yGAAWV,UAAAA,CAAKW,IAAI,CAACR,KAAKM;gBAChC,MAAMG,SAASC,8BAA8BH;gBAC7C,IAAIE,QAAQ;oBACV,IAAI,CAACV,WAAW;wBACd,OAAOQ;oBACT;oBACAF,QAAQ;oBACR;gBACF;YACF;YACA,IAAI,CAACA,OAAO;gBACVL,oGAAMH,UAAAA,CAAKc,OAAO,CAACX,KAAK,+BAA+B;;gBACvD;YACF;QACF;QACA,MAAMY,SAASb,UAAUC;QACzB,IAAIY,WAAW,MAAM;YACnB,OAAOZ;QACT;QACA,IAAI,OAAOY,WAAW,YAAYA,QAAQR,QAAQ;YAChD,OAAOQ;QACT;QACA,IAAIZ,QAAQE,MAAM;YAChB,OAAO,KAAK,8CAA8C;;QAC5D;QACAF,oGAAMH,UAAAA,CAAKc,OAAO,CAACX,KAAK,+BAA+B;;IACzD;AACF;AAKO,eAAea,OAAO,EAC3Bd,SAAS,EACTC,GAAG,EACHC,SAAS,EAKV;IACC,MAAM,EAAEC,IAAI,EAAE,iGAAGL,UAAAA,CAAKM,KAAK,CAACH;IAE5B,MAAO,KAAM;QACX,IAAIC,WAAWG,QAAQ;YACrB,IAAIC,QAAQ;YACZ,KAAK,MAAMC,YAAYL,UAAW;gBAChC,MAAMM,yGAAWV,UAAAA,CAAKiB,OAAO,CAACd,KAAKM;gBACnC,MAAMG,SAAS,MAAMM,0BAA0BR;gBAC/C,IAAIE,QAAQ;oBACV,IAAI,CAACV,WAAW;wBACd,OAAOQ;oBACT;oBACAF,QAAQ;oBACR;gBACF;YACF;YACA,IAAI,CAACA,OAAO;gBACVL,oGAAMH,UAAAA,CAAKc,OAAO,CAACX,KAAK,+BAA+B;;gBACvD;YACF;QACF;QACA,MAAMY,SAAS,MAAMb,UAAUC;QAC/B,IAAIY,WAAW,MAAM;YACnB,OAAOZ;QACT;QACA,IAAI,OAAOY,WAAW,YAAYA,QAAQR,QAAQ;YAChD,OAAOQ;QACT;QACA,IAAIZ,QAAQE,MAAM;YAChB,OAAO,KAAK,8CAA8C;;QAC5D;QACAF,oGAAMH,UAAAA,CAAKc,OAAO,CAACX,KAAK,+BAA+B;;IACzD;AACF;AAMO,SAASU,8BAA8Bb,IAAY;IACxD,IAAI;oGACFD,UAAAA,CAAGoB,UAAU,CAACnB;QACd,OAAO;IACT,EAAE,OAAM;QACN,OAAO;IACT;AACF;AAEO,eAAekB,0BAA0BlB,IAAY;IAC1D,IAAI;QACF,kGAAMD,UAAAA,CAAGqB,QAAQ,CAACC,MAAM,CAACrB;QACzB,OAAO;IACT,EAAE,OAAM;QACN,OAAO;IACT;AACF"}},
    {"offset": {"line": 13565, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 13571, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/payload/src/utilities/dependencies/getDependencies.ts"],"sourcesContent":["/*\n  This source code has been taken and modified from https://github.com/vercel/next.js/blob/41a80533f900467e1b788bd2673abe2dca20be6a/packages/next/src/lib/has-necessary-dependencies.ts\n\n  License:\n\n  The MIT License (MIT)\n\n  Copyright (c) 2024 Vercel, Inc.\n\n  Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n\n  The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n\n  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n*/\n\nimport { promises as fs } from 'fs'\nimport path from 'path'\nimport { fileURLToPath } from 'url'\n\nimport { findUp } from '../findUp.js'\nimport { resolveFrom } from './resolveFrom.js'\n\nconst filename = fileURLToPath(import.meta.url)\nconst dirname = path.dirname(filename)\n\nconst payloadPkgDirname = path.resolve(dirname, '../../../') // pkg dir (outside src)\n// if node_modules is in payloadPkgDirname, go to parent dir which contains node_modules\nif (payloadPkgDirname.includes('node_modules')) {\n  payloadPkgDirname.split('node_modules').slice(0, -1)\n}\nconst resolvedCwd = path.resolve(process.cwd())\n\nexport type NecessaryDependencies = {\n  missing: string[]\n  resolved: Map<\n    string,\n    {\n      path: string\n      version: string\n    }\n  >\n}\n\nexport async function getDependencies(\n  baseDir: string,\n  requiredPackages: string[],\n): Promise<NecessaryDependencies> {\n  const resolutions = new Map<\n    string,\n    {\n      path: string\n      version: string\n    }\n  >()\n  const missingPackages: string[] = []\n\n  await Promise.all(\n    requiredPackages.map(async (pkg) => {\n      try {\n        const pkgPath = await fs.realpath(resolveFrom(baseDir, pkg))\n        const pkgDir = path.dirname(pkgPath)\n\n        let packageJsonFilePath = null\n\n        const foundPackageJsonDir = await findUp({\n          dir: pkgDir,\n          fileNames: ['package.json'],\n        })\n\n        if (foundPackageJsonDir) {\n          const resolvedFoundPath = path.resolve(foundPackageJsonDir)\n\n          if (\n            resolvedFoundPath.startsWith(resolvedCwd) ||\n            resolvedFoundPath.startsWith(payloadPkgDirname)\n          ) {\n            // We don't want to match node modules outside the user's project. Checking for both process.cwd and dirname is a reliable way to do this.\n            packageJsonFilePath = resolvedFoundPath\n          }\n        }\n\n        // No need to check if packageJsonFilePath exists - findUp checks that for us\n        if (packageJsonFilePath) {\n          // parse version\n          const packageJson = JSON.parse(await fs.readFile(packageJsonFilePath, 'utf8'))\n          const version = packageJson.version\n\n          resolutions.set(pkg, {\n            path: packageJsonFilePath,\n            version,\n          })\n        } else {\n          return missingPackages.push(pkg)\n        }\n      } catch (_) {\n        return missingPackages.push(pkg)\n      }\n    }),\n  )\n\n  return {\n    missing: missingPackages,\n    resolved: resolutions,\n  }\n}\n"],"names":["promises","fs","path","fileURLToPath","findUp","resolveFrom","filename","url","dirname","payloadPkgDirname","resolve","includes","split","slice","resolvedCwd","process","cwd","getDependencies","baseDir","requiredPackages","resolutions","Map","missingPackages","Promise","all","map","pkg","pkgPath","realpath","pkgDir","packageJsonFilePath","foundPackageJsonDir","dir","fileNames","resolvedFoundPath","startsWith","packageJson","JSON","parse","readFile","version","set","push","_","missing","resolved"],"mappings":"AAAA;;;;;;;;;;;;;;AAcA;;;AAEA,SAASA,YAAYC,EAAE,QAAQ,KAAI;AACnC,OAAOC,UAAU,OAAM;AACvB,SAASC,aAAa,QAAQ,MAAK;AAGnC,SAASE,WAAW,QAAQ,mBAAkB;AAD9C,SAASD,MAAM,QAAQ,eAAc;;;;;;;;;;;AAGrC,MAAME,4GAAWH,gBAAAA,EAAc,8BAAYI,GAAG;AAC9C,MAAMC,uGAAUN,WAAAA,CAAKM,OAAO,CAACF;AAE7B,MAAMG,kHAAoBP,UAAAA,CAAKQ,OAAO,CAACF,SAAS,aAAa,wBAAwB;;AACrF,wFAAwF;AACxF,IAAIC,kBAAkBE,QAAQ,CAAC,iBAAiB;IAC9CF,kBAAkBG,KAAK,CAAC,gBAAgBC,KAAK,CAAC,GAAG,CAAC;AACpD;AACA,MAAMC,4GAAcZ,UAAAA,CAAKQ,OAAO,CAACK,QAAQC,GAAG;AAarC,eAAeC,gBACpBC,OAAe,EACfC,gBAA0B;IAE1B,MAAMC,cAAc,IAAIC;IAOxB,MAAMC,kBAA4B,EAAE;IAEpC,MAAMC,QAAQC,GAAG,CACfL,iBAAiBM,GAAG,CAAC,OAAOC;QAC1B,IAAI;YACF,MAAMC,UAAU,kGAAM1B,WAAAA,CAAG2B,QAAQ,iLAACvB,cAAAA,EAAYa,SAASQ;YACvD,MAAMG,uGAAS3B,UAAAA,CAAKM,OAAO,CAACmB;YAE5B,IAAIG,sBAAsB;YAE1B,MAAMC,sBAAsB,MAAM3B,oKAAAA,EAAO;gBACvC4B,KAAKH;gBACLI,WAAW;oBAAC;iBAAe;YAC7B;YAEA,IAAIF,qBAAqB;gBACvB,MAAMG,kHAAoBhC,UAAAA,CAAKQ,OAAO,CAACqB;gBAEvC,IACEG,kBAAkBC,UAAU,CAACrB,gBAC7BoB,kBAAkBC,UAAU,CAAC1B,oBAC7B;oBACA,0IAA0I;oBAC1IqB,sBAAsBI;gBACxB;YACF;YAEA,6EAA6E;YAC7E,IAAIJ,qBAAqB;gBACvB,gBAAgB;gBAChB,MAAMM,cAAcC,KAAKC,KAAK,CAAC,MAAMrC,uGAAAA,CAAGsC,QAAQ,CAACT,qBAAqB;gBACtE,MAAMU,UAAUJ,YAAYI,OAAO;gBAEnCpB,YAAYqB,GAAG,CAACf,KAAK;oBACnBxB,MAAM4B;oBACNU;gBACF;YACF,OAAO;gBACL,OAAOlB,gBAAgBoB,IAAI,CAAChB;YAC9B;QACF,EAAE,OAAOiB,GAAG;YACV,OAAOrB,gBAAgBoB,IAAI,CAAChB;QAC9B;IACF;IAGF,OAAO;QACLkB,SAAStB;QACTuB,UAAUzB;IACZ;AACF"}},
    {"offset": {"line": 13654, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 13660, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/payload/src/utilities/dependencies/versionUtils.ts"],"sourcesContent":["import type { CustomVersionParser } from './dependencyChecker.js'\n\nexport function parseVersion(version: string): { parts: number[]; preReleases: string[] } {\n  const [mainVersion, ...preReleases] = version.split('-')\n  const parts = mainVersion.split('.').map(Number)\n  return { parts, preReleases }\n}\n\nfunction extractNumbers(str: string): number[] {\n  const matches = str.match(/\\d+/g) || []\n  return matches.map(Number)\n}\n\nfunction comparePreRelease(v1: string, v2: string): number {\n  const num1 = extractNumbers(v1)\n  const num2 = extractNumbers(v2)\n\n  for (let i = 0; i < Math.max(num1.length, num2.length); i++) {\n    if ((num1[i] || 0) < (num2[i] || 0)) {\n      return -1\n    }\n    if ((num1[i] || 0) > (num2[i] || 0)) {\n      return 1\n    }\n  }\n\n  // If numeric parts are equal, compare the whole string\n  if (v1 < v2) {\n    return -1\n  }\n  if (v1 > v2) {\n    return 1\n  }\n  return 0\n}\n\n/**\n * Compares two semantic version strings, including handling pre-release identifiers.\n *\n * This function first compares the major, minor, and patch components as integers.\n * If these components are equal, it then moves on to compare pre-release versions.\n * Pre-release versions are compared first by extracting and comparing any numerical values.\n * If numerical values are equal, it compares the whole pre-release string lexicographically.\n *\n * @param {string} compare - The first version string to compare.\n * @param {string} to - The second version string to compare.\n * @param {function} [customVersionParser] - An optional function to parse version strings into parts and pre-releases.\n * @returns {string} - Returns greater if compare is greater than to, lower if compare is less than to, and equal if they are equal.\n */\nexport function compareVersions(\n  compare: string,\n  to: string,\n  customVersionParser?: CustomVersionParser,\n): 'equal' | 'greater' | 'lower' {\n  const { parts: parts1, preReleases: preReleases1 } = customVersionParser\n    ? customVersionParser(compare)\n    : parseVersion(compare)\n  const { parts: parts2, preReleases: preReleases2 } = customVersionParser\n    ? customVersionParser(to)\n    : parseVersion(to)\n\n  // Compare main version parts\n  for (let i = 0; i < Math.max(parts1.length, parts2.length); i++) {\n    if ((parts1[i] || 0) > (parts2[i] || 0)) {\n      return 'greater'\n    }\n    if ((parts1[i] || 0) < (parts2[i] || 0)) {\n      return 'lower'\n    }\n  }\n\n  // Compare pre-release parts if main versions are equal\n  if (preReleases1?.length || preReleases2?.length) {\n    for (let i = 0; i < Math.max(preReleases1.length, preReleases2.length); i++) {\n      if (!preReleases1[i]) {\n        return 'greater'\n      }\n      if (!preReleases2[i]) {\n        return 'lower'\n      }\n\n      const result = comparePreRelease(preReleases1[i], preReleases2[i])\n      if (result !== 0) {\n        return result === 1 ? 'greater' : 'lower'\n      }\n      // Equal => continue for loop to check for next pre-release part\n    }\n  }\n\n  return 'equal'\n}\n"],"names":["parseVersion","version","mainVersion","preReleases","split","parts","map","Number","extractNumbers","str","matches","match","comparePreRelease","v1","v2","num1","num2","i","Math","max","length","compareVersions","compare","to","customVersionParser","parts1","preReleases1","parts2","preReleases2","result"],"mappings":";;;;AAEO,SAASA,aAAaC,OAAe;IAC1C,MAAM,CAACC,aAAa,GAAGC,YAAY,GAAGF,QAAQG,KAAK,CAAC;IACpD,MAAMC,QAAQH,YAAYE,KAAK,CAAC,KAAKE,GAAG,CAACC;IACzC,OAAO;QAAEF;QAAOF;IAAY;AAC9B;AAEA,SAASK,eAAeC,GAAW;IACjC,MAAMC,UAAUD,IAAIE,KAAK,CAAC,WAAW,EAAE;IACvC,OAAOD,QAAQJ,GAAG,CAACC;AACrB;AAEA,SAASK,kBAAkBC,EAAU,EAAEC,EAAU;IAC/C,MAAMC,OAAOP,eAAeK;IAC5B,MAAMG,OAAOR,eAAeM;IAE5B,IAAK,IAAIG,IAAI,GAAGA,IAAIC,KAAKC,GAAG,CAACJ,KAAKK,MAAM,EAAEJ,KAAKI,MAAM,GAAGH,IAAK;QAC3D,IAAKF,CAAAA,IAAI,CAACE,EAAE,IAAI,CAAA,IAAMD,CAAAA,IAAI,CAACC,EAAE,IAAI,CAAA,GAAI;YACnC,OAAO,CAAC;QACV;QACA,IAAKF,CAAAA,IAAI,CAACE,EAAE,IAAI,CAAA,IAAMD,CAAAA,IAAI,CAACC,EAAE,IAAI,CAAA,GAAI;YACnC,OAAO;QACT;IACF;IAEA,uDAAuD;IACvD,IAAIJ,KAAKC,IAAI;QACX,OAAO,CAAC;IACV;IACA,IAAID,KAAKC,IAAI;QACX,OAAO;IACT;IACA,OAAO;AACT;AAeO,SAASO,gBACdC,OAAe,EACfC,EAAU,EACVC,mBAAyC;IAEzC,MAAM,EAAEnB,OAAOoB,MAAM,EAAEtB,aAAauB,YAAY,EAAE,GAAGF,sBACjDA,oBAAoBF,WACpBtB,aAAasB;IACjB,MAAM,EAAEjB,OAAOsB,MAAM,EAAExB,aAAayB,YAAY,EAAE,GAAGJ,sBACjDA,oBAAoBD,MACpBvB,aAAauB;IAEjB,6BAA6B;IAC7B,IAAK,IAAIN,IAAI,GAAGA,IAAIC,KAAKC,GAAG,CAACM,OAAOL,MAAM,EAAEO,OAAOP,MAAM,GAAGH,IAAK;QAC/D,IAAKQ,CAAAA,MAAM,CAACR,EAAE,IAAI,CAAA,IAAMU,CAAAA,MAAM,CAACV,EAAE,IAAI,CAAA,GAAI;YACvC,OAAO;QACT;QACA,IAAKQ,CAAAA,MAAM,CAACR,EAAE,IAAI,CAAA,IAAMU,CAAAA,MAAM,CAACV,EAAE,IAAI,CAAA,GAAI;YACvC,OAAO;QACT;IACF;IAEA,uDAAuD;IACvD,IAAIS,cAAcN,UAAUQ,cAAcR,QAAQ;QAChD,IAAK,IAAIH,IAAI,GAAGA,IAAIC,KAAKC,GAAG,CAACO,aAAaN,MAAM,EAAEQ,aAAaR,MAAM,GAAGH,IAAK;YAC3E,IAAI,CAACS,YAAY,CAACT,EAAE,EAAE;gBACpB,OAAO;YACT;YACA,IAAI,CAACW,YAAY,CAACX,EAAE,EAAE;gBACpB,OAAO;YACT;YAEA,MAAMY,SAASjB,kBAAkBc,YAAY,CAACT,EAAE,EAAEW,YAAY,CAACX,EAAE;YACjE,IAAIY,WAAW,GAAG;gBAChB,OAAOA,WAAW,IAAI,YAAY;YACpC;QACA,gEAAgE;QAClE;IACF;IAEA,OAAO;AACT"}},
    {"offset": {"line": 13726, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 13732, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/payload/src/utilities/dependencies/dependencyChecker.ts"],"sourcesContent":["import path from 'path'\nimport { fileURLToPath } from 'url'\n\nimport { getDependencies } from '../../index.js'\nimport { compareVersions } from './versionUtils.js'\n\nconst filename = fileURLToPath(import.meta.url)\nconst dirname = path.dirname(filename)\n\nexport type CustomVersionParser = (version: string) => { parts: number[]; preReleases: string[] }\n\nexport type DependencyCheckerArgs = {\n  /**\n   * Define dependency groups to ensure that all dependencies within that group are on the same version, and that no dependencies in that group with different versions are found\n   */\n  dependencyGroups?: {\n    dependencies: string[]\n    /**\n     * Name of the dependency group to be displayed in the error message\n     */\n    name: string\n    targetVersion?: string\n    targetVersionDependency?: string\n  }[]\n  /**\n   * Dependency package names keyed to their required versions. Supports >= (greater or equal than version) as a prefix, or no prefix for the exact version\n   */\n  dependencyVersions?: {\n    [dependency: string]: {\n      customVersionParser?: CustomVersionParser\n      required?: boolean\n      version?: string\n    }\n  }\n}\n\nexport async function checkDependencies({\n  dependencyGroups,\n  dependencyVersions,\n}: DependencyCheckerArgs): Promise<void> {\n  if (dependencyGroups?.length) {\n    for (const dependencyGroup of dependencyGroups) {\n      const resolvedDependencies = await getDependencies(dirname, dependencyGroup.dependencies)\n\n      // Go through each resolved dependency. If any dependency has a mismatching version, throw an error\n      const foundVersions: {\n        [version: string]: string\n      } = {}\n      for (const [_pkg, { version }] of resolvedDependencies.resolved) {\n        if (!Object.keys(foundVersions).includes(version)) {\n          foundVersions[version] = _pkg\n        }\n      }\n      if (Object.keys(foundVersions).length > 1) {\n        const targetVersion =\n          dependencyGroup.targetVersion ??\n          resolvedDependencies.resolved.get(dependencyGroup.targetVersionDependency)?.version\n        if (targetVersion) {\n          const formattedVersionsWithPackageNameString = Object.entries(foundVersions)\n            .filter(([version]) => version !== targetVersion)\n            .map(([version, pkg]) => `${pkg}@${version} (Please change this to ${targetVersion})`)\n            .join(', ')\n          throw new Error(\n            `Mismatching \"${dependencyGroup.name}\" dependency versions found: ${formattedVersionsWithPackageNameString}. All \"${dependencyGroup.name}\" packages must have the same version. This is an error with your set-up, not a bug in Payload. Please go to your package.json and ensure all \"${dependencyGroup.name}\" packages have the same version.`,\n          )\n        } else {\n          const formattedVersionsWithPackageNameString = Object.entries(foundVersions)\n            .map(([version, pkg]) => `${pkg}@${version}`)\n            .join(', ')\n          throw new Error(\n            `Mismatching \"${dependencyGroup.name}\" dependency versions found: ${formattedVersionsWithPackageNameString}. All \"${dependencyGroup.name}\" packages must have the same version. This is an error with your set-up, not a bug in Payload. Please go to your package.json and ensure all \"${dependencyGroup.name}\" packages have the same version.`,\n          )\n        }\n      }\n    }\n  }\n\n  if (dependencyVersions && Object.keys(dependencyVersions).length) {\n    const resolvedDependencies = await getDependencies(dirname, Object.keys(dependencyVersions))\n    for (const [dependency, settings] of Object.entries(dependencyVersions)) {\n      const resolvedDependency = resolvedDependencies.resolved.get(dependency)\n      if (!resolvedDependency) {\n        if (!settings.required) {\n          continue\n        }\n        throw new Error(`Dependency ${dependency} not found. Please ensure it is installed.`)\n      }\n\n      if (settings.version) {\n        const settingsVersionToCheck = settings.version.startsWith('>=')\n          ? settings.version.slice(2)\n          : settings.version\n\n        const versionCompareResult = compareVersions(\n          resolvedDependency.version,\n          settingsVersionToCheck,\n          settings.customVersionParser,\n        )\n\n        if (settings.version.startsWith('>=')) {\n          if (versionCompareResult === 'lower') {\n            throw new Error(\n              `Dependency ${dependency} is on version ${resolvedDependency.version}, but ${settings.version} or greater is required. Please update this dependency.`,\n            )\n          }\n        } else if (versionCompareResult === 'lower' || versionCompareResult === 'greater') {\n          throw new Error(\n            `Dependency ${dependency} is on version ${resolvedDependency.version}, but ${settings.version} is required. Please update this dependency.`,\n          )\n        }\n      }\n    }\n  }\n}\n"],"names":["path","fileURLToPath","getDependencies","compareVersions","filename","url","dirname","checkDependencies","dependencyGroups","dependencyVersions","length","dependencyGroup","resolvedDependencies","dependencies","foundVersions","_pkg","version","resolved","Object","keys","includes","targetVersion","get","targetVersionDependency","formattedVersionsWithPackageNameString","entries","filter","map","pkg","join","Error","name","dependency","settings","resolvedDependency","required","settingsVersionToCheck","startsWith","slice","versionCompareResult","customVersionParser"],"mappings":"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"}},
    {"offset": {"line": 13797, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 13803, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/payload/src/checkPayloadDependencies.ts"],"sourcesContent":["import { checkDependencies } from './utilities/dependencies/dependencyChecker.js'\nimport { PAYLOAD_PACKAGE_LIST } from './versions/payloadPackageList.js'\n\nexport async function checkPayloadDependencies() {\n  const dependencies = [...PAYLOAD_PACKAGE_LIST]\n\n  if (process.env.PAYLOAD_CI_DEPENDENCY_CHECKER !== 'true') {\n    dependencies.push('@payloadcms/plugin-sentry')\n  }\n\n  // First load. First check if there are mismatching dependency versions of payload packages\n  await checkDependencies({\n    dependencyGroups: [\n      {\n        name: 'payload',\n        dependencies,\n        targetVersionDependency: 'payload',\n      },\n    ],\n  })\n}\n"],"names":["checkDependencies","PAYLOAD_PACKAGE_LIST","checkPayloadDependencies","dependencies","process","env","PAYLOAD_CI_DEPENDENCY_CHECKER","push","dependencyGroups","name","targetVersionDependency"],"mappings":";;;AACA,SAASC,oBAAoB,QAAQ,mCAAkC;AADvE,SAASD,iBAAiB,QAAQ,gDAA+C;;;AAG1E,eAAeE;IACpB,MAAMC,eAAe;6KAAIF,uBAAAA;KAAqB;IAE9C,IAAIG,QAAQC,GAAG,CAACC,6BAA6B,KAAK,QAAQ;QACxDH,aAAaI,IAAI,CAAC;IACpB;IAEA,2FAA2F;IAC3F,4LAAMP,oBAAAA,EAAkB;QACtBQ,kBAAkB;YAChB;gBACEC,MAAM;gBACNN;gBACAO,yBAAyB;YAC3B;SACD;IACH;AACF"}},
    {"offset": {"line": 13828, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 13834, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/payload/src/utilities/logger.ts"],"sourcesContent":["import { type Logger, pino } from 'pino'\nimport { build, type PinoPretty, type PrettyOptions } from 'pino-pretty'\n\nimport type { Config } from '../config/types.js'\n\n/**\n * Payload internal logger. Uses Pino.\n * This allows you to bring your own logger instance and let payload use it\n */\nexport type PayloadLogger = Logger\n\nconst prettyOptions: PrettyOptions = {\n  colorize: true,\n  ignore: 'pid,hostname',\n  translateTime: 'SYS:HH:MM:ss',\n}\n\nexport const prettySyncLoggerDestination: PinoPretty.PrettyStream = build({\n  ...prettyOptions,\n  destination: 1, // stdout\n  sync: true,\n})\n\nexport const defaultLoggerOptions: PinoPretty.PrettyStream = build(prettyOptions)\n\nexport const getLogger = (name = 'payload', logger?: Config['logger']): PayloadLogger => {\n  if (!logger) {\n    return pino(defaultLoggerOptions)\n  }\n\n  // Synchronous logger used by bin scripts\n  if (logger === 'sync') {\n    return pino(prettySyncLoggerDestination)\n  }\n\n  // Check if logger is an object\n  if ('options' in logger) {\n    const { destination, options } = logger\n\n    if (!options.name) {\n      options.name = name\n    }\n\n    if (!options.enabled) {\n      options.enabled = process.env.DISABLE_LOGGING !== 'true'\n    }\n\n    return pino(options, destination)\n  } else {\n    // Instantiated logger\n    return logger\n  }\n}\n"],"names":["pino","build","prettyOptions","colorize","ignore","translateTime","prettySyncLoggerDestination","destination","sync","defaultLoggerOptions","getLogger","name","logger","options","enabled","process","env","DISABLE_LOGGING"],"mappings":";;;;;AAAA,SAAsBA,IAAI,QAAQ,OAAM;AACxC,SAASC,KAAK,QAA6C,cAAa;;;AAUxE,MAAMC,gBAA+B;IACnCC,UAAU;IACVC,QAAQ;IACRC,eAAe;AACjB;AAEO,MAAMC,0IAAuDL,QAAAA,EAAM;IACxE,GAAGC,aAAa;IAChBK,aAAa;IACbC,MAAM;AACR,GAAE;AAEK,MAAMC,mIAAgDR,QAAAA,EAAMC,eAAc;AAE1E,MAAMQ,YAAY,CAACC,OAAO,SAAS,EAAEC;IAC1C,IAAI,CAACA,QAAQ;QACX,yGAAOZ,OAAAA,EAAKS;IACd;IAEA,yCAAyC;IACzC,IAAIG,WAAW,QAAQ;QACrB,yGAAOZ,OAAAA,EAAKM;IACd;IAEA,+BAA+B;IAC/B,IAAI,aAAaM,QAAQ;QACvB,MAAM,EAAEL,WAAW,EAAEM,OAAO,EAAE,GAAGD;QAEjC,IAAI,CAACC,QAAQF,IAAI,EAAE;YACjBE,QAAQF,IAAI,GAAGA;QACjB;QAEA,IAAI,CAACE,QAAQC,OAAO,EAAE;YACpBD,QAAQC,OAAO,GAAGC,QAAQC,GAAG,CAACC,eAAe,KAAK;QACpD;QAEA,yGAAOjB,OAAAA,EAAKa,SAASN;IACvB,OAAO;QACL,sBAAsB;QACtB,OAAOK;IACT;AACF,EAAC"}},
    {"offset": {"line": 13877, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 13883, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/payload/src/utilities/traverseFields.ts"],"sourcesContent":["import type { Field, TabAsField } from '../fields/config/types.js'\n\nimport { fieldHasSubFields } from '../fields/config/types.js'\n\nexport type TraverseFieldsCallback = (args: {\n  /**\n   * The current field\n   */\n  field: Field | TabAsField\n  /**\n   * Function that when called will skip the current field and continue to the next\n   */\n  next?: () => void\n  /**\n   * The parent reference object\n   */\n  parentRef?: Record<string, unknown> | unknown\n  /**\n   * The current reference object\n   */\n  ref?: Record<string, unknown> | unknown\n}) => boolean | void\n\ntype TraverseFieldsArgs = {\n  callback: TraverseFieldsCallback\n  fields: (Field | TabAsField)[]\n  parentRef?: Record<string, unknown> | unknown\n  ref?: Record<string, unknown> | unknown\n}\n\n/**\n * Iterate a recurse an array of fields, calling a callback for each field\n *\n * @param fields\n * @param callback callback called for each field, discontinue looping if callback returns truthy\n * @param ref\n * @param parentRef\n */\nexport const traverseFields = ({\n  callback,\n  fields,\n  parentRef = {},\n  ref = {},\n}: TraverseFieldsArgs): void => {\n  fields.some((field) => {\n    let skip = false\n    const next = () => {\n      skip = true\n    }\n    if (callback && callback({ field, next, parentRef, ref })) {\n      return true\n    }\n    if (skip) {\n      return false\n    }\n    if (field.type === 'tabs' && 'tabs' in field) {\n      field.tabs.forEach((tab) => {\n        if ('name' in tab && tab.name) {\n          if (typeof ref[tab.name] === 'undefined') {\n            ref[tab.name] = {}\n          }\n          ref = ref[tab.name]\n        }\n        if (callback && callback({ field: { ...tab, type: 'tab' }, next, parentRef, ref })) {\n          return true\n        }\n        traverseFields({ callback, fields: tab.fields, parentRef, ref })\n      })\n      return\n    }\n    if (field.type !== 'tab' && fieldHasSubFields(field)) {\n      const parentRef = ref\n      if ('name' in field && field.name) {\n        if (typeof ref[field.name] === 'undefined') {\n          if (field.type === 'array') {\n            if (field.localized) {\n              ref[field.name] = {}\n            } else {\n              ref[field.name] = []\n            }\n          }\n          if (field.type === 'group') {\n            ref[field.name] = {}\n          }\n        }\n        ref = ref[field.name]\n      }\n      traverseFields({ callback, fields: field.fields, parentRef, ref })\n    }\n  })\n}\n"],"names":["fieldHasSubFields","traverseFields","callback","fields","parentRef","ref","some","field","skip","next","type","tabs","forEach","tab","name","localized"],"mappings":";;;AAEA,SAASA,iBAAiB,QAAQ,4BAA2B;;AAoCtD,MAAMC,iBAAiB,CAAC,EAC7BC,QAAQ,EACRC,MAAM,EACNC,YAAY,CAAC,CAAC,EACdC,MAAM,CAAC,CAAC,EACW;IACnBF,OAAOG,IAAI,CAAC,CAACC;QACX,IAAIC,OAAO;QACX,MAAMC,OAAO;YACXD,OAAO;QACT;QACA,IAAIN,YAAYA,SAAS;YAAEK;YAAOE;YAAML;YAAWC;QAAI,IAAI;YACzD,OAAO;QACT;QACA,IAAIG,MAAM;YACR,OAAO;QACT;QACA,IAAID,MAAMG,IAAI,KAAK,UAAU,UAAUH,OAAO;YAC5CA,MAAMI,IAAI,CAACC,OAAO,CAAC,CAACC;gBAClB,IAAI,UAAUA,OAAOA,IAAIC,IAAI,EAAE;oBAC7B,IAAI,OAAOT,GAAG,CAACQ,IAAIC,IAAI,CAAC,KAAK,aAAa;wBACxCT,GAAG,CAACQ,IAAIC,IAAI,CAAC,GAAG,CAAC;oBACnB;oBACAT,MAAMA,GAAG,CAACQ,IAAIC,IAAI,CAAC;gBACrB;gBACA,IAAIZ,YAAYA,SAAS;oBAAEK,OAAO;wBAAE,GAAGM,GAAG;wBAAEH,MAAM;oBAAM;oBAAGD;oBAAML;oBAAWC;gBAAI,IAAI;oBAClF,OAAO;gBACT;gBACAJ,eAAe;oBAAEC;oBAAUC,QAAQU,IAAIV,MAAM;oBAAEC;oBAAWC;gBAAI;YAChE;YACA;QACF;QACA,IAAIE,MAAMG,IAAI,KAAK,0KAASV,oBAAAA,EAAkBO,QAAQ;YACpD,MAAMH,YAAYC;YAClB,IAAI,UAAUE,SAASA,MAAMO,IAAI,EAAE;gBACjC,IAAI,OAAOT,GAAG,CAACE,MAAMO,IAAI,CAAC,KAAK,aAAa;oBAC1C,IAAIP,MAAMG,IAAI,KAAK,SAAS;wBAC1B,IAAIH,MAAMQ,SAAS,EAAE;4BACnBV,GAAG,CAACE,MAAMO,IAAI,CAAC,GAAG,CAAC;wBACrB,OAAO;4BACLT,GAAG,CAACE,MAAMO,IAAI,CAAC,GAAG,EAAE;wBACtB;oBACF;oBACA,IAAIP,MAAMG,IAAI,KAAK,SAAS;wBAC1BL,GAAG,CAACE,MAAMO,IAAI,CAAC,GAAG,CAAC;oBACrB;gBACF;gBACAT,MAAMA,GAAG,CAACE,MAAMO,IAAI,CAAC;YACvB;YACAb,eAAe;gBAAEC;gBAAUC,QAAQI,MAAMJ,MAAM;gBAAEC;gBAAWC;YAAI;QAClE;IACF;AACF,EAAC"}},
    {"offset": {"line": 13959, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 13965, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/payload/src/email/defaults.ts"],"sourcesContent":["import type { InitializedEmailAdapter } from './types.js'\n\nexport const emailDefaults: Pick<\n  InitializedEmailAdapter,\n  'defaultFromAddress' | 'defaultFromName'\n> = {\n  defaultFromAddress: 'info@payloadcms.com',\n  defaultFromName: 'Payload',\n}\n"],"names":["emailDefaults","defaultFromAddress","defaultFromName"],"mappings":";;;AAEO,MAAMA,gBAGT;IACFC,oBAAoB;IACpBC,iBAAiB;AACnB,EAAC"}},
    {"offset": {"line": 13972, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 13978, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/payload/src/email/getStringifiedToAddress.ts"],"sourcesContent":["import type { SendEmailOptions } from './types.js'\n\nexport const getStringifiedToAddress = (message: SendEmailOptions): string | undefined => {\n  let stringifiedTo: string | undefined\n\n  if (typeof message.to === 'string') {\n    stringifiedTo = message.to\n  } else if (Array.isArray(message.to)) {\n    stringifiedTo = message.to\n      .map((to) => {\n        if (typeof to === 'string') {\n          return to\n        } else if (to.address) {\n          return to.address\n        }\n        return ''\n      })\n      .join(', ')\n  } else if (message.to.address) {\n    stringifiedTo = message.to.address\n  }\n  return stringifiedTo\n}\n"],"names":["getStringifiedToAddress","message","stringifiedTo","to","Array","isArray","map","address","join"],"mappings":";;;AAEO,MAAMA,0BAA0B,CAACC;IACtC,IAAIC;IAEJ,IAAI,OAAOD,QAAQE,EAAE,KAAK,UAAU;QAClCD,gBAAgBD,QAAQE,EAAE;IAC5B,OAAO,IAAIC,MAAMC,OAAO,CAACJ,QAAQE,EAAE,GAAG;QACpCD,gBAAgBD,QAAQE,EAAE,CACvBG,GAAG,CAAC,CAACH;YACJ,IAAI,OAAOA,OAAO,UAAU;gBAC1B,OAAOA;YACT,OAAO,IAAIA,GAAGI,OAAO,EAAE;gBACrB,OAAOJ,GAAGI,OAAO;YACnB;YACA,OAAO;QACT,GACCC,IAAI,CAAC;IACV,OAAO,IAAIP,QAAQE,EAAE,CAACI,OAAO,EAAE;QAC7BL,gBAAgBD,QAAQE,EAAE,CAACI,OAAO;IACpC;IACA,OAAOL;AACT,EAAC"}},
    {"offset": {"line": 13999, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 14005, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/payload/src/email/consoleEmailAdapter.ts"],"sourcesContent":["import type { EmailAdapter } from './types.js'\n\nimport { emailDefaults } from './defaults.js'\nimport { getStringifiedToAddress } from './getStringifiedToAddress.js'\n\nexport const consoleEmailAdapter: EmailAdapter<void> = ({ payload }) => ({\n  name: 'console',\n  defaultFromAddress: emailDefaults.defaultFromAddress,\n  defaultFromName: emailDefaults.defaultFromName,\n  sendEmail: async (message) => {\n    const stringifiedTo = getStringifiedToAddress(message)\n    const res = `Email attempted without being configured. To: '${stringifiedTo}', Subject: '${message.subject}'`\n    payload.logger.info({ msg: res })\n    return Promise.resolve()\n  },\n})\n"],"names":["emailDefaults","getStringifiedToAddress","consoleEmailAdapter","payload","name","defaultFromAddress","defaultFromName","sendEmail","message","stringifiedTo","res","subject","logger","info","msg","Promise","resolve"],"mappings":";;;AAEA,SAASA,aAAa,QAAQ,gBAAe;AAC7C,SAASC,uBAAuB,QAAQ,+BAA8B;;;AAE/D,MAAMC,sBAA0C,CAAC,EAAEC,OAAO,EAAE,GAAM,CAAA;QACvEC,MAAM;QACNC,yKAAoBL,gBAAAA,CAAcK,kBAAkB;QACpDC,qKAAiBN,iBAAAA,CAAcM,eAAe;QAC9CC,WAAW,OAAOC;YAChB,MAAMC,wLAAgBR,0BAAAA,EAAwBO;YAC9C,MAAME,MAAM,CAAC,+CAA+C,EAAED,cAAc,aAAa,EAAED,QAAQG,OAAO,CAAC,CAAC,CAAC;YAC7GR,QAAQS,MAAM,CAACC,IAAI,CAAC;gBAAEC,KAAKJ;YAAI;YAC/B,OAAOK,QAAQC,OAAO;QACxB;IACF,CAAA,EAAE"}},
    {"offset": {"line": 14025, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 14031, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/payload/src/utilities/telemetry/conf/envPaths.ts"],"sourcesContent":["/**\n * Taken from https://github.com/sindresorhus/env-paths/blob/main/index.js\n *\n * MIT License\n *\n * Copyright (c) Sindre Sorhus <sindresorhus@gmail.com> (https://sindresorhus.com)\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n */\n\nimport os from 'node:os'\nimport path from 'node:path'\nimport process from 'node:process'\n\nconst homedir = os.homedir()\nconst tmpdir = os.tmpdir()\nconst { env } = process\n\nconst macos = (name) => {\n  const library = path.join(homedir, 'Library')\n\n  return {\n    cache: path.join(library, 'Caches', name),\n    config: path.join(library, 'Preferences', name),\n    data: path.join(library, 'Application Support', name),\n    log: path.join(library, 'Logs', name),\n    temp: path.join(tmpdir, name),\n  }\n}\n\nconst windows = (name) => {\n  const appData = env.APPDATA || path.join(homedir, 'AppData', 'Roaming')\n  const localAppData = env.LOCALAPPDATA || path.join(homedir, 'AppData', 'Local')\n\n  return {\n    // Data/config/cache/log are invented by me as Windows isn't opinionated about this\n    cache: path.join(localAppData, name, 'Cache'),\n    config: path.join(appData, name, 'Config'),\n    data: path.join(localAppData, name, 'Data'),\n    log: path.join(localAppData, name, 'Log'),\n    temp: path.join(tmpdir, name),\n  }\n}\n\n// https://specifications.freedesktop.org/basedir-spec/basedir-spec-latest.html\nconst linux = (name) => {\n  const username = path.basename(homedir)\n\n  return {\n    cache: path.join(env.XDG_CACHE_HOME || path.join(homedir, '.cache'), name),\n    config: path.join(env.XDG_CONFIG_HOME || path.join(homedir, '.config'), name),\n    data: path.join(env.XDG_DATA_HOME || path.join(homedir, '.local', 'share'), name),\n    // https://wiki.debian.org/XDGBaseDirectorySpecification#state\n    log: path.join(env.XDG_STATE_HOME || path.join(homedir, '.local', 'state'), name),\n    temp: path.join(tmpdir, username, name),\n  }\n}\n\nexport function envPaths(name, { suffix = 'nodejs' } = {}) {\n  if (typeof name !== 'string') {\n    throw new TypeError(`Expected a string, got ${typeof name}`)\n  }\n\n  if (suffix) {\n    // Add suffix to prevent possible conflict with native apps\n    name += `-${suffix}`\n  }\n\n  if (process.platform === 'darwin') {\n    return macos(name)\n  }\n\n  if (process.platform === 'win32') {\n    return windows(name)\n  }\n\n  return linux(name)\n}\n"],"names":["os","path","process","homedir","tmpdir","env","macos","name","library","join","cache","config","data","log","temp","windows","appData","APPDATA","localAppData","LOCALAPPDATA","linux","username","basename","XDG_CACHE_HOME","XDG_CONFIG_HOME","XDG_DATA_HOME","XDG_STATE_HOME","envPaths","suffix","TypeError","platform"],"mappings":"AAAA;;;;;;;;;;;;CAYC;;;AAED,OAAOA,QAAQ,UAAS;AACxB,OAAOC,UAAU,YAAW;AAC5B,OAAOC,aAAa,eAAc;;;;AAElC,MAAMC,8GAAUH,UAAAA,CAAGG,OAAO;AAC1B,MAAMC,6GAASJ,UAAAA,CAAGI,MAAM;AACxB,MAAM,EAAEC,GAAG,EAAE,4GAAGH,UAAAA;AAEhB,MAAMI,QAAQ,CAACC;IACb,MAAMC,gHAAUP,UAAAA,CAAKQ,IAAI,CAACN,SAAS;IAEnC,OAAO;QACLO,6GAAOT,UAAAA,CAAKQ,IAAI,CAACD,SAAS,UAAUD;QACpCI,8GAAQV,UAAAA,CAAKQ,IAAI,CAACD,SAAS,eAAeD;QAC1CK,4GAAMX,UAAAA,CAAKQ,IAAI,CAACD,SAAS,uBAAuBD;QAChDM,2GAAKZ,UAAAA,CAAKQ,IAAI,CAACD,SAAS,QAAQD;QAChCO,4GAAMb,UAAAA,CAAKQ,IAAI,CAACL,QAAQG;IAC1B;AACF;AAEA,MAAMQ,UAAU,CAACR;IACf,MAAMS,UAAUX,IAAIY,OAAO,0GAAIhB,UAAAA,CAAKQ,IAAI,CAACN,SAAS,WAAW;IAC7D,MAAMe,eAAeb,IAAIc,YAAY,0GAAIlB,UAAAA,CAAKQ,IAAI,CAACN,SAAS,WAAW;IAEvE,OAAO;QACL,mFAAmF;QACnFO,6GAAOT,UAAAA,CAAKQ,IAAI,CAACS,cAAcX,MAAM;QACrCI,8GAAQV,UAAAA,CAAKQ,IAAI,CAACO,SAAST,MAAM;QACjCK,4GAAMX,UAAAA,CAAKQ,IAAI,CAACS,cAAcX,MAAM;QACpCM,2GAAKZ,UAAAA,CAAKQ,IAAI,CAACS,cAAcX,MAAM;QACnCO,4GAAMb,UAAAA,CAAKQ,IAAI,CAACL,QAAQG;IAC1B;AACF;AAEA,+EAA+E;AAC/E,MAAMa,QAAQ,CAACb;IACb,MAAMc,iHAAWpB,UAAAA,CAAKqB,QAAQ,CAACnB;IAE/B,OAAO;QACLO,6GAAOT,UAAAA,CAAKQ,IAAI,CAACJ,IAAIkB,cAAc,0GAAItB,UAAAA,CAAKQ,IAAI,CAACN,SAAS,WAAWI;QACrEI,8GAAQV,UAAAA,CAAKQ,IAAI,CAACJ,IAAImB,eAAe,0GAAIvB,UAAAA,CAAKQ,IAAI,CAACN,SAAS,YAAYI;QACxEK,4GAAMX,UAAAA,CAAKQ,IAAI,CAACJ,IAAIoB,aAAa,0GAAIxB,UAAAA,CAAKQ,IAAI,CAACN,SAAS,UAAU,UAAUI;QAC5E,8DAA8D;QAC9DM,2GAAKZ,UAAAA,CAAKQ,IAAI,CAACJ,IAAIqB,cAAc,0GAAIzB,UAAAA,CAAKQ,IAAI,CAACN,SAAS,UAAU,UAAUI;QAC5EO,4GAAMb,UAAAA,CAAKQ,IAAI,CAACL,QAAQiB,UAAUd;IACpC;AACF;AAEO,SAASoB,SAASpB,IAAI,EAAE,EAAEqB,SAAS,QAAQ,EAAE,GAAG,CAAC,CAAC;IACvD,IAAI,OAAOrB,SAAS,UAAU;QAC5B,MAAM,IAAIsB,UAAU,CAAC,uBAAuB,EAAE,OAAOtB,KAAK,CAAC;IAC7D;IAEA,IAAIqB,QAAQ;QACV,2DAA2D;QAC3DrB,QAAQ,CAAC,CAAC,EAAEqB,OAAO,CAAC;IACtB;IAEA,6GAAI1B,UAAAA,CAAQ4B,QAAQ,KAAK,UAAU;QACjC,OAAOxB,MAAMC;IACf;IAEA,6GAAIL,UAAAA,CAAQ4B,QAAQ,KAAK,SAAS;QAChC,OAAOf,QAAQR;IACjB;IAEA,OAAOa,MAAMb;AACf"}},
    {"offset": {"line": 14105, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 14111, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/payload/src/utilities/telemetry/conf/index.ts"],"sourcesContent":["/**\n * Taken & simplified from https://github.com/sindresorhus/conf/blob/main/source/index.ts\n *\n * MIT License\n *\n * Copyright (c) Sindre Sorhus <sindresorhus@gmail.com> (https://sindresorhus.com)\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n */\n\nimport assert from 'node:assert'\nimport fs from 'node:fs'\nimport path from 'node:path'\n\nimport { envPaths } from './envPaths.js'\n\nconst createPlainObject = <T = Record<string, unknown>>(): T => Object.create(null)\n\nconst checkValueType = (key: string, value: unknown): void => {\n  const nonJsonTypes = new Set(['undefined', 'symbol', 'function'])\n\n  const type = typeof value\n\n  if (nonJsonTypes.has(type)) {\n    throw new TypeError(\n      `Setting a value of type \\`${type}\\` for key \\`${key}\\` is not allowed as it's not supported by JSON`,\n    )\n  }\n}\n\nexport class Conf<T extends Record<string, any> = Record<string, unknown>>\n  implements Iterable<[keyof T, T[keyof T]]>\n{\n  readonly #options: Readonly<Partial<Options>>\n  private readonly _deserialize: Deserialize<T> = (value) => JSON.parse(value)\n  private readonly _serialize: Serialize<T> = (value) => JSON.stringify(value, undefined, '\\t')\n\n  readonly events: EventTarget\n\n  readonly path: string\n\n  constructor() {\n    const options: Partial<Options> = {\n      configFileMode: 0o666,\n      configName: 'config',\n      fileExtension: 'json',\n      projectSuffix: 'nodejs',\n    }\n\n    const cwd = envPaths('payload', { suffix: options.projectSuffix }).config\n\n    this.#options = options\n\n    this.events = new EventTarget()\n\n    const fileExtension = options.fileExtension ? `.${options.fileExtension}` : ''\n    this.path = path.resolve(cwd, `${options.configName ?? 'config'}${fileExtension}`)\n\n    const fileStore = this.store\n    const store = Object.assign(createPlainObject(), fileStore)\n\n    try {\n      assert.deepEqual(fileStore, store)\n    } catch {\n      this.store = store\n    }\n  }\n\n  private _ensureDirectory(): void {\n    // Ensure the directory exists as it could have been deleted in the meantime.\n    fs.mkdirSync(path.dirname(this.path), { recursive: true })\n  }\n\n  private _write(value: T): void {\n    const data: string | Uint8Array = this._serialize(value)\n\n    fs.writeFileSync(this.path, data, { mode: this.#options.configFileMode })\n  }\n\n  /**\n   Delete an item.\n\n   @param key - The key of the item to delete.\n   */\n  delete(key: string): void {\n    const { store } = this\n    delete store[key]\n\n    this.store = store\n  }\n\n  /**\n   Get an item.\n\n   @param key - The key of the item to get.\n   */\n  get<Key extends keyof T>(key: Key): T[Key] {\n    const { store } = this\n    return store[key]\n  }\n\n  /**\n   Set an item or multiple items at once.\n\n   @param key - You can use [dot-notation](https://github.com/sindresorhus/dot-prop) in a key to access nested properties. Or a hashmap of items to set at once.\n   @param value - Must be JSON serializable. Trying to set the type `undefined`, `function`, or `symbol` will result in a `TypeError`.\n   */\n  set<Key extends keyof T>(key: string, value?: T[Key] | unknown): void {\n    if (typeof key !== 'string' && typeof key !== 'object') {\n      throw new TypeError(\n        `Expected \\`key\\` to be of type \\`string\\` or \\`object\\`, got ${typeof key}`,\n      )\n    }\n\n    if (typeof key !== 'object' && value === undefined) {\n      throw new TypeError('Use `delete()` to clear values')\n    }\n\n    const { store } = this\n\n    const set = (key: string, value?: T | T[Key] | unknown): void => {\n      checkValueType(key, value)\n      store[key as Key] = value as T[Key]\n    }\n\n    if (typeof key === 'object') {\n      const object = key\n      for (const [key, value] of Object.entries(object)) {\n        set(key, value)\n      }\n    } else {\n      set(key, value)\n    }\n\n    this.store = store\n  }\n\n  *[Symbol.iterator](): IterableIterator<[keyof T, T[keyof T]]> {\n    for (const [key, value] of Object.entries(this.store)) {\n      yield [key, value]\n    }\n  }\n  get size(): number {\n    return Object.keys(this.store).length\n  }\n  get store(): T {\n    try {\n      const dataString = fs.readFileSync(this.path, 'utf8')\n      const deserializedData = this._deserialize(dataString)\n      return Object.assign(createPlainObject(), deserializedData)\n    } catch (error: unknown) {\n      if ((error as any)?.code === 'ENOENT') {\n        this._ensureDirectory()\n        return createPlainObject()\n      }\n\n      throw error\n    }\n  }\n\n  set store(value: T) {\n    this._ensureDirectory()\n\n    this._write(value)\n\n    this.events.dispatchEvent(new Event('change'))\n  }\n}\n\nexport type Options = {\n  /**\n   The config is cleared if reading the config file causes a `SyntaxError`. This is a good behavior for unimportant data, as the config file is not intended to be hand-edited, so it usually means the config is corrupt and there's nothing the user can do about it anyway. However, if you let the user edit the config file directly, mistakes might happen and it could be more useful to throw an error when the config is invalid instead of clearing.\n\n   @default false\n   */\n  clearInvalidConfig?: boolean\n\n  /**\n   The [mode](https://en.wikipedia.org/wiki/File-system_permissions#Numeric_notation) that will be used for the config file.\n\n   You would usually not need this, but it could be useful if you want to restrict the permissions of the config file. Setting a permission such as `0o600` would result in a config file that can only be accessed by the user running the program.\n\n   Note that setting restrictive permissions can cause problems if different users need to read the file. A common problem is a user running your tool with and without `sudo` and then not being able to access the config the second time.\n\n   @default 0o666\n   */\n  readonly configFileMode?: number\n\n  /**\n   Name of the config file (without extension).\n\n   Useful if you need multiple config files for your app or module. For example, different config files between two major versions.\n\n   @default 'config'\n   */\n  configName?: string\n\n  /**\n   Extension of the config file.\n\n   You would usually not need this, but could be useful if you want to interact with a file with a custom file extension that can be associated with your app. These might be simple save/export/preference files that are intended to be shareable or saved outside of the app.\n\n   @default 'json'\n   */\n  fileExtension?: string\n\n  readonly projectSuffix?: string\n}\n\nexport type Serialize<T> = (value: T) => string\nexport type Deserialize<T> = (text: string) => T\n"],"names":["assert","fs","path","envPaths","createPlainObject","Object","create","checkValueType","key","value","nonJsonTypes","Set","type","has","TypeError","Conf","_deserialize","JSON","parse","_serialize","stringify","undefined","events","constructor","options","configFileMode","configName","fileExtension","projectSuffix","cwd","suffix","config","EventTarget","resolve","fileStore","store","assign","deepEqual","_ensureDirectory","mkdirSync","dirname","recursive","_write","data","writeFileSync","mode","delete","get","set","object","entries","Symbol","iterator","size","keys","length","dataString","readFileSync","deserializedData","error","code","dispatchEvent","Event"],"mappings":"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"}},
    {"offset": {"line": 14260, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 14266, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/payload/src/utilities/telemetry/oneWayHash.ts"],"sourcesContent":["import type { BinaryLike } from 'crypto'\n\nimport { createHash } from 'crypto'\n\nexport const oneWayHash = (data: BinaryLike, secret: string): string => {\n  const hash = createHash('sha256')\n\n  // prepend value with payload secret. This ensure one-way.\n  hash.update(secret)\n\n  // Update is an append operation, not a replacement. The secret from the prior\n  // update is still present!\n  hash.update(data)\n  return hash.digest('hex')\n}\n"],"names":["createHash","oneWayHash","data","secret","hash","update","digest"],"mappings":";;;AAEA,SAASA,UAAU,QAAQ,SAAQ;;AAE5B,MAAMC,aAAa,CAACC,MAAkBC;IAC3C,MAAMC,2GAAOJ,aAAAA,EAAW;IAExB,0DAA0D;IAC1DI,KAAKC,MAAM,CAACF;IAEZ,8EAA8E;IAC9E,2BAA2B;IAC3BC,KAAKC,MAAM,CAACH;IACZ,OAAOE,KAAKE,MAAM,CAAC;AACrB,EAAC"}},
    {"offset": {"line": 14280, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 14286, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/payload/src/utilities/telemetry/index.ts"],"sourcesContent":["import { execSync } from 'child_process'\nimport ciInfo from 'ci-info'\nimport { randomBytes } from 'crypto'\nimport fs from 'fs'\nimport path from 'path'\nimport { fileURLToPath } from 'url'\n\nimport type { Payload } from '../../types/index.js'\nimport type { AdminInitEvent } from './events/adminInit.js'\nimport type { ServerInitEvent } from './events/serverInit.js'\n\nimport { findUp } from '../findUp.js'\nimport { Conf } from './conf/index.js'\nimport { oneWayHash } from './oneWayHash.js'\n\nexport type BaseEvent = {\n  ciName: null | string\n  dbAdapter: string\n  emailAdapter: null | string\n  envID: string\n  isCI: boolean\n  locales: string[]\n  localizationDefaultLocale: null | string\n  localizationEnabled: boolean\n  nodeEnv: string\n  nodeVersion: string\n  payloadVersion: string\n  projectID: string\n  uploadAdapters: string[]\n}\n\ntype PackageJSON = {\n  dependencies: Record<string, string | undefined>\n  name: string\n}\n\ntype TelemetryEvent = AdminInitEvent | ServerInitEvent\n\ntype Args = {\n  event: TelemetryEvent\n  payload: Payload\n}\n\nlet baseEvent: BaseEvent | null = null\n\nexport const sendEvent = async ({ event, payload }: Args): Promise<void> => {\n  try {\n    const { packageJSON, packageJSONPath } = await getPackageJSON()\n\n    // Only generate the base event once\n    if (!baseEvent) {\n      baseEvent = {\n        ciName: ciInfo.isCI ? ciInfo.name : null,\n        envID: getEnvID(),\n        isCI: ciInfo.isCI,\n        nodeEnv: process.env.NODE_ENV || 'development',\n        nodeVersion: process.version,\n        payloadVersion: getPayloadVersion(packageJSON),\n        projectID: getProjectID(payload, packageJSON),\n        ...getLocalizationInfo(payload),\n        dbAdapter: payload.db.name,\n        emailAdapter: payload.email?.name || null,\n        uploadAdapters: payload.config.upload.adapters,\n      }\n    }\n\n    if (process.env.PAYLOAD_TELEMETRY_DEBUG) {\n      payload.logger.info({\n        event: { ...baseEvent, ...event, packageJSONPath },\n        msg: 'Telemetry Event',\n      })\n      return\n    }\n\n    if (payload.config.telemetry !== false) {\n      await fetch('https://telemetry.payloadcms.com/events', {\n        body: JSON.stringify({ ...baseEvent, ...event }),\n        headers: {\n          'Content-Type': 'application/json',\n        },\n        method: 'post',\n      })\n    }\n  } catch (_) {\n    // Eat any errors in sending telemetry event\n  }\n}\n\n/**\n * This is a quasi-persistent identifier used to dedupe recurring events. It's\n * generated from random data and completely anonymous.\n */\nconst getEnvID = (): string => {\n  const conf = new Conf()\n  const ENV_ID = 'envID'\n\n  const val = conf.get(ENV_ID)\n  if (val) {\n    return val as string\n  }\n\n  const generated = randomBytes(32).toString('hex')\n  conf.set(ENV_ID, generated)\n  return generated\n}\n\nconst getProjectID = (payload: Payload, packageJSON: PackageJSON): string => {\n  const projectID =\n    getGitID(payload) ||\n    getPackageJSONID(payload, packageJSON) ||\n    payload.config.serverURL ||\n    process.cwd()\n  return oneWayHash(projectID, payload.secret)\n}\n\nconst getGitID = (payload: Payload) => {\n  try {\n    const originBuffer = execSync('git config --local --get remote.origin.url', {\n      stdio: 'pipe',\n      timeout: 1000,\n    })\n\n    return oneWayHash(String(originBuffer).trim(), payload.secret)\n  } catch (_) {\n    return null\n  }\n}\n\nconst getPackageJSON = async (): Promise<{\n  packageJSON?: PackageJSON\n  packageJSONPath: string\n}> => {\n  let packageJSONPath = path.resolve(process.cwd(), 'package.json')\n\n  if (!fs.existsSync(packageJSONPath)) {\n    // Old logic\n    const filename = fileURLToPath(import.meta.url)\n    const dirname = path.dirname(filename)\n    packageJSONPath = await findUp({\n      dir: dirname,\n      fileNames: ['package.json'],\n    })\n  }\n\n  const jsonContentString = await fs.promises.readFile(packageJSONPath, 'utf-8')\n  const jsonContent: PackageJSON = JSON.parse(jsonContentString)\n  return { packageJSON: jsonContent, packageJSONPath }\n}\n\nconst getPackageJSONID = (payload: Payload, packageJSON: PackageJSON): string => {\n  return oneWayHash(packageJSON.name, payload.secret)\n}\n\nexport const getPayloadVersion = (packageJSON: PackageJSON): string => {\n  return packageJSON?.dependencies?.payload ?? ''\n}\n\nexport const getLocalizationInfo = (\n  payload: Payload,\n): Pick<BaseEvent, 'locales' | 'localizationDefaultLocale' | 'localizationEnabled'> => {\n  if (!payload.config.localization) {\n    return {\n      locales: [],\n      localizationDefaultLocale: null,\n      localizationEnabled: false,\n    }\n  }\n\n  return {\n    locales: payload.config.localization.localeCodes,\n    localizationDefaultLocale: payload.config.localization.defaultLocale,\n    localizationEnabled: true,\n  }\n}\n"],"names":["execSync","ciInfo","randomBytes","fs","path","fileURLToPath","findUp","Conf","oneWayHash","baseEvent","sendEvent","event","payload","packageJSON","packageJSONPath","getPackageJSON","ciName","isCI","name","envID","getEnvID","nodeEnv","process","env","NODE_ENV","nodeVersion","version","payloadVersion","getPayloadVersion","projectID","getProjectID","getLocalizationInfo","dbAdapter","db","emailAdapter","email","uploadAdapters","config","upload","adapters","PAYLOAD_TELEMETRY_DEBUG","logger","info","msg","telemetry","fetch","body","JSON","stringify","headers","method","_","conf","ENV_ID","val","get","generated","toString","set","getGitID","getPackageJSONID","serverURL","cwd","secret","originBuffer","stdio","timeout","String","trim","resolve","existsSync","filename","url","dirname","dir","fileNames","jsonContentString","promises","readFile","jsonContent","parse","dependencies","localization","locales","localizationDefaultLocale","localizationEnabled","localeCodes","defaultLocale"],"mappings":"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"}},
    {"offset": {"line": 14430, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 14436, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/payload/src/utilities/telemetry/events/serverInit.ts"],"sourcesContent":["import type { Payload } from '../../../index.js'\n\nimport { sendEvent } from '../index.js'\n\nexport type ServerInitEvent = {\n  type: 'server-init'\n}\n\nexport const serverInit = (payload: Payload): void => {\n  // eslint-disable-next-line @typescript-eslint/no-floating-promises\n  sendEvent({\n    event: {\n      type: 'server-init',\n    },\n    payload,\n  })\n}\n"],"names":["sendEvent","serverInit","payload","event","type"],"mappings":";;;AAEA,SAASA,SAAS,QAAQ,cAAa;;AAMhC,MAAMC,aAAa,CAACC;IACzB,mEAAmE;2KACnEF,YAAAA,EAAU;QACRG,OAAO;YACLC,MAAM;QACR;QACAF;IACF;AACF,EAAC"}},
    {"offset": {"line": 14450, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 14456, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/payload/src/auth/strategies/apiKey.ts"],"sourcesContent":["import crypto from 'crypto'\n\nimport type { SanitizedCollectionConfig } from '../../collections/config/types.js'\nimport type { Where } from '../../types/index.js'\nimport type { AuthStrategyFunction, User } from '../index.js'\n\nexport const APIKeyAuthentication =\n  (collectionConfig: SanitizedCollectionConfig): AuthStrategyFunction =>\n  async ({ headers, payload }) => {\n    const authHeader = headers.get('Authorization')\n\n    if (authHeader?.startsWith(`${collectionConfig.slug} API-Key `)) {\n      const apiKey = authHeader.replace(`${collectionConfig.slug} API-Key `, '')\n      const apiKeyIndex = crypto.createHmac('sha1', payload.secret).update(apiKey).digest('hex')\n\n      try {\n        const where: Where = {}\n        if (collectionConfig.auth?.verify) {\n          where.and = [\n            {\n              apiKeyIndex: {\n                equals: apiKeyIndex,\n              },\n            },\n            {\n              _verified: {\n                not_equals: false,\n              },\n            },\n          ]\n        } else {\n          where.apiKeyIndex = {\n            equals: apiKeyIndex,\n          }\n        }\n\n        const userQuery = await payload.find({\n          collection: collectionConfig.slug,\n          depth: collectionConfig.auth.depth,\n          limit: 1,\n          overrideAccess: true,\n          pagination: false,\n          where,\n        })\n\n        if (userQuery.docs && userQuery.docs.length > 0) {\n          const user = userQuery.docs[0]\n          user.collection = collectionConfig.slug\n          user._strategy = 'api-key'\n\n          return {\n            user: user as User,\n          }\n        }\n      } catch (err) {\n        return { user: null }\n      }\n    }\n\n    return { user: null }\n  }\n"],"names":["crypto","APIKeyAuthentication","collectionConfig","headers","payload","authHeader","get","startsWith","slug","apiKey","replace","apiKeyIndex","createHmac","secret","update","digest","where","auth","verify","and","equals","_verified","not_equals","userQuery","find","collection","depth","limit","overrideAccess","pagination","docs","length","user","_strategy","err"],"mappings":";;;AAAA,OAAOA,YAAY,SAAQ;;AAMpB,MAAMC,uBACX,CAACC,mBACD,OAAO,EAAEC,OAAO,EAAEC,OAAO,EAAE;QACzB,MAAMC,aAAaF,QAAQG,GAAG,CAAC;QAE/B,IAAID,YAAYE,WAAW,CAAC,EAAEL,iBAAiBM,IAAI,CAAC,SAAS,CAAC,GAAG;YAC/D,MAAMC,SAASJ,WAAWK,OAAO,CAAC,CAAC,EAAER,iBAAiBM,IAAI,CAAC,SAAS,CAAC,EAAE;YACvE,MAAMG,8GAAcX,UAAAA,CAAOY,UAAU,CAAC,QAAQR,QAAQS,MAAM,EAAEC,MAAM,CAACL,QAAQM,MAAM,CAAC;YAEpF,IAAI;gBACF,MAAMC,QAAe,CAAC;gBACtB,IAAId,iBAAiBe,IAAI,EAAEC,QAAQ;oBACjCF,MAAMG,GAAG,GAAG;wBACV;4BACER,aAAa;gCACXS,QAAQT;4BACV;wBACF;wBACA;4BACEU,WAAW;gCACTC,YAAY;4BACd;wBACF;qBACD;gBACH,OAAO;oBACLN,MAAML,WAAW,GAAG;wBAClBS,QAAQT;oBACV;gBACF;gBAEA,MAAMY,YAAY,MAAMnB,QAAQoB,IAAI,CAAC;oBACnCC,YAAYvB,iBAAiBM,IAAI;oBACjCkB,OAAOxB,iBAAiBe,IAAI,CAACS,KAAK;oBAClCC,OAAO;oBACPC,gBAAgB;oBAChBC,YAAY;oBACZb;gBACF;gBAEA,IAAIO,UAAUO,IAAI,IAAIP,UAAUO,IAAI,CAACC,MAAM,GAAG,GAAG;oBAC/C,MAAMC,OAAOT,UAAUO,IAAI,CAAC,EAAE;oBAC9BE,KAAKP,UAAU,GAAGvB,iBAAiBM,IAAI;oBACvCwB,KAAKC,SAAS,GAAG;oBAEjB,OAAO;wBACLD,MAAMA;oBACR;gBACF;YACF,EAAE,OAAOE,KAAK;gBACZ,OAAO;oBAAEF,MAAM;gBAAK;YACtB;QACF;QAEA,OAAO;YAAEA,MAAM;QAAK;IACtB,EAAC"}},
    {"offset": {"line": 14512, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 14518, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/payload/src/utilities/parseCookies.ts"],"sourcesContent":["import { APIError } from '../errors/APIError.js'\n\nexport const parseCookies = (headers: Request['headers']): Map<string, string> => {\n  const list = new Map<string, string>()\n  const rc = headers.get('Cookie')\n\n  if (rc) {\n    rc.split(';').forEach((cookie) => {\n      const parts = cookie.split('=')\n      const key = parts.shift().trim()\n      const encodedValue = parts.join('=')\n\n      try {\n        const decodedValue = decodeURI(encodedValue)\n        list.set(key, decodedValue)\n      } catch (e) {\n        throw new APIError(`Error decoding cookie value for key ${key}: ${e.message}`)\n      }\n    })\n  }\n\n  return list\n}\n"],"names":["APIError","parseCookies","headers","list","Map","rc","get","split","forEach","cookie","parts","key","shift","trim","encodedValue","join","decodedValue","decodeURI","set","e","message"],"mappings":";;;AAAA,SAASA,QAAQ,QAAQ,wBAAuB;;AAEzC,MAAMC,eAAe,CAACC;IAC3B,MAAMC,OAAO,IAAIC;IACjB,MAAMC,KAAKH,QAAQI,GAAG,CAAC;IAEvB,IAAID,IAAI;QACNA,GAAGE,KAAK,CAAC,KAAKC,OAAO,CAAC,CAACC;YACrB,MAAMC,QAAQD,OAAOF,KAAK,CAAC;YAC3B,MAAMI,MAAMD,MAAME,KAAK,GAAGC,IAAI;YAC9B,MAAMC,eAAeJ,MAAMK,IAAI,CAAC;YAEhC,IAAI;gBACF,MAAMC,eAAeC,UAAUH;gBAC/BX,KAAKe,GAAG,CAACP,KAAKK;YAChB,EAAE,OAAOG,GAAG;gBACV,MAAM,0JAAInB,WAAAA,CAAS,CAAC,oCAAoC,EAAEW,IAAI,EAAE,EAAEQ,EAAEC,OAAO,CAAC,CAAC;YAC/E;QACF;IACF;IAEA,OAAOjB;AACT,EAAC"}},
    {"offset": {"line": 14541, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 14547, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/payload/src/auth/extractJWT.ts"],"sourcesContent":["import type { AuthStrategyFunctionArgs } from './index.js'\n\nimport { parseCookies } from '../utilities/parseCookies.js'\n\nexport const extractJWT = (args: AuthStrategyFunctionArgs): null | string => {\n  const { headers, payload } = args\n\n  const jwtFromHeader = headers.get('Authorization')\n  const origin = headers.get('Origin')\n\n  if (jwtFromHeader?.startsWith('JWT ')) {\n    return jwtFromHeader.replace('JWT ', '')\n  }\n  // allow RFC6750 OAuth 2.0 compliant Bearer tokens\n  // in addition to the payload default JWT format\n  if (jwtFromHeader?.startsWith('Bearer ')) {\n    return jwtFromHeader.replace('Bearer ', '')\n  }\n\n  const cookies = parseCookies(headers)\n  const tokenCookieName = `${payload.config.cookiePrefix}-token`\n  const cookieToken = cookies.get(tokenCookieName)\n\n  if (!cookieToken) {\n    return null\n  }\n\n  if (!origin || payload.config.csrf.length === 0 || payload.config.csrf.indexOf(origin) > -1) {\n    return cookieToken\n  }\n\n  return null\n}\n"],"names":["parseCookies","extractJWT","args","headers","payload","jwtFromHeader","get","origin","startsWith","replace","cookies","tokenCookieName","config","cookiePrefix","cookieToken","csrf","length","indexOf"],"mappings":";;;AAEA,SAASA,YAAY,QAAQ,+BAA8B;;AAEpD,MAAMC,aAAa,CAACC;IACzB,MAAM,EAAEC,OAAO,EAAEC,OAAO,EAAE,GAAGF;IAE7B,MAAMG,gBAAgBF,QAAQG,GAAG,CAAC;IAClC,MAAMC,SAASJ,QAAQG,GAAG,CAAC;IAE3B,IAAID,eAAeG,WAAW,SAAS;QACrC,OAAOH,cAAcI,OAAO,CAAC,QAAQ;IACvC;IACA,kDAAkD;IAClD,gDAAgD;IAChD,IAAIJ,eAAeG,WAAW,YAAY;QACxC,OAAOH,cAAcI,OAAO,CAAC,WAAW;IAC1C;IAEA,MAAMC,2KAAUV,eAAAA,EAAaG;IAC7B,MAAMQ,kBAAkB,CAAC,EAAEP,QAAQQ,MAAM,CAACC,YAAY,CAAC,MAAM,CAAC;IAC9D,MAAMC,cAAcJ,QAAQJ,GAAG,CAACK;IAEhC,IAAI,CAACG,aAAa;QAChB,OAAO;IACT;IAEA,IAAI,CAACP,UAAUH,QAAQQ,MAAM,CAACG,IAAI,CAACC,MAAM,KAAK,KAAKZ,QAAQQ,MAAM,CAACG,IAAI,CAACE,OAAO,CAACV,UAAU,CAAC,GAAG;QAC3F,OAAOO;IACT;IAEA,OAAO;AACT,EAAC"}},
    {"offset": {"line": 14575, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 14581, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/payload/src/auth/strategies/jwt.ts"],"sourcesContent":["import { jwtVerify } from 'jose'\n\nimport type { Payload, Where } from '../../types/index.js'\nimport type { AuthStrategyFunction, User } from '../index.js'\n\nimport { extractJWT } from '../extractJWT.js'\n\ntype JWTToken = {\n  collection: string\n  id: string\n}\n\nasync function autoLogin({\n  isGraphQL,\n  payload,\n}: {\n  isGraphQL: boolean\n  payload: Payload\n}): Promise<{\n  user: null | User\n}> {\n  if (\n    typeof payload?.config?.admin?.autoLogin !== 'object' ||\n    payload.config.admin?.autoLogin.prefillOnly ||\n    !payload?.config?.admin?.autoLogin ||\n    (!payload.config.admin?.autoLogin.email && !payload.config.admin?.autoLogin.username)\n  ) {\n    return { user: null }\n  }\n\n  const collection = payload.collections[payload.config.admin.user]\n\n  const where: Where = {\n    or: [],\n  }\n  if (payload.config.admin?.autoLogin.email) {\n    where.or.push({\n      email: {\n        equals: payload.config.admin?.autoLogin.email,\n      },\n    })\n  } else if (payload.config.admin?.autoLogin.username) {\n    where.or.push({\n      username: {\n        equals: payload.config.admin?.autoLogin.username,\n      },\n    })\n  }\n\n  const user = (\n    await payload.find({\n      collection: collection.config.slug,\n      depth: isGraphQL ? 0 : collection.config.auth.depth,\n      where,\n    })\n  ).docs[0]\n\n  if (!user) {\n    return { user: null }\n  }\n  user.collection = collection.config.slug\n  user._strategy = 'local-jwt'\n\n  return {\n    user: user as User,\n  }\n}\n\nexport const JWTAuthentication: AuthStrategyFunction = async ({\n  headers,\n  isGraphQL = false,\n  payload,\n}) => {\n  try {\n    const token = extractJWT({ headers, payload })\n\n    if (!token) {\n      if (headers.get('DisableAutologin') !== 'true') {\n        return await autoLogin({ isGraphQL, payload })\n      }\n      return { user: null }\n    }\n\n    const secretKey = new TextEncoder().encode(payload.secret)\n    const { payload: decodedPayload } = await jwtVerify<JWTToken>(token, secretKey)\n    const collection = payload.collections[decodedPayload.collection]\n\n    const user = await payload.findByID({\n      id: decodedPayload.id,\n      collection: decodedPayload.collection,\n      depth: isGraphQL ? 0 : collection.config.auth.depth,\n    })\n\n    if (user && (!collection.config.auth.verify || user._verified)) {\n      user.collection = collection.config.slug\n      user._strategy = 'local-jwt'\n      return {\n        user: user as User,\n      }\n    } else {\n      if (headers.get('DisableAutologin') !== 'true') {\n        return await autoLogin({ isGraphQL, payload })\n      }\n      return { user: null }\n    }\n  } catch (error) {\n    if (headers.get('DisableAutologin') !== 'true') {\n      return await autoLogin({ isGraphQL, payload })\n    }\n    return { user: null }\n  }\n}\n"],"names":["jwtVerify","extractJWT","autoLogin","isGraphQL","payload","config","admin","prefillOnly","email","username","user","collection","collections","where","or","push","equals","find","slug","depth","auth","docs","_strategy","JWTAuthentication","headers","token","get","secretKey","TextEncoder","encode","secret","decodedPayload","findByID","id","verify","_verified","error"],"mappings":"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"}},
    {"offset": {"line": 14681, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 14687, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/payload/src/index.ts"],"sourcesContent":["import type { ExecutionResult, GraphQLSchema, ValidationRule } from 'graphql'\nimport type { Request as graphQLRequest, OperationArgs } from 'graphql-http'\nimport type { Logger } from 'pino'\n\nimport { spawn } from 'child_process'\nimport crypto from 'crypto'\nimport { fileURLToPath } from 'node:url'\nimport path from 'path'\n\nimport type { AuthArgs } from './auth/operations/auth.js'\nimport type { Result as ForgotPasswordResult } from './auth/operations/forgotPassword.js'\nimport type { Options as ForgotPasswordOptions } from './auth/operations/local/forgotPassword.js'\nimport type { Options as LoginOptions } from './auth/operations/local/login.js'\nimport type { Options as ResetPasswordOptions } from './auth/operations/local/resetPassword.js'\nimport type { Options as UnlockOptions } from './auth/operations/local/unlock.js'\nimport type { Options as VerifyEmailOptions } from './auth/operations/local/verifyEmail.js'\nimport type { Result as LoginResult } from './auth/operations/login.js'\nimport type { Result as ResetPasswordResult } from './auth/operations/resetPassword.js'\nimport type { AuthStrategy, User } from './auth/types.js'\nimport type { ImportMap } from './bin/generateImportMap/index.js'\nimport type {\n  BulkOperationResult,\n  Collection,\n  DataFromCollectionSlug,\n  TypeWithID,\n} from './collections/config/types.js'\nexport type * from './admin/types.js'\nimport type { Options as CountOptions } from './collections/operations/local/count.js'\nimport type { Options as CreateOptions } from './collections/operations/local/create.js'\nimport type {\n  ByIDOptions as DeleteByIDOptions,\n  ManyOptions as DeleteManyOptions,\n  Options as DeleteOptions,\n} from './collections/operations/local/delete.js'\nexport type { MappedView } from './admin/views/types.js'\nimport type { Options as DuplicateOptions } from './collections/operations/local/duplicate.js'\nimport type { Options as FindOptions } from './collections/operations/local/find.js'\nimport type { Options as FindByIDOptions } from './collections/operations/local/findByID.js'\nimport type { Options as FindVersionByIDOptions } from './collections/operations/local/findVersionByID.js'\nimport type { Options as FindVersionsOptions } from './collections/operations/local/findVersions.js'\nimport type { Options as RestoreVersionOptions } from './collections/operations/local/restoreVersion.js'\nimport type {\n  ByIDOptions as UpdateByIDOptions,\n  ManyOptions as UpdateManyOptions,\n  Options as UpdateOptions,\n} from './collections/operations/local/update.js'\nimport type { InitOptions, SanitizedConfig } from './config/types.js'\nimport type { BaseDatabaseAdapter, PaginatedDocs } from './database/types.js'\nimport type { InitializedEmailAdapter } from './email/types.js'\nimport type { DataFromGlobalSlug, Globals } from './globals/config/types.js'\nimport type { Options as FindGlobalOptions } from './globals/operations/local/findOne.js'\nimport type { Options as FindGlobalVersionByIDOptions } from './globals/operations/local/findVersionByID.js'\nimport type { Options as FindGlobalVersionsOptions } from './globals/operations/local/findVersions.js'\nimport type { Options as RestoreGlobalVersionOptions } from './globals/operations/local/restoreVersion.js'\nimport type { Options as UpdateGlobalOptions } from './globals/operations/local/update.js'\nimport type { JsonObject } from './types/index.js'\nimport type { TraverseFieldsCallback } from './utilities/traverseFields.js'\nimport type { TypeWithVersion } from './versions/types.js'\n\nimport { decrypt, encrypt } from './auth/crypto.js'\nimport { APIKeyAuthentication } from './auth/strategies/apiKey.js'\nimport { JWTAuthentication } from './auth/strategies/jwt.js'\nimport { checkPayloadDependencies } from './checkPayloadDependencies.js'\nimport localOperations from './collections/operations/local/index.js'\nimport { consoleEmailAdapter } from './email/consoleEmailAdapter.js'\nimport { fieldAffectsData } from './fields/config/types.js'\nimport localGlobalOperations from './globals/operations/local/index.js'\nimport { getLogger } from './utilities/logger.js'\nimport { serverInit as serverInitTelemetry } from './utilities/telemetry/events/serverInit.js'\nimport { traverseFields } from './utilities/traverseFields.js'\n\nexport interface GeneratedTypes {\n  authUntyped: {\n    [slug: string]: {\n      forgotPassword: {\n        email: string\n      }\n      login: {\n        email: string\n        password: string\n      }\n      registerFirstUser: {\n        email: string\n        password: string\n      }\n      unlock: {\n        email: string\n      }\n    }\n  }\n  collectionsUntyped: {\n    [slug: string]: JsonObject & TypeWithID\n  }\n  dbUntyped: {\n    defaultIDType: number | string\n  }\n  globalsUntyped: {\n    [slug: string]: JsonObject\n  }\n  localeUntyped: null | string\n  userUntyped: User\n}\n\n// Helper type to resolve the correct type using conditional types\ntype ResolveCollectionType<T> = 'collections' extends keyof T\n  ? T['collections']\n  : // @ts-expect-error\n    T['collectionsUntyped']\n// @ts-expect-error\ntype ResolveGlobalType<T> = 'globals' extends keyof T ? T['globals'] : T['globalsUntyped']\n\n// Applying helper types to GeneratedTypes\nexport type TypedCollection = ResolveCollectionType<GeneratedTypes>\nexport type TypedGlobal = ResolveGlobalType<GeneratedTypes>\n\n// Extract string keys from the type\ntype StringKeyOf<T> = Extract<keyof T, string>\n\n// Define the types for slugs using the appropriate collections and globals\nexport type CollectionSlug = StringKeyOf<TypedCollection>\n\ntype ResolveDbType<T> = 'db' extends keyof T\n  ? T['db']\n  : // @ts-expect-error\n    T['dbUntyped']\n\nexport type DefaultDocumentIDType = ResolveDbType<GeneratedTypes>['defaultIDType']\nexport type GlobalSlug = StringKeyOf<TypedGlobal>\n\n// now for locale and user\n\n// @ts-expect-error\ntype ResolveLocaleType<T> = 'locale' extends keyof T ? T['locale'] : T['localeUntyped']\n// @ts-expect-error\ntype ResolveUserType<T> = 'user' extends keyof T ? T['user'] : T['userUntyped']\n\nexport type TypedLocale = ResolveLocaleType<GeneratedTypes>\nexport type TypedUser = ResolveUserType<GeneratedTypes>\n\n// @ts-expect-error\ntype ResolveAuthOperationsType<T> = 'auth' extends keyof T ? T['auth'] : T['authUntyped']\nexport type TypedAuthOperations = ResolveAuthOperationsType<GeneratedTypes>\n\nconst filename = fileURLToPath(import.meta.url)\nconst dirname = path.dirname(filename)\n\nlet checkedDependencies = false\n\n/**\n * @description Payload\n */\nexport class BasePayload {\n  /**\n   * @description Authorization and Authentication using headers and cookies to run auth user strategies\n   * @returns permissions: Permissions\n   * @returns user: User\n   */\n  auth = async (options: AuthArgs) => {\n    const { auth } = localOperations.auth\n    return auth(this, options)\n  }\n\n  authStrategies: AuthStrategy[]\n\n  collections: {\n    [slug: string]: Collection\n  } = {}\n\n  config: SanitizedConfig\n  /**\n   * @description Performs count operation\n   * @param options\n   * @returns count of documents satisfying query\n   */\n  count = async <T extends CollectionSlug>(\n    options: CountOptions<T>,\n  ): Promise<{ totalDocs: number }> => {\n    const { count } = localOperations\n    return count(this, options)\n  }\n\n  /**\n   * @description Performs create operation\n   * @param options\n   * @returns created document\n   */\n  create = async <TSlug extends CollectionSlug>(\n    options: CreateOptions<TSlug>,\n  ): Promise<DataFromCollectionSlug<TSlug>> => {\n    const { create } = localOperations\n    return create<TSlug>(this, options)\n  }\n\n  db: DatabaseAdapter\n  decrypt = decrypt\n\n  duplicate = async <TSlug extends CollectionSlug>(\n    options: DuplicateOptions<TSlug>,\n  ): Promise<DataFromCollectionSlug<TSlug>> => {\n    const { duplicate } = localOperations\n    return duplicate<TSlug>(this, options)\n  }\n\n  email: InitializedEmailAdapter\n\n  encrypt = encrypt\n\n  // TODO: re-implement or remove?\n  // errorHandler: ErrorHandler\n\n  extensions: (args: {\n    args: OperationArgs<any>\n    req: graphQLRequest<unknown, unknown>\n    result: ExecutionResult\n  }) => Promise<any>\n\n  /**\n   * @description Find documents with criteria\n   * @param options\n   * @returns documents satisfying query\n   */\n  find = async <TSlug extends CollectionSlug>(\n    options: FindOptions<TSlug>,\n  ): Promise<PaginatedDocs<DataFromCollectionSlug<TSlug>>> => {\n    const { find } = localOperations\n    return find<TSlug>(this, options)\n  }\n\n  /**\n   * @description Find document by ID\n   * @param options\n   * @returns document with specified ID\n   */\n  findByID = async <TOptions extends FindByIDOptions>(\n    options: TOptions,\n  ): Promise<\n    TOptions['disableErrors'] extends true\n      ? DataFromCollectionSlug<TOptions['collection']> | null\n      : DataFromCollectionSlug<TOptions['collection']>\n  > => {\n    const { findByID } = localOperations\n    return findByID<TOptions>(this, options)\n  }\n\n  findGlobal = async <TSlug extends GlobalSlug>(\n    options: FindGlobalOptions<TSlug>,\n  ): Promise<DataFromGlobalSlug<TSlug>> => {\n    const { findOne } = localGlobalOperations\n    return findOne<TSlug>(this, options)\n  }\n\n  /**\n   * @description Find global version by ID\n   * @param options\n   * @returns global version with specified ID\n   */\n  findGlobalVersionByID = async <TSlug extends GlobalSlug>(\n    options: FindGlobalVersionByIDOptions<TSlug>,\n  ): Promise<TypeWithVersion<DataFromGlobalSlug<TSlug>>> => {\n    const { findVersionByID } = localGlobalOperations\n    return findVersionByID<TSlug>(this, options)\n  }\n\n  /**\n   * @description Find global versions with criteria\n   * @param options\n   * @returns versions satisfying query\n   */\n  findGlobalVersions = async <TSlug extends GlobalSlug>(\n    options: FindGlobalVersionsOptions<TSlug>,\n  ): Promise<PaginatedDocs<TypeWithVersion<DataFromGlobalSlug<TSlug>>>> => {\n    const { findVersions } = localGlobalOperations\n    return findVersions<TSlug>(this, options)\n  }\n\n  /**\n   * @description Find version by ID\n   * @param options\n   * @returns version with specified ID\n   */\n  findVersionByID = async <TSlug extends CollectionSlug>(\n    options: FindVersionByIDOptions<TSlug>,\n  ): Promise<TypeWithVersion<DataFromCollectionSlug<TSlug>>> => {\n    const { findVersionByID } = localOperations\n    return findVersionByID<TSlug>(this, options)\n  }\n\n  /**\n   * @description Find versions with criteria\n   * @param options\n   * @returns versions satisfying query\n   */\n  findVersions = async <TSlug extends CollectionSlug>(\n    options: FindVersionsOptions<TSlug>,\n  ): Promise<PaginatedDocs<TypeWithVersion<DataFromCollectionSlug<TSlug>>>> => {\n    const { findVersions } = localOperations\n    return findVersions<TSlug>(this, options)\n  }\n\n  forgotPassword = async <TSlug extends CollectionSlug>(\n    options: ForgotPasswordOptions<TSlug>,\n  ): Promise<ForgotPasswordResult> => {\n    const { forgotPassword } = localOperations.auth\n    return forgotPassword<TSlug>(this, options)\n  }\n\n  getAdminURL = (): string => `${this.config.serverURL}${this.config.routes.admin}`\n\n  getAPIURL = (): string => `${this.config.serverURL}${this.config.routes.api}`\n\n  globals: Globals\n\n  importMap: ImportMap\n\n  logger: Logger\n\n  login = async <TSlug extends CollectionSlug>(\n    options: LoginOptions<TSlug>,\n  ): Promise<{ user: DataFromCollectionSlug<TSlug> } & LoginResult> => {\n    const { login } = localOperations.auth\n    return login<TSlug>(this, options)\n  }\n\n  resetPassword = async <TSlug extends CollectionSlug>(\n    options: ResetPasswordOptions<TSlug>,\n  ): Promise<ResetPasswordResult> => {\n    const { resetPassword } = localOperations.auth\n    return resetPassword<TSlug>(this, options)\n  }\n\n  /**\n   * @description Restore global version by ID\n   * @param options\n   * @returns version with specified ID\n   */\n  restoreGlobalVersion = async <TSlug extends GlobalSlug>(\n    options: RestoreGlobalVersionOptions<TSlug>,\n  ): Promise<DataFromGlobalSlug<TSlug>> => {\n    const { restoreVersion } = localGlobalOperations\n    return restoreVersion<TSlug>(this, options)\n  }\n\n  /**\n   * @description Restore version by ID\n   * @param options\n   * @returns version with specified ID\n   */\n  restoreVersion = async <TSlug extends CollectionSlug>(\n    options: RestoreVersionOptions<TSlug>,\n  ): Promise<DataFromCollectionSlug<TSlug>> => {\n    const { restoreVersion } = localOperations\n    return restoreVersion<TSlug>(this, options)\n  }\n\n  schema: GraphQLSchema\n\n  secret: string\n\n  sendEmail: InitializedEmailAdapter['sendEmail']\n\n  types: {\n    arrayTypes: any\n    blockInputTypes: any\n    blockTypes: any\n    fallbackLocaleInputType?: any\n    groupTypes: any\n    localeInputType?: any\n    tabTypes: any\n  }\n\n  unlock = async <TSlug extends CollectionSlug>(\n    options: UnlockOptions<TSlug>,\n  ): Promise<boolean> => {\n    const { unlock } = localOperations.auth\n    return unlock<TSlug>(this, options)\n  }\n\n  updateGlobal = async <TSlug extends GlobalSlug>(\n    options: UpdateGlobalOptions<TSlug>,\n  ): Promise<DataFromGlobalSlug<TSlug>> => {\n    const { update } = localGlobalOperations\n    return update<TSlug>(this, options)\n  }\n\n  validationRules: (args: OperationArgs<any>) => ValidationRule[]\n\n  verifyEmail = async <TSlug extends CollectionSlug>(\n    options: VerifyEmailOptions<TSlug>,\n  ): Promise<boolean> => {\n    const { verifyEmail } = localOperations.auth\n    return verifyEmail(this, options)\n  }\n\n  versions: {\n    [slug: string]: any // TODO: Type this\n  } = {}\n\n  async bin({\n    args,\n    cwd,\n    log,\n  }: {\n    args: string[]\n    cwd?: string\n    log?: boolean\n  }): Promise<{ code: number }> {\n    return new Promise((resolve, reject) => {\n      const spawned = spawn('node', [path.resolve(dirname, '../bin.js'), ...args], {\n        cwd,\n        stdio: log || log === undefined ? 'inherit' : 'ignore',\n      })\n\n      spawned.on('exit', (code) => {\n        resolve({ code })\n      })\n\n      spawned.on('error', (error) => {\n        reject(error)\n      })\n    })\n  }\n\n  /**\n   * @description delete one or more documents\n   * @param options\n   * @returns Updated document(s)\n   */\n  delete<TSlug extends CollectionSlug>(\n    options: DeleteByIDOptions<TSlug>,\n  ): Promise<DataFromCollectionSlug<TSlug>>\n\n  delete<TSlug extends CollectionSlug>(\n    options: DeleteManyOptions<TSlug>,\n  ): Promise<BulkOperationResult<TSlug>>\n\n  delete<TSlug extends CollectionSlug>(\n    options: DeleteOptions<TSlug>,\n  ): Promise<BulkOperationResult<TSlug> | DataFromCollectionSlug<TSlug>> {\n    const { deleteLocal } = localOperations\n    return deleteLocal<TSlug>(this, options)\n  }\n\n  /**\n   * @description Initializes Payload\n   * @param options\n   */\n  async init(options: InitOptions): Promise<Payload> {\n    if (\n      process.env.NODE_ENV !== 'production' &&\n      process.env.PAYLOAD_DISABLE_DEPENDENCY_CHECKER !== 'true' &&\n      !checkedDependencies\n    ) {\n      checkedDependencies = true\n      await checkPayloadDependencies()\n    }\n\n    this.importMap = options.importMap\n\n    if (!options?.config) {\n      throw new Error('Error: the payload config is required to initialize payload.')\n    }\n\n    this.config = await options.config\n    this.logger = getLogger('payload', this.config.logger)\n\n    if (!this.config.secret) {\n      throw new Error('Error: missing secret key. A secret key is needed to secure Payload.')\n    }\n\n    this.secret = crypto.createHash('sha256').update(this.config.secret).digest('hex').slice(0, 32)\n\n    this.globals = {\n      config: this.config.globals,\n    }\n\n    this.config.collections.forEach((collection) => {\n      let customIDType = undefined\n      const findCustomID: TraverseFieldsCallback = ({ field, next }) => {\n        if (['array', 'blocks'].includes(field.type)) {\n          next()\n          return\n        }\n        if (!fieldAffectsData(field)) {\n          return\n        }\n        if (field.name === 'id') {\n          customIDType = field.type\n          return true\n        }\n      }\n\n      traverseFields({ callback: findCustomID, fields: collection.fields })\n\n      this.collections[collection.slug] = {\n        config: collection,\n        customIDType,\n      }\n    })\n\n    // Generate types on startup\n    if (process.env.NODE_ENV !== 'production' && this.config.typescript.autoGenerate !== false) {\n      // We cannot run it directly here, as generate-types imports json-schema-to-typescript, which breaks on turbopack.\n      // see: https://github.com/vercel/next.js/issues/66723\n      void this.bin({\n        args: ['generate:types'],\n        log: false,\n      })\n    }\n\n    this.db = this.config.db.init({ payload: this })\n    this.db.payload = this\n\n    if (this.db?.init) {\n      await this.db.init()\n    }\n\n    if (!options.disableDBConnect && this.db.connect) {\n      await this.db.connect()\n    }\n\n    // Load email adapter\n    if (this.config.email instanceof Promise) {\n      const awaitedAdapter = await this.config.email\n      this.email = awaitedAdapter({ payload: this })\n    } else if (this.config.email) {\n      this.email = this.config.email({ payload: this })\n    } else {\n      if (process.env.NEXT_PHASE !== 'phase-production-build') {\n        this.logger.warn(\n          `No email adapter provided. Email will be written to console. More info at https://payloadcms.com/docs/email/overview.`,\n        )\n      }\n\n      this.email = consoleEmailAdapter({ payload: this })\n    }\n\n    // Warn if image resizing is enabled but sharp is not installed\n    if (\n      !this.config.sharp &&\n      this.config.collections.some((c) => c.upload.imageSizes || c.upload.formatOptions)\n    ) {\n      this.logger.warn(\n        `Image resizing is enabled for one or more collections, but sharp not installed. Please install 'sharp' and pass into the config.`,\n      )\n    }\n\n    this.sendEmail = this.email['sendEmail']\n\n    serverInitTelemetry(this)\n\n    // 1. loop over collections, if collection has auth strategy, initialize and push to array\n    let jwtStrategyEnabled = false\n    this.authStrategies = this.config.collections.reduce((authStrategies, collection) => {\n      if (collection?.auth) {\n        if (collection.auth.strategies.length > 0) {\n          authStrategies.push(...collection.auth.strategies)\n        }\n\n        // 2. if api key enabled, push api key strategy into the array\n        if (collection.auth?.useAPIKey) {\n          authStrategies.push({\n            name: `${collection.slug}-api-key`,\n            authenticate: APIKeyAuthentication(collection),\n          })\n        }\n\n        // 3. if localStrategy flag is true\n        if (!collection.auth.disableLocalStrategy && !jwtStrategyEnabled) {\n          jwtStrategyEnabled = true\n        }\n      }\n\n      return authStrategies\n    }, [] as AuthStrategy[])\n\n    // 4. if enabled, push jwt strategy into authStrategies last\n    if (jwtStrategyEnabled) {\n      this.authStrategies.push({\n        name: 'local-jwt',\n        authenticate: JWTAuthentication,\n      })\n    }\n\n    if (!options.disableOnInit) {\n      if (typeof options.onInit === 'function') {\n        await options.onInit(this)\n      }\n      if (typeof this.config.onInit === 'function') {\n        await this.config.onInit(this)\n      }\n    }\n\n    return this\n  }\n\n  update<TSlug extends CollectionSlug>(\n    options: UpdateManyOptions<TSlug>,\n  ): Promise<BulkOperationResult<TSlug>>\n\n  /**\n   * @description Update one or more documents\n   * @param options\n   * @returns Updated document(s)\n   */\n  update<TSlug extends CollectionSlug>(\n    options: UpdateByIDOptions<TSlug>,\n  ): Promise<DataFromCollectionSlug<TSlug>>\n\n  update<TSlug extends CollectionSlug>(\n    options: UpdateOptions<TSlug>,\n  ): Promise<BulkOperationResult<TSlug> | DataFromCollectionSlug<TSlug>> {\n    const { update } = localOperations\n    return update<TSlug>(this, options)\n  }\n}\n\nconst initialized = new BasePayload()\n\nexport default initialized\n\nlet cached = global._payload\n\nif (!cached) {\n  cached = global._payload = { payload: null, promise: null }\n}\n\nexport const getPayload = async (options: InitOptions): Promise<BasePayload> => {\n  if (!options?.config) {\n    throw new Error('Error: the payload config is required for getPayload to work.')\n  }\n\n  if (cached.payload) {\n    return cached.payload\n  }\n\n  if (!cached.promise) {\n    cached.promise = new BasePayload().init(options)\n  }\n\n  try {\n    cached.payload = await cached.promise\n  } catch (e) {\n    cached.promise = null\n    throw e\n  }\n\n  return cached.payload\n}\n\ntype Payload = BasePayload\n\ninterface RequestContext {\n  [key: string]: unknown\n}\n\n// eslint-disable-next-line @typescript-eslint/no-empty-object-type\nexport interface DatabaseAdapter extends BaseDatabaseAdapter {}\nexport type { Payload, RequestContext }\nexport { default as executeAccess } from './auth/executeAccess.js'\nexport { executeAuthStrategies } from './auth/executeAuthStrategies.js'\nexport { getAccessResults } from './auth/getAccessResults.js'\nexport { getFieldsToSign } from './auth/getFieldsToSign.js'\nexport * from './auth/index.js'\nexport { accessOperation } from './auth/operations/access.js'\nexport { forgotPasswordOperation } from './auth/operations/forgotPassword.js'\nexport { initOperation } from './auth/operations/init.js'\nexport { loginOperation } from './auth/operations/login.js'\nexport { logoutOperation } from './auth/operations/logout.js'\nexport type { MeOperationResult } from './auth/operations/me.js'\nexport { meOperation } from './auth/operations/me.js'\nexport { refreshOperation } from './auth/operations/refresh.js'\nexport { registerFirstUserOperation } from './auth/operations/registerFirstUser.js'\nexport { resetPasswordOperation } from './auth/operations/resetPassword.js'\nexport { unlockOperation } from './auth/operations/unlock.js'\nexport { verifyEmailOperation } from './auth/operations/verifyEmail.js'\nexport type {\n  AuthStrategyFunction,\n  AuthStrategyFunctionArgs,\n  CollectionPermission,\n  DocumentPermissions,\n  FieldPermissions,\n  GlobalPermission,\n  IncomingAuthType,\n  Permission,\n  Permissions,\n  User,\n  VerifyConfig,\n} from './auth/types.js'\nexport { generateImportMap } from './bin/generateImportMap/index.js'\nexport type { ImportMap } from './bin/generateImportMap/index.js'\nexport { genImportMapIterateFields } from './bin/generateImportMap/iterateFields.js'\nexport type { ClientCollectionConfig } from './collections/config/client.js'\nexport type {\n  ServerOnlyCollectionAdminProperties,\n  ServerOnlyCollectionProperties,\n  ServerOnlyUploadProperties,\n} from './collections/config/client.js'\nexport type {\n  AfterChangeHook as CollectionAfterChangeHook,\n  AfterDeleteHook as CollectionAfterDeleteHook,\n  AfterErrorHook as CollectionAfterErrorHook,\n  AfterForgotPasswordHook as CollectionAfterForgotPasswordHook,\n  AfterLoginHook as CollectionAfterLoginHook,\n  AfterLogoutHook as CollectionAfterLogoutHook,\n  AfterMeHook as CollectionAfterMeHook,\n  AfterOperationHook as CollectionAfterOperationHook,\n  AfterReadHook as CollectionAfterReadHook,\n  AfterRefreshHook as CollectionAfterRefreshHook,\n  AuthCollection,\n  AuthOperationsFromCollectionSlug,\n  BeforeChangeHook as CollectionBeforeChangeHook,\n  BeforeDeleteHook as CollectionBeforeDeleteHook,\n  BeforeLoginHook as CollectionBeforeLoginHook,\n  BeforeOperationHook as CollectionBeforeOperationHook,\n  BeforeReadHook as CollectionBeforeReadHook,\n  BeforeValidateHook as CollectionBeforeValidateHook,\n  BulkOperationResult,\n  Collection,\n  CollectionAdminOptions,\n  CollectionConfig,\n  DataFromCollectionSlug,\n  HookOperationType,\n  MeHook as CollectionMeHook,\n  RefreshHook as CollectionRefreshHook,\n  RequiredDataFromCollection,\n  RequiredDataFromCollectionSlug,\n  SanitizedCollectionConfig,\n  SanitizedJoins,\n  TypeWithID,\n  TypeWithTimestamps,\n} from './collections/config/types.js'\nexport { createDataloaderCacheKey, getDataLoader } from './collections/dataloader.js'\nexport { countOperation } from './collections/operations/count.js'\nexport { createOperation } from './collections/operations/create.js'\nexport { deleteOperation } from './collections/operations/delete.js'\nexport { deleteByIDOperation } from './collections/operations/deleteByID.js'\nexport { docAccessOperation } from './collections/operations/docAccess.js'\nexport { duplicateOperation } from './collections/operations/duplicate.js'\nexport { findOperation } from './collections/operations/find.js'\nexport { findByIDOperation } from './collections/operations/findByID.js'\nexport { findVersionByIDOperation } from './collections/operations/findVersionByID.js'\nexport { findVersionsOperation } from './collections/operations/findVersions.js'\nexport { restoreVersionOperation } from './collections/operations/restoreVersion.js'\nexport { updateOperation } from './collections/operations/update.js'\nexport { updateByIDOperation } from './collections/operations/updateByID.js'\nexport { buildConfig } from './config/build.js'\nexport type { ClientConfig } from './config/client.js'\n\nexport { serverOnlyConfigProperties } from './config/client.js'\nexport { defaults } from './config/defaults.js'\nexport { sanitizeConfig } from './config/sanitize.js'\nexport type * from './config/types.js'\nexport { combineQueries } from './database/combineQueries.js'\nexport { createDatabaseAdapter } from './database/createDatabaseAdapter.js'\nexport { defaultBeginTransaction } from './database/defaultBeginTransaction.js'\nexport { default as flattenWhereToOperators } from './database/flattenWhereToOperators.js'\nexport { getLocalizedPaths } from './database/getLocalizedPaths.js'\nexport { createMigration } from './database/migrations/createMigration.js'\nexport { getMigrations } from './database/migrations/getMigrations.js'\nexport { getPredefinedMigration } from './database/migrations/getPredefinedMigration.js'\nexport { migrate } from './database/migrations/migrate.js'\nexport { migrateDown } from './database/migrations/migrateDown.js'\nexport { migrateRefresh } from './database/migrations/migrateRefresh.js'\nexport { migrateReset } from './database/migrations/migrateReset.js'\nexport { migrateStatus } from './database/migrations/migrateStatus.js'\nexport { migrationsCollection } from './database/migrations/migrationsCollection.js'\nexport { migrationTemplate } from './database/migrations/migrationTemplate.js'\nexport { readMigrationFiles } from './database/migrations/readMigrationFiles.js'\nexport { writeMigrationIndex } from './database/migrations/writeMigrationIndex.js'\nexport type * from './database/queryValidation/types.js'\nexport type { EntityPolicies, PathToQuery } from './database/queryValidation/types.js'\nexport { validateQueryPaths } from './database/queryValidation/validateQueryPaths.js'\nexport { validateSearchParam } from './database/queryValidation/validateSearchParams.js'\nexport type {\n  BaseDatabaseAdapter,\n  BeginTransaction,\n  CommitTransaction,\n  Connect,\n  Count,\n  CountArgs,\n  Create,\n  CreateArgs,\n  CreateGlobal,\n  CreateGlobalArgs,\n  CreateGlobalVersion,\n  CreateGlobalVersionArgs,\n  CreateMigration,\n  CreateVersion,\n  CreateVersionArgs,\n  DatabaseAdapterResult as DatabaseAdapterObj,\n  DBIdentifierName,\n  DeleteMany,\n  DeleteManyArgs,\n  DeleteOne,\n  DeleteOneArgs,\n  DeleteVersions,\n  DeleteVersionsArgs,\n  Destroy,\n  Find,\n  FindArgs,\n  FindGlobal,\n  FindGlobalArgs,\n  FindGlobalVersions,\n  FindGlobalVersionsArgs,\n  FindOne,\n  FindOneArgs,\n  FindVersions,\n  FindVersionsArgs,\n  Init,\n  Migration,\n  MigrationData,\n  MigrationTemplateArgs,\n  PaginatedDocs,\n  QueryDrafts,\n  QueryDraftsArgs,\n  RollbackTransaction,\n  Transaction,\n  UpdateGlobal,\n  UpdateGlobalArgs,\n  UpdateGlobalVersion,\n  UpdateGlobalVersionArgs,\n  UpdateOne,\n  UpdateOneArgs,\n  UpdateVersion,\n  UpdateVersionArgs,\n  Upsert,\n} from './database/types.js'\nexport type { EmailAdapter as PayloadEmailAdapter, SendEmailOptions } from './email/types.js'\nexport {\n  APIError,\n  APIErrorName,\n  AuthenticationError,\n  DuplicateCollection,\n  DuplicateFieldName,\n  DuplicateGlobal,\n  ErrorDeletingFile,\n  FileRetrievalError,\n  FileUploadError,\n  Forbidden,\n  InvalidConfiguration,\n  InvalidFieldName,\n  InvalidFieldRelationship,\n  Locked,\n  LockedAuth,\n  MissingCollectionLabel,\n  MissingEditorProp,\n  MissingFieldInputOptions,\n  MissingFieldType,\n  MissingFile,\n  NotFound,\n  QueryError,\n  ValidationError,\n  ValidationErrorName,\n} from './errors/index.js'\nexport { baseBlockFields } from './fields/baseFields/baseBlockFields.js'\nexport { baseIDField } from './fields/baseFields/baseIDField.js'\nexport type { ServerOnlyFieldProperties } from './fields/config/client.js'\nexport type { ServerOnlyFieldAdminProperties } from './fields/config/client.js'\nexport { sanitizeFields } from './fields/config/sanitize.js'\nexport type {\n  AdminClient,\n  ArrayField,\n  ArrayFieldClient,\n  BaseValidateOptions,\n  Block,\n  BlocksField,\n  BlocksFieldClient,\n  CheckboxField,\n  CheckboxFieldClient,\n  ClientBlock,\n  ClientField,\n  CodeField,\n  CodeFieldClient,\n  CollapsibleField,\n  CollapsibleFieldClient,\n  Condition,\n  DateField,\n  DateFieldClient,\n  EmailField,\n  EmailFieldClient,\n  Field,\n  FieldAccess,\n  FieldAffectingData,\n  FieldAffectingDataClient,\n  FieldBase,\n  FieldBaseClient,\n  FieldHook,\n  FieldHookArgs,\n  FieldPresentationalOnly,\n  FieldPresentationalOnlyClient,\n  FieldTypes,\n  FieldWithMany,\n  FieldWithManyClient,\n  FieldWithMaxDepth,\n  FieldWithMaxDepthClient,\n  FieldWithPath,\n  FieldWithPathClient,\n  FieldWithSubFields,\n  FieldWithSubFieldsClient,\n  FilterOptions,\n  FilterOptionsProps,\n  GroupField,\n  GroupFieldClient,\n  HookName,\n  JoinField,\n  JoinFieldClient,\n  JSONField,\n  JSONFieldClient,\n  Labels,\n  LabelsClient,\n  NamedTab,\n  NonPresentationalField,\n  NonPresentationalFieldClient,\n  NumberField,\n  NumberFieldClient,\n  Option,\n  OptionObject,\n  PointField,\n  PointFieldClient,\n  PolymorphicRelationshipField,\n  PolymorphicRelationshipFieldClient,\n  RadioField,\n  RadioFieldClient,\n  RelationshipField,\n  RelationshipFieldClient,\n  RelationshipValue,\n  RichTextField,\n  RichTextFieldClient,\n  RowField,\n  RowFieldClient,\n  SelectField,\n  SelectFieldClient,\n  SingleRelationshipField,\n  SingleRelationshipFieldClient,\n  Tab,\n  TabAsField,\n  TabAsFieldClient,\n  TabsField,\n  TabsFieldClient,\n  TextareaField,\n  TextareaFieldClient,\n  TextField,\n  TextFieldClient,\n  UIField,\n  UIFieldClient,\n  UnnamedTab,\n  UploadField,\n  UploadFieldClient,\n  Validate,\n  ValidateOptions,\n  ValueWithRelation,\n} from './fields/config/types.js'\n\nexport { getDefaultValue } from './fields/getDefaultValue.js'\nexport { traverseFields as afterChangeTraverseFields } from './fields/hooks/afterChange/traverseFields.js'\nexport { promise as afterReadPromise } from './fields/hooks/afterRead/promise.js'\nexport { traverseFields as afterReadTraverseFields } from './fields/hooks/afterRead/traverseFields.js'\nexport { traverseFields as beforeChangeTraverseFields } from './fields/hooks/beforeChange/traverseFields.js'\nexport { traverseFields as beforeValidateTraverseFields } from './fields/hooks/beforeValidate/traverseFields.js'\nexport { default as sortableFieldTypes } from './fields/sortableFieldTypes.js'\nexport type {\n  ArrayFieldValidation,\n  BlocksFieldValidation,\n  CheckboxFieldValidation,\n  CodeFieldValidation,\n  ConfirmPasswordFieldValidation,\n  DateFieldValidation,\n  EmailFieldValidation,\n  JSONFieldValidation,\n  NumberFieldManyValidation,\n  NumberFieldSingleValidation,\n  NumberFieldValidation,\n  PasswordFieldValidation,\n  PointFieldValidation,\n  RadioFieldValidation,\n  RelationshipFieldManyValidation,\n  RelationshipFieldSingleValidation,\n  RelationshipFieldValidation,\n  RichTextFieldValidation,\n  SelectFieldManyValidation,\n  SelectFieldSingleValidation,\n  SelectFieldValidation,\n  TextareaFieldValidation,\n  TextFieldManyValidation,\n  TextFieldSingleValidation,\n  TextFieldValidation,\n  UploadFieldManyValidation,\n  UploadFieldSingleValidation,\n  UploadFieldValidation,\n  UsernameFieldValidation,\n} from './fields/validations.js'\nexport type { ClientGlobalConfig } from './globals/config/client.js'\nexport type {\n  ServerOnlyGlobalAdminProperties,\n  ServerOnlyGlobalProperties,\n} from './globals/config/client.js'\nexport type {\n  AfterChangeHook as GlobalAfterChangeHook,\n  AfterReadHook as GlobalAfterReadHook,\n  BeforeChangeHook as GlobalBeforeChangeHook,\n  BeforeReadHook as GlobalBeforeReadHook,\n  BeforeValidateHook as GlobalBeforeValidateHook,\n  DataFromGlobalSlug,\n  GlobalAdminOptions,\n  GlobalConfig,\n  SanitizedGlobalConfig,\n} from './globals/config/types.js'\nexport { docAccessOperation as docAccessOperationGlobal } from './globals/operations/docAccess.js'\nexport { findOneOperation } from './globals/operations/findOne.js'\nexport { findVersionByIDOperation as findVersionByIDOperationGlobal } from './globals/operations/findVersionByID.js'\nexport { findVersionsOperation as findVersionsOperationGlobal } from './globals/operations/findVersions.js'\nexport { restoreVersionOperation as restoreVersionOperationGlobal } from './globals/operations/restoreVersion.js'\nexport { updateOperation as updateOperationGlobal } from './globals/operations/update.js'\nexport type {\n  CollapsedPreferences,\n  DocumentPreferences,\n  FieldsPreferences,\n  InsideFieldsPreferences,\n  PreferenceRequest,\n  PreferenceUpdateRequest,\n  TabsPreferences,\n} from './preferences/types.js'\nexport { getLocalI18n } from './translations/getLocalI18n.js'\nexport * from './types/index.js'\nexport { getFileByPath } from './uploads/getFileByPath.js'\nexport type * from './uploads/types.js'\nexport { commitTransaction } from './utilities/commitTransaction.js'\nexport {\n  configToJSONSchema,\n  entityToJSONSchema,\n  fieldsToJSONSchema,\n  withNullableJSONSchemaType,\n} from './utilities/configToJSONSchema.js'\nexport { createArrayFromCommaDelineated } from './utilities/createArrayFromCommaDelineated.js'\nexport { createLocalReq } from './utilities/createLocalReq.js'\nexport {\n  deepCopyObject,\n  deepCopyObjectComplex,\n  deepCopyObjectSimple,\n} from './utilities/deepCopyObject.js'\nexport {\n  deepMerge,\n  deepMergeWithCombinedArrays,\n  deepMergeWithReactComponents,\n  deepMergeWithSourceArrays,\n} from './utilities/deepMerge.js'\nexport {\n  checkDependencies,\n  type CustomVersionParser,\n} from './utilities/dependencies/dependencyChecker.js'\nexport { getDependencies } from './utilities/dependencies/getDependencies.js'\nexport {\n  findUp,\n  findUpSync,\n  pathExistsAndIsAccessible,\n  pathExistsAndIsAccessibleSync,\n} from './utilities/findUp.js'\nexport { default as flattenTopLevelFields } from './utilities/flattenTopLevelFields.js'\nexport { formatLabels, formatNames, toWords } from './utilities/formatLabels.js'\nexport { getCollectionIDFieldTypes } from './utilities/getCollectionIDFieldTypes.js'\nexport { getObjectDotNotation } from './utilities/getObjectDotNotation.js'\nexport { initTransaction } from './utilities/initTransaction.js'\nexport { isEntityHidden } from './utilities/isEntityHidden.js'\nexport { default as isolateObjectProperty } from './utilities/isolateObjectProperty.js'\nexport { isPlainObject } from './utilities/isPlainObject.js'\nexport { isValidID } from './utilities/isValidID.js'\nexport { killTransaction } from './utilities/killTransaction.js'\nexport { mapAsync } from './utilities/mapAsync.js'\nexport { mergeListSearchAndWhere } from './utilities/mergeListSearchAndWhere.js'\nexport { traverseFields } from './utilities/traverseFields.js'\nexport type { TraverseFieldsCallback } from './utilities/traverseFields.js'\nexport { buildVersionCollectionFields } from './versions/buildCollectionFields.js'\nexport { buildVersionGlobalFields } from './versions/buildGlobalFields.js'\nexport { versionDefaults } from './versions/defaults.js'\nexport { deleteCollectionVersions } from './versions/deleteCollectionVersions.js'\nexport { enforceMaxVersions } from './versions/enforceMaxVersions.js'\nexport { getLatestCollectionVersion } from './versions/getLatestCollectionVersion.js'\nexport { getLatestGlobalVersion } from './versions/getLatestGlobalVersion.js'\nexport { saveVersion } from './versions/saveVersion.js'\n\nexport type { TypeWithVersion } from './versions/types.js'\nexport { deepMergeSimple } from '@payloadcms/translations/utilities'\n"],"names":["spawn","crypto","fileURLToPath","path","decrypt","encrypt","APIKeyAuthentication","JWTAuthentication","checkPayloadDependencies","localOperations","consoleEmailAdapter","fieldAffectsData","localGlobalOperations","getLogger","serverInit","serverInitTelemetry","traverseFields","filename","url","dirname","checkedDependencies","BasePayload","auth","options","authStrategies","collections","config","count","create","db","duplicate","email","extensions","find","findByID","findGlobal","findOne","findGlobalVersionByID","findVersionByID","findGlobalVersions","findVersions","forgotPassword","getAdminURL","serverURL","routes","admin","getAPIURL","api","globals","importMap","logger","login","resetPassword","restoreGlobalVersion","restoreVersion","schema","secret","sendEmail","types","unlock","updateGlobal","update","validationRules","verifyEmail","versions","bin","args","cwd","log","Promise","resolve","reject","spawned","stdio","undefined","on","code","error","delete","deleteLocal","init","process","env","NODE_ENV","PAYLOAD_DISABLE_DEPENDENCY_CHECKER","Error","createHash","digest","slice","forEach","collection","customIDType","findCustomID","field","next","includes","type","name","callback","fields","slug","typescript","autoGenerate","payload","disableDBConnect","connect","awaitedAdapter","NEXT_PHASE","warn","sharp","some","c","upload","imageSizes","formatOptions","jwtStrategyEnabled","reduce","strategies","length","push","useAPIKey","authenticate","disableLocalStrategy","disableOnInit","onInit","initialized","cached","global","_payload","promise","getPayload","e","default","executeAccess","executeAuthStrategies","getAccessResults","getFieldsToSign","accessOperation","forgotPasswordOperation","initOperation","loginOperation","logoutOperation","meOperation","refreshOperation","registerFirstUserOperation","resetPasswordOperation","unlockOperation","verifyEmailOperation","generateImportMap","genImportMapIterateFields","createDataloaderCacheKey","getDataLoader","countOperation","createOperation","deleteOperation","deleteByIDOperation","docAccessOperation","duplicateOperation","findOperation","findByIDOperation","findVersionByIDOperation","findVersionsOperation","restoreVersionOperation","updateOperation","updateByIDOperation","buildConfig","serverOnlyConfigProperties","defaults","sanitizeConfig","combineQueries","createDatabaseAdapter","defaultBeginTransaction","flattenWhereToOperators","getLocalizedPaths","createMigration","getMigrations","getPredefinedMigration","migrate","migrateDown","migrateRefresh","migrateReset","migrateStatus","migrationsCollection","migrationTemplate","readMigrationFiles","writeMigrationIndex","validateQueryPaths","validateSearchParam","APIError","APIErrorName","AuthenticationError","DuplicateCollection","DuplicateFieldName","DuplicateGlobal","ErrorDeletingFile","FileRetrievalError","FileUploadError","Forbidden","InvalidConfiguration","InvalidFieldName","InvalidFieldRelationship","Locked","LockedAuth","MissingCollectionLabel","MissingEditorProp","MissingFieldInputOptions","MissingFieldType","MissingFile","NotFound","QueryError","ValidationError","ValidationErrorName","baseBlockFields","baseIDField","sanitizeFields","getDefaultValue","afterChangeTraverseFields","afterReadPromise","afterReadTraverseFields","beforeChangeTraverseFields","beforeValidateTraverseFields","sortableFieldTypes","docAccessOperationGlobal","findOneOperation","findVersionByIDOperationGlobal","findVersionsOperationGlobal","restoreVersionOperationGlobal","updateOperationGlobal","getLocalI18n","getFileByPath","commitTransaction","configToJSONSchema","entityToJSONSchema","fieldsToJSONSchema","withNullableJSONSchemaType","createArrayFromCommaDelineated","createLocalReq","deepCopyObject","deepCopyObjectComplex","deepCopyObjectSimple","deepMerge","deepMergeWithCombinedArrays","deepMergeWithReactComponents","deepMergeWithSourceArrays","checkDependencies","getDependencies","findUp","findUpSync","pathExistsAndIsAccessible","pathExistsAndIsAccessibleSync","flattenTopLevelFields","formatLabels","formatNames","toWords","getCollectionIDFieldTypes","getObjectDotNotation","initTransaction","isEntityHidden","isolateObjectProperty","isPlainObject","isValidID","killTransaction","mapAsync","mergeListSearchAndWhere","buildVersionCollectionFields","buildVersionGlobalFields","versionDefaults","deleteCollectionVersions","enforceMaxVersions","getLatestCollectionVersion","getLatestGlobalVersion","saveVersion","deepMergeSimple"],"mappings":"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"}},
    {"offset": {"line": 15165, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 15171, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/payload/src/auth/cookies.ts"],"sourcesContent":["import type { SanitizedCollectionConfig } from './../collections/config/types.js'\n\ntype CookieOptions = {\n  domain?: string\n  expires?: Date\n  httpOnly?: boolean\n  maxAge?: number\n  name: string\n  path?: string\n  returnCookieAsObject: boolean\n  sameSite?: 'Lax' | 'None' | 'Strict'\n  secure?: boolean\n  value?: string\n}\n\ntype CookieObject = {\n  domain?: string\n  expires?: string\n  httpOnly?: boolean\n  maxAge?: number\n  name: string\n  path?: string\n  sameSite?: 'Lax' | 'None' | 'Strict'\n  secure?: boolean\n  value: string\n}\n\nexport const generateCookie = <ReturnCookieAsObject = boolean>(\n  args: CookieOptions,\n): ReturnCookieAsObject extends true ? CookieObject : string => {\n  const {\n    name,\n    domain,\n    expires,\n    httpOnly,\n    maxAge,\n    path,\n    returnCookieAsObject,\n    sameSite,\n    secure: secureArg,\n    value,\n  } = args\n\n  let cookieString = `${name}=${value || ''}`\n  const cookieObject: CookieObject = {\n    name,\n    value,\n  }\n\n  const secure = secureArg || sameSite === 'None'\n\n  if (expires) {\n    if (returnCookieAsObject) {\n      cookieObject.expires = expires.toUTCString()\n    } else {\n      cookieString += `; Expires=${expires.toUTCString()}`\n    }\n  }\n\n  if (maxAge) {\n    if (returnCookieAsObject) {\n      cookieObject.maxAge = maxAge\n    } else {\n      cookieString += `; Max-Age=${maxAge.toString()}`\n    }\n  }\n\n  if (domain) {\n    if (returnCookieAsObject) {\n      cookieObject.domain = domain\n    } else {\n      cookieString += `; Domain=${domain}`\n    }\n  }\n\n  if (path) {\n    if (returnCookieAsObject) {\n      cookieObject.path = path\n    } else {\n      cookieString += `; Path=${path}`\n    }\n  }\n\n  if (secure) {\n    if (returnCookieAsObject) {\n      cookieObject.secure = secure\n    } else {\n      cookieString += `; Secure=${secure}`\n    }\n  }\n\n  if (httpOnly) {\n    if (returnCookieAsObject) {\n      cookieObject.httpOnly = httpOnly\n    } else {\n      cookieString += `; HttpOnly=${httpOnly}`\n    }\n  }\n\n  if (sameSite) {\n    if (returnCookieAsObject) {\n      cookieObject.sameSite = sameSite\n    } else {\n      cookieString += `; SameSite=${sameSite}`\n    }\n  }\n\n  return (returnCookieAsObject ? cookieObject : cookieString) as ReturnCookieAsObject extends true\n    ? CookieObject\n    : string\n}\ntype GetCookieExpirationArgs = {\n  /*\n    The number of seconds until the cookie expires\n    @default 7200 seconds (2 hours)\n  */\n  seconds: number\n}\nexport const getCookieExpiration = ({ seconds = 7200 }: GetCookieExpirationArgs) => {\n  const currentTime = new Date()\n  currentTime.setSeconds(currentTime.getSeconds() + seconds)\n  return currentTime\n}\n\ntype GeneratePayloadCookieArgs = {\n  /* The auth collection config */\n  collectionAuthConfig: SanitizedCollectionConfig['auth']\n  /* Prefix to scope the cookie */\n  cookiePrefix: string\n  /* The returnAs value */\n  returnCookieAsObject?: boolean\n  /* The token to be stored in the cookie */\n  token: string\n}\nexport const generatePayloadCookie = <T extends GeneratePayloadCookieArgs>({\n  collectionAuthConfig,\n  cookiePrefix,\n  returnCookieAsObject = false,\n  token,\n}: T): T['returnCookieAsObject'] extends true ? CookieObject : string => {\n  const sameSite =\n    typeof collectionAuthConfig.cookies.sameSite === 'string'\n      ? collectionAuthConfig.cookies.sameSite\n      : collectionAuthConfig.cookies.sameSite\n        ? 'Strict'\n        : undefined\n\n  return generateCookie<T['returnCookieAsObject']>({\n    name: `${cookiePrefix}-token`,\n    domain: collectionAuthConfig.cookies.domain ?? undefined,\n    expires: getCookieExpiration({ seconds: collectionAuthConfig.tokenExpiration }),\n    httpOnly: true,\n    path: '/',\n    returnCookieAsObject,\n    sameSite,\n    secure: collectionAuthConfig.cookies.secure,\n    value: token,\n  })\n}\n\nexport const generateExpiredPayloadCookie = <T extends Omit<GeneratePayloadCookieArgs, 'token'>>({\n  collectionAuthConfig,\n  cookiePrefix,\n  returnCookieAsObject = false,\n}: T): T['returnCookieAsObject'] extends true ? CookieObject : string => {\n  const sameSite =\n    typeof collectionAuthConfig.cookies.sameSite === 'string'\n      ? collectionAuthConfig.cookies.sameSite\n      : collectionAuthConfig.cookies.sameSite\n        ? 'Strict'\n        : undefined\n\n  const expires = new Date(Date.now() - 1000)\n\n  return generateCookie<T['returnCookieAsObject']>({\n    name: `${cookiePrefix}-token`,\n    domain: collectionAuthConfig.cookies.domain ?? undefined,\n    expires,\n    httpOnly: true,\n    path: '/',\n    returnCookieAsObject,\n    sameSite,\n    secure: collectionAuthConfig.cookies.secure,\n  })\n}\n\nexport const parseCookies = (headers: Request['headers']): Map<string, string> => {\n  const cookieMap = new Map<string, string>()\n  const cookie = headers.get('Cookie')\n\n  if (cookie) {\n    cookie.split(';').forEach((cookie) => {\n      const parts = cookie.split('=')\n      const key = parts.shift().trim()\n      const encodedValue = parts.join('=')\n\n      try {\n        const decodedValue = decodeURI(encodedValue)\n        cookieMap.set(key, decodedValue)\n      } catch (e) {\n        return null\n      }\n    })\n  }\n\n  return cookieMap\n}\n"],"names":["generateCookie","args","name","domain","expires","httpOnly","maxAge","path","returnCookieAsObject","sameSite","secure","secureArg","value","cookieString","cookieObject","toUTCString","toString","getCookieExpiration","seconds","currentTime","Date","setSeconds","getSeconds","generatePayloadCookie","collectionAuthConfig","cookiePrefix","token","cookies","undefined","tokenExpiration","generateExpiredPayloadCookie","now","parseCookies","headers","cookieMap","Map","cookie","get","split","forEach","parts","key","shift","trim","encodedValue","join","decodedValue","decodeURI","set","e"],"mappings":"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"}},
    {"offset": {"line": 15290, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 15306, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/payload/src/utilities/createArrayFromCommaDelineated.ts"],"sourcesContent":["export function createArrayFromCommaDelineated(input: string): string[] {\n  if (Array.isArray(input)) {\n    return input\n  }\n  if (input.indexOf(',') > -1) {\n    return input.split(',')\n  }\n  return [input]\n}\n"],"names":["createArrayFromCommaDelineated","input","Array","isArray","indexOf","split"],"mappings":";;;AAAO,SAASA,+BAA+BC,KAAa;IAC1D,IAAIC,MAAMC,OAAO,CAACF,QAAQ;QACxB,OAAOA;IACT;IACA,IAAIA,MAAMG,OAAO,CAAC,OAAO,CAAC,GAAG;QAC3B,OAAOH,MAAMI,KAAK,CAAC;IACrB;IACA,OAAO;QAACJ;KAAM;AAChB"}},
    {"offset": {"line": 15320, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 15326, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/payload/src/database/migrations/readMigrationFiles.ts"],"sourcesContent":["import fs from 'fs'\nimport { pathToFileURL } from 'node:url'\nimport path from 'path'\n\nimport type { Payload } from '../../index.js'\nimport type { Migration } from '../types.js'\n\n/**\n * Read the migration files from disk\n */\nexport const readMigrationFiles = async ({\n  payload,\n}: {\n  payload: Payload\n}): Promise<Migration[]> => {\n  if (!fs.existsSync(payload.db.migrationDir)) {\n    payload.logger.error({\n      msg: `No migration directory found at ${payload.db.migrationDir}`,\n    })\n    return []\n  }\n\n  payload.logger.info({\n    msg: `Reading migration files from ${payload.db.migrationDir}`,\n  })\n\n  const files = fs\n    .readdirSync(payload.db.migrationDir)\n    .sort()\n    .filter((f) => {\n      return (f.endsWith('.ts') || f.endsWith('.js')) && !f.includes('index.')\n    })\n    .map((file) => {\n      return path.resolve(payload.db.migrationDir, file)\n    })\n\n  return Promise.all(\n    files.map(async (filePath) => {\n      // eval used to circumvent errors bundling\n      let migration =\n        typeof require === 'function'\n          ? await eval(`require('${filePath.replaceAll('\\\\', '/')}')`)\n          : await eval(`import('${pathToFileURL(filePath).href}')`)\n      if ('default' in migration) {\n        migration = migration.default\n      }\n\n      const result: Migration = {\n        name: path.basename(filePath).split('.')?.[0],\n        down: migration.down,\n        up: migration.up,\n      }\n\n      return result\n    }),\n  )\n}\n"],"names":["fs","pathToFileURL","path","readMigrationFiles","payload","existsSync","db","migrationDir","logger","error","msg","info","files","readdirSync","sort","filter","f","endsWith","includes","map","file","resolve","Promise","all","filePath","migration","require","eval","replaceAll","href","default","result","name","basename","split","down","up"],"mappings":";;;AAAA,OAAOA,QAAQ,KAAI;AACnB,SAASC,aAAa,QAAQ,WAAU;AACxC,OAAOC,UAAU,OAAM;;;;AAQhB,MAAMC,qBAAqB,OAAO,EACvCC,OAAO,EAGR;IACC,IAAI,6FAACJ,UAAAA,CAAGK,UAAU,CAACD,QAAQE,EAAE,CAACC,YAAY,GAAG;QAC3CH,QAAQI,MAAM,CAACC,KAAK,CAAC;YACnBC,KAAK,CAAC,gCAAgC,EAAEN,QAAQE,EAAE,CAACC,YAAY,CAAC,CAAC;QACnE;QACA,OAAO,EAAE;IACX;IAEAH,QAAQI,MAAM,CAACG,IAAI,CAAC;QAClBD,KAAK,CAAC,6BAA6B,EAAEN,QAAQE,EAAE,CAACC,YAAY,CAAC,CAAC;IAChE;IAEA,MAAMK,oGAAQZ,UAAAA,CACXa,WAAW,CAACT,QAAQE,EAAE,CAACC,YAAY,EACnCO,IAAI,GACJC,MAAM,CAAC,CAACC;QACP,OAAQA,CAAAA,EAAEC,QAAQ,CAAC,UAAUD,EAAEC,QAAQ,CAAC,MAAK,KAAM,CAACD,EAAEE,QAAQ,CAAC;IACjE,GACCC,GAAG,CAAC,CAACC;QACJ,qGAAOlB,UAAAA,CAAKmB,OAAO,CAACjB,QAAQE,EAAE,CAACC,YAAY,EAAEa;IAC/C;IAEF,OAAOE,QAAQC,GAAG,CAChBX,MAAMO,GAAG,CAAC,OAAOK;QACf,0CAA0C;QAC1C,IAAIC,YACF,OAAOC,YAAY,oBACf,MAAMC,KAAK,CAAC,SAAS,EAAEH,SAASI,UAAU,CAAC,MAAM,KAAK,EAAE,CAAC,IACzD,MAAMD,KAAK,CAAC,QAAQ,EAAE1B,cAAcuB,UAAUK,IAAI,CAAC,EAAE,CAAC;QAC5D,IAAI,aAAaJ,WAAW;YAC1BA,YAAYA,UAAUK,OAAO;QAC/B;QAEA,MAAMC,SAAoB;YACxBC,oGAAM9B,UAAAA,CAAK+B,QAAQ,CAACT,UAAUU,KAAK,CAAC,MAAM,CAAC,EAAE;YAC7CC,MAAMV,UAAUU,IAAI;YACpBC,IAAIX,UAAUW,EAAE;QAClB;QAEA,OAAOL;IACT;AAEJ,EAAC"}},
    {"offset": {"line": 15364, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 15370, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/payload/src/database/migrations/getMigrations.ts"],"sourcesContent":["import type { Payload } from '../../index.js'\nimport type { MigrationData } from '../types.js'\n\n/**\n * Gets all existing migrations from the database, excluding the dev migration\n */\nexport async function getMigrations({\n  payload,\n}: {\n  payload: Payload\n}): Promise<{ existingMigrations: MigrationData[]; latestBatch: number }> {\n  const migrationQuery = await payload.find({\n    collection: 'payload-migrations',\n    limit: 0,\n    sort: '-name',\n    where: {\n      batch: {\n        not_equals: -1,\n      },\n    },\n  })\n\n  const existingMigrations = migrationQuery.docs as unknown as MigrationData[]\n\n  // Get the highest batch number from existing migrations\n  const latestBatch = Number(existingMigrations?.[0]?.batch) || 0\n\n  return {\n    existingMigrations,\n    latestBatch,\n  }\n}\n"],"names":["getMigrations","payload","migrationQuery","find","collection","limit","sort","where","batch","not_equals","existingMigrations","docs","latestBatch","Number"],"mappings":"AAGA;;CAEC,GACD;;;AAAO,eAAeA,cAAc,EAClCC,OAAO,EAGR;IACC,MAAMC,iBAAiB,MAAMD,QAAQE,IAAI,CAAC;QACxCC,YAAY;QACZC,OAAO;QACPC,MAAM;QACNC,OAAO;YACLC,OAAO;gBACLC,YAAY,CAAC;YACf;QACF;IACF;IAEA,MAAMC,qBAAqBR,eAAeS,IAAI;IAE9C,wDAAwD;IACxD,MAAMC,cAAcC,OAAOH,oBAAoB,CAAC,EAAE,EAAEF,UAAU;IAE9D,OAAO;QACLE;QACAE;IACF;AACF"}},
    {"offset": {"line": 15394, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 15400, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/payload/src/errors/InvalidConfiguration.ts"],"sourcesContent":["import httpStatus from 'http-status'\n\nimport { APIError } from './APIError.js'\n\nexport class InvalidConfiguration extends APIError {\n  constructor(message: string) {\n    super(message, httpStatus.INTERNAL_SERVER_ERROR)\n  }\n}\n"],"names":["httpStatus","APIError","InvalidConfiguration","constructor","message","INTERNAL_SERVER_ERROR"],"mappings":";;;AAAA,OAAOA,gBAAgB,cAAa;AAEpC,SAASC,QAAQ,QAAQ,gBAAe;;;AAEjC,MAAMC,mLAA6BD,WAAAA;IACxCE,YAAYC,OAAe,CAAE;QAC3B,KAAK,CAACA,wJAASJ,UAAAA,CAAWK,qBAAqB;IACjD;AACF"}},
    {"offset": {"line": 15412, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 15418, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/payload/src/database/migrations/getPredefinedMigration.ts"],"sourcesContent":["import fs from 'fs'\nimport path from 'path'\nimport { pathToFileURL } from 'url'\n\nimport type { Payload } from '../../index.js'\nimport type { MigrationTemplateArgs } from '../types.js'\n\n/**\n * Get predefined migration 'up', 'down' and 'imports'\n */\nexport const getPredefinedMigration = async ({\n  dirname,\n  file,\n  migrationName: migrationNameArg,\n  payload,\n}: {\n  dirname: string\n  file?: string\n  migrationName?: string\n  payload: Payload\n}): Promise<MigrationTemplateArgs> => {\n  // Check for predefined migration.\n  // Either passed in via --file or prefixed with '@payloadcms/db-mongodb/' for example\n  if (file || migrationNameArg?.startsWith('@payloadcms/')) {\n    // removes the package name from the migrationName.\n    const migrationName = (file || migrationNameArg).split('/').slice(2).join('/')\n    let cleanPath = path.join(dirname, `./predefinedMigrations/${migrationName}.mjs`)\n\n    // Check if predefined migration exists\n    if (fs.existsSync(cleanPath)) {\n      cleanPath = cleanPath.replaceAll('\\\\', '/')\n      const moduleURL = pathToFileURL(cleanPath)\n      try {\n        const { downSQL, imports, upSQL } = await eval(`import('${moduleURL.href}')`)\n        return { downSQL, imports, upSQL }\n      } catch (error) {\n        payload.logger.error({\n          error,\n          msg: `Error loading predefined migration ${migrationName}`,\n        })\n        process.exit(1)\n      }\n    } else {\n      payload.logger.error({\n        msg: `Canned migration ${migrationName} not found.`,\n      })\n      process.exit(1)\n    }\n  }\n  return {}\n}\n"],"names":["fs","path","pathToFileURL","getPredefinedMigration","dirname","file","migrationName","migrationNameArg","payload","startsWith","split","slice","join","cleanPath","existsSync","replaceAll","moduleURL","downSQL","imports","upSQL","eval","href","error","logger","msg","process","exit"],"mappings":";;;AAAA,OAAOA,QAAQ,KAAI;AACnB,OAAOC,UAAU,OAAM;AACvB,SAASC,aAAa,QAAQ,MAAK;;;;AAQ5B,MAAMC,yBAAyB,OAAO,EAC3CC,OAAO,EACPC,IAAI,EACJC,eAAeC,gBAAgB,EAC/BC,OAAO,EAMR;IACC,kCAAkC;IAClC,qFAAqF;IACrF,IAAIH,QAAQE,kBAAkBE,WAAW,iBAAiB;QACxD,mDAAmD;QACnD,MAAMH,gBAAiBD,CAAAA,QAAQE,gBAAe,EAAGG,KAAK,CAAC,KAAKC,KAAK,CAAC,GAAGC,IAAI,CAAC;QAC1E,IAAIC,0GAAYZ,UAAAA,CAAKW,IAAI,CAACR,SAAS,CAAC,uBAAuB,EAAEE,cAAc,IAAI,CAAC;QAEhF,uCAAuC;QACvC,gGAAIN,UAAAA,CAAGc,UAAU,CAACD,YAAY;YAC5BA,YAAYA,UAAUE,UAAU,CAAC,MAAM;YACvC,MAAMC,6GAAYd,gBAAAA,EAAcW;YAChC,IAAI;gBACF,MAAM,EAAEI,OAAO,EAAEC,OAAO,EAAEC,KAAK,EAAE,GAAG,MAAMC,KAAK,CAAC,QAAQ,EAAEJ,UAAUK,IAAI,CAAC,EAAE,CAAC;gBAC5E,OAAO;oBAAEJ;oBAASC;oBAASC;gBAAM;YACnC,EAAE,OAAOG,OAAO;gBACdd,QAAQe,MAAM,CAACD,KAAK,CAAC;oBACnBA;oBACAE,KAAK,CAAC,mCAAmC,EAAElB,cAAc,CAAC;gBAC5D;gBACAmB,QAAQC,IAAI,CAAC;YACf;QACF,OAAO;YACLlB,QAAQe,MAAM,CAACD,KAAK,CAAC;gBACnBE,KAAK,CAAC,iBAAiB,EAAElB,cAAc,WAAW,CAAC;YACrD;YACAmB,QAAQC,IAAI,CAAC;QACf;IACF;IACA,OAAO,CAAC;AACV,EAAC"}},
    {"offset": {"line": 15461, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 15467, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/payload/src/database/migrations/writeMigrationIndex.ts"],"sourcesContent":["import fs from 'fs'\nimport { getTsconfig } from 'get-tsconfig'\nimport path from 'path'\n\n// Function to get all migration files (TS or JS) excluding 'index'\nconst getMigrationFiles = (dir: string) => {\n  return fs\n    .readdirSync(dir)\n    .filter(\n      (file) =>\n        (file.endsWith('.ts') || file.endsWith('.js')) &&\n        file !== 'index.ts' &&\n        file !== 'index.js',\n    )\n    .sort()\n}\n\n// Function to generate the index.ts content\nconst generateIndexContent = (files: string[]) => {\n  const tsconfig = getTsconfig()\n  const importExt = tsconfig?.config?.compilerOptions?.moduleResolution === 'NodeNext' ? '.js' : ''\n\n  let imports = ''\n  let exportsArray = 'export const migrations = [\\n'\n\n  files.forEach((file, index) => {\n    const fileNameWithoutExt = file.replace(/\\.[^/.]+$/, '')\n    imports += `import * as migration_${fileNameWithoutExt} from './${fileNameWithoutExt}${importExt}';\\n`\n    exportsArray += `  {\n    up: migration_${fileNameWithoutExt}.up,\n    down: migration_${fileNameWithoutExt}.down,\n    name: '${fileNameWithoutExt}'${index !== files.length - 1 ? ',' : ''}\\n  },\\n`\n  })\n\n  exportsArray += '];\\n'\n  return imports + '\\n' + exportsArray\n}\n\n// Main function to create the index.ts file\nexport const writeMigrationIndex = (args: { migrationsDir: string }) => {\n  const migrationFiles = getMigrationFiles(args.migrationsDir)\n  const indexContent = generateIndexContent(migrationFiles)\n\n  fs.writeFileSync(path.join(args.migrationsDir, 'index.ts'), indexContent)\n}\n"],"names":["fs","getTsconfig","path","getMigrationFiles","dir","readdirSync","filter","file","endsWith","sort","generateIndexContent","files","tsconfig","importExt","config","compilerOptions","moduleResolution","imports","exportsArray","forEach","index","fileNameWithoutExt","replace","length","writeMigrationIndex","args","migrationFiles","migrationsDir","indexContent","writeFileSync","join"],"mappings":";;;AAAA,OAAOA,QAAQ,KAAI;AACnB,SAASC,WAAW,QAAQ,eAAc;AAC1C,OAAOC,UAAU,OAAM;;;;AAEvB,mEAAmE;AACnE,MAAMC,oBAAoB,CAACC;IACzB,mGAAOJ,UAAAA,CACJK,WAAW,CAACD,KACZE,MAAM,CACL,CAACC,OACEA,CAAAA,KAAKC,QAAQ,CAAC,UAAUD,KAAKC,QAAQ,CAAC,MAAK,KAC5CD,SAAS,cACTA,SAAS,YAEZE,IAAI;AACT;AAEA,4CAA4C;AAC5C,MAAMC,uBAAuB,CAACC;IAC5B,MAAMC,WAAWX,oKAAAA;IACjB,MAAMY,YAAYD,UAAUE,QAAQC,iBAAiBC,qBAAqB,aAAa,QAAQ;IAE/F,IAAIC,UAAU;IACd,IAAIC,eAAe;IAEnBP,MAAMQ,OAAO,CAAC,CAACZ,MAAMa;QACnB,MAAMC,qBAAqBd,KAAKe,OAAO,CAAC,aAAa;QACrDL,WAAW,CAAC,sBAAsB,EAAEI,mBAAmB,SAAS,EAAEA,mBAAmB,EAAER,UAAU,IAAI,CAAC;QACtGK,gBAAgB,CAAC;kBACH,EAAEG,mBAAmB;oBACnB,EAAEA,mBAAmB;WAC9B,EAAEA,mBAAmB,CAAC,EAAED,UAAUT,MAAMY,MAAM,GAAG,IAAI,MAAM,GAAG,QAAQ,CAAC;IAChF;IAEAL,gBAAgB;IAChB,OAAOD,UAAU,OAAOC;AAC1B;AAGO,MAAMM,sBAAsB,CAACC;IAClC,MAAMC,iBAAiBvB,kBAAkBsB,KAAKE,aAAa;IAC3D,MAAMC,eAAelB,qBAAqBgB;gGAE1C1B,UAAAA,CAAG6B,aAAa,+FAAC3B,UAAAA,CAAK4B,IAAI,CAACL,KAAKE,aAAa,EAAE,aAAaC;AAC9D,EAAC"}},
    {"offset": {"line": 15502, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 15508, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/payload/src/database/migrations/migrationTemplate.ts"],"sourcesContent":["export const migrationTemplate = `\nimport {\n  MigrateUpArgs,\n  MigrateDownArgs,\n} from \"@payloadcms/db-mongodb\";\n\nexport async function up({ payload, req }: MigrateUpArgs): Promise<void> {\n  // Migration code\n};\n\nexport async function down({ payload, req }: MigrateDownArgs): Promise<void> {\n  // Migration code\n};\n`\n"],"names":["migrationTemplate"],"mappings":";;;AAAO,MAAMA,oBAAoB,CAAC;;;;;;;;;;;;;AAalC,CAAC,CAAA"}},
    {"offset": {"line": 15525, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 15531, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/payload/src/database/migrations/createMigration.ts"],"sourcesContent":["import fs from 'fs'\n\nimport type { CreateMigration } from '../types.js'\n\nimport { writeMigrationIndex } from '../../index.js'\nimport { migrationTemplate } from './migrationTemplate.js'\n\nexport const createMigration: CreateMigration = function createMigration({\n  migrationName,\n  payload,\n}) {\n  const dir = payload.db.migrationDir\n  if (!fs.existsSync(dir)) {\n    fs.mkdirSync(dir)\n  }\n\n  const [yyymmdd, hhmmss] = new Date().toISOString().split('T')\n  const formattedDate = yyymmdd.replace(/\\D/g, '')\n  const formattedTime = hhmmss.split('.')[0].replace(/\\D/g, '')\n\n  const timestamp = `${formattedDate}_${formattedTime}`\n\n  const formattedName = migrationName.replace(/\\W/g, '_')\n  const fileName = `${timestamp}_${formattedName}.ts`\n  const filePath = `${dir}/${fileName}`\n  fs.writeFileSync(filePath, migrationTemplate)\n\n  writeMigrationIndex({ migrationsDir: payload.db.migrationDir })\n\n  payload.logger.info({ msg: `Migration created at ${filePath}` })\n}\n"],"names":["fs","writeMigrationIndex","migrationTemplate","createMigration","migrationName","payload","dir","db","migrationDir","existsSync","mkdirSync","yyymmdd","hhmmss","Date","toISOString","split","formattedDate","replace","formattedTime","timestamp","formattedName","fileName","filePath","writeFileSync","migrationsDir","logger","info","msg"],"mappings":";;;AAAA,OAAOA,QAAQ,KAAI;AAKnB,SAASE,iBAAiB,QAAQ,yBAAwB;AAD1D,SAASD,mBAAmB,QAAQ,iBAAgB;;;;AAG7C,MAAME,kBAAmC,SAASA,gBAAgB,EACvEC,aAAa,EACbC,OAAO,EACR;IACC,MAAMC,MAAMD,QAAQE,EAAE,CAACC,YAAY;IACnC,IAAI,6FAACR,UAAAA,CAAGS,UAAU,CAACH,MAAM;oGACvBN,UAAAA,CAAGU,SAAS,CAACJ;IACf;IAEA,MAAM,CAACK,SAASC,OAAO,GAAG,IAAIC,OAAOC,WAAW,GAAGC,KAAK,CAAC;IACzD,MAAMC,gBAAgBL,QAAQM,OAAO,CAAC,OAAO;IAC7C,MAAMC,gBAAgBN,OAAOG,KAAK,CAAC,IAAI,CAAC,EAAE,CAACE,OAAO,CAAC,OAAO;IAE1D,MAAME,YAAY,CAAC,EAAEH,cAAc,CAAC,EAAEE,cAAc,CAAC;IAErD,MAAME,gBAAgBhB,cAAca,OAAO,CAAC,OAAO;IACnD,MAAMI,WAAW,CAAC,EAAEF,UAAU,CAAC,EAAEC,cAAc,GAAG,CAAC;IACnD,MAAME,WAAW,CAAC,EAAEhB,IAAI,CAAC,EAAEe,SAAS,CAAC;gGACrCrB,UAAAA,CAAGuB,aAAa,CAACD,yLAAUpB,oBAAAA;yLAE3BD,sBAAAA,EAAoB;QAAEuB,eAAenB,QAAQE,EAAE,CAACC,YAAY;IAAC;IAE7DH,QAAQoB,MAAM,CAACC,IAAI,CAAC;QAAEC,KAAK,CAAC,qBAAqB,EAAEL,SAAS,CAAC;IAAC;AAChE,EAAC"}},
    {"offset": {"line": 15560, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 15566, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/payload/src/database/migrations/migrate.ts"],"sourcesContent":["import type { PayloadRequest } from '../../types/index.js'\nimport type { BaseDatabaseAdapter } from '../types.js'\n\nimport { commitTransaction } from '../../utilities/commitTransaction.js'\nimport { initTransaction } from '../../utilities/initTransaction.js'\nimport { killTransaction } from '../../utilities/killTransaction.js'\nimport { getMigrations } from './getMigrations.js'\nimport { readMigrationFiles } from './readMigrationFiles.js'\n\nexport const migrate: BaseDatabaseAdapter['migrate'] = async function migrate(\n  this: BaseDatabaseAdapter,\n  args,\n): Promise<void> {\n  const { payload } = this\n  const migrationFiles = args?.migrations || (await readMigrationFiles({ payload }))\n  const { existingMigrations, latestBatch } = await getMigrations({ payload })\n\n  const newBatch = latestBatch + 1\n\n  // Execute 'up' function for each migration sequentially\n  for (const migration of migrationFiles) {\n    const existingMigration = existingMigrations.find(\n      (existing) => existing.name === migration.name,\n    )\n\n    // Run migration if not found in database\n    if (existingMigration) {\n      continue\n    }\n\n    const start = Date.now()\n    const req = { payload } as PayloadRequest\n\n    payload.logger.info({ msg: `Migrating: ${migration.name}` })\n\n    try {\n      await initTransaction(req)\n      await migration.up({ payload, req })\n      payload.logger.info({ msg: `Migrated:  ${migration.name} (${Date.now() - start}ms)` })\n      await payload.create({\n        collection: 'payload-migrations',\n        data: {\n          name: migration.name,\n          batch: newBatch,\n        },\n        req,\n      })\n      await commitTransaction(req)\n    } catch (err: unknown) {\n      await killTransaction(req)\n      payload.logger.error({ err, msg: `Error running migration ${migration.name}` })\n      throw err\n    }\n  }\n}\n"],"names":["commitTransaction","initTransaction","killTransaction","getMigrations","readMigrationFiles","migrate","args","payload","migrationFiles","migrations","existingMigrations","latestBatch","newBatch","migration","existingMigration","find","existing","name","start","Date","now","req","logger","info","msg","up","create","collection","data","batch","err","error"],"mappings":";;;AAOA,SAASI,kBAAkB,QAAQ,0BAAyB;AAD5D,SAASD,aAAa,QAAQ,qBAAoB;AAFlD,SAASF,eAAe,QAAQ,qCAAoC;AADpE,SAASD,iBAAiB,QAAQ,uCAAsC;AAExE,SAASE,eAAe,QAAQ,qCAAoC;;;;;;AAI7D,MAAMG,UAA0C,eAAeA,QAEpEC,IAAI;IAEJ,MAAM,EAAEC,OAAO,EAAE,GAAG,IAAI;IACxB,MAAMC,iBAAiBF,MAAMG,cAAe,0LAAML,qBAAAA,EAAmB;QAAEG;IAAQ;IAC/E,MAAM,EAAEG,kBAAkB,EAAEC,WAAW,EAAE,GAAG,qLAAMR,gBAAAA,EAAc;QAAEI;IAAQ;IAE1E,MAAMK,WAAWD,cAAc;IAE/B,wDAAwD;IACxD,KAAK,MAAME,aAAaL,eAAgB;QACtC,MAAMM,oBAAoBJ,mBAAmBK,IAAI,CAC/C,CAACC,WAAaA,SAASC,IAAI,KAAKJ,UAAUI,IAAI;QAGhD,yCAAyC;QACzC,IAAIH,mBAAmB;YACrB;QACF;QAEA,MAAMI,QAAQC,KAAKC,GAAG;QACtB,MAAMC,MAAM;YAAEd;QAAQ;QAEtBA,QAAQe,MAAM,CAACC,IAAI,CAAC;YAAEC,KAAK,CAAC,WAAW,EAAEX,UAAUI,IAAI,CAAC,CAAC;QAAC;QAE1D,IAAI;YACF,0KAAMhB,kBAAAA,EAAgBoB;YACtB,MAAMR,UAAUY,EAAE,CAAC;gBAAElB;gBAASc;YAAI;YAClCd,QAAQe,MAAM,CAACC,IAAI,CAAC;gBAAEC,KAAK,CAAC,WAAW,EAAEX,UAAUI,IAAI,CAAC,EAAE,EAAEE,KAAKC,GAAG,KAAKF,MAAM,GAAG,CAAC;YAAC;YACpF,MAAMX,QAAQmB,MAAM,CAAC;gBACnBC,YAAY;gBACZC,MAAM;oBACJX,MAAMJ,UAAUI,IAAI;oBACpBY,OAAOjB;gBACT;gBACAS;YACF;YACA,OAAMrB,yLAAAA,EAAkBqB;QAC1B,EAAE,OAAOS,KAAc;YACrB,0KAAM5B,kBAAAA,EAAgBmB;YACtBd,QAAQe,MAAM,CAACS,KAAK,CAAC;gBAAED;gBAAKN,KAAK,CAAC,wBAAwB,EAAEX,UAAUI,IAAI,CAAC,CAAC;YAAC;YAC7E,MAAMa;QACR;IACF;AACF,EAAC"}},
    {"offset": {"line": 15630, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 15636, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/payload/src/database/migrations/migrateDown.ts"],"sourcesContent":["import type { PayloadRequest } from '../../types/index.js'\nimport type { BaseDatabaseAdapter } from '../types.js'\n\nimport { commitTransaction } from '../../utilities/commitTransaction.js'\nimport { initTransaction } from '../../utilities/initTransaction.js'\nimport { killTransaction } from '../../utilities/killTransaction.js'\nimport { getMigrations } from './getMigrations.js'\nimport { readMigrationFiles } from './readMigrationFiles.js'\n\nexport async function migrateDown(this: BaseDatabaseAdapter): Promise<void> {\n  const { payload } = this\n  const migrationFiles = await readMigrationFiles({ payload })\n\n  const { existingMigrations, latestBatch } = await getMigrations({\n    payload,\n  })\n\n  if (!existingMigrations?.length) {\n    payload.logger.info({ msg: 'No migrations to rollback.' })\n    return\n  }\n\n  payload.logger.info({\n    msg: `Rolling back batch ${latestBatch} consisting of ${existingMigrations.length} migration(s).`,\n  })\n\n  const latestBatchMigrations = existingMigrations.filter(({ batch }) => batch === latestBatch)\n\n  for (const migration of latestBatchMigrations) {\n    const migrationFile = migrationFiles.find((m) => m.name === migration.name)\n    if (!migrationFile) {\n      throw new Error(`Migration ${migration.name} not found locally.`)\n    }\n\n    const start = Date.now()\n    const req = { payload } as PayloadRequest\n\n    try {\n      payload.logger.info({ msg: `Migrating down: ${migrationFile.name}` })\n      await initTransaction(req)\n      await migrationFile.down({ payload, req })\n      payload.logger.info({\n        msg: `Migrated down:  ${migrationFile.name} (${Date.now() - start}ms)`,\n      })\n      // Waiting for implementation here\n      await payload.delete({\n        id: migration.id,\n        collection: 'payload-migrations',\n        req,\n      })\n\n      await commitTransaction(req)\n    } catch (err: unknown) {\n      await killTransaction(req)\n      payload.logger.error({\n        err,\n        msg: `Error running migration ${migrationFile.name}`,\n      })\n      process.exit(1)\n    }\n  }\n}\n"],"names":["commitTransaction","initTransaction","killTransaction","getMigrations","readMigrationFiles","migrateDown","payload","migrationFiles","existingMigrations","latestBatch","length","logger","info","msg","latestBatchMigrations","filter","batch","migration","migrationFile","find","m","name","Error","start","Date","now","req","down","delete","id","collection","err","error","process","exit"],"mappings":";;;AAOA,SAASI,kBAAkB,QAAQ,0BAAyB;AAD5D,SAASD,aAAa,QAAQ,qBAAoB;AAFlD,SAASF,eAAe,QAAQ,qCAAoC;AADpE,SAASD,iBAAiB,QAAQ,uCAAsC;AAExE,SAASE,eAAe,QAAQ,qCAAoC;;;;;;AAI7D,eAAeG;IACpB,MAAM,EAAEC,OAAO,EAAE,GAAG,IAAI;IACxB,MAAMC,iBAAiB,0LAAMH,qBAAAA,EAAmB;QAAEE;IAAQ;IAE1D,MAAM,EAAEE,kBAAkB,EAAEC,WAAW,EAAE,GAAG,qLAAMN,gBAAAA,EAAc;QAC9DG;IACF;IAEA,IAAI,CAACE,oBAAoBE,QAAQ;QAC/BJ,QAAQK,MAAM,CAACC,IAAI,CAAC;YAAEC,KAAK;QAA6B;QACxD;IACF;IAEAP,QAAQK,MAAM,CAACC,IAAI,CAAC;QAClBC,KAAK,CAAC,mBAAmB,EAAEJ,YAAY,eAAe,EAAED,mBAAmBE,MAAM,CAAC,cAAc,CAAC;IACnG;IAEA,MAAMI,wBAAwBN,mBAAmBO,MAAM,CAAC,CAAC,EAAEC,KAAK,EAAE,GAAKA,UAAUP;IAEjF,KAAK,MAAMQ,aAAaH,sBAAuB;QAC7C,MAAMI,gBAAgBX,eAAeY,IAAI,CAAC,CAACC,IAAMA,EAAEC,IAAI,KAAKJ,UAAUI,IAAI;QAC1E,IAAI,CAACH,eAAe;YAClB,MAAM,IAAII,MAAM,CAAC,UAAU,EAAEL,UAAUI,IAAI,CAAC,mBAAmB,CAAC;QAClE;QAEA,MAAME,QAAQC,KAAKC,GAAG;QACtB,MAAMC,MAAM;YAAEpB;QAAQ;QAEtB,IAAI;YACFA,QAAQK,MAAM,CAACC,IAAI,CAAC;gBAAEC,KAAK,CAAC,gBAAgB,EAAEK,cAAcG,IAAI,CAAC,CAAC;YAAC;YACnE,0KAAMpB,kBAAAA,EAAgByB;YACtB,MAAMR,cAAcS,IAAI,CAAC;gBAAErB;gBAASoB;YAAI;YACxCpB,QAAQK,MAAM,CAACC,IAAI,CAAC;gBAClBC,KAAK,CAAC,gBAAgB,EAAEK,cAAcG,IAAI,CAAC,EAAE,EAAEG,KAAKC,GAAG,KAAKF,MAAM,GAAG,CAAC;YACxE;YACA,kCAAkC;YAClC,MAAMjB,QAAQsB,MAAM,CAAC;gBACnBC,IAAIZ,UAAUY,EAAE;gBAChBC,YAAY;gBACZJ;YACF;YAEA,4KAAM1B,oBAAAA,EAAkB0B;QAC1B,EAAE,OAAOK,KAAc;YACrB,0KAAM7B,kBAAAA,EAAgBwB;YACtBpB,QAAQK,MAAM,CAACqB,KAAK,CAAC;gBACnBD;gBACAlB,KAAK,CAAC,wBAAwB,EAAEK,cAAcG,IAAI,CAAC,CAAC;YACtD;YACAY,QAAQC,IAAI,CAAC;QACf;IACF;AACF"}},
    {"offset": {"line": 15705, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 15711, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/payload/src/database/migrations/migrateRefresh.ts"],"sourcesContent":["import type { PayloadRequest } from '../../types/index.js'\nimport type { BaseDatabaseAdapter } from '../types.js'\n\nimport { commitTransaction } from '../../utilities/commitTransaction.js'\nimport { initTransaction } from '../../utilities/initTransaction.js'\nimport { killTransaction } from '../../utilities/killTransaction.js'\nimport { getMigrations } from './getMigrations.js'\nimport { readMigrationFiles } from './readMigrationFiles.js'\n\n/**\n * Run all migration down functions before running up\n */\nexport async function migrateRefresh(this: BaseDatabaseAdapter) {\n  const { payload } = this\n  const migrationFiles = await readMigrationFiles({ payload })\n\n  const { existingMigrations, latestBatch } = await getMigrations({\n    payload,\n  })\n\n  if (!existingMigrations?.length) {\n    payload.logger.info({ msg: 'No migrations to rollback.' })\n    return\n  }\n\n  payload.logger.info({\n    msg: `Rolling back batch ${latestBatch} consisting of ${existingMigrations.length} migration(s).`,\n  })\n\n  const req = { payload } as PayloadRequest\n\n  // Reverse order of migrations to rollback\n  existingMigrations.reverse()\n\n  for (const migration of existingMigrations) {\n    try {\n      const migrationFile = migrationFiles.find((m) => m.name === migration.name)\n      if (!migrationFile) {\n        throw new Error(`Migration ${migration.name} not found locally.`)\n      }\n\n      payload.logger.info({ msg: `Migrating down: ${migration.name}` })\n      const start = Date.now()\n      await initTransaction(req)\n      await migrationFile.down({ payload, req })\n      payload.logger.info({\n        msg: `Migrated down:  ${migration.name} (${Date.now() - start}ms)`,\n      })\n      await payload.delete({\n        collection: 'payload-migrations',\n        req,\n        where: {\n          name: {\n            equals: migration.name,\n          },\n        },\n      })\n    } catch (err: unknown) {\n      await killTransaction(req)\n      let msg = `Error running migration ${migration.name}. Rolling back.`\n      if (err instanceof Error) {\n        msg += ` ${err.message}`\n      }\n      payload.logger.error({\n        err,\n        msg,\n      })\n      process.exit(1)\n    }\n  }\n\n  // Run all migrate up\n  for (const migration of migrationFiles) {\n    payload.logger.info({ msg: `Migrating: ${migration.name}` })\n    try {\n      const start = Date.now()\n      await initTransaction(req)\n      await migration.up({ payload, req })\n      await payload.create({\n        collection: 'payload-migrations',\n        data: {\n          name: migration.name,\n          executed: true,\n        },\n        req,\n      })\n      await commitTransaction(req)\n\n      payload.logger.info({ msg: `Migrated:  ${migration.name} (${Date.now() - start}ms)` })\n    } catch (err: unknown) {\n      await killTransaction(req)\n      let msg = `Error running migration ${migration.name}. Rolling back.`\n      if (err instanceof Error) {\n        msg += ` ${err.message}`\n      }\n      payload.logger.error({\n        err,\n        msg,\n      })\n      process.exit(1)\n    }\n  }\n}\n"],"names":["commitTransaction","initTransaction","killTransaction","getMigrations","readMigrationFiles","migrateRefresh","payload","migrationFiles","existingMigrations","latestBatch","length","logger","info","msg","req","reverse","migration","migrationFile","find","m","name","Error","start","Date","now","down","delete","collection","where","equals","err","message","error","process","exit","up","create","data","executed"],"mappings":"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"}},
    {"offset": {"line": 15824, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 15830, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/payload/src/database/migrations/migrateReset.ts"],"sourcesContent":["import type { PayloadRequest } from '../../types/index.js'\nimport type { BaseDatabaseAdapter } from '../types.js'\n\nimport { commitTransaction } from '../../utilities/commitTransaction.js'\nimport { initTransaction } from '../../utilities/initTransaction.js'\nimport { killTransaction } from '../../utilities/killTransaction.js'\nimport { getMigrations } from './getMigrations.js'\nimport { readMigrationFiles } from './readMigrationFiles.js'\n\nexport async function migrateReset(this: BaseDatabaseAdapter): Promise<void> {\n  const { payload } = this\n  const migrationFiles = await readMigrationFiles({ payload })\n\n  const { existingMigrations } = await getMigrations({ payload })\n\n  if (!existingMigrations?.length) {\n    payload.logger.info({ msg: 'No migrations to reset.' })\n    return\n  }\n\n  const req = { payload } as PayloadRequest\n\n  // Rollback all migrations in order\n  for (const migration of migrationFiles) {\n    // Create or update migration in database\n    const existingMigration = existingMigrations.find(\n      (existing) => existing.name === migration.name,\n    )\n    if (existingMigration) {\n      payload.logger.info({ msg: `Migrating down: ${migration.name}` })\n      try {\n        const start = Date.now()\n        await initTransaction(req)\n        await migration.down({ payload, req })\n        await payload.delete({\n          collection: 'payload-migrations',\n          req,\n          where: {\n            id: {\n              equals: existingMigration.id,\n            },\n          },\n        })\n        await commitTransaction(req)\n        payload.logger.info({ msg: `Migrated down:  ${migration.name} (${Date.now() - start}ms)` })\n      } catch (err: unknown) {\n        await killTransaction(req)\n        payload.logger.error({ err, msg: `Error running migration ${migration.name}` })\n        throw err\n      }\n    }\n  }\n\n  // Delete dev migration\n  try {\n    await payload.delete({\n      collection: 'payload-migrations',\n      where: {\n        batch: {\n          equals: -1,\n        },\n      },\n    })\n  } catch (err: unknown) {\n    payload.logger.error({ err, msg: 'Error deleting dev migration' })\n  }\n}\n"],"names":["commitTransaction","initTransaction","killTransaction","getMigrations","readMigrationFiles","migrateReset","payload","migrationFiles","existingMigrations","length","logger","info","msg","req","migration","existingMigration","find","existing","name","start","Date","now","down","delete","collection","where","id","equals","err","error","batch"],"mappings":";;;AAOA,SAASI,kBAAkB,QAAQ,0BAAyB;AAD5D,SAASD,aAAa,QAAQ,qBAAoB;AAFlD,SAASF,eAAe,QAAQ,qCAAoC;AADpE,SAASD,iBAAiB,QAAQ,uCAAsC;AAExE,SAASE,eAAe,QAAQ,qCAAoC;;;;;;AAI7D,eAAeG;IACpB,MAAM,EAAEC,OAAO,EAAE,GAAG,IAAI;IACxB,MAAMC,iBAAiB,0LAAMH,qBAAAA,EAAmB;QAAEE;IAAQ;IAE1D,MAAM,EAAEE,kBAAkB,EAAE,GAAG,qLAAML,gBAAAA,EAAc;QAAEG;IAAQ;IAE7D,IAAI,CAACE,oBAAoBC,QAAQ;QAC/BH,QAAQI,MAAM,CAACC,IAAI,CAAC;YAAEC,KAAK;QAA0B;QACrD;IACF;IAEA,MAAMC,MAAM;QAAEP;IAAQ;IAEtB,mCAAmC;IACnC,KAAK,MAAMQ,aAAaP,eAAgB;QACtC,yCAAyC;QACzC,MAAMQ,oBAAoBP,mBAAmBQ,IAAI,CAC/C,CAACC,WAAaA,SAASC,IAAI,KAAKJ,UAAUI,IAAI;QAEhD,IAAIH,mBAAmB;YACrBT,QAAQI,MAAM,CAACC,IAAI,CAAC;gBAAEC,KAAK,CAAC,gBAAgB,EAAEE,UAAUI,IAAI,CAAC,CAAC;YAAC;YAC/D,IAAI;gBACF,MAAMC,QAAQC,KAAKC,GAAG;gBACtB,0KAAMpB,kBAAAA,EAAgBY;gBACtB,MAAMC,UAAUQ,IAAI,CAAC;oBAAEhB;oBAASO;gBAAI;gBACpC,MAAMP,QAAQiB,MAAM,CAAC;oBACnBC,YAAY;oBACZX;oBACAY,OAAO;wBACLC,IAAI;4BACFC,QAAQZ,kBAAkBW,EAAE;wBAC9B;oBACF;gBACF;gBACA,4KAAM1B,oBAAAA,EAAkBa;gBACxBP,QAAQI,MAAM,CAACC,IAAI,CAAC;oBAAEC,KAAK,CAAC,gBAAgB,EAAEE,UAAUI,IAAI,CAAC,EAAE,EAAEE,KAAKC,GAAG,KAAKF,MAAM,GAAG,CAAC;gBAAC;YAC3F,EAAE,OAAOS,KAAc;gBACrB,0KAAM1B,kBAAAA,EAAgBW;gBACtBP,QAAQI,MAAM,CAACmB,KAAK,CAAC;oBAAED;oBAAKhB,KAAK,CAAC,wBAAwB,EAAEE,UAAUI,IAAI,CAAC,CAAC;gBAAC;gBAC7E,MAAMU;YACR;QACF;IACF;IAEA,uBAAuB;IACvB,IAAI;QACF,MAAMtB,QAAQiB,MAAM,CAAC;YACnBC,YAAY;YACZC,OAAO;gBACLK,OAAO;oBACLH,QAAQ,CAAC;gBACX;YACF;QACF;IACF,EAAE,OAAOC,KAAc;QACrBtB,QAAQI,MAAM,CAACmB,KAAK,CAAC;YAAED;YAAKhB,KAAK;QAA+B;IAClE;AACF"}},
    {"offset": {"line": 15915, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 15921, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/payload/src/database/migrations/migrateStatus.ts"],"sourcesContent":["import { Table } from 'console-table-printer'\n\nimport type { BaseDatabaseAdapter } from '../types.js'\n\nimport { getMigrations } from './getMigrations.js'\nimport { readMigrationFiles } from './readMigrationFiles.js'\n\nexport async function migrateStatus(this: BaseDatabaseAdapter): Promise<void> {\n  const { payload } = this\n  const migrationFiles = await readMigrationFiles({ payload })\n\n  payload.logger.debug({\n    msg: `Found ${migrationFiles.length} migration files.`,\n  })\n\n  const { existingMigrations } = await getMigrations({ payload })\n\n  if (!migrationFiles.length) {\n    payload.logger.info({ msg: 'No migrations found.' })\n    return\n  }\n\n  // Compare migration files to existing migrations\n  const statuses = migrationFiles.map((migration) => {\n    const existingMigration = existingMigrations.find((m) => m.name === migration.name)\n    return {\n      Name: migration.name,\n\n      Batch: existingMigration?.batch,\n      Ran: existingMigration ? 'Yes' : 'No',\n    }\n  })\n\n  const p = new Table()\n\n  statuses.forEach((s) => {\n    p.addRow(s, {\n      color: s.Ran === 'Yes' ? 'green' : 'red',\n    })\n  })\n  p.printTable()\n}\n"],"names":["Table","getMigrations","readMigrationFiles","migrateStatus","payload","migrationFiles","logger","debug","msg","length","existingMigrations","info","statuses","map","migration","existingMigration","find","m","name","Name","Batch","batch","Ran","p","forEach","s","addRow","color","printTable"],"mappings":";;;AAAA,SAASA,KAAK,QAAQ,wBAAuB;AAK7C,SAASE,kBAAkB,QAAQ,0BAAyB;AAD5D,SAASD,aAAa,QAAQ,qBAAoB;;;;AAG3C,eAAeE;IACpB,MAAM,EAAEC,OAAO,EAAE,GAAG,IAAI;IACxB,MAAMC,iBAAiB,0LAAMH,qBAAAA,EAAmB;QAAEE;IAAQ;IAE1DA,QAAQE,MAAM,CAACC,KAAK,CAAC;QACnBC,KAAK,CAAC,MAAM,EAAEH,eAAeI,MAAM,CAAC,iBAAiB,CAAC;IACxD;IAEA,MAAM,EAAEC,kBAAkB,EAAE,GAAG,qLAAMT,gBAAAA,EAAc;QAAEG;IAAQ;IAE7D,IAAI,CAACC,eAAeI,MAAM,EAAE;QAC1BL,QAAQE,MAAM,CAACK,IAAI,CAAC;YAAEH,KAAK;QAAuB;QAClD;IACF;IAEA,iDAAiD;IACjD,MAAMI,WAAWP,eAAeQ,GAAG,CAAC,CAACC;QACnC,MAAMC,oBAAoBL,mBAAmBM,IAAI,CAAC,CAACC,IAAMA,EAAEC,IAAI,KAAKJ,UAAUI,IAAI;QAClF,OAAO;YACLC,MAAML,UAAUI,IAAI;YAEpBE,OAAOL,mBAAmBM;YAC1BC,KAAKP,oBAAoB,QAAQ;QACnC;IACF;IAEA,MAAMQ,IAAI,iKAAIvB,QAAAA;IAEdY,SAASY,OAAO,CAAC,CAACC;QAChBF,EAAEG,MAAM,CAACD,GAAG;YACVE,OAAOF,EAAEH,GAAG,KAAK,QAAQ,UAAU;QACrC;IACF;IACAC,EAAEK,UAAU;AACd"}},
    {"offset": {"line": 15964, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 15970, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/payload/src/database/createDatabaseAdapter.ts"],"sourcesContent":["import type { MarkOptional } from 'ts-essentials'\n\nimport type {\n  BaseDatabaseAdapter,\n  BeginTransaction,\n  CommitTransaction,\n  RollbackTransaction,\n} from './types.js'\n\nimport { createMigration } from './migrations/createMigration.js'\nimport { migrate } from './migrations/migrate.js'\nimport { migrateDown } from './migrations/migrateDown.js'\nimport { migrateRefresh } from './migrations/migrateRefresh.js'\nimport { migrateReset } from './migrations/migrateReset.js'\nimport { migrateStatus } from './migrations/migrateStatus.js'\n\nconst beginTransaction: BeginTransaction = async () => null\nconst rollbackTransaction: RollbackTransaction = async () => null\nconst commitTransaction: CommitTransaction = async () => null\n\nexport function createDatabaseAdapter<T extends BaseDatabaseAdapter>(\n  args: MarkOptional<\n    T,\n    | 'createMigration'\n    | 'migrate'\n    | 'migrateDown'\n    | 'migrateFresh'\n    | 'migrateRefresh'\n    | 'migrateReset'\n    | 'migrateStatus'\n    | 'migrationDir'\n  >,\n): T {\n  return {\n    // Default 'null' transaction functions\n    beginTransaction,\n    commitTransaction,\n    createMigration,\n    migrate,\n    migrateDown,\n    migrateFresh: async ({ forceAcceptWarning = null }) => null,\n    migrateRefresh,\n    migrateReset,\n    migrateStatus,\n    rollbackTransaction,\n\n    ...args,\n\n    // Ensure migrationDir is set\n    migrationDir: args.migrationDir || 'migrations',\n  } as T\n}\n"],"names":["createMigration","migrate","migrateDown","migrateRefresh","migrateReset","migrateStatus","beginTransaction","rollbackTransaction","commitTransaction","createDatabaseAdapter","args","migrateFresh","forceAcceptWarning","migrationDir"],"mappings":";;;AASA,SAASA,eAAe,QAAQ,kCAAiC;AACjE,SAASC,OAAO,QAAQ,0BAAyB;AACjD,SAASC,WAAW,QAAQ,8BAA6B;AACzD,SAASC,cAAc,QAAQ,iCAAgC;AAC/D,SAASC,YAAY,QAAQ,+BAA8B;AAC3D,SAASC,aAAa,QAAQ,gCAA+B;;;;;;;AAE7D,MAAMC,mBAAqC,UAAY;AACvD,MAAMC,sBAA2C,UAAY;AAC7D,MAAMC,oBAAuC,UAAY;AAElD,SAASC,sBACdC,IAUC;IAED,OAAO;QACL,uCAAuC;QACvCJ;QACAE;sMACAR,kBAAAA;sLACAC,UAAAA;8LACAC,cAAAA;QACAS,cAAc,OAAO,EAAEC,qBAAqB,IAAI,EAAE,GAAK;oMACvDT,iBAAAA;gMACAC,eAAAA;kMACAC,gBAAAA;QACAE;QAEA,GAAGG,IAAI;QAEP,6BAA6B;QAC7BG,cAAcH,KAAKG,YAAY,IAAI;IACrC;AACF"}},
    {"offset": {"line": 16006, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 16012, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/payload/src/database/defaultBeginTransaction.ts"],"sourcesContent":["import type { BeginTransaction } from './types.js'\n\n/**\n * Default implementation of `beginTransaction` that returns a resolved promise of null\n */\nexport function defaultBeginTransaction(): BeginTransaction {\n  const promiseSingleton: Promise<null> = Promise.resolve(null)\n  return () => promiseSingleton\n}\n"],"names":["defaultBeginTransaction","promiseSingleton","Promise","resolve"],"mappings":"AAEA;;CAEC,GACD;;;AAAO,SAASA;IACd,MAAMC,mBAAkCC,QAAQC,OAAO,CAAC;IACxD,OAAO,IAAMF;AACf"}},
    {"offset": {"line": 16021, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 16027, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/payload/src/auth/defaultUser.ts"],"sourcesContent":["import type { CollectionConfig } from '../collections/config/types.js'\n\nexport const defaultUserCollection: CollectionConfig = {\n  slug: 'users',\n  admin: {\n    useAsTitle: 'email',\n  },\n  auth: {\n    tokenExpiration: 7200,\n  },\n  fields: [],\n  labels: {\n    plural: ({ t }) => t('general:users'),\n    singular: ({ t }) => t('general:user'),\n  },\n}\n"],"names":["defaultUserCollection","slug","admin","useAsTitle","auth","tokenExpiration","fields","labels","plural","t","singular"],"mappings":";;;AAEO,MAAMA,wBAA0C;IACrDC,MAAM;IACNC,OAAO;QACLC,YAAY;IACd;IACAC,MAAM;QACJC,iBAAiB;IACnB;IACAC,QAAQ,EAAE;IACVC,QAAQ;QACNC,QAAQ,CAAC,EAAEC,CAAC,EAAE,GAAKA,EAAE;QACrBC,UAAU,CAAC,EAAED,CAAC,EAAE,GAAKA,EAAE;IACzB;AACF,EAAC"}},
    {"offset": {"line": 16044, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 16050, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/payload/src/config/defaults.ts"],"sourcesContent":["import type { Config } from './types.js'\n\nexport const defaults: Omit<Config, 'db' | 'editor' | 'secret'> = {\n  admin: {\n    avatar: 'gravatar',\n    components: {},\n    custom: {},\n    dateFormat: 'MMMM do yyyy, h:mm a',\n    dependencies: {},\n    disable: false,\n    importMap: {\n      baseDir: `${typeof process?.cwd === 'function' ? process.cwd() : ''}`,\n    },\n    meta: {\n      defaultOGImageType: 'dynamic',\n      titleSuffix: '- Payload',\n    },\n    routes: {\n      account: '/account',\n      createFirstUser: '/create-first-user',\n      forgot: '/forgot',\n      inactivity: '/logout-inactivity',\n      login: '/login',\n      logout: '/logout',\n      reset: '/reset',\n      unauthorized: '/unauthorized',\n    },\n    theme: 'all',\n  },\n  bin: [],\n  collections: [],\n  cookiePrefix: 'payload',\n  cors: [],\n  csrf: [],\n  custom: {},\n  defaultDepth: 2,\n  defaultMaxTextLength: 40000,\n  endpoints: [],\n  globals: [],\n  graphQL: {\n    disablePlaygroundInProduction: true,\n    maxComplexity: 1000,\n    schemaOutputFile: `${typeof process?.cwd === 'function' ? process.cwd() : ''}/schema.graphql`,\n  },\n  hooks: {},\n  i18n: {},\n  localization: false,\n  maxDepth: 10,\n  routes: {\n    admin: '/admin',\n    api: '/api',\n    graphQL: '/graphql',\n    graphQLPlayground: '/graphql-playground',\n  },\n  serverURL: '',\n  telemetry: true,\n  typescript: {\n    autoGenerate: true,\n    outputFile: `${typeof process?.cwd === 'function' ? process.cwd() : ''}/payload-types.ts`,\n  },\n  upload: {},\n}\n"],"names":["defaults","admin","avatar","components","custom","dateFormat","dependencies","disable","importMap","baseDir","process","cwd","meta","defaultOGImageType","titleSuffix","routes","account","createFirstUser","forgot","inactivity","login","logout","reset","unauthorized","theme","bin","collections","cookiePrefix","cors","csrf","defaultDepth","defaultMaxTextLength","endpoints","globals","graphQL","disablePlaygroundInProduction","maxComplexity","schemaOutputFile","hooks","i18n","localization","maxDepth","api","graphQLPlayground","serverURL","telemetry","typescript","autoGenerate","outputFile","upload"],"mappings":";;;AAEO,MAAMA,WAAqD;IAChEC,OAAO;QACLC,QAAQ;QACRC,YAAY,CAAC;QACbC,QAAQ,CAAC;QACTC,YAAY;QACZC,cAAc,CAAC;QACfC,SAAS;QACTC,WAAW;YACTC,SAAS,CAAC,EAAE,OAAOC,SAASC,QAAQ,aAAaD,QAAQC,GAAG,KAAK,GAAG,CAAC;QACvE;QACAC,MAAM;YACJC,oBAAoB;YACpBC,aAAa;QACf;QACAC,QAAQ;YACNC,SAAS;YACTC,iBAAiB;YACjBC,QAAQ;YACRC,YAAY;YACZC,OAAO;YACPC,QAAQ;YACRC,OAAO;YACPC,cAAc;QAChB;QACAC,OAAO;IACT;IACAC,KAAK,EAAE;IACPC,aAAa,EAAE;IACfC,cAAc;IACdC,MAAM,EAAE;IACRC,MAAM,EAAE;IACRzB,QAAQ,CAAC;IACT0B,cAAc;IACdC,sBAAsB;IACtBC,WAAW,EAAE;IACbC,SAAS,EAAE;IACXC,SAAS;QACPC,+BAA+B;QAC/BC,eAAe;QACfC,kBAAkB,CAAC,EAAE,OAAO3B,SAASC,QAAQ,aAAaD,QAAQC,GAAG,KAAK,GAAG,eAAe,CAAC;IAC/F;IACA2B,OAAO,CAAC;IACRC,MAAM,CAAC;IACPC,cAAc;IACdC,UAAU;IACV1B,QAAQ;QACNd,OAAO;QACPyC,KAAK;QACLR,SAAS;QACTS,mBAAmB;IACrB;IACAC,WAAW;IACXC,WAAW;IACXC,YAAY;QACVC,cAAc;QACdC,YAAY,CAAC,EAAE,OAAOtC,SAASC,QAAQ,aAAaD,QAAQC,GAAG,KAAK,GAAG,iBAAiB,CAAC;IAC3F;IACAsC,QAAQ,CAAC;AACX,EAAC"}},
    {"offset": {"line": 16113, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 16119, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/payload/src/lockedDocuments/lockedDocumentsCollection.ts"],"sourcesContent":["import type { CollectionConfig } from '../collections/config/types.js'\nimport type { Config } from '../config/types.js'\n\nexport const getLockedDocumentsCollection = (config: Config): CollectionConfig => ({\n  slug: 'payload-locked-documents',\n  admin: {\n    hidden: true,\n  },\n  fields: [\n    {\n      name: 'document',\n      type: 'relationship',\n      index: true,\n      maxDepth: 0,\n      relationTo: [...config.collections.map((collectionConfig) => collectionConfig.slug)],\n    },\n    {\n      name: 'globalSlug',\n      type: 'text',\n      index: true,\n    },\n    {\n      name: 'user',\n      type: 'relationship',\n      maxDepth: 1,\n      relationTo: config.collections\n        .filter((collectionConfig) => collectionConfig.auth)\n        .map((collectionConfig) => collectionConfig.slug),\n      required: true,\n    },\n  ],\n  lockDocuments: false,\n})\n"],"names":["getLockedDocumentsCollection","config","slug","admin","hidden","fields","name","type","index","maxDepth","relationTo","collections","map","collectionConfig","filter","auth","required","lockDocuments"],"mappings":";;;AAGO,MAAMA,+BAA+B,CAACC,SAAsC,CAAA;QACjFC,MAAM;QACNC,OAAO;YACLC,QAAQ;QACV;QACAC,QAAQ;YACN;gBACEC,MAAM;gBACNC,MAAM;gBACNC,OAAO;gBACPC,UAAU;gBACVC,YAAY;uBAAIT,OAAOU,WAAW,CAACC,GAAG,CAAC,CAACC,mBAAqBA,iBAAiBX,IAAI;iBAAE;YACtF;YACA;gBACEI,MAAM;gBACNC,MAAM;gBACNC,OAAO;YACT;YACA;gBACEF,MAAM;gBACNC,MAAM;gBACNE,UAAU;gBACVC,YAAYT,OAAOU,WAAW,CAC3BG,MAAM,CAAC,CAACD,mBAAqBA,iBAAiBE,IAAI,EAClDH,GAAG,CAAC,CAACC,mBAAqBA,iBAAiBX,IAAI;gBAClDc,UAAU;YACZ;SACD;QACDC,eAAe;IACjB,CAAA,EAAE"}},
    {"offset": {"line": 16152, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 16158, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/payload/src/preferences/operations/findOne.ts"],"sourcesContent":["import type { TypedCollection } from '../../index.js'\nimport type { Where } from '../../types/index.js'\nimport type { PreferenceRequest } from '../types.js'\n\nexport async function findOne(args: PreferenceRequest): Promise<TypedCollection['_preference']> {\n  const {\n    key,\n    req: { payload },\n    req,\n    user,\n  } = args\n\n  if (!user) {\n    return null\n  }\n\n  const where: Where = {\n    and: [\n      { key: { equals: key } },\n      { 'user.value': { equals: user.id } },\n      { 'user.relationTo': { equals: user.collection } },\n    ],\n  }\n\n  const { docs } = await payload.db.find({\n    collection: 'payload-preferences',\n    limit: 1,\n    pagination: false,\n    req,\n    sort: '-updatedAt',\n    where,\n  })\n\n  return docs?.[0] || null\n}\n"],"names":["findOne","args","key","req","payload","user","where","and","equals","id","collection","docs","db","find","limit","pagination","sort"],"mappings":";;;AAIO,eAAeA,QAAQC,IAAuB;IACnD,MAAM,EACJC,GAAG,EACHC,KAAK,EAAEC,OAAO,EAAE,EAChBD,GAAG,EACHE,IAAI,EACL,GAAGJ;IAEJ,IAAI,CAACI,MAAM;QACT,OAAO;IACT;IAEA,MAAMC,QAAe;QACnBC,KAAK;YACH;gBAAEL,KAAK;oBAAEM,QAAQN;gBAAI;YAAE;YACvB;gBAAE,cAAc;oBAAEM,QAAQH,KAAKI,EAAE;gBAAC;YAAE;YACpC;gBAAE,mBAAmB;oBAAED,QAAQH,KAAKK,UAAU;gBAAC;YAAE;SAClD;IACH;IAEA,MAAM,EAAEC,IAAI,EAAE,GAAG,MAAMP,QAAQQ,EAAE,CAACC,IAAI,CAAC;QACrCH,YAAY;QACZI,OAAO;QACPC,YAAY;QACZZ;QACAa,MAAM;QACNV;IACF;IAEA,OAAOK,MAAM,CAAC,EAAE,IAAI;AACtB"}},
    {"offset": {"line": 16195, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 16201, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/payload/src/preferences/requestHandlers/findOne.ts"],"sourcesContent":["import httpStatus from 'http-status'\n\nimport type { PayloadHandler } from '../../config/types.js'\nimport type { PayloadRequest } from '../../types/index.js'\n\nimport { findOne } from '../operations/findOne.js'\n\nexport const findByIDHandler: PayloadHandler = async (incomingReq): Promise<Response> => {\n  // We cannot import the addDataAndFileToRequest utility here from the 'next' package because of dependency issues\n  // However that utility should be used where possible instead of manually appending the data\n  let data\n\n  try {\n    data = await incomingReq.json()\n  } catch (error) {\n    data = {}\n  }\n\n  const reqWithData: PayloadRequest = incomingReq\n\n  if (data) {\n    reqWithData.data = data\n    reqWithData.json = () => Promise.resolve(data)\n  }\n\n  const result = await findOne({\n    key: reqWithData.routeParams?.key as string,\n    req: reqWithData,\n    user: reqWithData.user,\n  })\n\n  return Response.json(\n    {\n      ...(result\n        ? result\n        : {\n            message: reqWithData.t('general:notFound'),\n            value: null,\n          }),\n    },\n    {\n      status: httpStatus.OK,\n    },\n  )\n}\n"],"names":["httpStatus","findOne","findByIDHandler","incomingReq","data","json","error","reqWithData","Promise","resolve","result","key","routeParams","req","user","Response","message","t","value","status","OK"],"mappings":";;;AAAA,OAAOA,gBAAgB,cAAa;AAKpC,SAASC,OAAO,QAAQ,2BAA0B;;;AAE3C,MAAMC,kBAAkC,OAAOC;IACpD,iHAAiH;IACjH,4FAA4F;IAC5F,IAAIC;IAEJ,IAAI;QACFA,OAAO,MAAMD,YAAYE,IAAI;IAC/B,EAAE,OAAOC,OAAO;QACdF,OAAO,CAAC;IACV;IAEA,MAAMG,cAA8BJ;IAEpC,IAAIC,MAAM;QACRG,YAAYH,IAAI,GAAGA;QACnBG,YAAYF,IAAI,GAAG,IAAMG,QAAQC,OAAO,CAACL;IAC3C;IAEA,MAAMM,SAAS,OAAMT,qLAAAA,EAAQ;QAC3BU,KAAKJ,YAAYK,WAAW,EAAED;QAC9BE,KAAKN;QACLO,MAAMP,YAAYO,IAAI;IACxB;IAEA,OAAOC,SAASV,IAAI,CAClB;QACE,GAAIK,SACAA,SACA;YACEM,SAAST,YAAYU,CAAC,CAAC;YACvBC,OAAO;QACT,CAAC;IACP,GACA;QACEC,uJAAQnB,UAAAA,CAAWoB,EAAE;IACvB;AAEJ,EAAC"}},
    {"offset": {"line": 16236, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 16242, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/payload/src/errors/UnathorizedError.ts"],"sourcesContent":["import type { TFunction } from '@payloadcms/translations'\n\nimport { en } from '@payloadcms/translations/languages/en'\nimport httpStatus from 'http-status'\n\nimport { APIError } from './APIError.js'\n\nexport class UnauthorizedError extends APIError {\n  constructor(t?: TFunction) {\n    super(t ? t('error:unauthorized') : en.translations.error.unauthorized, httpStatus.UNAUTHORIZED)\n  }\n}\n"],"names":["en","httpStatus","APIError","UnauthorizedError","constructor","t","translations","error","unauthorized","UNAUTHORIZED"],"mappings":";;;AAEA,SAASA,EAAE,QAAQ,wCAAuC;AAC1D,OAAOC,gBAAgB,cAAa;AAEpC,SAASC,QAAQ,QAAQ,gBAAe;;;;AAEjC,MAAMC,gLAA0BD,WAAAA;IACrCE,YAAYC,CAAa,CAAE;QACzB,KAAK,CAACA,IAAIA,EAAE,gMAAwBL,KAAAA,CAAGM,YAAY,CAACC,KAAK,CAACC,YAAY,iJAAEP,UAAAA,CAAWQ,YAAY;IACjG;AACF"}},
    {"offset": {"line": 16256, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 16262, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/payload/src/preferences/operations/delete.ts"],"sourcesContent":["import type { Document, Where } from '../../types/index.js'\nimport type { PreferenceRequest } from '../types.js'\n\nimport { NotFound } from '../../errors/NotFound.js'\nimport { UnauthorizedError } from '../../errors/UnathorizedError.js'\n\nexport async function deleteOperation(args: PreferenceRequest): Promise<Document> {\n  const {\n    key,\n    req: { payload },\n    req,\n    user,\n  } = args\n\n  if (!user) {\n    throw new UnauthorizedError(req.t)\n  }\n\n  const where: Where = {\n    and: [\n      { key: { equals: key } },\n      { 'user.value': { equals: user.id } },\n      { 'user.relationTo': { equals: user.collection } },\n    ],\n  }\n\n  const result = await payload.db.deleteOne({\n    collection: 'payload-preferences',\n    req,\n    where,\n  })\n\n  if (result) {\n    return result\n  }\n  throw new NotFound(req.t)\n}\n"],"names":["NotFound","UnauthorizedError","deleteOperation","args","key","req","payload","user","t","where","and","equals","id","collection","result","db","deleteOne"],"mappings":";;;AAIA,SAASC,iBAAiB,QAAQ,mCAAkC;AADpE,SAASD,QAAQ,QAAQ,2BAA0B;;;AAG5C,eAAeE,gBAAgBC,IAAuB;IAC3D,MAAM,EACJC,GAAG,EACHC,KAAK,EAAEC,OAAO,EAAE,EAChBD,GAAG,EACHE,IAAI,EACL,GAAGJ;IAEJ,IAAI,CAACI,MAAM;QACT,MAAM,kKAAIN,oBAAAA,CAAkBI,IAAIG,CAAC;IACnC;IAEA,MAAMC,QAAe;QACnBC,KAAK;YACH;gBAAEN,KAAK;oBAAEO,QAAQP;gBAAI;YAAE;YACvB;gBAAE,cAAc;oBAAEO,QAAQJ,KAAKK,EAAE;gBAAC;YAAE;YACpC;gBAAE,mBAAmB;oBAAED,QAAQJ,KAAKM,UAAU;gBAAC;YAAE;SAClD;IACH;IAEA,MAAMC,SAAS,MAAMR,QAAQS,EAAE,CAACC,SAAS,CAAC;QACxCH,YAAY;QACZR;QACAI;IACF;IAEA,IAAIK,QAAQ;QACV,OAAOA;IACT;IACA,MAAM,0JAAId,WAAAA,CAASK,IAAIG,CAAC;AAC1B"}},
    {"offset": {"line": 16303, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 16309, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/payload/src/preferences/requestHandlers/delete.ts"],"sourcesContent":["import httpStatus from 'http-status'\n\nimport type { PayloadHandler } from '../../config/types.js'\nimport type { PayloadRequest } from '../../types/index.js'\n\nimport { deleteOperation } from '../operations/delete.js'\n\nexport const deleteHandler: PayloadHandler = async (incomingReq): Promise<Response> => {\n  // We cannot import the addDataAndFileToRequest utility here from the 'next' package because of dependency issues\n  // However that utility should be used where possible instead of manually appending the data\n  let data\n\n  try {\n    data = await incomingReq.json()\n  } catch (error) {\n    data = {}\n  }\n\n  const reqWithData: PayloadRequest = incomingReq\n\n  if (data) {\n    reqWithData.data = data\n    reqWithData.json = () => Promise.resolve(data)\n  }\n\n  const result = await deleteOperation({\n    key: reqWithData.routeParams?.key as string,\n    req: reqWithData,\n    user: reqWithData.user,\n  })\n\n  return Response.json(\n    {\n      ...result,\n      message: reqWithData.t('general:deletedSuccessfully'),\n    },\n    {\n      status: httpStatus.OK,\n    },\n  )\n}\n"],"names":["httpStatus","deleteOperation","deleteHandler","incomingReq","data","json","error","reqWithData","Promise","resolve","result","key","routeParams","req","user","Response","message","t","status","OK"],"mappings":";;;AAAA,OAAOA,gBAAgB,cAAa;AAKpC,SAASC,eAAe,QAAQ,0BAAyB;;;AAElD,MAAMC,gBAAgC,OAAOC;IAClD,iHAAiH;IACjH,4FAA4F;IAC5F,IAAIC;IAEJ,IAAI;QACFA,OAAO,MAAMD,YAAYE,IAAI;IAC/B,EAAE,OAAOC,OAAO;QACdF,OAAO,CAAC;IACV;IAEA,MAAMG,cAA8BJ;IAEpC,IAAIC,MAAM;QACRG,YAAYH,IAAI,GAAGA;QACnBG,YAAYF,IAAI,GAAG,IAAMG,QAAQC,OAAO,CAACL;IAC3C;IAEA,MAAMM,SAAS,MAAMT,6LAAAA,EAAgB;QACnCU,KAAKJ,YAAYK,WAAW,EAAED;QAC9BE,KAAKN;QACLO,MAAMP,YAAYO,IAAI;IACxB;IAEA,OAAOC,SAASV,IAAI,CAClB;QACE,GAAGK,MAAM;QACTM,SAAST,YAAYU,CAAC,CAAC;IACzB,GACA;QACEC,uJAAQlB,UAAAA,CAAWmB,EAAE;IACvB;AAEJ,EAAC"}},
    {"offset": {"line": 16342, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 16348, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/payload/src/preferences/operations/update.ts"],"sourcesContent":["import type { Where } from '../../types/index.js'\nimport type { PreferenceUpdateRequest } from '../types.js'\n\nimport { UnauthorizedError } from '../../errors/UnathorizedError.js'\n\nexport async function update(args: PreferenceUpdateRequest) {\n  const {\n    key,\n    req: { payload },\n    req,\n    user,\n    value,\n  } = args\n\n  if (!user) {\n    throw new UnauthorizedError(req.t)\n  }\n\n  const collection = 'payload-preferences'\n\n  const where: Where = {\n    and: [\n      { key: { equals: key } },\n      { 'user.value': { equals: user.id } },\n      { 'user.relationTo': { equals: user.collection } },\n    ],\n  }\n\n  const preference = {\n    key,\n    user: {\n      relationTo: user.collection,\n      value: user.id,\n    },\n    value,\n  }\n\n  return await payload.db.upsert({\n    collection,\n    data: preference,\n    req,\n    where,\n  })\n}\n"],"names":["UnauthorizedError","update","args","key","req","payload","user","value","t","collection","where","and","equals","id","preference","relationTo","db","upsert","data"],"mappings":";;;AAGA,SAASA,iBAAiB,QAAQ,mCAAkC;;AAE7D,eAAeC,OAAOC,IAA6B;IACxD,MAAM,EACJC,GAAG,EACHC,KAAK,EAAEC,OAAO,EAAE,EAChBD,GAAG,EACHE,IAAI,EACJC,KAAK,EACN,GAAGL;IAEJ,IAAI,CAACI,MAAM;QACT,MAAM,kKAAIN,oBAAAA,CAAkBI,IAAII,CAAC;IACnC;IAEA,MAAMC,aAAa;IAEnB,MAAMC,QAAe;QACnBC,KAAK;YACH;gBAAER,KAAK;oBAAES,QAAQT;gBAAI;YAAE;YACvB;gBAAE,cAAc;oBAAES,QAAQN,KAAKO,EAAE;gBAAC;YAAE;YACpC;gBAAE,mBAAmB;oBAAED,QAAQN,KAAKG,UAAU;gBAAC;YAAE;SAClD;IACH;IAEA,MAAMK,aAAa;QACjBX;QACAG,MAAM;YACJS,YAAYT,KAAKG,UAAU;YAC3BF,OAAOD,KAAKO,EAAE;QAChB;QACAN;IACF;IAEA,OAAO,MAAMF,QAAQW,EAAE,CAACC,MAAM,CAAC;QAC7BR;QACAS,MAAMJ;QACNV;QACAM;IACF;AACF"}},
    {"offset": {"line": 16393, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 16399, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/payload/src/preferences/requestHandlers/update.ts"],"sourcesContent":["import httpStatus from 'http-status'\n\nimport type { PayloadHandler } from '../../config/types.js'\nimport type { PayloadRequest } from '../../types/index.js'\n\nimport { update } from '../operations/update.js'\n\nexport const updateHandler: PayloadHandler = async (incomingReq) => {\n  // We cannot import the addDataAndFileToRequest utility here from the 'next' package because of dependency issues\n  // However that utility should be used where possible instead of manually appending the data\n  let data\n\n  try {\n    data = await incomingReq.json()\n  } catch (error) {\n    data = {}\n  }\n\n  const reqWithData: PayloadRequest = incomingReq\n\n  if (data) {\n    reqWithData.data = data\n    reqWithData.json = () => Promise.resolve(data)\n  }\n\n  const doc = await update({\n    key: reqWithData.routeParams?.key as string,\n    req: reqWithData,\n    user: reqWithData?.user,\n    value: reqWithData.data.value || reqWithData.data,\n  })\n\n  return Response.json(\n    {\n      doc,\n      message: reqWithData.t('general:updatedSuccessfully'),\n    },\n    {\n      status: httpStatus.OK,\n    },\n  )\n}\n"],"names":["httpStatus","update","updateHandler","incomingReq","data","json","error","reqWithData","Promise","resolve","doc","key","routeParams","req","user","value","Response","message","t","status","OK"],"mappings":";;;AAAA,OAAOA,gBAAgB,cAAa;AAKpC,SAASC,MAAM,QAAQ,0BAAyB;;;AAEzC,MAAMC,gBAAgC,OAAOC;IAClD,iHAAiH;IACjH,4FAA4F;IAC5F,IAAIC;IAEJ,IAAI;QACFA,OAAO,MAAMD,YAAYE,IAAI;IAC/B,EAAE,OAAOC,OAAO;QACdF,OAAO,CAAC;IACV;IAEA,MAAMG,cAA8BJ;IAEpC,IAAIC,MAAM;QACRG,YAAYH,IAAI,GAAGA;QACnBG,YAAYF,IAAI,GAAG,IAAMG,QAAQC,OAAO,CAACL;IAC3C;IAEA,MAAMM,MAAM,OAAMT,mLAAAA,EAAO;QACvBU,KAAKJ,YAAYK,WAAW,EAAED;QAC9BE,KAAKN;QACLO,MAAMP,aAAaO;QACnBC,OAAOR,YAAYH,IAAI,CAACW,KAAK,IAAIR,YAAYH,IAAI;IACnD;IAEA,OAAOY,SAASX,IAAI,CAClB;QACEK;QACAO,SAASV,YAAYW,CAAC,CAAC;IACzB,GACA;QACEC,uJAAQnB,UAAAA,CAAWoB,EAAE;IACvB;AAEJ,EAAC"}},
    {"offset": {"line": 16433, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 16439, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/payload/src/preferences/preferencesCollection.ts"],"sourcesContent":["import type { CollectionConfig } from '../collections/config/types.js'\nimport type { Access, Config } from '../config/types.js'\n\nimport { deleteHandler } from './requestHandlers/delete.js'\nimport { findByIDHandler } from './requestHandlers/findOne.js'\nimport { updateHandler } from './requestHandlers/update.js'\n\nconst preferenceAccess: Access = ({ req }) => ({\n  'user.value': {\n    equals: req?.user?.id,\n  },\n})\n\nconst getPreferencesCollection = (config: Config): CollectionConfig => ({\n  slug: 'payload-preferences',\n  access: {\n    delete: preferenceAccess,\n    read: preferenceAccess,\n  },\n  admin: {\n    hidden: true,\n  },\n  endpoints: [\n    {\n      handler: findByIDHandler,\n      method: 'get',\n      path: '/:key',\n    },\n    {\n      handler: deleteHandler,\n      method: 'delete',\n      path: '/:key',\n    },\n    {\n      handler: updateHandler,\n      method: 'post',\n      path: '/:key',\n    },\n  ],\n  fields: [\n    {\n      name: 'user',\n      type: 'relationship',\n      hooks: {\n        beforeValidate: [\n          ({ req }) => {\n            if (!req?.user) {\n              return null\n            }\n            return {\n              relationTo: req?.user.collection,\n              value: req?.user.id,\n            }\n          },\n        ],\n      },\n      index: true,\n      relationTo: config.collections\n        .filter((collectionConfig) => collectionConfig.auth)\n        .map((collectionConfig) => collectionConfig.slug),\n      required: true,\n    },\n    {\n      name: 'key',\n      type: 'text',\n      index: true,\n    },\n    {\n      name: 'value',\n      type: 'json',\n    },\n  ],\n  lockDocuments: false,\n})\n\nexport default getPreferencesCollection\n"],"names":["deleteHandler","findByIDHandler","updateHandler","preferenceAccess","req","equals","user","id","getPreferencesCollection","config","slug","access","delete","read","admin","hidden","endpoints","handler","method","path","fields","name","type","hooks","beforeValidate","relationTo","collection","value","index","collections","filter","collectionConfig","auth","map","required","lockDocuments"],"mappings":";;;AAIA,SAASC,eAAe,QAAQ,+BAA8B;AAD9D,SAASD,aAAa,QAAQ,8BAA6B;AAE3D,SAASE,aAAa,QAAQ,8BAA6B;;;;AAE3D,MAAMC,mBAA2B,CAAC,EAAEC,GAAG,EAAE,GAAM,CAAA;QAC7C,cAAc;YACZC,QAAQD,KAAKE,MAAMC;QACrB;IACF,CAAA;AAEA,MAAMC,2BAA2B,CAACC,SAAsC,CAAA;QACtEC,MAAM;QACNC,QAAQ;YACNC,QAAQT;YACRU,MAAMV;QACR;QACAW,OAAO;YACLC,QAAQ;QACV;QACAC,WAAW;YACT;gBACEC,sLAAShB,kBAAAA;gBACTiB,QAAQ;gBACRC,MAAM;YACR;YACA;gBACEF,qLAASjB,gBAAAA;gBACTkB,QAAQ;gBACRC,MAAM;YACR;YACA;gBACEF,oLAASf,iBAAAA;gBACTgB,QAAQ;gBACRC,MAAM;YACR;SACD;QACDC,QAAQ;YACN;gBACEC,MAAM;gBACNC,MAAM;gBACNC,OAAO;oBACLC,gBAAgB;wBACd,CAAC,EAAEpB,GAAG,EAAE;4BACN,IAAI,CAACA,KAAKE,MAAM;gCACd,OAAO;4BACT;4BACA,OAAO;gCACLmB,YAAYrB,KAAKE,KAAKoB;gCACtBC,OAAOvB,KAAKE,KAAKC;4BACnB;wBACF;qBACD;gBACH;gBACAqB,OAAO;gBACPH,YAAYhB,OAAOoB,WAAW,CAC3BC,MAAM,CAAC,CAACC,mBAAqBA,iBAAiBC,IAAI,EAClDC,GAAG,CAAC,CAACF,mBAAqBA,iBAAiBrB,IAAI;gBAClDwB,UAAU;YACZ;YACA;gBACEb,MAAM;gBACNC,MAAM;gBACNM,OAAO;YACT;YACA;gBACEP,MAAM;gBACNC,MAAM;YACR;SACD;QACDa,eAAe;IACjB,CAAA;uCAEe3B,yBAAwB"}},
    {"offset": {"line": 16514, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 16520, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/payload/src/database/migrations/migrationsCollection.ts"],"sourcesContent":["import type { CollectionConfig } from '../../collections/config/types.js'\n\nexport const migrationsCollection: CollectionConfig = {\n  slug: 'payload-migrations',\n  admin: {\n    hidden: true,\n  },\n  endpoints: false,\n  fields: [\n    {\n      name: 'name',\n      type: 'text',\n    },\n    {\n      name: 'batch',\n      type: 'number',\n      // NOTE: This value is -1 if it is a \"dev push\"\n    },\n  ],\n  graphQL: false,\n  lockDocuments: false,\n}\n"],"names":["migrationsCollection","slug","admin","hidden","endpoints","fields","name","type","graphQL","lockDocuments"],"mappings":";;;AAEO,MAAMA,uBAAyC;IACpDC,MAAM;IACNC,OAAO;QACLC,QAAQ;IACV;IACAC,WAAW;IACXC,QAAQ;QACN;YACEC,MAAM;YACNC,MAAM;QACR;QACA;YACED,MAAM;YACNC,MAAM;QAER;KACD;IACDC,SAAS;IACTC,eAAe;AACjB,EAAC"}},
    {"offset": {"line": 16542, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 16548, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/payload/src/auth/defaultAccess.ts"],"sourcesContent":["import type { PayloadRequest } from '../types/index.js'\n\nexport default ({ req: { user } }: { req: PayloadRequest }): boolean => Boolean(user)\n"],"names":["req","user","Boolean"],"mappings":";;;uCAEe,CAAC,EAAEA,KAAK,EAAEC,IAAI,EAAE,EAA2B,GAAcC,QAAQD,KAAI,EAAC"}},
    {"offset": {"line": 16553, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 16559, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/payload/src/collections/config/defaults.ts"],"sourcesContent":["import type { IncomingAuthType, LoginWithUsernameOptions } from '../../auth/types.js'\nimport type { CollectionConfig } from './types.js'\n\nimport defaultAccess from '../../auth/defaultAccess.js'\n\nexport const defaults: Partial<CollectionConfig> = {\n  access: {\n    create: defaultAccess,\n    delete: defaultAccess,\n    read: defaultAccess,\n    unlock: defaultAccess,\n    update: defaultAccess,\n  },\n  admin: {\n    components: {},\n    custom: {},\n    enableRichTextLink: true,\n    enableRichTextRelationship: true,\n    pagination: {\n      defaultLimit: 10,\n      limits: [5, 10, 25, 50, 100],\n    },\n    useAsTitle: 'id',\n  },\n  auth: false,\n  custom: {},\n  endpoints: [],\n  fields: [],\n  hooks: {\n    afterChange: [],\n    afterDelete: [],\n    afterForgotPassword: [],\n    afterLogin: [],\n    afterLogout: [],\n    afterMe: [],\n    afterOperation: [],\n    afterRead: [],\n    afterRefresh: [],\n    beforeChange: [],\n    beforeDelete: [],\n    beforeLogin: [],\n    beforeOperation: [],\n    beforeRead: [],\n    beforeValidate: [],\n    me: [],\n    refresh: [],\n  },\n  timestamps: true,\n  upload: false,\n  versions: false,\n}\n\nexport const authDefaults: IncomingAuthType = {\n  cookies: {\n    sameSite: 'Lax',\n    secure: false,\n  },\n  forgotPassword: {},\n  lockTime: 600000, // 10 minutes\n  loginWithUsername: false,\n  maxLoginAttempts: 5,\n  tokenExpiration: 7200,\n  verify: false,\n}\n\nexport const loginWithUsernameDefaults: LoginWithUsernameOptions = {\n  allowEmailLogin: false,\n  requireEmail: false,\n  requireUsername: true,\n}\n"],"names":["defaultAccess","defaults","access","create","delete","read","unlock","update","admin","components","custom","enableRichTextLink","enableRichTextRelationship","pagination","defaultLimit","limits","useAsTitle","auth","endpoints","fields","hooks","afterChange","afterDelete","afterForgotPassword","afterLogin","afterLogout","afterMe","afterOperation","afterRead","afterRefresh","beforeChange","beforeDelete","beforeLogin","beforeOperation","beforeRead","beforeValidate","me","refresh","timestamps","upload","versions","authDefaults","cookies","sameSite","secure","forgotPassword","lockTime","loginWithUsername","maxLoginAttempts","tokenExpiration","verify","loginWithUsernameDefaults","allowEmailLogin","requireEmail","requireUsername"],"mappings":";;;;;AAGA,OAAOA,mBAAmB,8BAA6B;;AAEhD,MAAMC,WAAsC;IACjDC,QAAQ;QACNC,iKAAQH,UAAAA;QACRI,iKAAQJ,UAAAA;QACRK,+JAAML,UAAAA;QACNM,iKAAQN,UAAAA;QACRO,iKAAQP,UAAAA;IACV;IACAQ,OAAO;QACLC,YAAY,CAAC;QACbC,QAAQ,CAAC;QACTC,oBAAoB;QACpBC,4BAA4B;QAC5BC,YAAY;YACVC,cAAc;YACdC,QAAQ;gBAAC;gBAAG;gBAAI;gBAAI;gBAAI;aAAI;QAC9B;QACAC,YAAY;IACd;IACAC,MAAM;IACNP,QAAQ,CAAC;IACTQ,WAAW,EAAE;IACbC,QAAQ,EAAE;IACVC,OAAO;QACLC,aAAa,EAAE;QACfC,aAAa,EAAE;QACfC,qBAAqB,EAAE;QACvBC,YAAY,EAAE;QACdC,aAAa,EAAE;QACfC,SAAS,EAAE;QACXC,gBAAgB,EAAE;QAClBC,WAAW,EAAE;QACbC,cAAc,EAAE;QAChBC,cAAc,EAAE;QAChBC,cAAc,EAAE;QAChBC,aAAa,EAAE;QACfC,iBAAiB,EAAE;QACnBC,YAAY,EAAE;QACdC,gBAAgB,EAAE;QAClBC,IAAI,EAAE;QACNC,SAAS,EAAE;IACb;IACAC,YAAY;IACZC,QAAQ;IACRC,UAAU;AACZ,EAAC;AAEM,MAAMC,eAAiC;IAC5CC,SAAS;QACPC,UAAU;QACVC,QAAQ;IACV;IACAC,gBAAgB,CAAC;IACjBC,UAAU;IACVC,mBAAmB;IACnBC,kBAAkB;IAClBC,iBAAiB;IACjBC,QAAQ;AACV,EAAC;AAEM,MAAMC,4BAAsD;IACjEC,iBAAiB;IACjBC,cAAc;IACdC,iBAAiB;AACnB,EAAC"}},
    {"offset": {"line": 16635, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 16641, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/payload/src/errors/MissingFieldType.ts"],"sourcesContent":["import type { Field } from '../fields/config/types.js'\n\nimport { fieldAffectsData } from '../fields/config/types.js'\nimport { APIError } from './APIError.js'\n\nexport class MissingFieldType extends APIError {\n  constructor(field: Field) {\n    super(\n      `Field${\n        fieldAffectsData(field) ? ` \"${field.name}\"` : ''\n      } is either missing a field type or it does not match an available field type`,\n    )\n  }\n}\n"],"names":["fieldAffectsData","APIError","MissingFieldType","constructor","field","name"],"mappings":";;;AAEA,SAASA,gBAAgB,QAAQ,4BAA2B;AAC5D,SAASC,QAAQ,QAAQ,gBAAe;;;AAEjC,MAAMC,+KAAyBD,WAAAA;IACpCE,YAAYC,KAAY,CAAE;QACxB,KAAK,CACH,CAAC,KAAK,mKACJJ,mBAAAA,EAAiBI,SAAS,CAAC,EAAE,EAAEA,MAAMC,IAAI,CAAC,CAAC,CAAC,GAAG,GAChD,4EAA4E,CAAC;IAElF;AACF"}},
    {"offset": {"line": 16653, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 16659, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/payload/src/errors/InvalidFieldName.ts"],"sourcesContent":["import type { FieldAffectingData } from '../fields/config/types.js'\n\nimport { APIError } from './APIError.js'\n\nexport class InvalidFieldName extends APIError {\n  constructor(field: FieldAffectingData, fieldName: string) {\n    super(\n      `Field ${field.label} has invalid name '${fieldName}'. Field names can not include periods (.) and must be alphanumeric.`,\n    )\n  }\n}\n"],"names":["APIError","InvalidFieldName","constructor","field","fieldName","label"],"mappings":";;;AAEA,SAASA,QAAQ,QAAQ,gBAAe;;AAEjC,MAAMC,+KAAyBD,WAAAA;IACpCE,YAAYC,KAAyB,EAAEC,SAAiB,CAAE;QACxD,KAAK,CACH,CAAC,MAAM,EAAED,MAAME,KAAK,CAAC,mBAAmB,EAAED,UAAU,oEAAoE,CAAC;IAE7H;AACF"}},
    {"offset": {"line": 16669, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 16675, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/payload/src/utilities/formatLabels.ts"],"sourcesContent":["import pluralize from 'pluralize'\nconst { isPlural, singular } = pluralize\n\nconst capitalizeFirstLetter = (string: string): string =>\n  string.charAt(0).toUpperCase() + string.slice(1)\n\nconst toWords = (inputString: string, joinWords = false): string => {\n  const notNullString = inputString || ''\n  const trimmedString = notNullString.trim()\n  const arrayOfStrings = trimmedString.split(/[\\s-]/)\n\n  const splitStringsArray = []\n  arrayOfStrings.forEach((tempString) => {\n    if (tempString !== '') {\n      const splitWords = tempString.split(/(?=[A-Z])/).join(' ')\n      splitStringsArray.push(capitalizeFirstLetter(splitWords))\n    }\n  })\n\n  return joinWords ? splitStringsArray.join('').replace(/\\s/g, '') : splitStringsArray.join(' ')\n}\n\nconst formatLabels = (slug: string): { plural: string; singular: string } => {\n  const words = toWords(slug)\n  return isPlural(slug)\n    ? {\n        plural: words,\n        singular: singular(words),\n      }\n    : {\n        plural: pluralize(words),\n        singular: words,\n      }\n}\n\nconst formatNames = (slug: string): { plural: string; singular: string } => {\n  const words = toWords(slug, true)\n  return isPlural(slug)\n    ? {\n        plural: words,\n        singular: singular(words),\n      }\n    : {\n        plural: pluralize(words),\n        singular: words,\n      }\n}\n\nexport { formatLabels, formatNames, toWords }\n"],"names":["pluralize","isPlural","singular","capitalizeFirstLetter","string","charAt","toUpperCase","slice","toWords","inputString","joinWords","notNullString","trimmedString","trim","arrayOfStrings","split","splitStringsArray","forEach","tempString","splitWords","join","push","replace","formatLabels","slug","words","plural","formatNames"],"mappings":";;;;;AAAA,OAAOA,eAAe,YAAW;;AACjC,MAAM,EAAEC,QAAQ,EAAEC,QAAQ,EAAE,0IAAGF,UAAAA;AAE/B,MAAMG,wBAAwB,CAACC,SAC7BA,OAAOC,MAAM,CAAC,GAAGC,WAAW,KAAKF,OAAOG,KAAK,CAAC;AAEhD,MAAMC,UAAU,CAACC,aAAqBC,YAAY,KAAK;IACrD,MAAMC,gBAAgBF,eAAe;IACrC,MAAMG,gBAAgBD,cAAcE,IAAI;IACxC,MAAMC,iBAAiBF,cAAcG,KAAK,CAAC;IAE3C,MAAMC,oBAAoB,EAAE;IAC5BF,eAAeG,OAAO,CAAC,CAACC;QACtB,IAAIA,eAAe,IAAI;YACrB,MAAMC,aAAaD,WAAWH,KAAK,CAAC,aAAaK,IAAI,CAAC;YACtDJ,kBAAkBK,IAAI,CAAClB,sBAAsBgB;QAC/C;IACF;IAEA,OAAOT,YAAYM,kBAAkBI,IAAI,CAAC,IAAIE,OAAO,CAAC,OAAO,MAAMN,kBAAkBI,IAAI,CAAC;AAC5F;AAEA,MAAMG,eAAe,CAACC;IACpB,MAAMC,QAAQjB,QAAQgB;IACtB,OAAOvB,SAASuB,QACZ;QACEE,QAAQD;QACRvB,UAAUA,SAASuB;IACrB,IACA;QACEC,mJAAQ1B,UAAAA,EAAUyB;QAClBvB,UAAUuB;IACZ;AACN;AAEA,MAAME,cAAc,CAACH;IACnB,MAAMC,QAAQjB,QAAQgB,MAAM;IAC5B,OAAOvB,SAASuB,QACZ;QACEE,QAAQD;QACRvB,UAAUA,SAASuB;IACrB,IACA;QACEC,mJAAQ1B,UAAAA,EAAUyB;QAClBvB,UAAUuB;IACZ;AACN"}},
    {"offset": {"line": 16719, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 16725, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/payload/src/errors/InvalidFieldJoin.ts"],"sourcesContent":["import type { JoinField } from '../fields/config/types.js'\n\nimport { APIError } from './APIError.js'\n\nexport class InvalidFieldJoin extends APIError {\n  constructor(field: JoinField) {\n    super(\n      `Invalid join field ${field.name}. The config does not have a field '${field.on}' in collection '${field.collection}'.`,\n    )\n  }\n}\n"],"names":["APIError","InvalidFieldJoin","constructor","field","name","on","collection"],"mappings":";;;AAEA,SAASA,QAAQ,QAAQ,gBAAe;;AAEjC,MAAMC,+KAAyBD,WAAAA;IACpCE,YAAYC,KAAgB,CAAE;QAC5B,KAAK,CACH,CAAC,mBAAmB,EAAEA,MAAMC,IAAI,CAAC,oCAAoC,EAAED,MAAME,EAAE,CAAC,iBAAiB,EAAEF,MAAMG,UAAU,CAAC,EAAE,CAAC;IAE3H;AACF"}},
    {"offset": {"line": 16735, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 16741, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/payload/src/fields/config/sanitizeJoinField.ts"],"sourcesContent":["import type { SanitizedJoin, SanitizedJoins } from '../../collections/config/types.js'\nimport type { Config } from '../../config/types.js'\nimport type { JoinField, RelationshipField, UploadField } from './types.js'\n\nimport { APIError } from '../../errors/index.js'\nimport { InvalidFieldJoin } from '../../errors/InvalidFieldJoin.js'\nimport { traverseFields } from '../../utilities/traverseFields.js'\nexport const sanitizeJoinField = ({\n  config,\n  field,\n  joins,\n  schemaPath,\n}: {\n  config: Config\n  field: JoinField\n  joins?: SanitizedJoins\n  schemaPath?: string\n}) => {\n  // the `joins` arg is not passed for globals or when recursing on fields that do not allow a join field\n  if (typeof joins === 'undefined') {\n    throw new APIError('Join fields cannot be added to arrays, blocks or globals.')\n  }\n  if (!field.maxDepth) {\n    field.maxDepth = 1\n  }\n  const join: SanitizedJoin = {\n    field,\n    schemaPath: `${schemaPath || ''}${schemaPath ? '.' : ''}${field.name}`,\n    targetField: undefined,\n  }\n  const joinCollection = config.collections.find(\n    (collection) => collection.slug === field.collection,\n  )\n  if (!joinCollection) {\n    throw new InvalidFieldJoin(field)\n  }\n  let joinRelationship: RelationshipField | UploadField\n\n  const pathSegments = field.on.split('.') // Split the schema path into segments\n  let currentSegmentIndex = 0\n\n  // Traverse fields and match based on the schema path\n  traverseFields({\n    callback: ({ field, next }) => {\n      if (!('name' in field) || !field.name) {\n        return\n      }\n      const currentSegment = pathSegments[currentSegmentIndex]\n      // match field on path segments\n      if ('name' in field && field.name === currentSegment) {\n        // Check if this is the last segment in the path\n        if (\n          (currentSegmentIndex === pathSegments.length - 1 &&\n            'type' in field &&\n            field.type === 'relationship') ||\n          field.type === 'upload'\n        ) {\n          joinRelationship = field // Return the matched field\n          next()\n          return true\n        } else {\n          // Move to the next path segment and continue traversal\n          currentSegmentIndex++\n        }\n      } else {\n        // skip fields in non-matching path segments\n        next()\n        return\n      }\n    },\n    fields: joinCollection.fields,\n  })\n\n  if (!joinRelationship) {\n    throw new InvalidFieldJoin(join.field)\n  }\n  if (Array.isArray(joinRelationship.relationTo)) {\n    throw new APIError('Join fields cannot be used with polymorphic relationships.')\n  }\n\n  join.targetField = joinRelationship\n\n  // override the join field localized property to use whatever the relationship field has\n  field.localized = joinRelationship.localized\n  // override the join field hasMany property to use whatever the relationship field has\n  field.hasMany = joinRelationship.hasMany\n\n  if (!joins[field.collection]) {\n    joins[field.collection] = [join]\n  } else {\n    joins[field.collection].push(join)\n  }\n}\n"],"names":["APIError","InvalidFieldJoin","traverseFields","sanitizeJoinField","config","field","joins","schemaPath","maxDepth","join","name","targetField","undefined","joinCollection","collections","find","collection","slug","joinRelationship","pathSegments","on","split","currentSegmentIndex","callback","next","currentSegment","length","type","fields","Array","isArray","relationTo","localized","hasMany","push"],"mappings":";;;AAIA,SAASA,QAAQ,QAAQ,wBAAuB;AAChD,SAASC,gBAAgB,QAAQ,mCAAkC;AACnE,SAASC,cAAc,QAAQ,oCAAmC;;;;AAC3D,MAAMC,oBAAoB,CAAC,EAChCC,MAAM,EACNC,KAAK,EACLC,KAAK,EACLC,UAAU,EAMX;IACC,uGAAuG;IACvG,IAAI,OAAOD,UAAU,aAAa;QAChC,MAAM,yJAAIN,YAAAA,CAAS;IACrB;IACA,IAAI,CAACK,MAAMG,QAAQ,EAAE;QACnBH,MAAMG,QAAQ,GAAG;IACnB;IACA,MAAMC,OAAsB;QAC1BJ;QACAE,YAAY,CAAC,EAAEA,cAAc,GAAG,EAAEA,aAAa,MAAM,GAAG,EAAEF,MAAMK,IAAI,CAAC,CAAC;QACtEC,aAAaC;IACf;IACA,MAAMC,iBAAiBT,OAAOU,WAAW,CAACC,IAAI,CAC5C,CAACC,aAAeA,WAAWC,IAAI,KAAKZ,MAAMW,UAAU;IAEtD,IAAI,CAACH,gBAAgB;QACnB,MAAM,kKAAIZ,mBAAAA,CAAiBI;IAC7B;IACA,IAAIa;IAEJ,MAAMC,eAAed,MAAMe,EAAE,CAACC,KAAK,CAAC,KAAK,sCAAsC;;IAC/E,IAAIC,sBAAsB;IAE1B,qDAAqD;QACrDpB,gLAAAA,EAAe;QACbqB,UAAU,CAAC,EAAElB,KAAK,EAAEmB,IAAI,EAAE;YACxB,IAAI,CAAE,CAAA,UAAUnB,KAAI,KAAM,CAACA,MAAMK,IAAI,EAAE;gBACrC;YACF;YACA,MAAMe,iBAAiBN,YAAY,CAACG,oBAAoB;YACxD,+BAA+B;YAC/B,IAAI,UAAUjB,SAASA,MAAMK,IAAI,KAAKe,gBAAgB;gBACpD,gDAAgD;gBAChD,IACGH,wBAAwBH,aAAaO,MAAM,GAAG,KAC7C,UAAUrB,SACVA,MAAMsB,IAAI,KAAK,kBACjBtB,MAAMsB,IAAI,KAAK,UACf;oBACAT,mBAAmBb,MAAM,2BAA2B;;oBACpDmB;oBACA,OAAO;gBACT,OAAO;oBACL,uDAAuD;oBACvDF;gBACF;YACF,OAAO;gBACL,4CAA4C;gBAC5CE;gBACA;YACF;QACF;QACAI,QAAQf,eAAee,MAAM;IAC/B;IAEA,IAAI,CAACV,kBAAkB;QACrB,MAAM,kKAAIjB,mBAAAA,CAAiBQ,KAAKJ,KAAK;IACvC;IACA,IAAIwB,MAAMC,OAAO,CAACZ,iBAAiBa,UAAU,GAAG;QAC9C,MAAM,IAAI/B,iKAAAA,CAAS;IACrB;IAEAS,KAAKE,WAAW,GAAGO;IAEnB,wFAAwF;IACxFb,MAAM2B,SAAS,GAAGd,iBAAiBc,SAAS;IAC5C,sFAAsF;IACtF3B,MAAM4B,OAAO,GAAGf,iBAAiBe,OAAO;IAExC,IAAI,CAAC3B,KAAK,CAACD,MAAMW,UAAU,CAAC,EAAE;QAC5BV,KAAK,CAACD,MAAMW,UAAU,CAAC,GAAG;YAACP;SAAK;IAClC,OAAO;QACLH,KAAK,CAACD,MAAMW,UAAU,CAAC,CAACkB,IAAI,CAACzB;IAC/B;AACF,EAAC"}},
    {"offset": {"line": 16817, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 16823, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/payload/src/errors/InvalidFieldRelationship.ts"],"sourcesContent":["import type { RelationshipField, UploadField } from '../fields/config/types.js'\n\nimport { APIError } from './APIError.js'\n\nexport class InvalidFieldRelationship extends APIError {\n  constructor(field: RelationshipField | UploadField, relationship: string) {\n    super(`Field ${field.label} has invalid relationship '${relationship}'.`)\n  }\n}\n"],"names":["APIError","InvalidFieldRelationship","constructor","field","relationship","label"],"mappings":";;;AAEA,SAASA,QAAQ,QAAQ,gBAAe;;AAEjC,MAAMC,uLAAiCD,WAAAA;IAC5CE,YAAYC,KAAsC,EAAEC,YAAoB,CAAE;QACxE,KAAK,CAAC,CAAC,MAAM,EAAED,MAAME,KAAK,CAAC,2BAA2B,EAAED,aAAa,EAAE,CAAC;IAC1E;AACF"}},
    {"offset": {"line": 16833, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 16839, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/payload/src/fields/baseFields/baseIDField.ts"],"sourcesContent":["import ObjectIdImport from 'bson-objectid'\n\nimport type { TextField } from '../config/types.js'\n\nconst ObjectId = (ObjectIdImport.default ||\n  ObjectIdImport) as unknown as typeof ObjectIdImport.default\n\nexport const baseIDField: TextField = {\n  name: 'id',\n  type: 'text',\n  admin: {\n    hidden: true,\n  },\n  defaultValue: () => new ObjectId().toHexString(),\n  hooks: {\n    beforeChange: [\n      ({ operation, value }) => {\n        // If creating new doc, need to disregard any\n        // ids that have been passed in because they will cause\n        // primary key unique conflicts in relational DBs\n        if (!value || (operation === 'create' && value)) {\n          return new ObjectId().toHexString()\n        }\n\n        return value\n      },\n    ],\n    beforeDuplicate: [\n      () => {\n        return new ObjectId().toHexString()\n      },\n    ],\n  },\n  label: 'ID',\n}\n"],"names":["ObjectIdImport","ObjectId","default","baseIDField","name","type","admin","hidden","defaultValue","toHexString","hooks","beforeChange","operation","value","beforeDuplicate","label"],"mappings":";;;AAAA,OAAOA,oBAAoB,gBAAe;;AAI1C,MAAMC,wJAAYD,UAAAA,CAAeE,OAAO,iJACtCF,UAAAA;AAEK,MAAMG,cAAyB;IACpCC,MAAM;IACNC,MAAM;IACNC,OAAO;QACLC,QAAQ;IACV;IACAC,cAAc,IAAM,IAAIP,WAAWQ,WAAW;IAC9CC,OAAO;QACLC,cAAc;YACZ,CAAC,EAAEC,SAAS,EAAEC,KAAK,EAAE;gBACnB,6CAA6C;gBAC7C,uDAAuD;gBACvD,iDAAiD;gBACjD,IAAI,CAACA,SAAUD,cAAc,YAAYC,OAAQ;oBAC/C,OAAO,IAAIZ,WAAWQ,WAAW;gBACnC;gBAEA,OAAOI;YACT;SACD;QACDC,iBAAiB;YACf;gBACE,OAAO,IAAIb,WAAWQ,WAAW;YACnC;SACD;IACH;IACAM,OAAO;AACT,EAAC"}},
    {"offset": {"line": 16872, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 16878, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/payload/src/errors/DuplicateFieldName.ts"],"sourcesContent":["import { APIError } from './APIError.js'\n\nexport class DuplicateFieldName extends APIError {\n  constructor(fieldName: string) {\n    super(\n      `A field with the name '${fieldName}' was found multiple times on the same level. Field names must be unique.`,\n    )\n  }\n}\n"],"names":["APIError","DuplicateFieldName","constructor","fieldName"],"mappings":";;;AAAA,SAASA,QAAQ,QAAQ,gBAAe;;AAEjC,MAAMC,iLAA2BD,WAAAA;IACtCE,YAAYC,SAAiB,CAAE;QAC7B,KAAK,CACH,CAAC,uBAAuB,EAAEA,UAAU,yEAAyE,CAAC;IAElH;AACF"}},
    {"offset": {"line": 16888, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 16894, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/payload/src/fields/setDefaultBeforeDuplicate.ts"],"sourcesContent":["// default beforeDuplicate hook for required and unique fields\nimport type { FieldAffectingData, FieldHook } from './config/types.js'\n\nconst unique: FieldHook = ({ value }) => (typeof value === 'string' ? `${value} - Copy` : undefined)\nconst localizedUnique: FieldHook = ({ req, value }) =>\n  value ? `${value} - ${req?.t('general:copy') ?? 'Copy'}` : undefined\nconst uniqueRequired: FieldHook = ({ value }) => `${value} - Copy`\nconst localizedUniqueRequired: FieldHook = ({ req, value }) =>\n  `${value} - ${req?.t('general:copy') ?? 'Copy'}`\n\nexport const setDefaultBeforeDuplicate = (field: FieldAffectingData) => {\n  if (\n    (('required' in field && field.required) || field.unique) &&\n    (!field.hooks?.beforeDuplicate ||\n      (Array.isArray(field.hooks.beforeDuplicate) && field.hooks.beforeDuplicate.length === 0))\n  ) {\n    if ((field.type === 'text' || field.type === 'textarea') && field.required && field.unique) {\n      field.hooks.beforeDuplicate = [field.localized ? localizedUniqueRequired : uniqueRequired]\n    } else if (field.unique) {\n      field.hooks.beforeDuplicate = [field.localized ? localizedUnique : unique]\n    }\n  }\n}\n"],"names":["unique","value","undefined","localizedUnique","req","t","uniqueRequired","localizedUniqueRequired","setDefaultBeforeDuplicate","field","required","hooks","beforeDuplicate","Array","isArray","length","type","localized"],"mappings":"AAAA,8DAA8D;;;;AAG9D,MAAMA,SAAoB,CAAC,EAAEC,KAAK,EAAE,GAAM,OAAOA,UAAU,WAAW,CAAC,EAAEA,MAAM,OAAO,CAAC,GAAGC;AAC1F,MAAMC,kBAA6B,CAAC,EAAEC,GAAG,EAAEH,KAAK,EAAE,GAChDA,QAAQ,CAAC,EAAEA,MAAM,GAAG,EAAEG,KAAKC,EAAE,mBAAmB,OAAO,CAAC,GAAGH;AAC7D,MAAMI,iBAA4B,CAAC,EAAEL,KAAK,EAAE,GAAK,CAAC,EAAEA,MAAM,OAAO,CAAC;AAClE,MAAMM,0BAAqC,CAAC,EAAEH,GAAG,EAAEH,KAAK,EAAE,GACxD,CAAC,EAAEA,MAAM,GAAG,EAAEG,KAAKC,EAAE,mBAAmB,OAAO,CAAC;AAE3C,MAAMG,4BAA4B,CAACC;IACxC,IACG,CAAC,cAAcA,SAASA,MAAMC,QAAQ,IAAKD,MAAMT,MAAK,KACtD,CAAA,CAACS,MAAME,KAAK,EAAEC,mBACZC,MAAMC,OAAO,CAACL,MAAME,KAAK,CAACC,eAAe,KAAKH,MAAME,KAAK,CAACC,eAAe,CAACG,MAAM,KAAK,CAAC,GACzF;QACA,IAAKN,CAAAA,MAAMO,IAAI,KAAK,UAAUP,MAAMO,IAAI,KAAK,UAAS,KAAMP,MAAMC,QAAQ,IAAID,MAAMT,MAAM,EAAE;YAC1FS,MAAME,KAAK,CAACC,eAAe,GAAG;gBAACH,MAAMQ,SAAS,GAAGV,0BAA0BD;aAAe;QAC5F,OAAO,IAAIG,MAAMT,MAAM,EAAE;YACvBS,MAAME,KAAK,CAACC,eAAe,GAAG;gBAACH,MAAMQ,SAAS,GAAGd,kBAAkBH;aAAO;QAC5E;IACF;AACF,EAAC"}},
    {"offset": {"line": 16915, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 16921, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/payload/src/fields/baseFields/baseBlockFields.ts"],"sourcesContent":["import type { Field } from '../config/types.js'\n\nimport { baseIDField } from './baseIDField.js'\n\nexport const baseBlockFields: Field[] = [\n  baseIDField,\n  {\n    name: 'blockName',\n    type: 'text',\n    admin: {\n      disabled: true,\n    },\n    label: 'Block Name',\n    required: false,\n  },\n]\n"],"names":["baseIDField","baseBlockFields","name","type","admin","disabled","label","required"],"mappings":";;;AAEA,SAASA,WAAW,QAAQ,mBAAkB;;AAEvC,MAAMC,kBAA2B;2KACtCD,cAAAA;IACA;QACEE,MAAM;QACNC,MAAM;QACNC,OAAO;YACLC,UAAU;QACZ;QACAC,OAAO;QACPC,UAAU;IACZ;CACD,CAAA"}},
    {"offset": {"line": 16938, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 16944, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/payload/src/fields/config/sanitize.ts"],"sourcesContent":["import { deepMergeSimple } from '@payloadcms/translations/utilities'\n\nimport type { CollectionConfig, SanitizedJoins } from '../../collections/config/types.js'\nimport type { Config, SanitizedConfig } from '../../config/types.js'\nimport type { Field } from './types.js'\n\nimport {\n  DuplicateFieldName,\n  InvalidFieldName,\n  InvalidFieldRelationship,\n  MissingEditorProp,\n  MissingFieldType,\n} from '../../errors/index.js'\nimport { formatLabels, toWords } from '../../utilities/formatLabels.js'\nimport { baseBlockFields } from '../baseFields/baseBlockFields.js'\nimport { baseIDField } from '../baseFields/baseIDField.js'\nimport { setDefaultBeforeDuplicate } from '../setDefaultBeforeDuplicate.js'\nimport validations from '../validations.js'\nimport { sanitizeJoinField } from './sanitizeJoinField.js'\nimport { fieldAffectsData, tabHasName } from './types.js'\n\ntype Args = {\n  collectionConfig?: CollectionConfig\n  config: Config\n  existingFieldNames?: Set<string>\n  fields: Field[]\n  /**\n   * When not passed in, assume that join are not supported (globals, arrays, blocks)\n   */\n  joins?: SanitizedJoins\n  parentIsLocalized: boolean\n  /**\n   * If true, a richText field will require an editor property to be set, as the sanitizeFields function will not add it from the payload config if not present.\n   *\n   * @default false\n   */\n  requireFieldLevelRichTextEditor?: boolean\n\n  /**\n   * If this property is set, RichText fields won't be sanitized immediately. Instead, they will be added to this array as promises\n   * so that you can sanitize them together, after the config has been sanitized.\n   */\n  richTextSanitizationPromises?: Array<(config: SanitizedConfig) => Promise<void>>\n  schemaPath?: string\n  /**\n   * If not null, will validate that upload and relationship fields do not relate to a collection that is not in this array.\n   * This validation will be skipped if validRelationships is null.\n   */\n  validRelationships: null | string[]\n}\n\nfunction generateSchemaPath({ name, path = '' }: { name?: string; path?: string }): string {\n  if (!name) {\n    return path\n  }\n  return path ? `${path}.${name}` : name\n}\n\nexport const sanitizeFields = async ({\n  config,\n  existingFieldNames = new Set(),\n  fields,\n  joins,\n  parentIsLocalized,\n  requireFieldLevelRichTextEditor = false,\n  richTextSanitizationPromises,\n  schemaPath = '',\n  validRelationships,\n}: Args): Promise<Field[]> => {\n  if (!fields) {\n    return []\n  }\n\n  for (let i = 0; i < fields.length; i++) {\n    const field = fields[i]\n\n    if ('_sanitized' in field && field._sanitized === true) {\n      continue\n    }\n\n    if (!field.type) {\n      throw new MissingFieldType(field)\n    }\n\n    // assert that field names do not contain forbidden characters\n    if (fieldAffectsData(field) && field.name.includes('.')) {\n      throw new InvalidFieldName(field, field.name)\n    }\n\n    // Auto-label\n    if (\n      'name' in field &&\n      field.name &&\n      typeof field.label !== 'object' &&\n      typeof field.label !== 'string' &&\n      typeof field.label !== 'function' &&\n      field.label !== false\n    ) {\n      field.label = toWords(field.name)\n    }\n\n    if (\n      field.type === 'checkbox' &&\n      typeof field.defaultValue === 'undefined' &&\n      field.required === true\n    ) {\n      field.defaultValue = false\n    }\n\n    if (field.type === 'join') {\n      sanitizeJoinField({ config, field, joins, schemaPath })\n    }\n\n    if (field.type === 'relationship' || field.type === 'upload') {\n      if (validRelationships) {\n        const relationships = Array.isArray(field.relationTo)\n          ? field.relationTo\n          : [field.relationTo]\n        relationships.forEach((relationship: string) => {\n          if (!validRelationships.includes(relationship)) {\n            throw new InvalidFieldRelationship(field, relationship)\n          }\n        })\n      }\n\n      if (field.min && !field.minRows) {\n        console.warn(\n          `(payload): The \"min\" property is deprecated for the Relationship field \"${field.name}\" and will be removed in a future version. Please use \"minRows\" instead.`,\n        )\n      }\n      if (field.max && !field.maxRows) {\n        console.warn(\n          `(payload): The \"max\" property is deprecated for the Relationship field \"${field.name}\" and will be removed in a future version. Please use \"maxRows\" instead.`,\n        )\n      }\n      field.minRows = field.minRows || field.min\n      field.maxRows = field.maxRows || field.max\n    }\n\n    if (field.type === 'upload') {\n      if (!field.admin || !('isSortable' in field.admin)) {\n        field.admin = {\n          isSortable: true,\n          ...field.admin,\n        }\n      }\n    }\n\n    if (field.type === 'array' && field.fields) {\n      field.fields.push(baseIDField)\n    }\n\n    if ((field.type === 'blocks' || field.type === 'array') && field.label) {\n      field.labels = field.labels || formatLabels(field.name)\n    }\n\n    if (fieldAffectsData(field)) {\n      if (existingFieldNames.has(field.name)) {\n        throw new DuplicateFieldName(field.name)\n      } else if (!['blockName', 'id'].includes(field.name)) {\n        existingFieldNames.add(field.name)\n      }\n\n      if (typeof field.localized !== 'undefined') {\n        let shouldDisableLocalized = !config.localization\n\n        if (!config.compatibility?.allowLocalizedWithinLocalized && parentIsLocalized) {\n          shouldDisableLocalized = true\n        }\n\n        if (shouldDisableLocalized) {\n          delete field.localized\n        }\n      }\n\n      if (typeof field.validate === 'undefined') {\n        const defaultValidate = validations[field.type]\n        if (defaultValidate) {\n          field.validate = (val, options) => defaultValidate(val, { ...field, ...options })\n        } else {\n          field.validate = (): true => true\n        }\n      }\n\n      if (typeof field.virtual === 'undefined') {\n        field.virtual = false\n      }\n\n      if (!field.hooks) {\n        field.hooks = {}\n      }\n      if (!field.access) {\n        field.access = {}\n      }\n\n      setDefaultBeforeDuplicate(field)\n    }\n\n    if (!field.admin) {\n      field.admin = {}\n    }\n\n    // Make sure that the richText field has an editor\n    if (field.type === 'richText') {\n      const sanitizeRichText = async (_config: SanitizedConfig) => {\n        if (!field.editor) {\n          if (_config.editor && !requireFieldLevelRichTextEditor) {\n            // config.editor should be sanitized at this point\n            field.editor = _config.editor\n          } else {\n            throw new MissingEditorProp(field) // while we allow disabling editor functionality, you should not have any richText fields defined if you do not have an editor\n          }\n        }\n\n        if (typeof field.editor === 'function') {\n          field.editor = await field.editor({\n            config: _config,\n            isRoot: requireFieldLevelRichTextEditor,\n            parentIsLocalized: parentIsLocalized || field.localized,\n          })\n        }\n\n        if (field.editor.i18n && Object.keys(field.editor.i18n).length >= 0) {\n          config.i18n.translations = deepMergeSimple(config.i18n.translations, field.editor.i18n)\n        }\n      }\n      if (richTextSanitizationPromises) {\n        richTextSanitizationPromises.push(sanitizeRichText)\n      } else {\n        await sanitizeRichText(config as unknown as SanitizedConfig)\n      }\n    }\n\n    if (field.type === 'blocks' && field.blocks) {\n      for (const block of field.blocks) {\n        if (block._sanitized === true) {\n          continue\n        }\n        block._sanitized = true\n        block.fields = block.fields.concat(baseBlockFields)\n        block.labels = !block.labels ? formatLabels(block.slug) : block.labels\n        block.fields = await sanitizeFields({\n          config,\n          existingFieldNames: new Set(),\n          fields: block.fields,\n          parentIsLocalized: parentIsLocalized || field.localized,\n          requireFieldLevelRichTextEditor,\n          richTextSanitizationPromises,\n          validRelationships,\n        })\n      }\n    }\n\n    if ('fields' in field && field.fields) {\n      field.fields = await sanitizeFields({\n        config,\n        existingFieldNames: fieldAffectsData(field) ? new Set() : existingFieldNames,\n        fields: field.fields,\n        joins,\n        parentIsLocalized: parentIsLocalized || field.localized,\n        requireFieldLevelRichTextEditor,\n        richTextSanitizationPromises,\n        schemaPath: generateSchemaPath({\n          name: 'name' in field ? field.name : undefined,\n          path: schemaPath,\n        }),\n        validRelationships,\n      })\n    }\n\n    if (field.type === 'tabs') {\n      for (let j = 0; j < field.tabs.length; j++) {\n        const tab = field.tabs[j]\n        if (tabHasName(tab)) {\n          if (typeof tab.label === 'undefined') {\n            tab.label = toWords(tab.name)\n          }\n        }\n\n        tab.fields = await sanitizeFields({\n          config,\n          existingFieldNames: tabHasName(tab) ? new Set() : existingFieldNames,\n          fields: tab.fields,\n          joins,\n          parentIsLocalized: parentIsLocalized || (tabHasName(tab) && tab.localized),\n          requireFieldLevelRichTextEditor,\n          richTextSanitizationPromises,\n          schemaPath: generateSchemaPath({\n            name: 'name' in tab ? tab.name : undefined,\n            path: schemaPath,\n          }),\n          validRelationships,\n        })\n        field.tabs[j] = tab\n      }\n    }\n\n    if (field.type === 'ui' && typeof field.admin.disableBulkEdit === 'undefined') {\n      field.admin.disableBulkEdit = true\n    }\n\n    if ('_sanitized' in field) {\n      field._sanitized = true\n    }\n\n    fields[i] = field\n  }\n\n  return fields\n}\n"],"names":["deepMergeSimple","DuplicateFieldName","InvalidFieldName","InvalidFieldRelationship","MissingEditorProp","MissingFieldType","formatLabels","toWords","baseBlockFields","baseIDField","setDefaultBeforeDuplicate","validations","sanitizeJoinField","fieldAffectsData","tabHasName","generateSchemaPath","name","path","sanitizeFields","config","existingFieldNames","Set","fields","joins","parentIsLocalized","requireFieldLevelRichTextEditor","richTextSanitizationPromises","schemaPath","validRelationships","i","length","field","_sanitized","type","includes","label","defaultValue","required","relationships","Array","isArray","relationTo","forEach","relationship","min","minRows","console","warn","max","maxRows","admin","isSortable","push","labels","has","add","localized","shouldDisableLocalized","localization","compatibility","allowLocalizedWithinLocalized","validate","defaultValidate","val","options","virtual","hooks","access","sanitizeRichText","_config","editor","isRoot","i18n","Object","keys","translations","blocks","block","concat","slug","undefined","j","tabs","tab","disableBulkEdit"],"mappings":"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"}},
    {"offset": {"line": 17183, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 17189, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/payload/src/errors/TimestampsRequired.ts"],"sourcesContent":["import type { CollectionConfig } from '../collections/config/types.js'\n\nimport { APIError } from './APIError.js'\n\nexport class TimestampsRequired extends APIError {\n  constructor(collection: CollectionConfig) {\n    super(\n      `Timestamps are required in the collection ${collection.slug} because you have opted in to Versions.`,\n    )\n  }\n}\n"],"names":["APIError","TimestampsRequired","constructor","collection","slug"],"mappings":";;;AAEA,SAASA,QAAQ,QAAQ,gBAAe;;AAEjC,MAAMC,iLAA2BD,WAAAA;IACtCE,YAAYC,UAA4B,CAAE;QACxC,KAAK,CACH,CAAC,0CAA0C,EAAEA,WAAWC,IAAI,CAAC,uCAAuC,CAAC;IAEzG;AACF"}},
    {"offset": {"line": 17199, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 17205, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/payload/src/versions/defaults.ts"],"sourcesContent":["export const versionDefaults = {\n  autosaveInterval: 2000,\n}\n"],"names":["versionDefaults","autosaveInterval"],"mappings":";;;AAAO,MAAMA,kBAAkB;IAC7BC,kBAAkB;AACpB,EAAC"}},
    {"offset": {"line": 17211, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 17217, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/payload/src/fields/mergeBaseFields.ts"],"sourcesContent":["import type { Field, FieldWithSubFields } from './config/types.js'\n\nimport { deepMergeWithReactComponents } from '../utilities/deepMerge.js'\nimport { fieldAffectsData, fieldHasSubFields } from './config/types.js'\n\nconst mergeBaseFields = (fields: Field[], baseFields: Field[]): Field[] => {\n  const mergedFields = [...(fields || [])]\n\n  baseFields.forEach((baseField) => {\n    let matchedIndex = null\n\n    if (fieldAffectsData(baseField)) {\n      const match = mergedFields.find((field, i) => {\n        if (fieldAffectsData(field) && field.name === baseField.name) {\n          matchedIndex = i\n          return true\n        }\n\n        return false\n      })\n\n      if (match) {\n        const matchCopy: Field = { ...match }\n        mergedFields.splice(matchedIndex, 1)\n\n        const mergedField = deepMergeWithReactComponents<Field>(baseField, matchCopy)\n\n        if (fieldHasSubFields(baseField) && fieldHasSubFields(matchCopy)) {\n          ;(mergedField as FieldWithSubFields).fields = mergeBaseFields(\n            matchCopy.fields,\n            baseField.fields,\n          )\n        }\n\n        mergedFields.push(mergedField)\n      } else {\n        mergedFields.push(baseField)\n      }\n    }\n  })\n\n  return mergedFields\n}\n\nexport default mergeBaseFields\n"],"names":["deepMergeWithReactComponents","fieldAffectsData","fieldHasSubFields","mergeBaseFields","fields","baseFields","mergedFields","forEach","baseField","matchedIndex","match","find","field","i","name","matchCopy","splice","mergedField","push"],"mappings":";;;AAGA,SAASC,gBAAgB,EAAEC,iBAAiB,QAAQ,oBAAmB;AADvE,SAASF,4BAA4B,QAAQ,4BAA2B;;;AAGxE,MAAMG,kBAAkB,CAACC,QAAiBC;IACxC,MAAMC,eAAe;WAAKF,UAAU,EAAE;KAAE;IAExCC,WAAWE,OAAO,CAAC,CAACC;QAClB,IAAIC,eAAe;QAEnB,KAAIR,mLAAAA,EAAiBO,YAAY;YAC/B,MAAME,QAAQJ,aAAaK,IAAI,CAAC,CAACC,OAAOC;gBACtC,KAAIZ,mLAAAA,EAAiBW,UAAUA,MAAME,IAAI,KAAKN,UAAUM,IAAI,EAAE;oBAC5DL,eAAeI;oBACf,OAAO;gBACT;gBAEA,OAAO;YACT;YAEA,IAAIH,OAAO;gBACT,MAAMK,YAAmB;oBAAE,GAAGL,KAAK;gBAAC;gBACpCJ,aAAaU,MAAM,CAACP,cAAc;gBAElC,MAAMQ,4LAAcjB,+BAAAA,EAAoCQ,WAAWO;gBAEnE,qKAAIb,oBAAAA,EAAkBM,+KAAcN,oBAAAA,EAAkBa,YAAY;oBAC9DE,YAAmCb,MAAM,GAAGD,gBAC5CY,UAAUX,MAAM,EAChBI,UAAUJ,MAAM;gBAEpB;gBAEAE,aAAaY,IAAI,CAACD;YACpB,OAAO;gBACLX,aAAaY,IAAI,CAACV;YACpB;QACF;IACF;IAEA,OAAOF;AACT;uCAEeH,gBAAe"}},
    {"offset": {"line": 17257, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 17263, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/payload/src/errors/ReservedFieldName.ts"],"sourcesContent":["import type { FieldAffectingData } from '../fields/config/types.js'\n\nimport { APIError } from './APIError.js'\n\nexport class ReservedFieldName extends APIError {\n  constructor(field: FieldAffectingData, fieldName: string) {\n    super(`Field ${field.label} has reserved name '${fieldName}'.`)\n  }\n}\n"],"names":["APIError","ReservedFieldName","constructor","field","fieldName","label"],"mappings":";;;AAEA,SAASA,QAAQ,QAAQ,gBAAe;;AAEjC,MAAMC,gLAA0BD,WAAAA;IACrCE,YAAYC,KAAyB,EAAEC,SAAiB,CAAE;QACxD,KAAK,CAAC,CAAC,MAAM,EAAED,MAAME,KAAK,CAAC,oBAAoB,EAAED,UAAU,EAAE,CAAC;IAChE;AACF"}},
    {"offset": {"line": 17273, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 17279, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/payload/src/collections/config/reservedFieldNames.ts"],"sourcesContent":["import type { Field } from '../../fields/config/types.js'\nimport type { CollectionConfig } from '../../index.js'\n\nimport { ReservedFieldName } from '../../errors/ReservedFieldName.js'\nimport { fieldAffectsData } from '../../fields/config/types.js'\n\n// Note for future reference: We've slimmed down the reserved field names but left them in here for reference in case it's needed in the future.\n\n/**\n * Reserved field names for collections with auth config enabled\n */\nconst reservedBaseAuthFieldNames = [\n  /* 'email',\n  'resetPasswordToken',\n  'resetPasswordExpiration', */\n  'salt',\n  'hash',\n]\n/**\n * Reserved field names for auth collections with verify: true\n */\nconst reservedVerifyFieldNames = [\n  /* '_verified', '_verificationToken' */\n]\n/**\n * Reserved field names for auth collections with useApiKey: true\n */\nconst reservedAPIKeyFieldNames = [\n  /* 'enableAPIKey', 'apiKeyIndex', 'apiKey' */\n]\n\n/**\n * Reserved field names for collections with upload config enabled\n */\nconst reservedBaseUploadFieldNames = [\n  'file',\n  /* 'mimeType',\n  'thumbnailURL',\n  'width',\n  'height',\n  'filesize',\n  'filename',\n  'url',\n  'focalX',\n  'focalY',\n  'sizes', */\n]\n\n/**\n * Reserved field names for collections with versions enabled\n */\nconst reservedVersionsFieldNames = [\n  /* '__v', '_status' */\n]\n\n/**\n * Sanitize fields for collections with auth config enabled.\n *\n * Should run on top level fields only.\n */\nexport const sanitizeAuthFields = (fields: Field[], config: CollectionConfig) => {\n  for (let i = 0; i < fields.length; i++) {\n    const field = fields[i]\n\n    if (fieldAffectsData(field) && field.name) {\n      if (config.auth && typeof config.auth === 'object' && !config.auth.disableLocalStrategy) {\n        const auth = config.auth\n\n        if (reservedBaseAuthFieldNames.includes(field.name)) {\n          throw new ReservedFieldName(field, field.name)\n        }\n\n        if (auth.verify) {\n          if (reservedAPIKeyFieldNames.includes(field.name)) {\n            throw new ReservedFieldName(field, field.name)\n          }\n        }\n\n        /* if (auth.maxLoginAttempts) {\n          if (field.name === 'loginAttempts' || field.name === 'lockUntil') {\n            throw new ReservedFieldName(field, field.name)\n          }\n        } */\n\n        /* if (auth.loginWithUsername) {\n          if (field.name === 'username') {\n            throw new ReservedFieldName(field, field.name)\n          }\n        } */\n\n        if (auth.verify) {\n          if (reservedVerifyFieldNames.includes(field.name)) {\n            throw new ReservedFieldName(field, field.name)\n          }\n        }\n      }\n    }\n\n    // Handle tabs without a name\n    if (field.type === 'tabs') {\n      for (let j = 0; j < field.tabs.length; j++) {\n        const tab = field.tabs[j]\n\n        if (!('name' in tab)) {\n          sanitizeAuthFields(tab.fields, config)\n        }\n      }\n    }\n\n    // Handle presentational fields like rows and collapsibles\n    if (!fieldAffectsData(field) && 'fields' in field && field.fields) {\n      sanitizeAuthFields(field.fields, config)\n    }\n  }\n}\n\n/**\n * Sanitize fields for collections with upload config enabled.\n *\n * Should run on top level fields only.\n */\nexport const sanitizeUploadFields = (fields: Field[], config: CollectionConfig) => {\n  if (config.upload && typeof config.upload === 'object') {\n    for (let i = 0; i < fields.length; i++) {\n      const field = fields[i]\n\n      if (fieldAffectsData(field) && field.name) {\n        if (reservedBaseUploadFieldNames.includes(field.name)) {\n          throw new ReservedFieldName(field, field.name)\n        }\n      }\n\n      // Handle tabs without a name\n      if (field.type === 'tabs') {\n        for (let j = 0; j < field.tabs.length; j++) {\n          const tab = field.tabs[j]\n\n          if (!('name' in tab)) {\n            sanitizeUploadFields(tab.fields, config)\n          }\n        }\n      }\n\n      // Handle presentational fields like rows and collapsibles\n      if (!fieldAffectsData(field) && 'fields' in field && field.fields) {\n        sanitizeUploadFields(field.fields, config)\n      }\n    }\n  }\n}\n"],"names":["ReservedFieldName","fieldAffectsData","reservedBaseAuthFieldNames","reservedVerifyFieldNames","reservedAPIKeyFieldNames","reservedBaseUploadFieldNames","reservedVersionsFieldNames","sanitizeAuthFields","fields","config","i","length","field","name","auth","disableLocalStrategy","includes","verify","type","j","tabs","tab","sanitizeUploadFields","upload"],"mappings":"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"}},
    {"offset": {"line": 17379, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 17385, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/payload/src/uploads/mimeTypeValidator.ts"],"sourcesContent":["import type { Validate } from '../fields/config/types.js'\n\nexport const mimeTypeValidator =\n  (mimeTypes: string[]): Validate =>\n  (val: string, { siblingData }) => {\n    if (!siblingData.filename) {\n      return true\n    }\n\n    if (!val) {\n      return 'Invalid file type'\n    }\n\n    const cleanedMimeTypes = mimeTypes.map((v) => v.replace('*', ''))\n    return !cleanedMimeTypes.some((v) => val.startsWith(v)) ? `Invalid file type: '${val}'` : true\n  }\n"],"names":["mimeTypeValidator","mimeTypes","val","siblingData","filename","cleanedMimeTypes","map","v","replace","some","startsWith"],"mappings":";;;AAEO,MAAMA,oBACX,CAACC,YACD,CAACC,KAAa,EAAEC,WAAW,EAAE;QAC3B,IAAI,CAACA,YAAYC,QAAQ,EAAE;YACzB,OAAO;QACT;QAEA,IAAI,CAACF,KAAK;YACR,OAAO;QACT;QAEA,MAAMG,mBAAmBJ,UAAUK,GAAG,CAAC,CAACC,IAAMA,EAAEC,OAAO,CAAC,KAAK;QAC7D,OAAO,CAACH,iBAAiBI,IAAI,CAAC,CAACF,IAAML,IAAIQ,UAAU,CAACH,MAAM,CAAC,oBAAoB,EAAEL,IAAI,CAAC,CAAC,GAAG;IAC5F,EAAC"}},
    {"offset": {"line": 17398, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 17404, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/payload/src/uploads/getBaseFields.ts"],"sourcesContent":["import type { CollectionConfig } from '../collections/config/types.js'\nimport type { Config } from '../config/types.js'\nimport type { Field } from '../fields/config/types.js'\nimport type { UploadConfig } from './types.js'\n\nimport { mimeTypeValidator } from './mimeTypeValidator.js'\n\ntype GenerateURLArgs = {\n  collectionSlug: string\n  config: Config\n  filename?: string\n}\nconst generateURL = ({ collectionSlug, config, filename }: GenerateURLArgs) => {\n  if (filename) {\n    return `${config.serverURL || ''}${config.routes.api || ''}/${collectionSlug}/file/${filename}`\n  }\n  return undefined\n}\n\ntype Options = {\n  collection: CollectionConfig\n  config: Config\n}\n\nexport const getBaseUploadFields = ({ collection, config }: Options): Field[] => {\n  const uploadOptions: UploadConfig = typeof collection.upload === 'object' ? collection.upload : {}\n\n  const mimeType: Field = {\n    name: 'mimeType',\n    type: 'text',\n    admin: {\n      hidden: true,\n      readOnly: true,\n    },\n    label: 'MIME Type',\n  }\n\n  const thumbnailURL: Field = {\n    name: 'thumbnailURL',\n    type: 'text',\n    admin: {\n      hidden: true,\n      readOnly: true,\n    },\n    hooks: {\n      afterRead: [\n        ({ originalDoc }) => {\n          const adminThumbnail =\n            typeof collection.upload !== 'boolean' ? collection.upload?.adminThumbnail : undefined\n\n          if (typeof adminThumbnail === 'function') {\n            return adminThumbnail({ doc: originalDoc })\n          }\n\n          if (\n            typeof adminThumbnail === 'string' &&\n            'sizes' in originalDoc &&\n            originalDoc.sizes?.[adminThumbnail]?.filename\n          ) {\n            return generateURL({\n              collectionSlug: collection.slug,\n              config,\n              filename: originalDoc.sizes?.[adminThumbnail].filename as string,\n            })\n          }\n\n          return null\n        },\n      ],\n    },\n    label: 'Thumbnail URL',\n  }\n\n  const width: Field = {\n    name: 'width',\n    type: 'number',\n    admin: {\n      hidden: true,\n      readOnly: true,\n    },\n    label: ({ t }) => t('upload:width'),\n  }\n\n  const height: Field = {\n    name: 'height',\n    type: 'number',\n    admin: {\n      hidden: true,\n      readOnly: true,\n    },\n    label: ({ t }) => t('upload:height'),\n  }\n\n  const filesize: Field = {\n    name: 'filesize',\n    type: 'number',\n    admin: {\n      hidden: true,\n      readOnly: true,\n    },\n    label: ({ t }) => t('upload:fileSize'),\n  }\n\n  const filename: Field = {\n    name: 'filename',\n    type: 'text',\n    admin: {\n      disableBulkEdit: true,\n      hidden: true,\n      readOnly: true,\n    },\n    index: true,\n    label: ({ t }) => t('upload:fileName'),\n  }\n\n  // Only set unique: true if the collection does not have a compound index\n  if (\n    collection.upload === true ||\n    (typeof collection.upload === 'object' && !collection.upload.filenameCompoundIndex)\n  ) {\n    filename.unique = true\n  }\n\n  const url: Field = {\n    name: 'url',\n    type: 'text',\n    admin: {\n      hidden: true,\n      readOnly: true,\n    },\n    label: 'URL',\n  }\n\n  let uploadFields: Field[] = [\n    {\n      ...url,\n      hooks: {\n        afterRead: [\n          ({ data, value }) => {\n            if (value && !data.filename) {\n              return value\n            }\n\n            return generateURL({\n              collectionSlug: collection.slug,\n              config,\n              filename: data?.filename,\n            })\n          },\n        ],\n      },\n    },\n    thumbnailURL,\n    filename,\n    mimeType,\n    filesize,\n    width,\n    height,\n  ]\n\n  // Add focal point fields if not disabled\n  if (\n    uploadOptions.focalPoint !== false ||\n    uploadOptions.imageSizes ||\n    uploadOptions.resizeOptions\n  ) {\n    uploadFields = uploadFields.concat(\n      ['focalX', 'focalY'].map((name) => {\n        return {\n          name,\n          type: 'number',\n          admin: {\n            hidden: true,\n          },\n        }\n      }),\n    )\n  }\n\n  if (uploadOptions.mimeTypes) {\n    mimeType.validate = mimeTypeValidator(uploadOptions.mimeTypes)\n  }\n\n  if (uploadOptions.imageSizes) {\n    uploadFields = uploadFields.concat([\n      {\n        name: 'sizes',\n        type: 'group',\n        admin: {\n          hidden: true,\n        },\n        fields: uploadOptions.imageSizes.map((size) => ({\n          name: size.name,\n          type: 'group',\n          admin: {\n            hidden: true,\n          },\n          fields: [\n            {\n              ...url,\n              hooks: {\n                afterRead: [\n                  ({ data, value }) => {\n                    if (value && size.height && size.width && !data.filename) {\n                      return value\n                    }\n\n                    const sizeFilename = data?.sizes?.[size.name]?.filename\n\n                    if (sizeFilename) {\n                      return `${config.serverURL}${config.routes.api}/${collection.slug}/file/${sizeFilename}`\n                    }\n\n                    return null\n                  },\n                ],\n              },\n            },\n            width,\n            height,\n            mimeType,\n            filesize,\n            {\n              ...filename,\n              unique: false,\n            },\n          ],\n          label: size.name,\n        })),\n        label: ({ t }) => t('upload:sizes'),\n      },\n    ])\n  }\n  return uploadFields\n}\n"],"names":["mimeTypeValidator","generateURL","collectionSlug","config","filename","serverURL","routes","api","undefined","getBaseUploadFields","collection","uploadOptions","upload","mimeType","name","type","admin","hidden","readOnly","label","thumbnailURL","hooks","afterRead","originalDoc","adminThumbnail","doc","sizes","slug","width","t","height","filesize","disableBulkEdit","index","filenameCompoundIndex","unique","url","uploadFields","data","value","focalPoint","imageSizes","resizeOptions","concat","map","mimeTypes","validate","fields","size","sizeFilename"],"mappings":"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"}},
    {"offset": {"line": 17598, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 17604, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/payload/src/auth/baseFields/apiKey.ts"],"sourcesContent":["import crypto from 'crypto'\n\nimport type { Field, FieldHook } from '../../fields/config/types.js'\n\nconst encryptKey: FieldHook = ({ req, value }) =>\n  value ? req.payload.encrypt(value as string) : null\nconst decryptKey: FieldHook = ({ req, value }) =>\n  value ? req.payload.decrypt(value as string) : undefined\n\nexport const apiKeyFields = [\n  {\n    name: 'enableAPIKey',\n    type: 'checkbox',\n    admin: {\n      components: {\n        Field: false,\n      },\n    },\n    label: ({ t }) => t('authentication:enableAPIKey'),\n  },\n  {\n    name: 'apiKey',\n    type: 'text',\n    admin: {\n      components: {\n        Field: false,\n      },\n    },\n    hooks: {\n      afterRead: [decryptKey],\n      beforeChange: [encryptKey],\n    },\n    label: ({ t }) => t('authentication:apiKey'),\n  },\n  {\n    name: 'apiKeyIndex',\n    type: 'text',\n    admin: {\n      disabled: true,\n    },\n    hidden: true,\n    hooks: {\n      beforeValidate: [\n        ({ data, req, value }) => {\n          if (data.apiKey === false || data.apiKey === null) {\n            return null\n          }\n          if (data.enableAPIKey === false || data.enableAPIKey === null) {\n            return null\n          }\n          if (data.apiKey) {\n            return crypto\n              .createHmac('sha1', req.payload.secret)\n              .update(data.apiKey as string)\n              .digest('hex')\n          }\n          return value\n        },\n      ],\n    },\n  },\n] as Field[]\n"],"names":["crypto","encryptKey","req","value","payload","encrypt","decryptKey","decrypt","undefined","apiKeyFields","name","type","admin","components","Field","label","t","hooks","afterRead","beforeChange","disabled","hidden","beforeValidate","data","apiKey","enableAPIKey","createHmac","secret","update","digest"],"mappings":";;;AAAA,OAAOA,YAAY,SAAQ;;AAI3B,MAAMC,aAAwB,CAAC,EAAEC,GAAG,EAAEC,KAAK,EAAE,GAC3CA,QAAQD,IAAIE,OAAO,CAACC,OAAO,CAACF,SAAmB;AACjD,MAAMG,aAAwB,CAAC,EAAEJ,GAAG,EAAEC,KAAK,EAAE,GAC3CA,QAAQD,IAAIE,OAAO,CAACG,OAAO,CAACJ,SAAmBK;AAE1C,MAAMC,eAAe;IAC1B;QACEC,MAAM;QACNC,MAAM;QACNC,OAAO;YACLC,YAAY;gBACVC,OAAO;YACT;QACF;QACAC,OAAO,CAAC,EAAEC,CAAC,EAAE,GAAKA,EAAE;IACtB;IACA;QACEN,MAAM;QACNC,MAAM;QACNC,OAAO;YACLC,YAAY;gBACVC,OAAO;YACT;QACF;QACAG,OAAO;YACLC,WAAW;gBAACZ;aAAW;YACvBa,cAAc;gBAAClB;aAAW;QAC5B;QACAc,OAAO,CAAC,EAAEC,CAAC,EAAE,GAAKA,EAAE;IACtB;IACA;QACEN,MAAM;QACNC,MAAM;QACNC,OAAO;YACLQ,UAAU;QACZ;QACAC,QAAQ;QACRJ,OAAO;YACLK,gBAAgB;gBACd,CAAC,EAAEC,IAAI,EAAErB,GAAG,EAAEC,KAAK,EAAE;oBACnB,IAAIoB,KAAKC,MAAM,KAAK,SAASD,KAAKC,MAAM,KAAK,MAAM;wBACjD,OAAO;oBACT;oBACA,IAAID,KAAKE,YAAY,KAAK,SAASF,KAAKE,YAAY,KAAK,MAAM;wBAC7D,OAAO;oBACT;oBACA,IAAIF,KAAKC,MAAM,EAAE;wBACf,uGAAOxB,UAAAA,CACJ0B,UAAU,CAAC,QAAQxB,IAAIE,OAAO,CAACuB,MAAM,EACrCC,MAAM,CAACL,KAAKC,MAAM,EAClBK,MAAM,CAAC;oBACZ;oBACA,OAAO1B;gBACT;aACD;QACH;IACF;CACD,CAAW"}},
    {"offset": {"line": 17665, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 17671, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/payload/src/auth/baseFields/email.ts"],"sourcesContent":["import type { EmailField } from '../../fields/config/types.js'\n\nimport { email } from '../../fields/validations.js'\n\nexport const emailFieldConfig: EmailField = {\n  name: 'email',\n  type: 'email',\n  admin: {\n    components: {\n      Field: false,\n    },\n  },\n  hooks: {\n    beforeChange: [\n      ({ value }) => {\n        if (value) {\n          return value.toLowerCase().trim()\n        }\n      },\n    ],\n  },\n  label: ({ t }) => t('general:email'),\n  required: true,\n  unique: true,\n  validate: email,\n}\n"],"names":["email","emailFieldConfig","name","type","admin","components","Field","hooks","beforeChange","value","toLowerCase","trim","label","t","required","unique","validate"],"mappings":";;;AAEA,SAASA,KAAK,QAAQ,8BAA6B;;AAE5C,MAAMC,mBAA+B;IAC1CC,MAAM;IACNC,MAAM;IACNC,OAAO;QACLC,YAAY;YACVC,OAAO;QACT;IACF;IACAC,OAAO;QACLC,cAAc;YACZ,CAAC,EAAEC,KAAK,EAAE;gBACR,IAAIA,OAAO;oBACT,OAAOA,MAAMC,WAAW,GAAGC,IAAI;gBACjC;YACF;SACD;IACH;IACAC,OAAO,CAAC,EAAEC,CAAC,EAAE,GAAKA,EAAE;IACpBC,UAAU;IACVC,QAAQ;IACRC,mKAAUhB,QAAAA;AACZ,EAAC"}},
    {"offset": {"line": 17698, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 17704, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/payload/src/auth/baseFields/username.ts"],"sourcesContent":["import type { TextField } from '../../fields/config/types.js'\n\nimport { username } from '../../fields/validations.js'\n\nexport const usernameFieldConfig: TextField = {\n  name: 'username',\n  type: 'text',\n  admin: {\n    components: {\n      Field: false,\n    },\n  },\n  hooks: {\n    beforeChange: [\n      ({ value }) => {\n        if (value) {\n          return value.toLowerCase().trim()\n        }\n      },\n    ],\n  },\n  label: ({ t }) => t('authentication:username'),\n  required: true,\n  unique: true,\n  validate: username,\n}\n"],"names":["username","usernameFieldConfig","name","type","admin","components","Field","hooks","beforeChange","value","toLowerCase","trim","label","t","required","unique","validate"],"mappings":";;;AAEA,SAASA,QAAQ,QAAQ,8BAA6B;;AAE/C,MAAMC,sBAAiC;IAC5CC,MAAM;IACNC,MAAM;IACNC,OAAO;QACLC,YAAY;YACVC,OAAO;QACT;IACF;IACAC,OAAO;QACLC,cAAc;YACZ,CAAC,EAAEC,KAAK,EAAE;gBACR,IAAIA,OAAO;oBACT,OAAOA,MAAMC,WAAW,GAAGC,IAAI;gBACjC;YACF;SACD;IACH;IACAC,OAAO,CAAC,EAAEC,CAAC,EAAE,GAAKA,EAAE;IACpBC,UAAU;IACVC,QAAQ;IACRC,mKAAUhB,WAAAA;AACZ,EAAC"}},
    {"offset": {"line": 17731, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 17737, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/payload/src/auth/baseFields/auth.ts"],"sourcesContent":["import type { Field } from '../../fields/config/types.js'\n\nexport const baseAuthFields: Field[] = [\n  {\n    name: 'resetPasswordToken',\n    type: 'text',\n    hidden: true,\n  },\n  {\n    name: 'resetPasswordExpiration',\n    type: 'date',\n    hidden: true,\n  },\n  {\n    name: 'salt',\n    type: 'text',\n    hidden: true,\n  },\n  {\n    name: 'hash',\n    type: 'text',\n    hidden: true,\n  },\n]\n"],"names":["baseAuthFields","name","type","hidden"],"mappings":";;;AAEO,MAAMA,iBAA0B;IACrC;QACEC,MAAM;QACNC,MAAM;QACNC,QAAQ;IACV;IACA;QACEF,MAAM;QACNC,MAAM;QACNC,QAAQ;IACV;IACA;QACEF,MAAM;QACNC,MAAM;QACNC,QAAQ;IACV;IACA;QACEF,MAAM;QACNC,MAAM;QACNC,QAAQ;IACV;CACD,CAAA"}},
    {"offset": {"line": 17762, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 17768, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/payload/src/auth/baseFields/verification.ts"],"sourcesContent":["import type { Field, FieldHook } from '../../fields/config/types.js'\n\nconst autoRemoveVerificationToken: FieldHook = ({ data, operation, originalDoc, value }) => {\n  // If a user manually sets `_verified` to true,\n  // and it was `false`, set _verificationToken to `null`.\n  // This is useful because the admin panel\n  // allows users to set `_verified` to true manually\n\n  if (operation === 'update') {\n    if (data?._verified === true && originalDoc?._verified === false) {\n      return null\n    }\n  }\n\n  return value\n}\n\nexport const verificationFields: Field[] = [\n  {\n    name: '_verified',\n    type: 'checkbox',\n    access: {\n      create: ({ req: { user } }) => Boolean(user),\n      read: ({ req: { user } }) => Boolean(user),\n      update: ({ req: { user } }) => Boolean(user),\n    },\n    admin: {\n      components: {\n        Field: false,\n      },\n    },\n    label: ({ t }) => t('authentication:verified'),\n  },\n  {\n    name: '_verificationToken',\n    type: 'text',\n    hidden: true,\n    hooks: {\n      beforeChange: [autoRemoveVerificationToken],\n    },\n  },\n] as Field[]\n"],"names":["autoRemoveVerificationToken","data","operation","originalDoc","value","_verified","verificationFields","name","type","access","create","req","user","Boolean","read","update","admin","components","Field","label","t","hidden","hooks","beforeChange"],"mappings":";;;AAEA,MAAMA,8BAAyC,CAAC,EAAEC,IAAI,EAAEC,SAAS,EAAEC,WAAW,EAAEC,KAAK,EAAE;IACrF,+CAA+C;IAC/C,wDAAwD;IACxD,yCAAyC;IACzC,mDAAmD;IAEnD,IAAIF,cAAc,UAAU;QAC1B,IAAID,MAAMI,cAAc,QAAQF,aAAaE,cAAc,OAAO;YAChE,OAAO;QACT;IACF;IAEA,OAAOD;AACT;AAEO,MAAME,qBAA8B;IACzC;QACEC,MAAM;QACNC,MAAM;QACNC,QAAQ;YACNC,QAAQ,CAAC,EAAEC,KAAK,EAAEC,IAAI,EAAE,EAAE,GAAKC,QAAQD;YACvCE,MAAM,CAAC,EAAEH,KAAK,EAAEC,IAAI,EAAE,EAAE,GAAKC,QAAQD;YACrCG,QAAQ,CAAC,EAAEJ,KAAK,EAAEC,IAAI,EAAE,EAAE,GAAKC,QAAQD;QACzC;QACAI,OAAO;YACLC,YAAY;gBACVC,OAAO;YACT;QACF;QACAC,OAAO,CAAC,EAAEC,CAAC,EAAE,GAAKA,EAAE;IACtB;IACA;QACEb,MAAM;QACNC,MAAM;QACNa,QAAQ;QACRC,OAAO;YACLC,cAAc;gBAACvB;aAA4B;QAC7C;IACF;CACD,CAAW"}},
    {"offset": {"line": 17810, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 17816, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/payload/src/auth/baseFields/accountLock.ts"],"sourcesContent":["import type { Field } from '../../fields/config/types.js'\n\nexport const accountLockFields: Field[] = [\n  {\n    name: 'loginAttempts',\n    type: 'number',\n    defaultValue: 0,\n    hidden: true,\n  },\n  {\n    name: 'lockUntil',\n    type: 'date',\n    hidden: true,\n  },\n] as Field[]\n"],"names":["accountLockFields","name","type","defaultValue","hidden"],"mappings":";;;AAEO,MAAMA,oBAA6B;IACxC;QACEC,MAAM;QACNC,MAAM;QACNC,cAAc;QACdC,QAAQ;IACV;IACA;QACEH,MAAM;QACNC,MAAM;QACNE,QAAQ;IACV;CACD,CAAW"}},
    {"offset": {"line": 17832, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 17838, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/payload/src/auth/getAuthFields.ts"],"sourcesContent":["import type { Field, TextField } from '../fields/config/types.js'\nimport type { IncomingAuthType } from './types.js'\n\nimport { accountLockFields } from './baseFields/accountLock.js'\nimport { apiKeyFields } from './baseFields/apiKey.js'\nimport { baseAuthFields } from './baseFields/auth.js'\nimport { emailFieldConfig } from './baseFields/email.js'\nimport { usernameFieldConfig } from './baseFields/username.js'\nimport { verificationFields } from './baseFields/verification.js'\n\nexport const getBaseAuthFields = (authConfig: IncomingAuthType): Field[] => {\n  const authFields: Field[] = []\n\n  if (authConfig.useAPIKey) {\n    authFields.push(...apiKeyFields)\n  }\n\n  if (!authConfig.disableLocalStrategy) {\n    const emailField = { ...emailFieldConfig }\n    let usernameField: TextField | undefined\n\n    if (authConfig.loginWithUsername) {\n      usernameField = { ...usernameFieldConfig }\n      if (typeof authConfig.loginWithUsername === 'object') {\n        if (authConfig.loginWithUsername.requireEmail === false) {\n          emailField.required = false\n        }\n        if (authConfig.loginWithUsername.requireUsername === false) {\n          usernameField.required = false\n        }\n      }\n    }\n\n    authFields.push(emailField)\n    if (usernameField) {\n      authFields.push(usernameField)\n    }\n\n    authFields.push(...baseAuthFields)\n\n    if (authConfig.verify) {\n      authFields.push(...verificationFields)\n    }\n\n    if (authConfig.maxLoginAttempts > 0) {\n      authFields.push(...accountLockFields)\n    }\n  }\n\n  return authFields\n}\n"],"names":["accountLockFields","apiKeyFields","baseAuthFields","emailFieldConfig","usernameFieldConfig","verificationFields","getBaseAuthFields","authConfig","authFields","useAPIKey","push","disableLocalStrategy","emailField","usernameField","loginWithUsername","requireEmail","required","requireUsername","verify","maxLoginAttempts"],"mappings":";;;AAIA,SAASC,YAAY,QAAQ,yBAAwB;AAErD,SAASE,gBAAgB,QAAQ,wBAAuB;AACxD,SAASC,mBAAmB,QAAQ,2BAA0B;AAF9D,SAASF,cAAc,QAAQ,uBAAsB;AAGrD,SAASG,kBAAkB,QAAQ,+BAA8B;AALjE,SAASL,iBAAiB,QAAQ,8BAA6B;;;;;;;AAOxD,MAAMM,oBAAoB,CAACC;IAChC,MAAMC,aAAsB,EAAE;IAE9B,IAAID,WAAWE,SAAS,EAAE;QACxBD,WAAWE,IAAI,oKAAIT,eAAAA;IACrB;IAEA,IAAI,CAACM,WAAWI,oBAAoB,EAAE;QACpC,MAAMC,aAAa;YAAE,kKAAGT,mBAAgB;QAAC;QACzC,IAAIU;QAEJ,IAAIN,WAAWO,iBAAiB,EAAE;YAChCD,gBAAgB;gBAAE,qKAAGT,sBAAmB;YAAC;YACzC,IAAI,OAAOG,WAAWO,iBAAiB,KAAK,UAAU;gBACpD,IAAIP,WAAWO,iBAAiB,CAACC,YAAY,KAAK,OAAO;oBACvDH,WAAWI,QAAQ,GAAG;gBACxB;gBACA,IAAIT,WAAWO,iBAAiB,CAACG,eAAe,KAAK,OAAO;oBAC1DJ,cAAcG,QAAQ,GAAG;gBAC3B;YACF;QACF;QAEAR,WAAWE,IAAI,CAACE;QAChB,IAAIC,eAAe;YACjBL,WAAWE,IAAI,CAACG;QAClB;QAEAL,WAAWE,IAAI,iKAAIR,kBAAAA;QAEnB,IAAIK,WAAWW,MAAM,EAAE;YACrBV,WAAWE,IAAI,0KAAIL,qBAAAA;QACrB;QAEA,IAAIE,WAAWY,gBAAgB,GAAG,GAAG;YACnCX,WAAWE,IAAI,yKAAIV,oBAAAA;QACrB;IACF;IAEA,OAAOQ;AACT,EAAC"}},
    {"offset": {"line": 17890, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 17896, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/payload/src/collections/config/useAsTitle.ts"],"sourcesContent":["import type { CollectionConfig } from '../../index.js'\n\nimport { InvalidConfiguration } from '../../errors/InvalidConfiguration.js'\nimport { fieldAffectsData, fieldIsVirtual } from '../../fields/config/types.js'\nimport flattenFields from '../../utilities/flattenTopLevelFields.js'\n\n/**\n * Validate useAsTitle for collections.\n */\nexport const validateUseAsTitle = (config: CollectionConfig) => {\n  if (config.admin.useAsTitle.includes('.')) {\n    throw new InvalidConfiguration(\n      `\"useAsTitle\" cannot be a nested field. Please specify a top-level field in the collection \"${config.slug}\"`,\n    )\n  }\n\n  if (config?.admin && config.admin?.useAsTitle && config.admin.useAsTitle !== 'id') {\n    const fields = flattenFields(config.fields)\n    const useAsTitleField = fields.find((field) => {\n      if (fieldAffectsData(field) && config.admin) {\n        return field.name === config.admin.useAsTitle\n      }\n      return false\n    })\n\n    // If auth is enabled then we don't need to\n    if (config.auth) {\n      if (config.admin.useAsTitle !== 'email') {\n        if (!useAsTitleField) {\n          throw new InvalidConfiguration(\n            `The field \"${config.admin.useAsTitle}\" specified in \"admin.useAsTitle\" does not exist in the collection \"${config.slug}\"`,\n          )\n        }\n      }\n    } else {\n      if (useAsTitleField && fieldIsVirtual(useAsTitleField)) {\n        throw new InvalidConfiguration(\n          `The field \"${config.admin.useAsTitle}\" specified in \"admin.useAsTitle\" in the collection \"${config.slug}\" is virtual. A virtual field cannot be used as the title.`,\n        )\n      }\n      if (!useAsTitleField) {\n        throw new InvalidConfiguration(\n          `The field \"${config.admin.useAsTitle}\" specified in \"admin.useAsTitle\" does not exist in the collection \"${config.slug}\"`,\n        )\n      }\n    }\n  }\n}\n"],"names":["InvalidConfiguration","fieldAffectsData","fieldIsVirtual","flattenFields","validateUseAsTitle","config","admin","useAsTitle","includes","slug","fields","useAsTitleField","find","field","name","auth"],"mappings":";;;AAEA,SAASA,oBAAoB,QAAQ,uCAAsC;AAE3E,OAAOG,mBAAmB,2CAA0C;AADpE,SAASF,gBAAgB,EAAEC,cAAc,QAAQ,+BAA8B;;;;AAMxE,MAAME,qBAAqB,CAACC;IACjC,IAAIA,OAAOC,KAAK,CAACC,UAAU,CAACC,QAAQ,CAAC,MAAM;QACzC,MAAM,sKAAIR,uBAAAA,CACR,CAAC,2FAA2F,EAAEK,OAAOI,IAAI,CAAC,CAAC,CAAC;IAEhH;IAEA,IAAIJ,QAAQC,SAASD,OAAOC,KAAK,EAAEC,cAAcF,OAAOC,KAAK,CAACC,UAAU,KAAK,MAAM;QACjF,MAAMG,mLAASP,UAAAA,EAAcE,OAAOK,MAAM;QAC1C,MAAMC,kBAAkBD,OAAOE,IAAI,CAAC,CAACC;YACnC,qKAAIZ,mBAAAA,EAAiBY,UAAUR,OAAOC,KAAK,EAAE;gBAC3C,OAAOO,MAAMC,IAAI,KAAKT,OAAOC,KAAK,CAACC,UAAU;YAC/C;YACA,OAAO;QACT;QAEA,2CAA2C;QAC3C,IAAIF,OAAOU,IAAI,EAAE;YACf,IAAIV,OAAOC,KAAK,CAACC,UAAU,KAAK,SAAS;gBACvC,IAAI,CAACI,iBAAiB;oBACpB,MAAM,IAAIX,yLAAAA,CACR,CAAC,WAAW,EAAEK,OAAOC,KAAK,CAACC,UAAU,CAAC,oEAAoE,EAAEF,OAAOI,IAAI,CAAC,CAAC,CAAC;gBAE9H;YACF;QACF,OAAO;YACL,IAAIE,mBAAmBT,kLAAAA,EAAeS,kBAAkB;gBACtD,MAAM,sKAAIX,uBAAAA,CACR,CAAC,WAAW,EAAEK,OAAOC,KAAK,CAACC,UAAU,CAAC,qDAAqD,EAAEF,OAAOI,IAAI,CAAC,0DAA0D,CAAC;YAExK;YACA,IAAI,CAACE,iBAAiB;gBACpB,MAAM,sKAAIX,uBAAAA,CACR,CAAC,WAAW,EAAEK,OAAOC,KAAK,CAACC,UAAU,CAAC,oEAAoE,EAAEF,OAAOI,IAAI,CAAC,CAAC,CAAC;YAE9H;QACF;IACF;AACF,EAAC"}},
    {"offset": {"line": 17934, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 17940, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/payload/src/collections/config/sanitize.ts"],"sourcesContent":["import type { LoginWithUsernameOptions } from '../../auth/types.js'\nimport type { Config, SanitizedConfig } from '../../config/types.js'\nimport type { CollectionConfig, SanitizedCollectionConfig, SanitizedJoins } from './types.js'\n\nimport { getBaseAuthFields } from '../../auth/getAuthFields.js'\nimport { TimestampsRequired } from '../../errors/TimestampsRequired.js'\nimport { sanitizeFields } from '../../fields/config/sanitize.js'\nimport { fieldAffectsData } from '../../fields/config/types.js'\nimport mergeBaseFields from '../../fields/mergeBaseFields.js'\nimport { getBaseUploadFields } from '../../uploads/getBaseFields.js'\nimport { deepMergeWithReactComponents } from '../../utilities/deepMerge.js'\nimport { formatLabels } from '../../utilities/formatLabels.js'\nimport baseVersionFields from '../../versions/baseFields.js'\nimport { versionDefaults } from '../../versions/defaults.js'\nimport { authDefaults, defaults, loginWithUsernameDefaults } from './defaults.js'\nimport { sanitizeAuthFields, sanitizeUploadFields } from './reservedFieldNames.js'\nimport { validateUseAsTitle } from './useAsTitle.js'\n\nexport const sanitizeCollection = async (\n  config: Config,\n  collection: CollectionConfig,\n  /**\n   * If this property is set, RichText fields won't be sanitized immediately. Instead, they will be added to this array as promises\n   * so that you can sanitize them together, after the config has been sanitized.\n   */\n  richTextSanitizationPromises?: Array<(config: SanitizedConfig) => Promise<void>>,\n): Promise<SanitizedCollectionConfig> => {\n  // /////////////////////////////////\n  // Make copy of collection config\n  // /////////////////////////////////\n\n  const sanitized: CollectionConfig = deepMergeWithReactComponents(defaults, collection)\n\n  // /////////////////////////////////\n  // Sanitize fields\n  // /////////////////////////////////\n\n  const validRelationships = config.collections.map((c) => c.slug) || []\n  const joins: SanitizedJoins = {}\n  sanitized.fields = await sanitizeFields({\n    collectionConfig: sanitized,\n    config,\n    fields: sanitized.fields,\n    joins,\n    parentIsLocalized: false,\n    richTextSanitizationPromises,\n    schemaPath: '',\n    validRelationships,\n  })\n\n  if (sanitized.timestamps !== false) {\n    // add default timestamps fields only as needed\n    let hasUpdatedAt = null\n    let hasCreatedAt = null\n    sanitized.fields.some((field) => {\n      if (fieldAffectsData(field)) {\n        if (field.name === 'updatedAt') {\n          hasUpdatedAt = true\n        }\n        if (field.name === 'createdAt') {\n          hasCreatedAt = true\n        }\n      }\n      return hasCreatedAt && hasUpdatedAt\n    })\n    if (!hasUpdatedAt) {\n      sanitized.fields.push({\n        name: 'updatedAt',\n        type: 'date',\n        admin: {\n          disableBulkEdit: true,\n          hidden: true,\n        },\n        index: true,\n        label: ({ t }) => t('general:updatedAt'),\n      })\n    }\n    if (!hasCreatedAt) {\n      sanitized.fields.push({\n        name: 'createdAt',\n        admin: {\n          disableBulkEdit: true,\n          hidden: true,\n        },\n        // The default sort for list view is createdAt. Thus, enabling indexing by default, is a major performance improvement, especially for large or a large amount of collections.\n        type: 'date',\n        index: true,\n        label: ({ t }) => t('general:createdAt'),\n      })\n    }\n  }\n\n  sanitized.labels = sanitized.labels || formatLabels(sanitized.slug)\n\n  if (sanitized.versions) {\n    if (sanitized.versions === true) {\n      sanitized.versions = { drafts: false }\n    }\n\n    if (sanitized.timestamps === false) {\n      throw new TimestampsRequired(collection)\n    }\n\n    if (sanitized.versions.drafts) {\n      if (sanitized.versions.drafts === true) {\n        sanitized.versions.drafts = {\n          autosave: false,\n          validate: false,\n        }\n      }\n\n      if (sanitized.versions.drafts.autosave === true) {\n        sanitized.versions.drafts.autosave = {\n          interval: versionDefaults.autosaveInterval,\n        }\n      }\n\n      if (sanitized.versions.drafts.validate === undefined) {\n        sanitized.versions.drafts.validate = false\n      }\n\n      sanitized.fields = mergeBaseFields(sanitized.fields, baseVersionFields)\n    }\n  }\n\n  if (sanitized.upload) {\n    if (sanitized.upload === true) {\n      sanitized.upload = {}\n    }\n\n    // sanitize fields for reserved names\n    sanitizeUploadFields(sanitized.fields, sanitized)\n\n    sanitized.upload.bulkUpload = sanitized.upload?.bulkUpload ?? true\n    sanitized.upload.staticDir = sanitized.upload.staticDir || sanitized.slug\n    sanitized.admin.useAsTitle =\n      sanitized.admin.useAsTitle && sanitized.admin.useAsTitle !== 'id'\n        ? sanitized.admin.useAsTitle\n        : 'filename'\n\n    const uploadFields = getBaseUploadFields({\n      collection: sanitized,\n      config,\n    })\n\n    sanitized.fields = mergeBaseFields(sanitized.fields, uploadFields)\n  }\n\n  if (sanitized.auth) {\n    // sanitize fields for reserved names\n    sanitizeAuthFields(sanitized.fields, sanitized)\n\n    sanitized.auth = deepMergeWithReactComponents(\n      authDefaults,\n      typeof sanitized.auth === 'object' ? sanitized.auth : {},\n    )\n\n    if (!sanitized.auth.disableLocalStrategy && sanitized.auth.verify === true) {\n      sanitized.auth.verify = {}\n    }\n\n    // disable duplicate for auth enabled collections by default\n    sanitized.disableDuplicate = sanitized.disableDuplicate ?? true\n\n    if (!sanitized.auth.strategies) {\n      sanitized.auth.strategies = []\n    }\n\n    if (sanitized.auth.loginWithUsername) {\n      if (sanitized.auth.loginWithUsername === true) {\n        sanitized.auth.loginWithUsername = loginWithUsernameDefaults\n      } else {\n        const loginWithUsernameWithDefaults = {\n          ...loginWithUsernameDefaults,\n          ...sanitized.auth.loginWithUsername,\n        } as LoginWithUsernameOptions\n\n        // if allowEmailLogin is false, requireUsername must be true\n        if (loginWithUsernameWithDefaults.allowEmailLogin === false) {\n          loginWithUsernameWithDefaults.requireUsername = true\n        }\n        sanitized.auth.loginWithUsername = loginWithUsernameWithDefaults\n      }\n    } else {\n      sanitized.auth.loginWithUsername = false\n    }\n\n    sanitized.fields = mergeBaseFields(sanitized.fields, getBaseAuthFields(sanitized.auth))\n  }\n\n  if (collection?.admin?.pagination?.limits?.length) {\n    sanitized.admin.pagination.limits = collection.admin.pagination.limits\n  }\n\n  validateUseAsTitle(sanitized)\n\n  const sanitizedConfig = sanitized as SanitizedCollectionConfig\n\n  sanitizedConfig.joins = joins\n\n  return sanitizedConfig\n}\n"],"names":["getBaseAuthFields","TimestampsRequired","sanitizeFields","fieldAffectsData","mergeBaseFields","getBaseUploadFields","deepMergeWithReactComponents","formatLabels","baseVersionFields","versionDefaults","authDefaults","defaults","loginWithUsernameDefaults","sanitizeAuthFields","sanitizeUploadFields","validateUseAsTitle","sanitizeCollection","config","collection","richTextSanitizationPromises","sanitized","validRelationships","collections","map","c","slug","joins","fields","collectionConfig","parentIsLocalized","schemaPath","timestamps","hasUpdatedAt","hasCreatedAt","some","field","name","push","type","admin","disableBulkEdit","hidden","index","label","t","labels","versions","drafts","autosave","validate","interval","autosaveInterval","undefined","upload","bulkUpload","staticDir","useAsTitle","uploadFields","auth","disableLocalStrategy","verify","disableDuplicate","strategies","loginWithUsername","loginWithUsernameWithDefaults","allowEmailLogin","requireUsername","pagination","limits","length","sanitizedConfig"],"mappings":"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"}},
    {"offset": {"line": 18115, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 18121, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/payload/src/errors/DuplicateCollection.ts"],"sourcesContent":["import { APIError } from './APIError.js'\n\nexport class DuplicateCollection extends APIError {\n  constructor(propertyName: string, duplicates: string[]) {\n    super(`Collection ${propertyName} already in use: \"${duplicates.join(', ')}\"`)\n  }\n}\n"],"names":["APIError","DuplicateCollection","constructor","propertyName","duplicates","join"],"mappings":";;;AAAA,SAASA,QAAQ,QAAQ,gBAAe;;AAEjC,MAAMC,kLAA4BD,WAAAA;IACvCE,YAAYC,YAAoB,EAAEC,UAAoB,CAAE;QACtD,KAAK,CAAC,CAAC,WAAW,EAAED,aAAa,kBAAkB,EAAEC,WAAWC,IAAI,CAAC,MAAM,CAAC,CAAC;IAC/E;AACF"}},
    {"offset": {"line": 18131, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 18137, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/payload/src/utilities/checkDuplicateCollections.ts"],"sourcesContent":["import type { SanitizedCollectionConfig } from '../collections/config/types.js'\n\nimport { DuplicateCollection } from '../errors/DuplicateCollection.js'\n\nconst getDuplicates = (arr: string[]) => arr.filter((item, index) => arr.indexOf(item) !== index)\n\nconst checkDuplicateCollections = (collections: SanitizedCollectionConfig[]): void => {\n  const duplicateSlugs = getDuplicates(collections.map((c) => c.slug))\n  if (duplicateSlugs.length > 0) {\n    throw new DuplicateCollection('slug', duplicateSlugs)\n  }\n}\n\nexport default checkDuplicateCollections\n"],"names":["DuplicateCollection","getDuplicates","arr","filter","item","index","indexOf","checkDuplicateCollections","collections","duplicateSlugs","map","c","slug","length"],"mappings":";;;AAEA,SAASA,mBAAmB,QAAQ,mCAAkC;;AAEtE,MAAMC,gBAAgB,CAACC,MAAkBA,IAAIC,MAAM,CAAC,CAACC,MAAMC,QAAUH,IAAII,OAAO,CAACF,UAAUC;AAE3F,MAAME,4BAA4B,CAACC;IACjC,MAAMC,iBAAiBR,cAAcO,YAAYE,GAAG,CAAC,CAACC,IAAMA,EAAEC,IAAI;IAClE,IAAIH,eAAeI,MAAM,GAAG,GAAG;QAC7B,MAAM,qKAAIb,sBAAAA,CAAoB,QAAQS;IACxC;AACF;uCAEeF,0BAAyB"}},
    {"offset": {"line": 18151, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 18157, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/payload/src/globals/config/sanitize.ts"],"sourcesContent":["import type { Config, SanitizedConfig } from '../../config/types.js'\nimport type { SanitizedGlobalConfig } from './types.js'\n\nimport defaultAccess from '../../auth/defaultAccess.js'\nimport { sanitizeFields } from '../../fields/config/sanitize.js'\nimport { fieldAffectsData } from '../../fields/config/types.js'\nimport mergeBaseFields from '../../fields/mergeBaseFields.js'\nimport { toWords } from '../../utilities/formatLabels.js'\nimport baseVersionFields from '../../versions/baseFields.js'\nimport { versionDefaults } from '../../versions/defaults.js'\n\nexport const sanitizeGlobals = async (\n  config: Config,\n  /**\n   * If this property is set, RichText fields won't be sanitized immediately. Instead, they will be added to this array as promises\n   * so that you can sanitize them together, after the config has been sanitized.\n   */\n  richTextSanitizationPromises?: Array<(config: SanitizedConfig) => Promise<void>>,\n): Promise<SanitizedGlobalConfig[]> => {\n  const { collections, globals } = config\n\n  for (let i = 0; i < globals.length; i++) {\n    const global = globals[i]\n    global.label = global.label || toWords(global.slug)\n\n    // /////////////////////////////////\n    // Ensure that collection has required object structure\n    // /////////////////////////////////\n\n    global.endpoints = global.endpoints ?? []\n    if (!global.hooks) {\n      global.hooks = {}\n    }\n    if (!global.access) {\n      global.access = {}\n    }\n    if (!global.admin) {\n      global.admin = {}\n    }\n\n    if (!global.access.read) {\n      global.access.read = defaultAccess\n    }\n    if (!global.access.update) {\n      global.access.update = defaultAccess\n    }\n\n    if (!global.hooks.beforeValidate) {\n      global.hooks.beforeValidate = []\n    }\n    if (!global.hooks.beforeChange) {\n      global.hooks.beforeChange = []\n    }\n    if (!global.hooks.afterChange) {\n      global.hooks.afterChange = []\n    }\n    if (!global.hooks.beforeRead) {\n      global.hooks.beforeRead = []\n    }\n    if (!global.hooks.afterRead) {\n      global.hooks.afterRead = []\n    }\n\n    // Sanitize fields\n    const validRelationships = collections.map((c) => c.slug) || []\n    global.fields = await sanitizeFields({\n      config,\n      fields: global.fields,\n      parentIsLocalized: false,\n      richTextSanitizationPromises,\n      validRelationships,\n    })\n\n    if (global.versions) {\n      if (global.versions === true) {\n        global.versions = { drafts: false }\n      }\n\n      if (global.versions.drafts) {\n        if (global.versions.drafts === true) {\n          global.versions.drafts = {\n            autosave: false,\n            validate: false,\n          }\n        }\n\n        if (global.versions.drafts.autosave === true) {\n          global.versions.drafts.autosave = {\n            interval: versionDefaults.autosaveInterval,\n          }\n        }\n\n        if (global.versions.drafts.validate === undefined) {\n          global.versions.drafts.validate = false\n        }\n\n        global.fields = mergeBaseFields(global.fields, baseVersionFields)\n      }\n    }\n\n    if (!global.custom) {\n      global.custom = {}\n    }\n\n    // /////////////////////////////////\n    // Sanitize fields\n    // /////////////////////////////////\n    let hasUpdatedAt = null\n    let hasCreatedAt = null\n    global.fields.some((field) => {\n      if (fieldAffectsData(field)) {\n        if (field.name === 'updatedAt') {\n          hasUpdatedAt = true\n        }\n        if (field.name === 'createdAt') {\n          hasCreatedAt = true\n        }\n      }\n      return hasCreatedAt && hasUpdatedAt\n    })\n    if (!hasUpdatedAt) {\n      global.fields.push({\n        name: 'updatedAt',\n        type: 'date',\n        admin: {\n          disableBulkEdit: true,\n          hidden: true,\n        },\n        label: ({ t }) => t('general:updatedAt'),\n      })\n    }\n    if (!hasCreatedAt) {\n      global.fields.push({\n        name: 'createdAt',\n        type: 'date',\n        admin: {\n          disableBulkEdit: true,\n          hidden: true,\n        },\n        label: ({ t }) => t('general:createdAt'),\n      })\n    }\n\n    globals[i] = global\n  }\n\n  return globals as SanitizedGlobalConfig[]\n}\n"],"names":["defaultAccess","sanitizeFields","fieldAffectsData","mergeBaseFields","toWords","baseVersionFields","versionDefaults","sanitizeGlobals","config","richTextSanitizationPromises","collections","globals","i","length","global","label","slug","endpoints","hooks","access","admin","read","update","beforeValidate","beforeChange","afterChange","beforeRead","afterRead","validRelationships","map","c","fields","parentIsLocalized","versions","drafts","autosave","validate","interval","autosaveInterval","undefined","custom","hasUpdatedAt","hasCreatedAt","some","field","name","push","type","disableBulkEdit","hidden","t"],"mappings":"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"}},
    {"offset": {"line": 18294, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 18300, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/payload/src/config/sanitize.ts"],"sourcesContent":["import type { AcceptedLanguages } from '@payloadcms/translations'\n\nimport { en } from '@payloadcms/translations/languages/en'\nimport { deepMergeSimple } from '@payloadcms/translations/utilities'\n\nimport type {\n  Config,\n  LocalizationConfigWithLabels,\n  LocalizationConfigWithNoLabels,\n  SanitizedConfig,\n} from './types.js'\n\nimport { defaultUserCollection } from '../auth/defaultUser.js'\nimport { sanitizeCollection } from '../collections/config/sanitize.js'\nimport { migrationsCollection } from '../database/migrations/migrationsCollection.js'\nimport { InvalidConfiguration } from '../errors/index.js'\nimport { sanitizeGlobals } from '../globals/config/sanitize.js'\nimport { getLockedDocumentsCollection } from '../lockedDocuments/lockedDocumentsCollection.js'\nimport getPreferencesCollection from '../preferences/preferencesCollection.js'\nimport checkDuplicateCollections from '../utilities/checkDuplicateCollections.js'\nimport { defaults } from './defaults.js'\n\nconst sanitizeAdminConfig = (configToSanitize: Config): Partial<SanitizedConfig> => {\n  const sanitizedConfig = { ...configToSanitize }\n\n  // add default user collection if none provided\n  if (!sanitizedConfig?.admin?.user) {\n    const firstCollectionWithAuth = sanitizedConfig.collections.find(({ auth }) => Boolean(auth))\n    if (firstCollectionWithAuth) {\n      sanitizedConfig.admin.user = firstCollectionWithAuth.slug\n    } else {\n      sanitizedConfig.admin.user = defaultUserCollection.slug\n      sanitizedConfig.collections.push(defaultUserCollection)\n    }\n  }\n\n  const userCollection = sanitizedConfig.collections.find(\n    ({ slug }) => slug === sanitizedConfig.admin.user,\n  )\n  if (!userCollection || !userCollection.auth) {\n    throw new InvalidConfiguration(\n      `${sanitizedConfig.admin.user} is not a valid admin user collection`,\n    )\n  }\n\n  return sanitizedConfig as unknown as Partial<SanitizedConfig>\n}\n\nexport const sanitizeConfig = async (incomingConfig: Config): Promise<SanitizedConfig> => {\n  const configWithDefaults = {\n    ...defaults,\n    ...incomingConfig,\n    admin: {\n      ...defaults.admin,\n      ...incomingConfig?.admin,\n      meta: {\n        ...defaults.admin.meta,\n        ...incomingConfig?.admin?.meta,\n      },\n      routes: {\n        ...defaults.admin.routes,\n        ...incomingConfig?.admin?.routes,\n      },\n    },\n    graphQL: {\n      ...defaults.graphQL,\n      ...incomingConfig?.graphQL,\n    },\n    routes: {\n      ...defaults.routes,\n      ...incomingConfig?.routes,\n    },\n    typescript: {\n      ...defaults.typescript,\n      ...incomingConfig?.typescript,\n    },\n  }\n\n  if (!configWithDefaults?.serverURL) {\n    configWithDefaults.serverURL = ''\n  }\n\n  if (process.env.NEXT_BASE_PATH) {\n    if (!incomingConfig?.routes?.api) {\n      // check for incomingConfig, as configWithDefaults will always have a default value for routes.api\n      configWithDefaults.routes.api = process.env.NEXT_BASE_PATH + '/api'\n    }\n  }\n\n  const config: Partial<SanitizedConfig> = sanitizeAdminConfig(configWithDefaults)\n\n  if (config.localization && config.localization.locales?.length > 0) {\n    // clone localization config so to not break everything\n    const firstLocale = config.localization.locales[0]\n    if (typeof firstLocale === 'string') {\n      config.localization.localeCodes = [\n        ...(config.localization as unknown as LocalizationConfigWithNoLabels).locales,\n      ]\n\n      // is string[], so convert to Locale[]\n      config.localization.locales = (\n        config.localization as unknown as LocalizationConfigWithNoLabels\n      ).locales.map((locale) => ({\n        code: locale,\n        label: locale,\n        rtl: false,\n        toString: () => locale,\n      }))\n    } else {\n      // is Locale[], so convert to string[] for localeCodes\n      config.localization.localeCodes = config.localization.locales.reduce((locales, locale) => {\n        locales.push(locale.code)\n        return locales\n      }, [] as string[])\n\n      config.localization.locales = (\n        config.localization as LocalizationConfigWithLabels\n      ).locales.map((locale) => ({\n        ...locale,\n        toString: () => locale.code,\n      }))\n    }\n  }\n\n  const i18nConfig: SanitizedConfig['i18n'] = {\n    fallbackLanguage: 'en',\n    supportedLanguages: {\n      en,\n    },\n    translations: {},\n  }\n\n  if (incomingConfig?.i18n) {\n    i18nConfig.supportedLanguages =\n      incomingConfig.i18n?.supportedLanguages || i18nConfig.supportedLanguages\n\n    const supportedLangKeys = <AcceptedLanguages[]>Object.keys(i18nConfig.supportedLanguages)\n    const fallbackLang = incomingConfig.i18n?.fallbackLanguage || i18nConfig.fallbackLanguage\n\n    i18nConfig.fallbackLanguage = supportedLangKeys.includes(fallbackLang)\n      ? fallbackLang\n      : supportedLangKeys[0]\n    i18nConfig.translations =\n      (incomingConfig.i18n?.translations as SanitizedConfig['i18n']['translations']) ||\n      i18nConfig.translations\n  }\n\n  config.i18n = i18nConfig\n\n  configWithDefaults.collections.push(getLockedDocumentsCollection(config as unknown as Config))\n  configWithDefaults.collections.push(getPreferencesCollection(config as unknown as Config))\n  configWithDefaults.collections.push(migrationsCollection)\n\n  const richTextSanitizationPromises: Array<(config: SanitizedConfig) => Promise<void>> = []\n  for (let i = 0; i < config.collections.length; i++) {\n    config.collections[i] = await sanitizeCollection(\n      config as unknown as Config,\n      config.collections[i],\n      richTextSanitizationPromises,\n    )\n  }\n\n  checkDuplicateCollections(config.collections)\n\n  if (config.globals.length > 0) {\n    config.globals = await sanitizeGlobals(\n      config as unknown as Config,\n      richTextSanitizationPromises,\n    )\n  }\n\n  if (config.serverURL !== '') {\n    config.csrf.push(config.serverURL)\n  }\n\n  // Get deduped list of upload adapters\n  if (!config.upload) {\n    config.upload = { adapters: [] }\n  }\n  config.upload.adapters = Array.from(\n    new Set(config.collections.map((c) => c.upload?.adapter).filter(Boolean)),\n  )\n\n  // Pass through the email config as is so adapters don't break\n  if (incomingConfig.email) {\n    config.email = incomingConfig.email\n  }\n\n  /*\n    Execute richText sanitization\n   */\n  if (typeof incomingConfig.editor === 'function') {\n    config.editor = await incomingConfig.editor({\n      config: config as SanitizedConfig,\n      isRoot: true,\n      parentIsLocalized: false,\n    })\n    if (config.editor.i18n && Object.keys(config.editor.i18n).length >= 0) {\n      config.i18n.translations = deepMergeSimple(config.i18n.translations, config.editor.i18n)\n    }\n  }\n\n  const promises: Promise<void>[] = []\n  for (const sanitizeFunction of richTextSanitizationPromises) {\n    promises.push(sanitizeFunction(config as SanitizedConfig))\n  }\n  await Promise.all(promises)\n\n  return config as SanitizedConfig\n}\n"],"names":["en","deepMergeSimple","defaultUserCollection","sanitizeCollection","migrationsCollection","InvalidConfiguration","sanitizeGlobals","getLockedDocumentsCollection","getPreferencesCollection","checkDuplicateCollections","defaults","sanitizeAdminConfig","configToSanitize","sanitizedConfig","admin","user","firstCollectionWithAuth","collections","find","auth","Boolean","slug","push","userCollection","sanitizeConfig","incomingConfig","configWithDefaults","meta","routes","graphQL","typescript","serverURL","process","env","NEXT_BASE_PATH","api","config","localization","locales","length","firstLocale","localeCodes","map","locale","code","label","rtl","toString","reduce","i18nConfig","fallbackLanguage","supportedLanguages","translations","i18n","supportedLangKeys","Object","keys","fallbackLang","includes","richTextSanitizationPromises","i","globals","csrf","upload","adapters","Array","from","Set","c","adapter","filter","email","editor","isRoot","parentIsLocalized","promises","sanitizeFunction","Promise","all"],"mappings":"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"}},
    {"offset": {"line": 18470, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 18476, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/payload/src/config/build.ts"],"sourcesContent":["import type { Config, SanitizedConfig } from './types.js'\n\nimport { sanitizeConfig } from './sanitize.js'\n\n/**\n * @description Builds and validates Payload configuration\n * @param config Payload Config\n * @returns Built and sanitized Payload Config\n */\nexport async function buildConfig(config: Config): Promise<SanitizedConfig> {\n  if (Array.isArray(config.plugins)) {\n    const configAfterPlugins = await config.plugins.reduce(async (acc, plugin) => {\n      const configAfterPlugin = await acc\n      return plugin(configAfterPlugin)\n    }, Promise.resolve(config))\n\n    return await sanitizeConfig(configAfterPlugins)\n  }\n\n  return await sanitizeConfig(config)\n}\n"],"names":["sanitizeConfig","buildConfig","config","Array","isArray","plugins","configAfterPlugins","reduce","acc","plugin","configAfterPlugin","Promise","resolve"],"mappings":";;;AAEA,SAASA,cAAc,QAAQ,gBAAe;;AAOvC,eAAeC,YAAYC,MAAc;IAC9C,IAAIC,MAAMC,OAAO,CAACF,OAAOG,OAAO,GAAG;QACjC,MAAMC,qBAAqB,MAAMJ,OAAOG,OAAO,CAACE,MAAM,CAAC,OAAOC,KAAKC;YACjE,MAAMC,oBAAoB,MAAMF;YAChC,OAAOC,OAAOC;QAChB,GAAGC,QAAQC,OAAO,CAACV;QAEnB,OAAO,gKAAMF,iBAAAA,EAAeM;IAC9B;IAEA,OAAO,gKAAMN,iBAAAA,EAAeE;AAC9B"}},
    {"offset": {"line": 18491, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 18537, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/payload/src/utilities/getCollectionIDFieldTypes.ts"],"sourcesContent":["import type { SanitizedConfig } from '../config/types.js'\n\n/**\n *  While the default ID is determined by the db adapter, it can still differ for a collection if they\n *  define a custom ID field. This builds a map of collection slugs to their ID field type.\n * @param defaultIDType as defined by the database adapter\n */\nexport function getCollectionIDFieldTypes({\n  config,\n  defaultIDType,\n}: {\n  config: SanitizedConfig\n  defaultIDType: 'number' | 'text'\n}): { [key: string]: 'number' | 'string' } {\n  return config.collections.reduce((acc, collection) => {\n    const customCollectionIdField = collection.fields.find(\n      (field) => 'name' in field && field.name === 'id',\n    )\n\n    acc[collection.slug] = defaultIDType === 'text' ? 'string' : 'number'\n\n    if (customCollectionIdField) {\n      acc[collection.slug] = customCollectionIdField.type === 'number' ? 'number' : 'string'\n    }\n\n    return acc\n  }, {})\n}\n"],"names":["getCollectionIDFieldTypes","config","defaultIDType","collections","reduce","acc","collection","customCollectionIdField","fields","find","field","name","slug","type"],"mappings":"AAEA;;;;CAIC,GACD;;;AAAO,SAASA,0BAA0B,EACxCC,MAAM,EACNC,aAAa,EAId;IACC,OAAOD,OAAOE,WAAW,CAACC,MAAM,CAAC,CAACC,KAAKC;QACrC,MAAMC,0BAA0BD,WAAWE,MAAM,CAACC,IAAI,CACpD,CAACC,QAAU,UAAUA,SAASA,MAAMC,IAAI,KAAK;QAG/CN,GAAG,CAACC,WAAWM,IAAI,CAAC,GAAGV,kBAAkB,SAAS,WAAW;QAE7D,IAAIK,yBAAyB;YAC3BF,GAAG,CAACC,WAAWM,IAAI,CAAC,GAAGL,wBAAwBM,IAAI,KAAK,WAAW,WAAW;QAChF;QAEA,OAAOR;IACT,GAAG,CAAC;AACN"}},
    {"offset": {"line": 18554, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 18560, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/payload/src/utilities/configToJSONSchema.ts"],"sourcesContent":["import type { JSONSchema4, JSONSchema4TypeName } from 'json-schema'\n\nimport pluralize from 'pluralize'\nconst { singular } = pluralize\n\nimport type { Auth } from '../auth/types.js'\nimport type { SanitizedCollectionConfig } from '../collections/config/types.js'\nimport type { SanitizedConfig } from '../config/types.js'\nimport type { Field, FieldAffectingData, Option } from '../fields/config/types.js'\nimport type { SanitizedGlobalConfig } from '../globals/config/types.js'\n\nimport { MissingEditorProp } from '../errors/MissingEditorProp.js'\nimport { fieldAffectsData, tabHasName } from '../fields/config/types.js'\nimport { deepCopyObject } from './deepCopyObject.js'\nimport { toWords } from './formatLabels.js'\nimport { getCollectionIDFieldTypes } from './getCollectionIDFieldTypes.js'\n\nconst fieldIsRequired = (field: Field) => {\n  const isConditional = Boolean(field?.admin && field?.admin?.condition)\n  if (isConditional) {\n    return false\n  }\n\n  const isMarkedRequired = 'required' in field && field.required === true\n  if (fieldAffectsData(field) && isMarkedRequired) {\n    return true\n  }\n\n  // if any subfields are required, this field is required\n  if ('fields' in field && field.type !== 'array') {\n    return field.fields.some((subField) => fieldIsRequired(subField))\n  }\n\n  // if any tab subfields have required fields, this field is required\n  if (field.type === 'tabs') {\n    return field.tabs.some((tab) => {\n      if ('name' in tab) {\n        return tab.fields.some((subField) => fieldIsRequired(subField))\n      }\n      return false\n    })\n  }\n\n  return false\n}\n\nfunction buildOptionEnums(options: Option[]): string[] {\n  return options.map((option) => {\n    if (typeof option === 'object' && 'value' in option) {\n      return option.value\n    }\n\n    return option\n  })\n}\n\nfunction generateEntitySchemas(\n  entities: (SanitizedCollectionConfig | SanitizedGlobalConfig)[],\n): JSONSchema4 {\n  const properties = [...entities].reduce((acc, { slug }) => {\n    acc[slug] = {\n      $ref: `#/definitions/${slug}`,\n    }\n\n    return acc\n  }, {})\n\n  return {\n    type: 'object',\n    additionalProperties: false,\n    properties,\n    required: Object.keys(properties),\n  }\n}\n\nfunction generateLocaleEntitySchemas(localization: SanitizedConfig['localization']): JSONSchema4 {\n  if (localization && 'locales' in localization && localization?.locales) {\n    const localesFromConfig = localization?.locales\n\n    const locales = [...localesFromConfig].map((locale) => {\n      return locale.code\n    }, [])\n\n    return {\n      type: 'string',\n      enum: locales,\n    }\n  }\n\n  return {\n    type: 'null',\n  }\n}\n\nfunction generateAuthEntitySchemas(entities: SanitizedCollectionConfig[]): JSONSchema4 {\n  const properties: JSONSchema4[] = [...entities]\n    .filter(({ auth }) => Boolean(auth))\n    .map(({ slug }) => {\n      return {\n        allOf: [\n          { $ref: `#/definitions/${slug}` },\n          {\n            type: 'object',\n            additionalProperties: false,\n            properties: {\n              collection: { type: 'string', enum: [slug] },\n            },\n            required: ['collection'],\n          },\n        ],\n      }\n    }, {})\n\n  return {\n    oneOf: properties,\n  }\n}\n\n/**\n * Generates the JSON Schema for database configuration\n *\n * @example { db: idType: string }\n */\nfunction generateDbEntitySchema(config: SanitizedConfig): JSONSchema4 {\n  const defaultIDType: JSONSchema4 =\n    config.db?.defaultIDType === 'number' ? { type: 'number' } : { type: 'string' }\n\n  return {\n    type: 'object',\n    additionalProperties: false,\n    properties: {\n      defaultIDType,\n    },\n    required: ['defaultIDType'],\n  }\n}\n\n/**\n * Returns a JSON Schema Type with 'null' added if the field is not required.\n */\nexport function withNullableJSONSchemaType(\n  fieldType: JSONSchema4TypeName,\n  isRequired: boolean,\n): JSONSchema4TypeName | JSONSchema4TypeName[] {\n  const fieldTypes = [fieldType]\n  if (isRequired) {\n    return fieldType\n  }\n  fieldTypes.push('null')\n  return fieldTypes\n}\n\nexport function fieldsToJSONSchema(\n  /**\n   * Used for relationship fields, to determine whether to use a string or number type for the ID.\n   * While there is a default ID field type set by the db adapter, they can differ on a collection-level\n   * if they have custom ID fields.\n   */\n  collectionIDFieldTypes: { [key: string]: 'number' | 'string' },\n  fields: Field[],\n  /**\n   * Allows you to define new top-level interfaces that can be re-used in the output schema.\n   */\n  interfaceNameDefinitions: Map<string, JSONSchema4>,\n  config?: SanitizedConfig,\n): {\n  properties: {\n    [k: string]: JSONSchema4\n  }\n  required: string[]\n} {\n  const requiredFieldNames = new Set<string>()\n\n  return {\n    properties: Object.fromEntries(\n      fields.reduce((fieldSchemas, field) => {\n        const isRequired = fieldAffectsData(field) && fieldIsRequired(field)\n        if (isRequired) {\n          requiredFieldNames.add(field.name)\n        }\n\n        let fieldSchema: JSONSchema4\n\n        switch (field.type) {\n          case 'text':\n            if (field.hasMany === true) {\n              fieldSchema = {\n                type: withNullableJSONSchemaType('array', isRequired),\n                items: { type: 'string' },\n              }\n            } else {\n              fieldSchema = { type: withNullableJSONSchemaType('string', isRequired) }\n            }\n            break\n          case 'textarea':\n          case 'code':\n          case 'email':\n          case 'date': {\n            fieldSchema = { type: withNullableJSONSchemaType('string', isRequired) }\n            break\n          }\n\n          case 'number': {\n            if (field.hasMany === true) {\n              fieldSchema = {\n                type: withNullableJSONSchemaType('array', isRequired),\n                items: { type: 'number' },\n              }\n            } else {\n              fieldSchema = { type: withNullableJSONSchemaType('number', isRequired) }\n            }\n            break\n          }\n\n          case 'checkbox': {\n            fieldSchema = { type: withNullableJSONSchemaType('boolean', isRequired) }\n            break\n          }\n\n          case 'json': {\n            fieldSchema = field.jsonSchema?.schema || {\n              type: ['object', 'array', 'string', 'number', 'boolean', 'null'],\n            }\n            break\n          }\n\n          case 'richText': {\n            if (!field?.editor) {\n              throw new MissingEditorProp(field) // while we allow disabling editor functionality, you should not have any richText fields defined if you do not have an editor\n            }\n            if (typeof field.editor === 'function') {\n              throw new Error('Attempted to access unsanitized rich text editor.')\n            }\n            if (field.editor.outputSchema) {\n              fieldSchema = field.editor.outputSchema({\n                collectionIDFieldTypes,\n                config,\n                field,\n                interfaceNameDefinitions,\n                isRequired,\n              })\n            } else {\n              // Maintain backwards compatibility with existing rich text editors\n              fieldSchema = {\n                type: withNullableJSONSchemaType('array', isRequired),\n                items: {\n                  type: 'object',\n                },\n              }\n            }\n\n            break\n          }\n\n          case 'radio': {\n            fieldSchema = {\n              type: withNullableJSONSchemaType('string', isRequired),\n              enum: buildOptionEnums(field.options),\n            }\n\n            break\n          }\n\n          case 'select': {\n            const optionEnums = buildOptionEnums(field.options)\n\n            if (field.hasMany) {\n              fieldSchema = {\n                type: withNullableJSONSchemaType('array', isRequired),\n                items: {\n                  type: 'string',\n                  enum: optionEnums,\n                },\n              }\n            } else {\n              fieldSchema = {\n                type: withNullableJSONSchemaType('string', isRequired),\n                enum: optionEnums,\n              }\n            }\n\n            break\n          }\n\n          case 'point': {\n            fieldSchema = {\n              type: withNullableJSONSchemaType('array', isRequired),\n              items: [\n                {\n                  type: 'number',\n                },\n                {\n                  type: 'number',\n                },\n              ],\n              maxItems: 2,\n              minItems: 2,\n            }\n            break\n          }\n\n          case 'join': {\n            fieldSchema = {\n              type: withNullableJSONSchemaType('object', false),\n              additionalProperties: false,\n              properties: {\n                docs: {\n                  type: withNullableJSONSchemaType('array', false),\n                  items: {\n                    oneOf: [\n                      {\n                        type: collectionIDFieldTypes[field.collection],\n                      },\n                      {\n                        $ref: `#/definitions/${field.collection}`,\n                      },\n                    ],\n                  },\n                },\n                hasNextPage: { type: withNullableJSONSchemaType('boolean', false) },\n              },\n            }\n            break\n          }\n\n          case 'upload':\n          case 'relationship': {\n            if (Array.isArray(field.relationTo)) {\n              if (field.hasMany) {\n                fieldSchema = {\n                  type: withNullableJSONSchemaType('array', isRequired),\n                  items: {\n                    oneOf: field.relationTo.map((relation) => {\n                      return {\n                        type: 'object',\n                        additionalProperties: false,\n                        properties: {\n                          relationTo: {\n                            const: relation,\n                          },\n                          value: {\n                            oneOf: [\n                              {\n                                type: collectionIDFieldTypes[relation],\n                              },\n                              {\n                                $ref: `#/definitions/${relation}`,\n                              },\n                            ],\n                          },\n                        },\n                        required: ['value', 'relationTo'],\n                      }\n                    }),\n                  },\n                }\n              } else {\n                fieldSchema = {\n                  oneOf: field.relationTo.map((relation) => {\n                    return {\n                      type: withNullableJSONSchemaType('object', isRequired),\n                      additionalProperties: false,\n                      properties: {\n                        relationTo: {\n                          const: relation,\n                        },\n                        value: {\n                          oneOf: [\n                            {\n                              type: collectionIDFieldTypes[relation],\n                            },\n                            {\n                              $ref: `#/definitions/${relation}`,\n                            },\n                          ],\n                        },\n                      },\n                      required: ['value', 'relationTo'],\n                    }\n                  }),\n                }\n              }\n            } else if (field.hasMany) {\n              fieldSchema = {\n                type: withNullableJSONSchemaType('array', isRequired),\n                items: {\n                  oneOf: [\n                    {\n                      type: collectionIDFieldTypes[field.relationTo],\n                    },\n                    {\n                      $ref: `#/definitions/${field.relationTo}`,\n                    },\n                  ],\n                },\n              }\n            } else {\n              fieldSchema = {\n                oneOf: [\n                  {\n                    type: withNullableJSONSchemaType(\n                      collectionIDFieldTypes[field.relationTo],\n                      isRequired,\n                    ),\n                  },\n                  {\n                    $ref: `#/definitions/${field.relationTo}`,\n                  },\n                ],\n              }\n            }\n\n            break\n          }\n\n          case 'blocks': {\n            // Check for a case where no blocks are provided.\n            // We need to generate an empty array for this case, note that JSON schema 4 doesn't support empty arrays\n            // so the best we can get is `unknown[]`\n            const hasBlocks = Boolean(field.blocks.length)\n\n            fieldSchema = {\n              type: withNullableJSONSchemaType('array', isRequired),\n              items: hasBlocks\n                ? {\n                    oneOf: field.blocks.map((block) => {\n                      const blockFieldSchemas = fieldsToJSONSchema(\n                        collectionIDFieldTypes,\n                        block.fields,\n                        interfaceNameDefinitions,\n                        config,\n                      )\n\n                      const blockSchema: JSONSchema4 = {\n                        type: 'object',\n                        additionalProperties: false,\n                        properties: {\n                          ...blockFieldSchemas.properties,\n                          blockType: {\n                            const: block.slug,\n                          },\n                        },\n                        required: ['blockType', ...blockFieldSchemas.required],\n                      }\n\n                      if (block.interfaceName) {\n                        interfaceNameDefinitions.set(block.interfaceName, blockSchema)\n\n                        return {\n                          $ref: `#/definitions/${block.interfaceName}`,\n                        }\n                      }\n\n                      return blockSchema\n                    }),\n                  }\n                : {},\n            }\n            break\n          }\n\n          case 'array': {\n            fieldSchema = {\n              type: withNullableJSONSchemaType('array', isRequired),\n              items: {\n                type: 'object',\n                additionalProperties: false,\n                ...fieldsToJSONSchema(\n                  collectionIDFieldTypes,\n                  field.fields,\n                  interfaceNameDefinitions,\n                  config,\n                ),\n              },\n            }\n\n            if (field.interfaceName) {\n              interfaceNameDefinitions.set(field.interfaceName, fieldSchema)\n\n              fieldSchema = {\n                $ref: `#/definitions/${field.interfaceName}`,\n              }\n            }\n            break\n          }\n\n          case 'row':\n          case 'collapsible': {\n            const childSchema = fieldsToJSONSchema(\n              collectionIDFieldTypes,\n              field.fields,\n              interfaceNameDefinitions,\n              config,\n            )\n            Object.entries(childSchema.properties).forEach(([propName, propSchema]) => {\n              fieldSchemas.set(propName, propSchema)\n            })\n            childSchema.required.forEach((propName) => {\n              requiredFieldNames.add(propName)\n            })\n            break\n          }\n\n          case 'tabs': {\n            field.tabs.forEach((tab) => {\n              const childSchema = fieldsToJSONSchema(\n                collectionIDFieldTypes,\n                tab.fields,\n                interfaceNameDefinitions,\n                config,\n              )\n              if (tabHasName(tab)) {\n                // could have interface\n                fieldSchemas.set(tab.name, {\n                  type: 'object',\n                  additionalProperties: false,\n                  ...childSchema,\n                })\n\n                // If the named tab has any required fields then we mark this as required otherwise it should be optional\n                const hasRequiredFields = tab.fields.some((subField) => fieldIsRequired(subField))\n\n                if (hasRequiredFields) {\n                  requiredFieldNames.add(tab.name)\n                }\n              } else {\n                Object.entries(childSchema.properties).forEach(([propName, propSchema]) => {\n                  fieldSchemas.set(propName, propSchema)\n                })\n                childSchema.required.forEach((propName) => {\n                  requiredFieldNames.add(propName)\n                })\n              }\n            })\n            break\n          }\n\n          case 'group': {\n            fieldSchema = {\n              type: 'object',\n              additionalProperties: false,\n              ...fieldsToJSONSchema(\n                collectionIDFieldTypes,\n                field.fields,\n                interfaceNameDefinitions,\n                config,\n              ),\n            }\n\n            if (field.interfaceName) {\n              interfaceNameDefinitions.set(field.interfaceName, fieldSchema)\n\n              fieldSchema = {\n                $ref: `#/definitions/${field.interfaceName}`,\n              }\n            }\n            break\n          }\n\n          default: {\n            break\n          }\n        }\n\n        if ('typescriptSchema' in field && field?.typescriptSchema?.length) {\n          for (const schema of field.typescriptSchema) {\n            fieldSchema = schema({ jsonSchema: fieldSchema })\n          }\n        }\n\n        if (fieldSchema && fieldAffectsData(field)) {\n          fieldSchemas.set(field.name, fieldSchema)\n        }\n\n        return fieldSchemas\n      }, new Map<string, JSONSchema4>()),\n    ),\n    required: Array.from(requiredFieldNames),\n  }\n}\n\n// This function is part of the public API and is exported through payload/utilities\nexport function entityToJSONSchema(\n  config: SanitizedConfig,\n  incomingEntity: SanitizedCollectionConfig | SanitizedGlobalConfig,\n  interfaceNameDefinitions: Map<string, JSONSchema4>,\n  defaultIDType: 'number' | 'text',\n): JSONSchema4 {\n  const entity: SanitizedCollectionConfig | SanitizedGlobalConfig = deepCopyObject(incomingEntity)\n  const title = entity.typescript?.interface\n    ? entity.typescript.interface\n    : singular(toWords(entity.slug, true))\n\n  const idField: FieldAffectingData = { name: 'id', type: defaultIDType as 'text', required: true }\n  const customIdField = entity.fields.find(\n    (field) => fieldAffectsData(field) && field.name === 'id',\n  ) as FieldAffectingData\n\n  if (customIdField && customIdField.type !== 'group' && customIdField.type !== 'tab') {\n    customIdField.required = true\n  } else {\n    entity.fields.unshift(idField)\n  }\n\n  // mark timestamp fields required\n  if ('timestamps' in entity && entity.timestamps !== false) {\n    entity.fields = entity.fields.map((field) => {\n      if (fieldAffectsData(field) && (field.name === 'createdAt' || field.name === 'updatedAt')) {\n        return {\n          ...field,\n          required: true,\n        }\n      }\n      return field\n    })\n  }\n\n  if ('auth' in entity && entity.auth && !entity.auth?.disableLocalStrategy) {\n    entity.fields.push({\n      name: 'password',\n      type: 'text',\n    })\n  }\n\n  //  Used for relationship fields, to determine whether to use a string or number type for the ID.\n  const collectionIDFieldTypes = getCollectionIDFieldTypes({ config, defaultIDType })\n\n  return {\n    type: 'object',\n    additionalProperties: false,\n    title,\n    ...fieldsToJSONSchema(collectionIDFieldTypes, entity.fields, interfaceNameDefinitions, config),\n  }\n}\n\nconst fieldType: JSONSchema4 = {\n  type: 'string',\n  required: false,\n}\nconst generateAuthFieldTypes = ({\n  type,\n  loginWithUsername,\n}: {\n  loginWithUsername: Auth['loginWithUsername']\n  type: 'forgotOrUnlock' | 'login' | 'register'\n}): JSONSchema4 => {\n  if (loginWithUsername) {\n    switch (type) {\n      case 'login': {\n        if (loginWithUsername.allowEmailLogin) {\n          // allow username or email and require password for login\n          return {\n            additionalProperties: false,\n            oneOf: [\n              {\n                additionalProperties: false,\n                properties: { email: fieldType, password: fieldType },\n                required: ['email', 'password'],\n              },\n              {\n                additionalProperties: false,\n                properties: { password: fieldType, username: fieldType },\n                required: ['username', 'password'],\n              },\n            ],\n          }\n        } else {\n          // allow only username and password for login\n          return {\n            additionalProperties: false,\n            properties: {\n              password: fieldType,\n              username: fieldType,\n            },\n            required: ['username', 'password'],\n          }\n        }\n      }\n\n      case 'register': {\n        const requiredFields: ('email' | 'password' | 'username')[] = ['password']\n        const properties: {\n          email?: JSONSchema4['properties']\n          password?: JSONSchema4['properties']\n          username?: JSONSchema4['properties']\n        } = {\n          password: fieldType,\n          username: fieldType,\n        }\n\n        if (loginWithUsername.requireEmail) {\n          requiredFields.push('email')\n        }\n        if (loginWithUsername.requireUsername) {\n          requiredFields.push('username')\n        }\n        if (loginWithUsername.requireEmail || loginWithUsername.allowEmailLogin) {\n          properties.email = fieldType\n        }\n\n        return {\n          additionalProperties: false,\n          properties,\n          required: requiredFields,\n        }\n      }\n\n      case 'forgotOrUnlock': {\n        if (loginWithUsername.allowEmailLogin) {\n          // allow email or username for unlock/forgot-password\n          return {\n            additionalProperties: false,\n            oneOf: [\n              {\n                additionalProperties: false,\n                properties: { email: fieldType },\n                required: ['email'],\n              },\n              {\n                additionalProperties: false,\n                properties: { username: fieldType },\n                required: ['username'],\n              },\n            ],\n          }\n        } else {\n          // allow only username for unlock/forgot-password\n          return {\n            additionalProperties: false,\n            properties: { username: fieldType },\n            required: ['username'],\n          }\n        }\n      }\n    }\n  }\n\n  // default email (and password for login/register)\n  return {\n    additionalProperties: false,\n    properties: { email: fieldType, password: fieldType },\n    required: ['email', 'password'],\n  }\n}\n\nexport function authCollectionToOperationsJSONSchema(\n  config: SanitizedCollectionConfig,\n): JSONSchema4 {\n  const loginWithUsername = config.auth?.loginWithUsername\n  const loginUserFields: JSONSchema4 = generateAuthFieldTypes({ type: 'login', loginWithUsername })\n  const forgotOrUnlockUserFields: JSONSchema4 = generateAuthFieldTypes({\n    type: 'forgotOrUnlock',\n    loginWithUsername,\n  })\n  const registerUserFields: JSONSchema4 = generateAuthFieldTypes({\n    type: 'register',\n    loginWithUsername,\n  })\n\n  const properties: JSONSchema4['properties'] = {\n    forgotPassword: forgotOrUnlockUserFields,\n    login: loginUserFields,\n    registerFirstUser: registerUserFields,\n    unlock: forgotOrUnlockUserFields,\n  }\n\n  return {\n    type: 'object',\n    additionalProperties: false,\n    properties,\n    required: Object.keys(properties),\n    title: `${singular(toWords(`${config.slug}`, true))}AuthOperations`,\n  }\n}\n\nfunction generateAuthOperationSchemas(collections: SanitizedCollectionConfig[]): JSONSchema4 {\n  const properties = collections.reduce((acc, collection) => {\n    if (collection.auth) {\n      acc[collection.slug] = {\n        $ref: `#/definitions/auth/${collection.slug}`,\n      }\n    }\n    return acc\n  }, {})\n\n  return {\n    type: 'object',\n    additionalProperties: false,\n    properties,\n    required: Object.keys(properties),\n  }\n}\n\n/**\n * This is used for generating the TypeScript types (payload-types.ts) with the payload generate:types command.\n */\nexport function configToJSONSchema(\n  config: SanitizedConfig,\n  defaultIDType?: 'number' | 'text',\n): JSONSchema4 {\n  // a mutable Map to store custom top-level `interfaceName` types. Fields with an `interfaceName` property will be moved to the top-level definitions here\n  const interfaceNameDefinitions: Map<string, JSONSchema4> = new Map()\n\n  // Collections and Globals have to be moved to the top-level definitions as well. Reason: The top-level type will be the `Config` type - we don't want all collection and global\n  // types to be inlined inside the `Config` type\n  const entityDefinitions: { [k: string]: JSONSchema4 } = [\n    ...config.globals,\n    ...config.collections,\n  ].reduce((acc, entity) => {\n    acc[entity.slug] = entityToJSONSchema(config, entity, interfaceNameDefinitions, defaultIDType)\n    return acc\n  }, {})\n\n  const authOperationDefinitions = [...config.collections]\n    .filter(({ auth }) => Boolean(auth))\n    .reduce(\n      (acc, authCollection) => {\n        acc.auth[authCollection.slug] = authCollectionToOperationsJSONSchema(authCollection)\n        return acc\n      },\n      { auth: {} },\n    )\n\n  let jsonSchema: JSONSchema4 = {\n    additionalProperties: false,\n    definitions: {\n      ...entityDefinitions,\n      ...Object.fromEntries(interfaceNameDefinitions),\n      ...authOperationDefinitions,\n    },\n    // These properties here will be very simple, as all the complexity is in the definitions. These are just the properties for the top-level `Config` type\n    type: 'object',\n    properties: {\n      auth: generateAuthOperationSchemas(config.collections),\n      collections: generateEntitySchemas(config.collections || []),\n      db: generateDbEntitySchema(config),\n      globals: generateEntitySchemas(config.globals || []),\n      locale: generateLocaleEntitySchemas(config.localization),\n      user: generateAuthEntitySchemas(config.collections),\n    },\n    required: ['user', 'locale', 'collections', 'globals', 'auth', 'db'],\n    title: 'Config',\n  }\n\n  if (config?.typescript?.schema?.length) {\n    for (const schema of config.typescript.schema) {\n      jsonSchema = schema({ jsonSchema })\n    }\n  }\n\n  return jsonSchema\n}\n"],"names":["pluralize","singular","MissingEditorProp","fieldAffectsData","tabHasName","deepCopyObject","toWords","getCollectionIDFieldTypes","fieldIsRequired","field","isConditional","Boolean","admin","condition","isMarkedRequired","required","type","fields","some","subField","tabs","tab","buildOptionEnums","options","map","option","value","generateEntitySchemas","entities","properties","reduce","acc","slug","$ref","additionalProperties","Object","keys","generateLocaleEntitySchemas","localization","locales","localesFromConfig","locale","code","enum","generateAuthEntitySchemas","filter","auth","allOf","collection","oneOf","generateDbEntitySchema","config","defaultIDType","db","withNullableJSONSchemaType","fieldType","isRequired","fieldTypes","push","fieldsToJSONSchema","collectionIDFieldTypes","interfaceNameDefinitions","requiredFieldNames","Set","fromEntries","fieldSchemas","add","name","fieldSchema","hasMany","items","jsonSchema","schema","editor","Error","outputSchema","optionEnums","maxItems","minItems","docs","hasNextPage","Array","isArray","relationTo","relation","const","hasBlocks","blocks","length","block","blockFieldSchemas","blockSchema","blockType","interfaceName","set","childSchema","entries","forEach","propName","propSchema","hasRequiredFields","typescriptSchema","Map","from","entityToJSONSchema","incomingEntity","entity","title","typescript","interface","idField","customIdField","find","unshift","timestamps","disableLocalStrategy","generateAuthFieldTypes","loginWithUsername","allowEmailLogin","email","password","username","requiredFields","requireEmail","requireUsername","authCollectionToOperationsJSONSchema","loginUserFields","forgotOrUnlockUserFields","registerUserFields","forgotPassword","login","registerFirstUser","unlock","generateAuthOperationSchemas","collections","configToJSONSchema","entityDefinitions","globals","authOperationDefinitions","authCollection","definitions","user"],"mappings":"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"}},
    {"offset": {"line": 19379, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}}]
}